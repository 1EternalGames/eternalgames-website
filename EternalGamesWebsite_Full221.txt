--- START OF FILE .env ---

# .env (COMBINED AND CLEANED)

# --- Primary Application Secrets ---
NEXTAUTH_SECRET=newS3cl7686ZQEQZWop8o7kQ2oiuAmWiA1OV/hDaQp6Xg=
NEXTAUTH_URL=http://localhost:3000
# MODIFIED: Changed protocol to https for production metadata
NEXT_PUBLIC_SITE_URL=https://eternalgames.vercel.app

# --- Third-Party Services ---
# THE DEFINITIVE FIX: Using the free, official MyMemory Translation API.
# This endpoint does not require an API key or a credit card.
TRANSLATION_API_URL="https://api.mymemory.translated.net/get"

# --- Database (Used by Prisma and Runtime) ---
# RUNTIME POOLED CONNECTION for Serverless functions
DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&pgbouncer=true&pool_timeout=60"

# BUILD-TIME DIRECT CONNECTION for long-lived build processes
BUILD_DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"

# --- Vercel Blob ---
BLOB_READ_WRITE_TOKEN="vercel_blob_rw_0dG10aVH15DAsZWd_NvTqPADY3zK83uptFEkaUZCEY0lC8P"

# --- Sanity Project Config ---
# For server-side fetching (e.g., in Server Components, API routes)
SANITY_PROJECT_ID="0zany1dm"
SANITY_DATASET="production"
# Exposed to the client for the Sanity Studio and client-side fetching.
NEXT_PUBLIC_SANITY_PROJECT_ID="0zany1dm"
NEXT_PUBLIC_SANITY_DATASET="production"

# --- Sanity Tokens ---
# SERVER-SIDE WRITE TOKEN (Used for creating drafts, etc.)
SANITY_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"

# SERVER-SIDE READ TOKEN (Used for fetching data in server components)
SANITY_API_READ_TOKEN="skWyr0w9l0GX2Cm2Zpmu9lApLQFcMxxnJtH8cpIyiWYurpe7FbNQncMSwQxifl2CPjrZKD24UNX1ssTdAvKNQIKD4JXzVH1Ja3AWuepTEtTRwBeOL64AyCG0xcF1UEtW25HInglUx9r8uhJ2HUFxatMJytU4RTdsy84Np8gHsNxDDgJsAhE0"

# --- Revalidation Secret ---
REVALIDATION_SECRET_TOKEN="f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8"

# --- OAuth Keys ---
AUTH_GITHUB_ID=Ov23liESurJ80uqMFTV0
AUTH_GITHUB_SECRET=e2a8a1fcf50a9f8f2e703858a1a84a7db185e035
GOOGLE_CLIENT_ID=239586132598-orantodqlrirebbhpi5f3dvcu12bampv.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
TWITTER_CLIENT_ID=X3dFNFptdlYzZDJwTVc4TWI1NE06MTpjaQ
TWITTER_CLIENT_SECRET=GzXf4VvOHb7N02qvPZ7SwSLQbujQtu9PtRQHZOUBh2x7mVHHNc

# --- Giscus (Public, but kept here for completeness) ---
NEXT_PUBLIC_GISCUS_REPO=1-eyx/eternalgames-comments
NEXT_PUBLIC_GISCUS_REPO_ID=R_kgDOPt_3hA
NEXT_PUBLIC_GISCUS_CATEGORY=Article Comments
NEXT_PUBLIC_GISCUS_CATEGORY_ID=DIC_kwDOPt_3hM4CvTrq

--- END OF FILE .env ---

================================================================================

--- START OF FILE next-auth.d.ts ---

// next-auth.d.ts
import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {
  /**
   * The `User` object is available in callbacks.
   */
  interface User {
    id: string;
    roles: string[];
    username?: string | null;
    name?: string | null;
    email?: string | null;
    image?: string | null;
  }

  /**
   * The `Session` object is what is returned to the client.
   */
  interface Session {
    user: User; // The user object now includes all our custom and default fields.
    needsOnboarding?: boolean;
    expires: string; // THE FIX: Explicitly add expires to satisfy SessionProvider requirements
  }
}

declare module 'next-auth/jwt' {
  /**
   * The `JWT` interface is used in the `jwt` callback.
   */
  interface JWT {
    id: string;
    roles: string[];
    username?: string | null;
    needsOnboarding?: boolean;
  }
}

--- END OF FILE next-auth.d.ts ---

================================================================================

--- START OF FILE next.config.ts ---

// next.config.ts
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,

    images: {
        remotePatterns: [
            { protocol: 'https', hostname: 'cdn.sanity.io' },
            { protocol: 'https', hostname: '*.public.blob.vercel-storage.com' },
            { protocol: 'https', hostname: 'lh3.googleusercontent.com' },
            { protocol: 'https', hostname: 'avatars.githubusercontent.com' },
        ],
    },

    experimental: {
        serverActions: {
            bodySizeLimit: '10mb',
        },
    },
};

export default nextConfig;

--- END OF FILE next.config.ts ---

================================================================================

--- START OF FILE package.json ---

{
  "name": "eternalgames-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "prisma generate && next build",
    "postinstall": "prisma generate",
    "start": "next start",
    "lint": "eslint",
    "prisma:seed": "npx ts-node -r dotenv/config prisma/seed.ts",
    "type-check": "tsc --noEmit",
    "type-watch": "tsc --noEmit --watch"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@portabletext/react": "^4.0.3",
    "@prisma/adapter-pg": "^7.0.0",
    "@prisma/client": "latest",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@react-three/postprocessing": "^3.0.4",
    "@sanity/client": "^7.12.0",
    "@sanity/icons": "^3.7.4",
    "@sanity/image-url": "^1.2.0",
    "@sanity/vision": "^4.10.1",
    "@tiptap/extension-color": "^2.27.1",
    "@tiptap/extension-image": "^2.5.5",
    "@tiptap/extension-link": "^2.5.5",
    "@tiptap/extension-placeholder": "^2.5.5",
    "@tiptap/extension-table": "^2.5.5",
    "@tiptap/extension-table-cell": "^2.5.5",
    "@tiptap/extension-table-header": "^2.5.5",
    "@tiptap/extension-table-row": "^2.5.5",
    "@tiptap/extension-text-style": "^2.27.1",
    "@tiptap/react": "^2.5.5",
    "@tiptap/starter-kit": "^2.5.5",
    "@types/bcryptjs": "^2.4.6",
    "@vercel/blob": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "dotenv": "^17.2.2",
    "framer-motion": "^12.23.12",
    "next": "16.0.1",
    "next-auth": "^4.24.11",
    "next-sanity": "^11.4.2",
    "next-themes": "^0.4.6",
    "pg": "^8.11.3",
    "react": "19.1.0",
    "react-compare-slider": "^3.1.0",
    "react-dom": "19.1.0",
    "react-image-crop": "^11.0.10",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19",
    "three": "^0.180.0",
    "transliteration": "^2.3.5",
    "uuid": "^9.0.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@fullhuman/postcss-purgecss": "^7.0.2",
    "@sanity/types": "^4.10.1",
    "@types/node": "^20",
    "@types/pg": "^8.10.9",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "@types/uuid": "^9.0.8",
    "cross-env": "^10.1.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "postcss": "^8.5.6",
    "postcss-cli": "^11.0.1",
    "prisma": "latest",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5"
  }
}


--- END OF FILE package.json ---

================================================================================

--- START OF FILE tsconfig.json ---

{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "lib/generated/client/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "sanity"
  ]
}

--- END OF FILE tsconfig.json ---

================================================================================

--- START OF FILE sanity.cli.ts ---

import { defineCliConfig } from 'sanity/cli'

const projectId = '0zany1dm'
const dataset = 'production'

export default defineCliConfig({
  api: { projectId, dataset }
})




--- END OF FILE sanity.cli.ts ---

================================================================================

--- START OF FILE app/globals.css ---

:root{
--bg-primary:#F9FAFB;
--bg-secondary:#FFFFFF;
--text-primary:#1F2937;
--text-secondary:#6B7280;
--accent:#0891B2;
--overlay-color:rgba(249,250,251,0.7);
--border-color:#E5E7EB;
--nav-height:8rem;
--nav-height-scrolled:6rem;
}
[data-theme="dark"]{
--bg-primary:#0A0B0F;
--bg-secondary:#14161D;
--text-primary:#E1E1E6;
--text-secondary:#7D808C;
--accent:#00E5FF;
--overlay-color:rgba(10,11,15,0.7);
--border-color:#2a2e3c;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}
html, body {
  width: 100%;
  overflow-x: hidden;
}
html{
font-size:62.5%;
scroll-behavior:smooth;
scrollbar-width:thin;
scrollbar-color:var(--accent) transparent;
direction: rtl;
}
body::-webkit-scrollbar{width:8px;}
body::-webkit-scrollbar-track{background:transparent;}
body::-webkit-scrollbar-thumb{background-color:var(--accent);border-radius:4px;}
body{
background-color:var(--bg-primary);
color:var(--text-primary);
font-family:var(--font-main), sans-serif;
font-size:1.8rem;
line-height:1.7;
transition:background-color 0.3s ease,color 0.3s ease;
}
h1,h2,h3,h4,h5,h6{
font-family:var(--font-main), sans-serif;
font-weight:700;
line-height:1.2;
}
h1{font-size:5.6rem;}
h2{font-size:4.0rem;}
h3{font-size:2.8rem;}
a{color:var(--accent);text-decoration:none;position:relative;display:inline-block;}
a:not(.no-underline)::after{
content:'';position:absolute;width:100%;transform:scaleX(0);height:2px;
bottom:-4px;right:0;
background-color:var(--accent);
transform-origin:bottom right;
transition:transform 0.3s ease-out;
}
a:not(.no-underline):hover::after{transform:scaleX(1);}
img{max-width:100%;height:auto;display:block;}
.container{max-width:1200px;margin:0 auto;padding:0 2rem;}
.section{padding:8rem 0;}
.section-title{text-align:center;margin-bottom:4rem;font-weight:800;color:var(--text-primary);}
.sr-only{
position:absolute;width:1px;height:1px;padding:0;margin:-1px;
overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0;
}
.page-container{padding-top:calc(var(--nav-height-scrolled) + 4rem);padding-bottom:6rem;min-height:80vh;}
.page-title{font-size:4.2rem;font-weight:800;text-align:center;margin-bottom:4rem;color:var(--text-primary);overflow-wrap:break-word;word-break:break-word;}
.content-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:3rem;grid-auto-rows:1fr;}

.portable-text-content {
  overflow-wrap: break-word;
  word-break: break-word;
}

/* --- THE DEFINITIVE FIX FOR EMPTY LINES (ADJUSTED) --- */
.portable-text-content p:empty {
  height: 3rem; /* Match the body's font-size to simulate one line break */
}

.toast-container-global {
position: fixed;
bottom: 2rem;
left: 2rem;
z-index: 9999;
display: flex;
flex-direction: column;
gap: 1rem;
}
.toast-container-global[style*="right: 2rem"] {
    right: 2rem;
    left: auto;
}
.toast-container-global[style*="left: 2rem"] {
    left: 2rem;
    right: auto;
}

.primary-button.delete-forever:hover {
  box-shadow: 0 0 20px color-mix(in srgb, #DC2626 50%, transparent) !important;
  transform: scale(1.05) translateY(-1px) !important;
}

.primary-button{background-color:var(--accent);color:#fff;border:none;padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:700;cursor:pointer;box-shadow:0 0 15px color-mix(in srgb,var(--accent) 30%,transparent);transition:transform 0.2s ease-out,box-shadow 0.2s ease-out;}
.primary-button:hover:not(:disabled){transform:scale(1.05) translateY(-1px);box-shadow:0 0 25px color-mix(in srgb,var(--accent) 50%,transparent);}
.primary-button:disabled{background-color:var(--border-color);color:var(--text-secondary);box-shadow:none;cursor:not-allowed;opacity:0.6;}
.outline-button{background:transparent;border:1px solid var(--border-color);color:var(--text-secondary);padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:500;cursor:pointer;transition:background-color 0.15s ease-out,color 0.15s ease-out,border-color 0.15s ease-out;}
.outline-button:hover:not(:disabled){border-color:var(--accent);color:var(--accent);background-color:color-mix(in srgb,var(--accent) 10%,transparent);}
.outline-button:disabled{opacity:0.6;cursor:not-allowed;}

.profile-form-group{
  position:relative;
  margin-bottom:2.5rem;
}

.profile-form-label{
  position:absolute;
  right:1.5rem;
  left: auto;
  top:1rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-secondary);
  pointer-events:none;
  transition:all 0.2s ease-out;
}

.profile-input:focus ~ .profile-form-label,
.profile-input:not([value=""]):not(:placeholder-shown) ~ .profile-form-label {
  top:-2rem;
  right:0;
  left: auto;
  font-size:1.4rem;
  font-weight:600;
  color:var(--accent);
}

.profile-input{
  width:100%;
  background-color:var(--bg-secondary);
  border:1px solid var(--border-color);
  border-radius:8px;
  padding: 1.2rem 1.5rem;
  height: 4.8rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-primary);
  transition:border-color 0.3s ease,box-shadow 0.3s ease;
  text-align: right;
}

.profile-input:focus{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 3px color-mix(in srgb,var(--accent) 20%,transparent);
}

/* THE DEFINITIVE PLACEHOLDER FIX */
.profile-input::placeholder {
  color: var(--text-secondary);
  opacity: 0.7;
}

.profile-input:focus::placeholder {
  opacity: 0.5;
}

.profile-input[type=number]::-webkit-inner-spin-button, 
.profile-input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
}
.profile-input[type=number] {
    -moz-appearance: textfield;
}

.user-avatar{
  border-radius:50%;
  border:2px solid transparent;
  transition:border-color 0.3s ease;
}

.primary-button.delete-forever {
  background-color: #DC2626;
  box-shadow: 0 0 15px color-mix(in srgb, #DC2626 30%, transparent);
}

.country-picker-button {
    display: block;
    width: 100%;
    padding: 0.75rem 1.5rem;
    text-align: right;
    background: none;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.country-picker-button:hover {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}

.info-tooltip-container {
    position: relative;
}
.info-tooltip-text {
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.75rem 1rem;
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 1px solid var(--border-color);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease-out, visibility 0.2s;
    pointer-events: none;
}
.info-tooltip-container:hover .info-tooltip-text {
    opacity: 1;
    visibility: visible;
}

.toggle {
  width: 44px;
  height: 24px;
  background-color: var(--border-color);
  border-radius: 999px;
  padding: 2px;
  display: flex;
  cursor: pointer;
  justify-content: flex-start;
  border: none;
  transition: background-color 0.2s ease-out;
}
.toggle.active {
  background-color: var(--accent);
  justify-content: flex-end;
}
.toggle-handle {
  width: 20px;
  height: 20px;
  background-color: white;
  border-radius: 50%;
}

.creator-credit-link {
  color: var(--accent);
  font-weight: 500;
}

.news-card-category {
    display: inline-block;
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    font-family: var(--font-main), sans-serif;
    font-size: 1.4rem;
    font-weight: 600;
    border: 1px solid var(--accent);
}

/* --- FINAL UI POLISH FIXES --- */

/* RTL Placeholder Text Alignment for Studio Inputs */
.sidebar-input::placeholder,
div[class*="sidebarInput"] > span {
    text-align: right;
    color: var(--text-secondary);
}

div[class*="sidebarInput"] > span[style*="position: absolute"] {
    right: 1rem !important;
    left: auto !important;
}

/* This rule is now removed to allow the header to show in the editor */

/* Disable Main Scroll for Editor and Mobile Menu */
body.editor-active,
body.mobile-menu-open {
    overflow: hidden !important;
}

/* Hide Footer in Editor and Constellation views */
body.editor-active footer,
body.constellation-active footer {
    display: none !important;
}

/* Fullscreen mode for immersive views */
body.fullscreen-active > header,
body.fullscreen-active > footer,
body.fullscreen-active > div[class*="StudioBar_studioBar"] {
    display: none !important;
}

body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"] {
    background: transparent !important;
    border-color: transparent !important;
    color: rgba(255,255,255,0.4) !important;
}

body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"]:hover {
    color: var(--accent) !important;
    box-shadow: none !important;
}

/* --- IMAGE LIGHTBOX HOVER EFFECT --- */
.image-lightbox-trigger {
    position: relative;
    display: block;
    cursor: zoom-in;
    border-radius: 8px;
    overflow: hidden;
}

.image-lightbox-trigger::after {
    content: 'عرض الصورة كاملة';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-main);
    font-weight: 600;
    font-size: 1.6rem;
    color: white;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(2px);
    opacity: 0;
    transition: opacity 0.2s ease-out;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3Cline x1='11' y1='8' x2='11' y2='14'%3E%3C/line%3E%3Cline x1='8' y1='11' x2='14' y2='11'%3E%3C/line%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center 25%;
    padding-top: 40px;
}

.image-lightbox-trigger:hover::after {
    opacity: 1;
}

.image-lightbox-trigger img {
    transition: transform 0.3s ease-out;
}

.image-lightbox-trigger:hover img {
    transform: scale(1.03);
}

/* --- THE DEFINITIVE SCROLL LOCK FOR LIGHTBOX --- */
body.lightbox-active {
    overflow: hidden !important;
}

/* --- MOBILE RESPONSIVENESS --- */
@media (max-width: 1024px) {
  html { font-size: 60%; }
}

@media (max-width: 768px) {
  h1 { font-size: 4.2rem; }
  h2 { font-size: 3.2rem; }
  h3 { font-size: 2.4rem; }
  .page-title { font-size: 3.6rem; }
  .section { padding: 6rem 0; }
  .page-container { padding-top: calc(var(--nav-height-scrolled) + 2rem); padding-bottom: 4rem; }
  .container { padding: 0 1.5rem; }
  .content-grid { 
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
  }
  .toast-container-global { bottom: 1.5rem; left: 1.5rem; right: 1.5rem !important; width: auto; }
  .primary-button, .outline-button { padding: 1.2rem 2rem; font-size: 1.6rem; }
  .news-card-category {
    font-size: 1.2rem;
    padding: 0.3rem 1rem;
  }
}

@media (max-width: 480px) {
  html { font-size: 58%; }
  body { font-size: 1.6rem; }
  h1 { font-size: 3.6rem; }
  h2 { font-size: 2.8rem; }
  h3 { font-size: 2.2rem; }
  .page-title { font-size: 2.5rem; }
  .content-grid { 
    grid-template-columns: 1fr;
  }
}

--- END OF FILE app/globals.css ---

================================================================================

--- START OF FILE app/icon.tsx ---

// app/icon.tsx
import { ImageResponse } from 'next/og';

// Route segment config
export const runtime = 'edge';

// Image metadata
export const size = {
  width: 32,
  height: 32,
};
export const contentType = 'image/png';

// Image generation
export default function Icon() {
  return new ImageResponse(
    (
      <div
        style={{
          background: '#0A0B0F',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: '20%', // Squircle shape
        }}
      >
        {/* EternalGames Infinity Logo SVG */}
        <svg
          width="24"
          height="24"
          viewBox="-2 -2 28 28"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            fillRule="evenodd"
            clipRule="evenodd"
            d="M6.5 8C4.42522 8 3 9.64616 3 12C3 14.3538 4.42522 16 6.5 16C6.89277 16 7.37581 15.8172 7.9365 15.4098C8.48745 15.0094 9.02767 14.4541 9.51373 13.8641C9.99579 13.279 10.4009 12.6889 10.6866 12.2423C10.7422 12.1554 10.7931 12.0742 10.8389 12C10.7931 11.9258 10.7422 11.8446 10.6866 11.7577C10.4009 11.3111 9.99579 10.721 9.51373 10.1359C9.02767 9.54588 8.48745 8.99058 7.9365 8.59022C7.37581 8.18279 6.89277 8 6.5 8ZM13.1611 12C13.2069 12.0742 13.2578 12.1554 13.3134 12.2423C13.5991 12.6889 14.0042 13.279 14.4863 13.8641C14.9723 14.4541 15.5125 15.0094 16.0635 15.4098C16.6242 15.8172 17.1072 16 17.5 16C19.5748 16 21 14.3538 21 12C21 9.64616 19.5748 8 17.5 8C17.1072 8 16.6242 8.18279 16.0635 8.59022C15.5125 8.99058 14.9723 9.54588 14.4863 10.1359C14.0042 10.721 13.5991 11.3111 13.3134 11.7577C13.2578 11.8446 13.2069 11.9258 13.1611 12ZM12 13.88C11.7349 14.2656 11.4167 14.6996 11.0573 15.1359C10.5136 15.7959 9.85138 16.4906 9.1122 17.0277C8.38275 17.5578 7.48794 18 6.5 18C3.05193 18 1 15.169 1 12C1 8.83099 3.05193 6 6.5 6C7.48794 6 8.38275 6.44221 9.1122 6.97228C9.85138 7.50942 10.5136 8.20412 11.0573 8.86414C11.4167 9.30035 11.7349 9.73442 12 10.12C12.2651 9.73442 12.5833 9.30035 12.9427 8.86414C13.4864 8.20412 14.1486 7.50942 14.8878 6.97228C15.6172 6.44221 16.5121 6 17.5 6C20.9481 6 23 8.83099 23 12C23 15.169 20.9481 18 17.5 18C16.5121 18 15.6172 17.5578 14.8878 17.0277C14.1486 16.4906 13.4864 15.7959 12.9427 15.1359C12.5833 14.6996 12.2651 14.2656 12 13.88Z"
            fill="#00E5FF"
          />
        </svg>
      </div>
    ),
    {
      ...size,
      // THE FIX: Set cache headers to 'immutable' to stop the browser from asking again.
      headers: {
        'Cache-Control': 'public, max-age=31536000, immutable',
      },
    }
  );
}

--- END OF FILE app/icon.tsx ---

================================================================================

--- START OF FILE app/layout.tsx ---

// app/layout.tsx
import { Cairo } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { ThemeProvider } from '@/components/ThemeProvider';
import NextAuthProvider from '@/components/SessionProvider';
import StudioBar from '@/components/StudioBar';
import ToastProvider from '@/components/ToastProvider';
import UserStoreHydration from '@/components/UserStoreHydration';
import Lightbox from '@/components/Lightbox';
import ScrollToTopButton from '@/components/ui/ScrollToTopButton';
import PageTransitionWrapper from '@/components/PageTransitionWrapper';
import type { Metadata } from 'next';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import prisma from '@/lib/prisma';
import BanEnforcer from '@/components/security/BanEnforcer';

const cairo = Cairo({
  subsets: ['arabic', 'latin'],
  display: 'swap',
  variable: '--font-main',
  weight: ['400', '500', '700', '800'],
});

const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';

export const metadata: Metadata = {
  metadataBase: new URL(siteUrl),
  title: {
    default: 'EternalGames | حيث لا تُفنى الألعاب',
    template: '%s | EternalGames',
  },
  description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
  alternates: {
  },
  openGraph: {
    title: {
      default: 'EternalGames | حيث لا تُفنى الألعاب',
      template: '%s | EternalGames',
    },
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    url: siteUrl,
    siteName: 'EternalGames',
    images: [
      {
        url: `${siteUrl}/og.png`,
        width: 1200,
        height: 630,
        alt: 'EternalGames Logo',
      },
    ],
    locale: 'ar_SA',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: {
      default: 'EternalGames | حيث لا تُفنى الألعاب',
      template: '%s | EternalGames',
    },
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    images: [`${siteUrl}/og.png`],
  },
};

export default async function RootLayout({ children }: { children: React.ReactNode; }) {
  const session = await getServerSession(authOptions);
  
  let userRoles: string[] = [];
  let isBanned = false;
  let banReason = null;
  let initialUserState = null;

  if (session?.user?.id) {
      try {
          const [user, engagements, shares] = await Promise.all([
              prisma.user.findUnique({
                  where: { id: session.user.id },
                  select: { 
                      roles: { select: { name: true } },
                      isBanned: true,
                      banReason: true
                  }
              }),
              prisma.engagement.findMany({ 
                  where: { userId: session.user.id }, 
                  select: { contentId: true, contentType: true, type: true } 
              }),
              prisma.share.findMany({ 
                  where: { userId: session.user.id }, 
                  select: { contentId: true, contentType: true } 
              })
          ]);

          userRoles = user?.roles.map((r: any) => r.name) || [];
          isBanned = user?.isBanned || false;
          banReason = user?.banReason || null;
          
          initialUserState = { engagements, shares };

      } catch (error) {
          console.error("Failed to fetch user details in RootLayout:", error);
      }
  }

  return (
    <html lang="ar" dir="rtl" className={cairo.variable} suppressHydrationWarning>
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link
          rel="preconnect"
          href="https://fonts.gstatic.com"
          crossOrigin="anonymous"
        />
        <link
          rel="preconnect"
          href="https://cdn.sanity.io"
          crossOrigin="anonymous"
        />
      </head>
      <body>
        {/* THE FIX: Pass the server session to the provider to avoid client-side refetching */}
        <NextAuthProvider session={session}>
          <UserStoreHydration initialUserState={initialUserState} />
          
          <BanEnforcer isBanned={isBanned} reason={banReason} />
          <ThemeProvider attribute="data-theme" defaultTheme="system" enableSystem disableTransitionOnChange>
            <div style={{ position: 'relative', width: '100%', overflowX: 'clip' }}>
              <ToastProvider />
              <Lightbox />
              <Navbar />
              <main>
                <PageTransitionWrapper>
                  {children}
                </PageTransitionWrapper>
              </main>
              <Footer />
              <StudioBar serverRoles={userRoles} />
              <ScrollToTopButton />
            </div>
          </ThemeProvider>
        </NextAuthProvider>
      </body>
    </html>
  );
}

--- END OF FILE app/layout.tsx ---

================================================================================

--- START OF FILE app/page.tsx ---

// app/page.tsx
import { unstable_cache } from 'next/cache';
import React from 'react';
import { client } from '@/lib/sanity.client';
import { allReleasesQuery, vanguardReviewsQuery, homepageArticlesQuery, homepageNewsQuery } from '@/lib/sanity.queries';
import DigitalAtriumHomePage from '@/components/DigitalAtriumHomePage';
import { Suspense } from 'react';
import AnimatedReleases from '@/components/AnimatedReleases';
import prisma from '@/lib/prisma';
import { SanityReview } from '@/types/sanity';
import HomepageFeeds from '@/components/homepage/HomepageFeeds';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import { enrichContentList } from '@/lib/enrichment';

const getCachedEngagementScoresMap = unstable_cache(
    async (): Promise<[number, number][]> => {
        try {
            const contentTypes = ['review', 'article', 'news'];
            const contentIdsQuery = await prisma.engagement.findMany({
                where: { contentType: { in: contentTypes }, type: 'LIKE' },
                select: { contentId: true },
                distinct: ['contentId']
            });
            const ids = contentIdsQuery.map((i: any) => i.contentId);

            const [likes, shares] = await Promise.all([
                prisma.engagement.groupBy({ by: ['contentId'], where: { contentId: { in: ids }, type: 'LIKE' }, _count: { userId: true } }),
                prisma.share.groupBy({ by: ['contentId'], where: { contentId: { in: ids } }, _count: { userId: true } })
            ]);

            const scoresMap = new Map<number, number>();
            ids.forEach((id: number) => {
                const likeCount = likes.find((s: any) => s.contentId === id)?._count.userId || 0;
                const shareCount = shares.find((s: any) => s.contentId === id)?._count.userId || 0;
                scoresMap.set(id, (likeCount * 2) + (shareCount * 5));
            });
            return Array.from(scoresMap.entries());
        } catch (error) {
            console.warn('[CACHE WARNING] DB connection failed for engagement scores. Gracefully continuing. Error:', error);
            return [];
        }
    },
    ['homepage-engagement-scores'],
    { tags: ['engagement-scores'] }
);


async function ReleasesSection() {
    const releases = await client.fetch(allReleasesQuery);
    const sanitizedReleases = (releases || []).filter((item: any) => 
        item?.mainImage?.url && item.releaseDate && item.title && item.slug
    );
    return <AnimatedReleases releases={sanitizedReleases} />;
}

export default async function HomePage() {
    const [
        reviewsRaw, 
        homepageArticlesRaw, 
        homepageNewsRaw, 
        scoresArray
    ] = await Promise.all([
        client.fetch(vanguardReviewsQuery),
        client.fetch(homepageArticlesQuery),
        client.fetch(homepageNewsQuery),
        getCachedEngagementScoresMap()
    ]);

    const reviews = (await enrichContentList(reviewsRaw)) as SanityReview[];
    const homepageArticles = await enrichContentList(homepageArticlesRaw);
    const homepageNews = await enrichContentList(homepageNewsRaw);

    if (reviews.length > 0) {
        const topRatedIndex = reviews.reduce((topIndex: number, currentReview: SanityReview, currentIndex: number) => {
            const topScore = reviews[topIndex].score ?? 0;
            const currentScore = currentReview.score ?? 0;
            return currentScore > topScore ? currentIndex : topIndex;
        }, 0);
        
        if (topRatedIndex > 0) {
            const [topRatedReview] = reviews.splice(topRatedIndex, 1);
            reviews.unshift(topRatedReview);
        }
    }

    const scoresMap = new Map(scoresArray);
    
    const sortItemsByScore = (items: any[]) => {
        return [...items].sort((a, b) => (scoresMap.get(b.legacyId) || 0) - (scoresMap.get(a.legacyId) || 0));
    };

    const sortedArticlesByScore = sortItemsByScore(homepageArticles);
    const topArticlesRaw = sortedArticlesByScore.slice(0, 2);
    const topArticleIds = new Set(topArticlesRaw.map((a: any) => a._id));
    // OPTIMIZATION: Request 800px for top cards
    const topArticles = topArticlesRaw.map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[];

    const latestArticles = homepageArticles
        .filter((a: any) => !topArticleIds.has(a._id))
        .slice(0, 10)
        // OPTIMIZATION: Request 400px for list items
        .map(item => adaptToCardProps(item, { width: 400 }))
        .filter(Boolean) as CardProps[];
    
    const sortedNewsByScore = sortItemsByScore(homepageNews);
    const topNewsRaw = sortedNewsByScore.slice(0, 3);
    const topNewsIds = new Set(topNewsRaw.map((n: any) => n._id));
    // OPTIMIZATION: 600px for spotlight
    const pinnedNews = topNewsRaw.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[];

    const newsList = homepageNews
        .filter((n: any) => !topNewsIds.has(n._id))
        .slice(0, 15)
        // OPTIMIZATION: 300px for stream
        .map(item => adaptToCardProps(item, { width: 300 }))
        .filter(Boolean) as CardProps[];

    const feedsContent = (
        <HomepageFeeds 
            topArticles={topArticles} 
            latestArticles={latestArticles} 
            pinnedNews={pinnedNews} 
            newsList={newsList} 
        />
    );

    const releasesSection = <ReleasesSection />;

    return (
        <DigitalAtriumHomePage 
            reviews={reviews}
            feedsContent={feedsContent}
            releasesSection={releasesSection}
        />
    );
}

--- END OF FILE app/page.tsx ---

================================================================================

--- START OF FILE app/template.tsx ---

// app/template.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { usePathname } from 'next/navigation';

export default function Template({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();

  return (
    <AnimatePresence mode="popLayout">
      <motion.div
        key={pathname}
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        // EXIT PROP REMOVED TO FIX THE LAYOUTID CONFLICT
        transition={{ duration: 0.3, ease: 'easeInOut' }}
      >
        {children}
      </motion.div>
    </AnimatePresence>
  );
}

--- END OF FILE app/template.tsx ---

================================================================================

--- START OF FILE app/(content)/[...slug]/page.tsx ---

// app/(content)/[...slug]/page.tsx
import { unstable_cache } from 'next/cache';
import { client } from '@/lib/sanity.client';
import {
    reviewBySlugQuery, latestReviewsFallbackQuery,
    articleBySlugQuery, latestArticlesFallbackQuery,
    newsBySlugQuery, latestNewsFallbackQuery
} from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import prisma from '@/lib/prisma';
import CommentSection from '@/components/comments/CommentSection';
import ContentPageClient from '@/components/content/ContentPageClient';
import { Suspense } from 'react';
import { groq } from 'next-sanity';
import type { Metadata } from 'next';
import { enrichCreators, enrichContentList } from '@/lib/enrichment';

const colorDictionaryQuery = groq`*[_type == "colorDictionary" && _id == "colorDictionary"][0]{ autoColors }`;

const contentConfig = {
    reviews: {
        query: reviewBySlugQuery,
        fallbackQuery: latestReviewsFallbackQuery,
        relatedProp: 'relatedReviews',
        creatorProps: ['authors', 'designers'],
        sanityType: 'review',
    },
    articles: {
        query: articleBySlugQuery,
        fallbackQuery: latestArticlesFallbackQuery,
        relatedProp: 'relatedArticles',
        creatorProps: ['authors', 'designers'],
        sanityType: 'article',
    },
    news: {
        query: newsBySlugQuery,
        fallbackQuery: latestNewsFallbackQuery,
        relatedProp: 'relatedNews',
        creatorProps: ['reporters', 'designers'],
        sanityType: 'news',
    },
};

export async function generateMetadata({ params }: { params: Promise<{ slug: string[] }> }): Promise<Metadata> {
    const { slug: slugArray } = await params;
    
    // THE FIX: Validate slug array length and content to prevent 400 Errors on static assets
    if (!slugArray || slugArray.length < 2) {
        return {};
    }

    const [type, slug] = slugArray;

    // Validate type to prevent default "news" fallthrough for garbage URLs
    const sanityType = type === 'reviews' ? 'review' : type === 'articles' ? 'article' : type === 'news' ? 'news' : null;
    
    if (!sanityType) return {};
    
    const item = await client.fetch(`*[_type == "${sanityType}" && slug.current == $slug][0]{title, mainImage, synopsis}`, { slug });

    if (!item) return {};

    return {
        title: item.title,
        description: item.synopsis || `Read the full ${type.slice(0, -1)} on EternalGames.`,
    }
}

const getCachedSanityData = unstable_cache(
    async (query: string, params: Record<string, any> = {}, tags: string[]) => {
        return client.fetch(query, params);
    },
    ['sanity-content-detail'],
);

async function getComments(slug: string) {
    try {
        const comments = await prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { 
                author: { select: { id: true, name: true, image: true, username: true } }, 
                votes: true, 
                _count: { select: { replies: true } }, 
                replies: { 
                    take: 2, 
                    include: { 
                        author: { select: { id: true, name: true, image: true, username: true } }, 
                        votes: true, 
                        _count: { select: { replies: true } } 
                    }, 
                    orderBy: { createdAt: 'asc' } 
                } 
            },
            orderBy: { createdAt: 'desc' },
        });
        return comments;
    } catch (error) {
        console.error("Failed to fetch comments server-side:", error);
        return [];
    }
}

export async function generateStaticParams() {
    try {
        const allContent = await client.fetch<any[]>(`*[_type in ["review", "article", "news"]]{ "slug": slug.current, _type }`);
        return allContent.filter(c => c.slug).map(c => {
            const type = c._type === 'review' ? 'reviews' : (c._type === 'article' ? 'articles' : 'news');
            return { slug: [type, c.slug] };
        });
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for generateStaticParams.`, error);
        throw error;
    }
}

export default async function ContentPage({ params }: { params: Promise<{ slug: string[] }> }) {
    const { slug: slugArray } = await params;
    
    // Strict validation for the page component as well
    if (!slugArray || slugArray.length !== 2) notFound();
    
    const [type, slug] = slugArray;
    const config = (contentConfig as any)[type];
    
    if (!config) notFound();
    
    const tags = [config.sanityType];

    let [item, colorDictionaryData, comments] = await Promise.all([
        getCachedSanityData(config.query, { slug }, tags),
        getCachedSanityData(colorDictionaryQuery, {}, ['colorDictionary']),
        getComments(slug)
    ]);
    
    if (!item) notFound();

    if (!item[config.relatedProp] || item[config.relatedProp].length === 0) {
        const fallbackContent = await getCachedSanityData(config.fallbackQuery, { currentId: item._id }, tags);
        item[config.relatedProp] = fallbackContent;
    }

    for (const prop of config.creatorProps) {
        if (item[prop]) {
            item[prop] = await enrichCreators(item[prop]);
        }
    }

    if (item[config.relatedProp]) {
        item[config.relatedProp] = await enrichContentList(item[config.relatedProp]);
    }
    
    const colorDictionary = colorDictionaryData?.autoColors || [];

    return (
        <ContentPageClient item={item} type={type as any} colorDictionary={colorDictionary}>
            <CommentSection slug={slug} contentType={type} initialComments={comments} /> 
        </ContentPageClient>
    );
}

--- END OF FILE app/(content)/[...slug]/page.tsx ---

================================================================================

--- START OF FILE app/actions/authActions.ts ---

// app/actions/authActions.ts
'use server';

import prisma from '@/lib/prisma';
import crypto from 'crypto';
import bcrypt from 'bcryptjs';

// This would be your email sending function. For now, it logs to the console.
async function sendPasswordResetEmail(email: string, token: string) {
    const resetLink = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`;
    console.log(`--- PASSWORD RESET EMAIL ---`);
    console.log(`To: ${email}`);
    console.log(`Link: ${resetLink}`);
    console.log(`--------------------------`);
    // In production, you would use a service like Resend, SendGrid, or Nodemailer here.
}

export async function requestPasswordReset(email: string) {
    try {
        const lowercasedEmail = email.toLowerCase(); // MODIFIED
        const user = await prisma.user.findUnique({ where: { email: lowercasedEmail } }); // MODIFIED
        if (!user || !user.password) {
            // Don't reveal if a user exists or not for security reasons.
            // Also, don't allow password resets for OAuth users.
            return { success: true, message: 'إن صَحَّ بريدُك، أتاك الرابط.' };
        }

        // Invalidate any existing tokens for this user
        await prisma.passwordResetToken.deleteMany({ where: { userId: user.id } });

        const token = crypto.randomBytes(32).toString('hex');
        const expires = new Date(new Date().getTime() + 60 * 60 * 1000); // 1 hour expiry

        await prisma.passwordResetToken.create({
            data: {
                userId: user.id,
                token,
                expires,
            },
        });

        await sendPasswordResetEmail(lowercasedEmail, token); // MODIFIED

        return { success: true, message: 'إن صَحَّ بريدُك، أتاك الرابط.' };
    } catch (error) {
        console.error('Password reset request failed:', error);
        return { success: false, message: 'طرأ خطبٌ ما.' };
    }
}

export async function resetPassword(token: string, newPassword: string) {
    try {
        if (!token || !newPassword) {
            return { success: false, message: 'طلبٌ غير صالح.' };
        }

        const resetToken = await prisma.passwordResetToken.findUnique({
            where: { token },
        });

        if (!resetToken || resetToken.expires < new Date()) {
            if (resetToken) {
                await prisma.passwordResetToken.delete({ where: { id: resetToken.id } });
            }
            return { success: false, message: 'الرمز باطل أو منتهي الصلاحية.' };
        }

        if (newPassword.length < 8) {
            return { success: false, message: 'كلمة السر لا تقل عن ثمانيةِ حروف.' };
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await prisma.user.update({
            where: { id: resetToken.userId },
            data: { password: hashedPassword },
        });

        await prisma.passwordResetToken.delete({
            where: { id: resetToken.id },
        });

        return { success: true, message: 'استُعيدت كلمة السّر.' };
    } catch (error) {
        console.error('Password reset failed:', error);
        return { success: false, message: 'طرأ خطبٌ ما.' };
    }
}

--- END OF FILE app/actions/authActions.ts ---

================================================================================

--- START OF FILE app/actions/banActions.ts ---

// app/actions/banActions.ts
'use server';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";
import prisma from "@/lib/prisma";
import { revalidatePath, revalidateTag } from "next/cache";
import { unstable_cache } from "next/cache";

// --- CONFIGURATION ---
const OWNER_EMAIL = "mhmfalsaadd@gmail.com"; 

const PROTECTED_ROLES = ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'];

const getCachedBanStatus = unstable_cache(
    async (userId: string) => {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { isBanned: true, banReason: true }
        });
        return { 
            isBanned: user?.isBanned || false, 
            banReason: user?.banReason || null 
        };
    },
    ['user-ban-status'], 
    { tags: ['ban-status'] }
);

export async function checkBanStatus() {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) return { isBanned: false, banReason: null };
    return await getCachedBanStatus(session.user.id);
}

export async function toggleUserBanAction(targetUserId: string, reason: string, shouldBan: boolean) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return { success: false, message: "غير مصرح لك." };
    }

    try {
        const actor = await prisma.user.findUnique({
            where: { id: session.user.id },
            select: { id: true, email: true, roles: { select: { name: true } } }
        });

        if (!actor) return { success: false, message: "المستخدم غير موجود." };
        
        const actorRoles = actor.roles.map((r: any) => r.name);
        const isDirector = actorRoles.includes('DIRECTOR');
        const isAdmin = actorRoles.includes('ADMIN');
        const isOwner = actor.email === OWNER_EMAIL; 

        if (!isDirector && !isAdmin && !isOwner) {
            return { success: false, message: "صلاحياتك لا تسمح بالحظر." };
        }

        const target = await prisma.user.findUnique({
            where: { id: targetUserId },
            select: { id: true, email: true, roles: { select: { name: true } } }
        });

        if (!target) return { success: false, message: "المستخدم المستهدف غير موجود." };
        const targetRoles = target.roles.map((r: any) => r.name);

        if (target.email === OWNER_EMAIL) {
            return { success: false, message: "هذا الكيان محصن ضد الحظر." };
        }

        if (!isOwner) {
            if (actor.id === target.id) {
                return { success: false, message: "لا يمكنك حظر نفسك." };
            }

            if (isDirector) {
                if (targetRoles.includes('DIRECTOR')) {
                    return { success: false, message: "لا يمكن للمدير حظر مدير آخر." };
                }
            } 
            else if (isAdmin) {
                const hasProtectedRole = targetRoles.some((role: string) => PROTECTED_ROLES.includes(role));
                if (hasProtectedRole) {
                    return { success: false, message: "المسؤولون لا يملكون صلاحية حظر طاقم العمل." };
                }
            }
        }

        await prisma.user.update({
            where: { id: targetUserId },
            data: {
                isBanned: shouldBan,
                banReason: shouldBan ? reason : null,
                bannedAt: shouldBan ? new Date() : null,
            }
        });

        // THE FIX: Added 'max' profile argument
        revalidateTag('ban-status', 'max');
        revalidatePath('/studio/director');
        
        return { success: true, message: shouldBan ? "تم حظر المستخدم." : "تم رفع الحظر." };

    } catch (error) {
        console.error("Ban action failed:", error);
        return { success: false, message: "حدث خطأ في النظام." };
    }
}

--- END OF FILE app/actions/banActions.ts ---

================================================================================

--- START OF FILE app/actions/commentActions.ts ---

// app/actions/commentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { VoteType, NotificationType } from '@/lib/generated/client';
import { getAuthenticatedSession } from '@/lib/auth'; 

export async function postReplyOrComment(contentSlug: string, content: string, path: string, parentId?: string) {
    try {
        const session = await getAuthenticatedSession();
        if (!content || content.trim().length === 0) return { success: false, error: 'لا يمكن نشر تعليق فارغ.' };

        console.log(`[COMMENT] User ${session.user.id} commenting on ${contentSlug}. ParentID: ${parentId || 'None'}`);

        const newComment = await prisma.comment.create({
            data: { contentSlug, content, authorId: session.user.id, parentId },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });

        // --- NOTIFICATION LOGIC ---
        if (parentId) {
            console.log(`[NOTIF] Processing reply notification for comment ${parentId}...`);
            try {
                const parentComment = await prisma.comment.findUnique({
                    where: { id: parentId },
                    select: { authorId: true }
                });

                if (!parentComment) {
                    console.warn(`[NOTIF] Parent comment ${parentId} not found.`);
                } else {
                    console.log(`[NOTIF] Parent author: ${parentComment.authorId}, Replier: ${session.user.id}`);
                    
                    if (parentComment.authorId !== session.user.id) {
                        console.log(`[NOTIF] Creating notification record...`);
                        const notif = await prisma.notification.create({
                            data: {
                                userId: parentComment.authorId, // Recipient
                                senderId: session.user.id,      // Triggered by
                                type: NotificationType.REPLY,
                                resourceId: newComment.id,
                                resourceSlug: contentSlug,
                                link: `${path}#comment-${newComment.id}`
                            }
                        });
                        console.log(`[NOTIF] SUCCESS! Created notification ID: ${notif.id}`);
                    } else {
                        console.log(`[NOTIF] Skipped: User replying to themselves.`);
                    }
                }
            } catch (notifError) {
                console.error("[NOTIF] CRITICAL FAILURE:", notifError);
            }
        }
        // --------------------------

        revalidatePath(path);
        return { success: true, comment: newComment };
    } catch (error: any) {
        console.error("[COMMENT] Creation failed:", error);
        return { success: false, error: error.message || "تعذر نشر التعليق." };
    }
}

export async function deleteComment(commentId: string) {
    try {
        const session = await getAuthenticatedSession();
        const commentToDelete = await prisma.comment.findUnique({
            where: { id: commentId },
            include: { _count: { select: { replies: true } } }
        });
        
        if (!commentToDelete) return { success: false, error: 'التعليق غير موجود.' };

        const userRoles = session.user.roles || [];
        const isAuthor = commentToDelete.authorId === session.user.id;
        const isModerator = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

        if (!isAuthor && !isModerator) {
            return { success: false, error: 'غير مصرح لك.' };
        }

        if (commentToDelete._count.replies > 0) {
            const updatedComment = await prisma.comment.update({
                where: { id: commentId },
                data: { content: '[طُمِسَ التعليق]', isDeleted: true }
            });
            return { success: true, wasDeleted: false, updatedComment };
        } else {
            await prisma.comment.delete({ where: { id: commentId } });
            return { success: true, wasDeleted: true, deletedId: commentId };
        }
    } catch (error: any) {
        return { success: false, error: error.message || 'يأبى التعليقُ الحذف.' };
    }
}

export async function updateComment(commentId: string, content: string) {
    try {
        const session = await getAuthenticatedSession();
        if (!content || content.trim().length === 0) return { success: false, error: 'لا يمكن نشر تعليق فارغ.' };

        const comment = await prisma.comment.findUnique({ where: { id: commentId }, select: { authorId: true, contentSlug: true } });
        if (!comment || comment.authorId !== session.user.id) return { success: false, error: 'غير مصرح لك.' };

        const updatedComment = await prisma.comment.update({
            where: { id: commentId },
            data: { content },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });

        revalidatePath(`/reviews/${comment.contentSlug}`);
        revalidatePath(`/articles/${comment.contentSlug}`);
        revalidatePath(`/news/${comment.contentSlug}`);
        return { success: true, updatedComment };
    } catch (error: any) {
        return { success: false, error: error.message || "أخفق التحديث." };
    }
}

export async function voteOnComment(commentId: string, voteType: VoteType) {
    try {
        const session = await getAuthenticatedSession();
        const existingVote = await prisma.commentVote.findUnique({ where: { userId_commentId: { userId: session.user.id, commentId } } });
        
        if (existingVote) {
            if (existingVote.type === voteType) { await prisma.commentVote.delete({ where: { id: existingVote.id } }); } 
            else { await prisma.commentVote.update({ where: { id: existingVote.id }, data: { type: voteType } }); }
        } else {
            await prisma.commentVote.create({ data: { userId: session.user.id, commentId, type: voteType } });
        }
        
        const updatedComment = await prisma.comment.findUnique({ where: { id: commentId }, select: { votes: true } });
        if (!updatedComment) throw new Error("Comment not found after vote update.");
        return { success: true, updatedVotes: updatedComment.votes };
    } catch (error: any) {
        return { success: false, error: error.message || 'تعذّر تسجيل التصويت.' };
    }
}

export async function getReplies(parentId: string) {
    try {
        const replies = await prisma.comment.findMany({
            where: { parentId },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            },
            orderBy: { createdAt: 'asc' }
        });
        return { success: true, replies };
    } catch (error) {
        return { success: false, error: 'أبت الردودُ أن تُجلَب.' };
    }
}

--- END OF FILE app/actions/commentActions.ts ---

================================================================================

--- START OF FILE app/actions/contentActions.ts ---

// app/actions/contentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { getAuthenticatedSession } from '@/lib/auth';
import { EngagementType } from '@/lib/generated/client';

/**
 * An idempotent function to set the state of an engagement.
 * It ensures the final state in the DB matches the desired `isEngaged` state.
 */
async function setEngagement(userId: string, contentId: number, contentType: string, engagementType: EngagementType, isEngaged: boolean) {
    const whereClause = {
        userId_contentId_contentType_type: { userId, contentId, contentType, type: engagementType },
    };

    if (isEngaged) {
        await prisma.engagement.upsert({
            where: whereClause,
            update: {},
            create: { userId, contentId, contentType, type: engagementType },
        });
    } else {
        await prisma.engagement.deleteMany({
            where: { userId, contentId, contentType, type: engagementType },
        });
    }
}

export async function setBookmarkAction(contentId: number, contentType: string, isBookmarked: boolean) {
    try {
        const session = await getAuthenticatedSession();
        await setEngagement(session.user.id, contentId, contentType, 'BOOKMARK', isBookmarked);
        // No revalidation needed; UI is handled optimistically by the client store.
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setBookmarkAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطبٌ ما.' };
    }
}

export async function setLikeAction(contentId: number, contentType: string, contentSlug: string, isLiked: boolean) {
    try {
        const session = await getAuthenticatedSession();
        await setEngagement(session.user.id, contentId, contentType, 'LIKE', isLiked);
        
        // THE FIX: Removed revalidatePath. 
        // The heart icon updates instantly via the client store.
        // We don't need to rebuild the entire HTML page just for a like.
        
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setLikeAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطبٌ ما.' };
    }
}

export async function recordShareAction(contentId: number, contentType: string, contentSlug: string) {
    try {
        const session = await getAuthenticatedSession();
        const userId = session.user.id;

        await prisma.share.create({
            data: { userId, contentId, contentType },
        });

        // THE FIX: Removed revalidatePath.
        // The store updates shares locally.
        
        const updatedShares = await prisma.share.findMany({
            where: { userId },
            select: { contentId: true, contentType: true }
        });
        
        return { success: true, shares: updatedShares, message: 'Share recorded.' };
    } catch (error: any) {
        console.error("CRITICAL: recordShareAction failed:", error);
        return { success: false, error: error.message || 'Could not record share.' };
    }
}

--- END OF FILE app/actions/contentActions.ts ---

================================================================================

--- START OF FILE app/actions/creatorActions.ts ---

'use server';

import prisma from '@/lib/prisma';

export async function getCreatorUsernames(creatorIds: string[]) {
    if (!creatorIds || creatorIds.length === 0) {
        return {};
    }

    try {
        const users = await prisma.user.findMany({
            where: {
                id: { in: creatorIds }
            },
            select: {
                id: true,
                username: true
            }
        });

        // Create a map of prismaUserId -> username
        const usernameMap = users.reduce((acc: any, user: any) => {
            if (user.username) {
                acc[user.id] = user.username;
            }
            return acc;
        }, {} as Record<string, string>);

        return usernameMap;
    } catch (error) {
        console.error("Failed to fetch creator usernames:", error);
        return {};
    }
}




--- END OF FILE app/actions/creatorActions.ts ---

================================================================================

--- START OF FILE app/actions/notificationActions.ts ---

// app/actions/notificationActions.ts
'use server';

import prisma from '@/lib/prisma';
import { getAuthenticatedSession } from '@/lib/auth';

export async function getNotifications() {
    try {
        const session = await getAuthenticatedSession();
        console.log(`[NOTIF-FETCH] Fetching for user ${session.user.id}`);
        
        const notifications = await prisma.notification.findMany({
            where: { userId: session.user.id },
            include: {
                sender: { select: { name: true, image: true, username: true } }
            },
            orderBy: { createdAt: 'desc' },
            take: 20
        });
        
        const unreadCount = await prisma.notification.count({
            where: { userId: session.user.id, read: false }
        });

        console.log(`[NOTIF-FETCH] Found ${notifications.length} items, ${unreadCount} unread.`);

        return { success: true, notifications, unreadCount };
    } catch (error) {
        console.error("[NOTIF-FETCH] Error:", error);
        return { success: false, error: 'Failed to fetch notifications.' };
    }
}

export async function markNotificationAsRead(notificationId: string) {
    try {
        const session = await getAuthenticatedSession();
        await prisma.notification.updateMany({
            where: { id: notificationId, userId: session.user.id },
            data: { read: true }
        });
        return { success: true };
    } catch (error) {
        return { success: false, error: 'Failed to mark as read.' };
    }
}

export async function markAllNotificationsAsRead() {
    try {
        const session = await getAuthenticatedSession();
        await prisma.notification.updateMany({
            where: { userId: session.user.id, read: false },
            data: { read: true }
        });
        return { success: true };
    } catch (error) {
        return { success: false, error: 'Failed to mark all as read.' };
    }
}

--- END OF FILE app/actions/notificationActions.ts ---

================================================================================

--- START OF FILE app/actions/userActions.ts ---

// app/actions/userActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath, revalidateTag } from 'next/cache';
import { put } from '@vercel/blob';
import bcrypt from 'bcryptjs';
import { getAuthenticatedSession } from '@/lib/auth';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';

// MODIFIED: Created a reusable function to sync Prisma user data to Sanity creator documents.
async function syncUserToSanity(userId: string) {
    try {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { id: true, name: true, image: true, bio: true, roles: { select: { name: true } } },
        });

        if (!user || !user.name) {
            console.warn(`[Sanity Sync] User ${userId} not found or has no name. Skipping sync.`);
            return;
        }

        const userRoles = user.roles.map((r: any) => r.name);
        const creatorTypes = userRoles
            .map((role: string) => ({
                'REVIEWER': 'reviewer',
                'AUTHOR': 'author',
                'REPORTER': 'reporter',
                'DESIGNER': 'designer',
            }[role]))
            .filter(Boolean) as string[];

        if (creatorTypes.length === 0) {
            return; // Not a creator, no need to sync.
        }

        const sanityDocs = await sanityWriteClient.fetch(
            groq`*[_type in $creatorTypes && prismaUserId == $userId]`,
            { creatorTypes, userId: user.id }
        );

        let imageAssetRef: string | undefined = undefined;
        if (user.image && user.image.startsWith('https://')) {
            try {
                // Check if this image URL already exists as an asset to avoid re-uploading
                const existingAsset = await sanityWriteClient.fetch(groq`*[_type == "sanity.imageAsset" && url == $imageUrl][0]._id`, { imageUrl: user.image });
                if (existingAsset) {
                    imageAssetRef = existingAsset;
                } else {
                    const response = await fetch(user.image);
                    const imageBlob = await response.blob();
                    const imageAsset = await sanityWriteClient.assets.upload('image', imageBlob, {
                        contentType: imageBlob.type,
                        filename: `${user.id}-avatar.jpg`
                    });
                    imageAssetRef = imageAsset._id;
                }
            } catch (e) {
                console.warn(`[Sanity Sync] Image upload failed for user ${userId}. Skipping image update.`, e);
            }
        }

        const transaction = sanityWriteClient.transaction();
        for (const doc of sanityDocs) {
            const patchData: { name: string; bio: string | null; image?: any } = {
                name: user.name,
                bio: user.bio,
            };
            if (imageAssetRef) {
                patchData.image = {
                    _type: 'image',
                    asset: { _type: 'reference', _ref: imageAssetRef }
                };
            }
            transaction.patch(doc._id, { set: patchData });
        }
        await transaction.commit();
        console.log(`[Sanity Sync] Synced profile for user ${userId} to ${sanityDocs.length} creator document(s).`);

    } catch (error) {
        console.error(`[CRITICAL] Failed to sync user ${userId} to Sanity:`, error);
        // We don't throw here to avoid failing the main user action.
    }
}

export async function getUserState() {
    try {
        const session = await getAuthenticatedSession();
        // Fetch all user state in parallel
        const [engagements, shares] = await Promise.all([
            prisma.engagement.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true, type: true } 
            }),
            prisma.share.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true } 
            }),
        ]);
        return { success: true, data: { engagements, shares } };
    } catch (error) {
        // This will happen if the user is not logged in, which is expected.
        return { success: false, data: null };
    }
}

export async function updateUserProfile(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        
        const name = formData.get('name') as string;
        const username = (formData.get('username') as string)?.toLowerCase();
        const bio = formData.get('bio') as string;
        const twitterHandle = formData.get('twitterHandle') as string;
        const instagramHandle = formData.get('instagramHandle') as string;
        const agePublic = formData.get('agePublic') === 'on';
        const countryPublic = formData.get('countryPublic') === 'on';

        if (username) {
            const validation = validateUsername(username);
            if (!validation.success) throw new Error(validation.message);
            const existingUser = await prisma.user.findUnique({ where: { username } });
            if (existingUser && existingUser.id !== session.user.id) {
                throw new Error('اسمٌ محجوز.');
            }
        }
        
        await prisma.user.update({
            where: { id: session.user.id },
            data: {
                name: name || undefined,
                username: username || undefined,
                bio: bio.slice(0, 500),
                twitterHandle,
                instagramHandle,
                agePublic,
                countryPublic,
            },
        });
        
        // MODIFIED: Trigger the Sanity sync after a successful profile update.
        await syncUserToSanity(session.user.id);

        // THE DEFINITIVE FIX: Added 'max' argument to revalidateTag.
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidatePath('/profile');
        revalidatePath(`/profile/${session.user.id}`);
        if (username) revalidatePath(`/creators/${username}`);

        return { success: true, message: 'تَجَدَّدَ مَلَفُكَ الشخصي.' };
    } catch (error: any) {
        return { success: false, message: error.message || 'أخفق تحديث الملف.' };
    }
}

export async function completeOnboardingAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });

        const fullName = formData.get('fullName') as string;
        const username = (formData.get('username') as string)?.toLowerCase();
        const ageStr = formData.get('age') as string;
        const country = formData.get('country') as string;

        if (!fullName || fullName.trim() === '') {
            return { success: false, message: 'الاسم الكامل مطلوب.' };
        }
        if (!username) {
            return { success: false, message: 'اسم المستخدم مطلوب.' };
        }

        if (username !== user?.username) {
            const usernameValidation = await checkUsernameAvailability(username);
            if (!usernameValidation.available) {
                return { success: false, message: usernameValidation.message };
            }
        }

        await prisma.user.update({
            where: { id: session.user.id },
            data: {
                name: fullName,
                username: username,
                age: ageStr ? parseInt(ageStr, 10) : null,
                country: country || null,
            },
        });

        // THE DEFINITIVE FIX: Added 'max' argument to revalidateTag.
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidatePath('/profile');
        if (username) revalidatePath(`/profile/${username}`);
        
        return { success: true };

    } catch (error: any) {
        return { success: false, message: error.message || 'طرأ خطبٌ عند التهيئة.' };
    }
}

export async function changePasswordAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });

        if (!user?.password) {
            return { success: false, message: 'لا يمكن تغيير كلمة السر للحسابات المربوطة بمزود خارجي.' };
        }

        const currentPassword = formData.get('currentPassword') as string;
        const newPassword = formData.get('newPassword') as string;
        const confirmPassword = formData.get('confirmPassword') as string;

        if (!currentPassword || !newPassword || !confirmPassword) {
            return { success: false, message: 'الحقولُ كلُّها لازمة.' };
        }

        const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
        if (!isPasswordValid) {
            return { success: false, message: 'كلمة السر الحالية خاطئة.' };
        }

        if (newPassword.length < 8) {
            return { success: false, message: 'كلمة السر الجديدة لا تقل عن ثمانيةِ حروف.' };
        }

        if (newPassword !== confirmPassword) {
            return { success: false, message: 'الكلمتان الجديدتان لا تتطابقان.' };
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await prisma.user.update({
            where: { id: user.id },
            data: { password: hashedPassword },
        });

        return { success: true, message: 'تغيَّرت كلمة السر.' };

    } catch (error: any) {
        return { success: false, message: error.message || 'طرأ خطبٌ ما.' };
    }
}
const validateUsername = (username: string) => {
    if (!username) return { success: false, message: 'اسم المستخدم مطلوب.' };
    const usernameRegex = /^[a-z0-9_]{3,20}$/;
    if (!usernameRegex.test(username)) {
        return { success: false, message: 'اسم المستخدم يجب أن يتكون من 3-20 حرفًا إنجليزيًا.' };
    }
    return { success: true, message: '' };
};

export async function checkUsernameAvailability(username: string): Promise<{ available: boolean; message: string }> {
    const validation = validateUsername(username);
    if (!validation.success) {
        return { available: false, message: validation.message };
    }
    const existingUser = await prisma.user.findUnique({ where: { username } });
    if (existingUser) {
        return { available: false, message: 'اسمٌ محجوز.' };
    }
    return { available: true, message: 'الاسمُ متاح.' };
}
export async function signUp(formData: FormData) {
    const name = formData.get('name') as string;
    const email = (formData.get('email') as string)?.toLowerCase(); // MODIFIED
    const password = formData.get('password') as string;
    const username = (formData.get('username') as string)?.toLowerCase();
    if (!name || !email || !password || !username) {
        return { success: false, message: 'الحقولُ كلُّها لازمة.' };
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
        return { success: false, message: 'البريد الإلكتروني غير صالح.' };
    }
    if (password.length < 8) {
        return { success: false, message: 'كلمة السر لا تقل عن ثمانيةِ حروف.' };
    }
    const usernameValidation = await checkUsernameAvailability(username);
    if (!usernameValidation.available) {
        return { success: false, message: usernameValidation.message };
    }
    const existingEmail = await prisma.user.findUnique({ where: { email } });
    if (existingEmail) {
        return { success: false, message: 'بريدٌ مسجل.' };
    }
    return { success: true, message: 'تمَّت المصادقة.' };
}
export async function setUsernameAction(username: string) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });
        if (user?.username) return { success: false, message: 'الاسمُ قد عُيِّن.' };

        const cleanUsername = username.toLowerCase();
        const validation = await checkUsernameAvailability(cleanUsername);
        if (!validation.available) return { success: false, message: validation.message };

        await prisma.user.update({
            where: { id: session.user.id },
            data: { username: cleanUsername },
        });
        revalidatePath('/profile');
        return { success: true };
    } catch (error: any) {
        return { success: false, message: error.message || 'أخفق تحديث الاسم.' };
    }
}
export async function updateUserAvatar(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const avatarFile = formData.get('avatar') as File | null;
        if (!avatarFile || avatarFile.size === 0) return { success: true, message: 'لا صورة جديدة.' };

        const sanitizedFilename = `${session.user.id}-${Date.now()}-${avatarFile.name.replace(/[^a-zA-Z0-9._-]/g, '-')}`;
        const blob = await put(sanitizedFilename, avatarFile, { access: 'public', contentType: avatarFile.type });
        await prisma.user.update({ where: { id: session.user.id }, data: { image: blob.url } });
        
        // MODIFIED: Trigger Sanity sync after avatar update.
        await syncUserToSanity(session.user.id);
        
        revalidatePath('/profile');
        // THE DEFINITIVE FIX: Added 'max' argument to revalidateTag.
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        return { success: true, message: 'تجدَّدت الصورة الرمزية.' };
    } catch (error: any) {
        return { success: false, message: error.message || 'أخفق الرفع.' };
    }
}
export async function getCommentedContentIds() {
    try {
        const session = await getAuthenticatedSession();
        const comments = await prisma.comment.findMany({
            where: { authorId: session.user.id, isDeleted: false },
            select: { contentSlug: true },
            distinct: ['contentSlug'],
        });
        return comments.map((c: any) => c.contentSlug);
    } catch (error) {
        return [];
    }
}

--- END OF FILE app/actions/userActions.ts ---

================================================================================

--- START OF FILE app/api/articles/route.ts ---

// app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedArticlesQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { unstable_cache } from 'next/cache';
import { enrichContentList } from '@/lib/enrichment';

const getCachedPaginatedArticles = unstable_cache(
    async (
        gameSlug: string | undefined, 
        tagSlugs: string[] | undefined, 
        searchTerm: string | undefined, 
        offset: number, 
        limit: number,
        sort: 'latest' | 'viral'
    ) => {
        const query = paginatedArticlesQuery(gameSlug, tagSlugs, searchTerm, offset, limit, sort);
        const sanityData = await client.fetch(query);
        const enrichedData = await enrichContentList(sanityData);
        // OPTIMIZATION: 600px width for grid items
        return enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);
    },
    ['paginated-articles'],
    { tags: ['article'] }
);

export async function GET(req: NextRequest) {
    try {
        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '0');
        const limit = parseInt(searchParams.get('limit') || '20');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'viral') || 'latest';

        const data = await getCachedPaginatedArticles(
            gameSlug, 
            tagSlugs, 
            searchTerm, 
            offset, 
            limit,
            sort
        );

        return NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });

    } catch (error) {
        console.error('Error fetching paginated articles:', error);
        return NextResponse.json({ error: 'Failed to fetch articles data' }, { status: 500 });
    }
}

--- END OF FILE app/api/articles/route.ts ---

================================================================================

--- START OF FILE app/api/auth/[...nextauth]/route.ts ---

// app/api/auth/[...nextauth]/route.ts

import NextAuth from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };




--- END OF FILE app/api/auth/[...nextauth]/route.ts ---

================================================================================

--- START OF FILE app/api/blob/upload/route.ts ---

// app/api/blob/upload/route.ts

import { put } from '@vercel/blob';
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import prisma from '@/lib/prisma'; // <-- THE FIX: Import prisma

export async function POST(request: NextRequest): Promise<NextResponse> {
  const body = await request.json();
  const { filename, contentType } = body;

  if (!filename || !contentType) {
    return NextResponse.json(
      { error: 'Filename and contentType are required' },
      { status: 400 }
    );
  }

  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
        return NextResponse.json({ error: 'غير مُصرَّح به' }, { status: 401 });
    }

    // THE DEFINITIVE FIX: Fetch fresh roles from DB
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id },
        select: { roles: { select: { name: true } } }
    });
    const userRoles = user?.roles.map((r: any) => r.name) || [];

    const isCreatorOrAdmin = userRoles.some((role: string) =>
      ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role)
    );

    if (!isCreatorOrAdmin) {
      return NextResponse.json(
        { error: 'غير مُصرَّح به' },
        { status: 401 }
      );
    }

    const blob = await put(filename, Buffer.from(''), {
      access: 'public',
      contentType,
    });

    return NextResponse.json(blob);
  } catch (error) {
    console.error('Error creating blob:', error);
    return NextResponse.json(
      { error: 'Failed to create blob' },
      { status: 500 }
    );
  }
}

--- END OF FILE app/api/blob/upload/route.ts ---

================================================================================

--- START OF FILE app/api/comments/[slug]/route.ts ---

// app/api/comments/[slug]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export const dynamic = 'force-dynamic'; // Ensures this route is always server-rendered

// MODIFIED: The context for params is now correctly typed as a Promise.
export async function GET(req: NextRequest, { params: paramsPromise }: { params: Promise<{ slug: string }> }) {
    try {
        // MODIFIED: We must await the promise to get the slug.
        const { slug } = await paramsPromise;

        if (!slug) {
            return NextResponse.json({ error: 'Slug is required' }, { status: 400 });
        }
        
        const comments = await prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { 
                author: { select: { id: true, name: true, image: true, username: true } }, 
                votes: true, 
                _count: { select: { replies: true } }, 
                replies: { 
                    take: 2, 
                    include: { 
                        author: { select: { id: true, name: true, image: true, username: true } }, 
                        votes: true, 
                        _count: { select: { replies: true } } 
                    }, 
                    orderBy: { createdAt: 'asc' } 
                } 
            },
            orderBy: { createdAt: 'desc' },
        });

        return NextResponse.json(comments);

    } catch (error) {
        console.error('API Error fetching comments:', error);
        return NextResponse.json({ error: 'Failed to fetch comments.' }, { status: 500 });
    }
}

--- END OF FILE app/api/comments/[slug]/route.ts ---

================================================================================

--- START OF FILE app/api/content-by-ids/route.ts ---

// app/api/content-by-ids/route.ts

import { NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { contentByIdsQuery } from '@/lib/sanity.queries';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { ids } = body;

    if (!Array.isArray(ids) || ids.length === 0) {
      return NextResponse.json([]);
    }

    const content = await client.fetch(contentByIdsQuery, { ids });

    return NextResponse.json(content);

  } catch (error) {
    console.error('API Error in /api/content-by-ids:', error);
    return NextResponse.json(
      { error: 'Failed to fetch content by IDs.' },
      { status: 500 }
    );
  }
}


--- END OF FILE app/api/content-by-ids/route.ts ---

================================================================================

--- START OF FILE app/api/cron/revalidate-scheduled/route.ts ---

// app/api/cron/revalidate-scheduled/route.ts

import { revalidatePath } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';

// This is the CRON job handler. It is secured by a secret token from Vercel.
export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('غير مُخَوَّل.', { status: 401 });
  }

  // Find all documents that were scheduled to be published in the last minute
  // and are now past their publication date.
  const now = new Date();
  const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);

  const query = groq`*[_type in ["مراجعة", "مقالة", "خبر"] && publishedAt >= $oneMinuteAgo && publishedAt < $now] {
    _type,
    "slug": slug.current
  }`;

  try {
    const docsToRevalidate: { _type: string; slug: string }[] = await sanityWriteClient.fetch(query, {
      oneMinuteAgo: oneMinuteAgo.toISOString(),
      now: now.toISOString(),
    });

    if (docsToRevalidate.length === 0) {
      return NextResponse.json({ success: true, message: 'لا وثائقَ لإعادة المصادقة.' });
    }

    // Use a Set to avoid revalidating the same path multiple times
    const pathsToRevalidate = new Set<string>();
    docsToRevalidate.forEach(doc => {
      const contentTypePlural = doc._type === 'خبر' ? 'خبر' : `${doc._type}s`;
      pathsToRevalidate.add(`/${contentTypePlural}`); // e.g., /articles
      pathsToRevalidate.add(`/${contentTypePlural}/${doc.slug}`); // e.g., /articles/my-slug
    });

    // Trigger revalidation for all unique paths
    pathsToRevalidate.forEach(path => {
      revalidatePath(path);
    });

    return NextResponse.json({ success: true, revalidatedPaths: Array.from(pathsToRevalidate) });

  } catch (error) {
    console.error('Cron job failed:', error);
    return NextResponse.json({ success: false, message: 'Cron job failed.' }, { status: 500 });
  }
}



















--- END OF FILE app/api/cron/revalidate-scheduled/route.ts ---

================================================================================

--- START OF FILE app/api/engagement-scores/route.ts ---

// app/api/engagement-scores/route.ts
import prisma from '@/lib/prisma';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const contentTypes = ['review', 'article', 'news'];
    
    // Find all unique contentIds across all types with a LIKE engagement
    const contentIdsQuery = await prisma.engagement.findMany({
        where: { contentType: { in: contentTypes }, type: 'LIKE' },
        select: { contentId: true },
        distinct: ['contentId']
    });
    const ids = contentIdsQuery.map((i: any) => i.contentId);

    // Aggregate Likes and Shares in parallel for all found IDs
    const [likes, shares] = await Promise.all([
        prisma.engagement.groupBy({
            by: ['contentId'],
            where: { contentId: { in: ids }, type: 'LIKE' },
            _count: { userId: true },
        }),
        prisma.share.groupBy({
            by: ['contentId'],
            where: { contentId: { in: ids } },
            _count: { userId: true },
        })
    ]);
    
    // Aggregate results and calculate viral score
    const result = ids.map((id: number) => {
        const likeCount = likes.find((s: any) => s.contentId === id)?._count.userId || 0;
        const shareCount = shares.find((s: any) => s.contentId === id)?._count.userId || 0;
        
        // Weighted viral score: Shares (x5) + Likes (x2)
        const engagementScore = (likeCount * 2) + (shareCount * 5); 
        
        return { id, engagementScore };
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Failed to fetch engagement scores:', error);
    return NextResponse.json({ error: 'Failed to fetch engagement metrics' }, { status: 500 });
  }
}

--- END OF FILE app/api/engagement-scores/route.ts ---

================================================================================

--- START OF FILE app/api/news/route.ts ---

// app/api/news/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedNewsQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { unstable_cache } from 'next/cache';
import { enrichContentList } from '@/lib/enrichment';

const getCachedPaginatedNews = unstable_cache(
    async (
        gameSlug: string | undefined, 
        tagSlugs: string[] | undefined, 
        searchTerm: string | undefined, 
        offset: number, 
        limit: number,
        sort: 'latest' | 'viral'
    ) => {
        const tags = tagSlugs?.length === 0 ? undefined : tagSlugs;
        const query = paginatedNewsQuery(gameSlug, tags, searchTerm, offset, limit, sort);
        const sanityData = await client.fetch(query);
        const enrichedData = await enrichContentList(sanityData);
        // OPTIMIZATION: 600px width for grid items
        const data = enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);
        return data;
    },
    ['paginated-news'],
    { tags: ['news'] }
);

export async function GET(req: NextRequest) {
    try {
        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '50');
        const limit = parseInt(searchParams.get('limit') || '50');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'viral') || 'latest';
        
        const data = await getCachedPaginatedNews(
            gameSlug, 
            tagSlugs, 
            searchTerm, 
            offset, 
            limit,
            sort
        );

        return NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });

    } catch (error) {
        console.error('Error fetching paginated news:', error);
        return NextResponse.json({ error: 'Failed to fetch news data' }, { status: 500 });
    }
}

--- END OF FILE app/api/news/route.ts ---

================================================================================

--- START OF FILE app/api/news-engagement/route.ts ---

// app/api/news-engagement/route.ts

import prisma from '@/lib/prisma';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // 1. Find all unique legacyIds (contentIds) tagged as 'خبر' and of type 'LIKE'
    const contentIdsQuery = await prisma.engagement.findMany({
        where: { contentType: 'خبر', type: 'LIKE' },
        select: { contentId: true },
        distinct: ['contentId']
    });
    const ids = contentIdsQuery.map((i: any) => i.contentId);

    // 2. Aggregate Likes and Shares separately
    const likes = await prisma.engagement.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر', type: 'LIKE' },
        _count: { userId: true },
    });

    const shares = await prisma.share.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر' },
        _count: { userId: true },
    });
    
    // Note: We cannot reliably calculate comments in this API without complex database mappings, 
    // so we maintain the weighted scoring structure based on available data (Likes/Shares).

    // 3. Aggregate results and calculate viral score
    const result = ids.map((id: number) => {
        const likeCount = likes.find((s: any) => s.contentId === id)?._count.userId || 0;
        const shareCount = shares.find((s: any) => s.contentId === id)?._count.userId || 0;
        
        // Weighted viral score: Shares (x5) + Likes (x2)
        const engagementScore = likeCount * 2 + shareCount * 5; 
        
        return {
            id,
            engagementScore,
        };
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Failed to fetch news engagement:', error);
    return NextResponse.json({ error: 'Failed to fetch engagement metrics' }, { status: 500 });
  }
}

--- END OF FILE app/api/news-engagement/route.ts ---

================================================================================

--- START OF FILE app/api/revalidate/route.ts ---

// app/api/revalidate/route.ts
import { revalidateTag } from 'next/cache'
import { type NextRequest, NextResponse } from 'next/server'
import { parseBody } from 'next-sanity/webhook'

type WebhookPayload = {
  _type: string
  slug?: {
    current: string
  }
}

export async function POST(req: NextRequest) {
  try {
    const { body, isValidSignature } = await parseBody<WebhookPayload>(
      req,
      process.env.REVALIDATION_SECRET_TOKEN,
    )
    if (!isValidSignature) {
      const message = 'Invalid signature'
      console.warn(`[REVALIDATE] ${message}`)
      return new Response(JSON.stringify({ message, body }), { status: 401 })
    }

    if (!body?._type) {
      const message = 'Bad Request: Missing _type in body'
      console.warn(`[REVALIDATE] ${message}`)
      return new Response(JSON.stringify({ message, body }), { status: 400 })
    }
    
    console.log(`[REVALIDATE] Received webhook for type: ${body._type}. Revalidating tag...`)
    // THE FIX: Added 'max' profile argument
    revalidateTag(body._type, 'max')

    const message = `Successfully revalidated tag: ${body._type}`
    console.log(`[REVALIDATE] ${message}`)
    return NextResponse.json({ body, message, revalidated: true, date: new Date().toISOString() })
  } catch (err: any) {
    console.error('[REVALIDATE] Error:', err)
    return new Response(err.message, { status: 500 })
  }
}

--- END OF FILE app/api/revalidate/route.ts ---

================================================================================

--- START OF FILE app/api/reviews/route.ts ---

// app/api/reviews/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedReviewsQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { unstable_cache } from 'next/cache';
import { ScoreFilter } from '@/components/filters/ReviewFilters';
import { enrichContentList } from '@/lib/enrichment';

const getCachedPaginatedReviews = unstable_cache(
    async (
        gameSlug: string | undefined, 
        tagSlugs: string[] | undefined, 
        searchTerm: string | undefined, 
        scoreRange: ScoreFilter | undefined,
        offset: number, 
        limit: number,
        sort: 'latest' | 'score'
    ) => {
        const query = paginatedReviewsQuery(gameSlug, tagSlugs, searchTerm, scoreRange, offset, limit, sort);
        const sanityData = await client.fetch(query);
        const enrichedData = await enrichContentList(sanityData);
        // OPTIMIZATION: 600px width for grid items
        return enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);
    },
    ['paginated-reviews'],
    { tags: ['review'] }
);

export async function GET(req: NextRequest) {
    try {
        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '0');
        const limit = parseInt(searchParams.get('limit') || '20');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'score') || 'latest';
        const scoreRange = searchParams.get('score') as ScoreFilter || undefined;

        const data = await getCachedPaginatedReviews(
            gameSlug, 
            tagSlugs, 
            searchTerm, 
            scoreRange,
            offset, 
            limit,
            sort
        );

        return NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });

    } catch (error) {
        console.error('Error fetching paginated reviews:', error);
        return NextResponse.json({ error: 'Failed to fetch reviews data' }, { status: 500 });
    }
}

--- END OF FILE app/api/reviews/route.ts ---

================================================================================

--- START OF FILE app/api/search/route.ts ---

import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { searchQuery } from '@/lib/sanity.queries';
import { SanitySearchResult } from '@/types/sanity';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q') || '';

  if (query.length < 3) {
    return NextResponse.json([]);
  }

  try {
    const results = await client.fetch<SanitySearchResult[]>(searchQuery, { searchTerm: query });
    return NextResponse.json(results);
  } catch (error) {
    console.error('Sanity search failed:', error);
    return NextResponse.json({ error: 'Search failed' }, { status: 500 });
  }
}




--- END OF FILE app/api/search/route.ts ---

================================================================================

--- START OF FILE app/api/translate/route.ts ---

// app/api/translate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { translateTitleToAction } from '@/app/studio/actions';
import prisma from '@/lib/prisma'; // <-- THE FIX: Import prisma

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
        return NextResponse.json({ error: 'غير مُصرَّح به.' }, { status: 401 });
    }

    // THE DEFINITIVE FIX: Fetch fresh roles from DB
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id },
        select: { roles: { select: { name: true } } }
    });
    const userRoles = user?.roles.map((r: any) => r.name) || [];

    const isAuthorized = userRoles.some((role: string) =>
      ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role)
    );

    if (!isAuthorized) {
      return NextResponse.json({ error: 'غير مُصرَّح به.' }, { status: 401 });
    }

    const { title } = await request.json();

    if (!title || typeof title !== 'string') {
      return NextResponse.json({ error: 'العنوان مطلوب.' }, { status: 400 });
    }

    const slug = await translateTitleToAction(title);

    return NextResponse.json({ slug });
  } catch (error) {
    console.error('API Error in /api/translate:', error);
    return NextResponse.json(
      { error: 'فشل في الترجمة.' },
      { status: 500 }
    );
  }
}

--- END OF FILE app/api/translate/route.ts ---

================================================================================

--- START OF FILE app/articles/ArticlesPageClient.tsx ---

// app/articles/ArticlesPageClient.tsx
'use client';

import React, { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import HorizontalShowcase from '@/components/HorizontalShowcase';
import ArticleFilters from '@/components/filters/ArticleFilters';
import ArticleCard from '@/components/ArticleCard';
import Image from 'next/image';
import Link from 'next/link';
import AnimatedGridBackground from '@/components/AnimatedGridBackground';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from '@/components/HorizontalShowcase.module.css';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { ContentBlock } from '@/components/ContentBlock';
import { ArticleIcon } from '@/components/icons';

const fetchArticles = async (params: URLSearchParams) => {
    const res = await fetch(`/api/articles?${params.toString()}`);
    if (!res.ok) throw new Error('Failed to fetch articles');
    return res.json();
};
// ... ArrowIcon and MobileShowcase (unchanged, omitting for brevity as they are purely visual/local)
const ArrowIcon = ({ direction = 'right' }: { direction?: 'left' | 'right' }) => (
    <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
      <polyline points={direction === 'right' ? "9 18 15 12 9 6" : "15 18 9 12 15 6"} />
    </svg>
);
  
const MobileShowcase = ({ articles, onActiveIndexChange }: { articles: CardProps[], onActiveIndexChange: (index: number) => void }) => {
    const [[page, direction], setPage] = useState([0, 0]);
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    
    const paginate = (newDirection: number) => {
        const newIndex = (page + newDirection + articles.length) % articles.length;
        setPage([newIndex, newDirection]);
        onActiveIndexChange(newIndex);
    };

    const activeArticle = articles[page];
    const layoutIdPrefix = "articles-showcase";
    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(`/articles/${activeArticle.slug}`, { scroll: false });
    };
    
    const variants = {
        enter: (direction: number) => ({ opacity: 0, x: direction > 0 ? 100 : -100 }),
        center: { opacity: 1, x: 0 },
        exit: (direction: number) => ({ opacity: 0, x: direction < 0 ? 100 : -100 }),
    };

    return (
        <div className={styles.mobileShowcaseContainer}>
             <AnimatePresence initial={false} custom={direction} mode="wait">
                <motion.div key={page} custom={direction} variants={variants} initial="enter" animate="center" exit="exit" className={styles.mobileShowcaseCardWrapper} transition={{ duration: 0.4, ease: 'easeInOut' }}>
                    <motion.div
                        layoutId={`${layoutIdPrefix}-card-container-${activeArticle.legacyId}`}
                        onClick={handleClick}
                        className={`no-underline ${styles.showcaseCardLink}`}
                    >
                        <motion.div layoutId={`${layoutIdPrefix}-card-image-${activeArticle.legacyId}`} className={styles.showcaseCardImageWrapper}><Image src={activeArticle.imageUrl} alt={activeArticle.title} fill sizes="80vw" style={{ objectFit: 'cover' }} className={styles.showcaseCardImage}/></motion.div>
                        <div className={styles.showcaseCardContent}><motion.h3 layoutId={`${layoutIdPrefix}-card-title-${activeArticle.legacyId}`} className={styles.showcaseCardTitle}>{activeArticle.title}</motion.h3><p className={styles.showcaseCardGame}>{activeArticle.game}</p></div>
                    </motion.div>
                </motion.div>
            </AnimatePresence>
            <button className={`${styles.showcaseArrow} ${styles.left}`} onClick={() => paginate(-1)}><ArrowIcon direction="left" /></button>
            <button className={`${styles.showcaseArrow} ${styles.right}`} onClick={() => paginate(1)}><ArrowIcon direction="right" /></button>
        </div>
    );
};

export default function ArticlesPageClient({ featuredArticles, initialGridArticles, allGames, allGameTags, allArticleTypeTags }: {
  featuredArticles: SanityArticle[]; initialGridArticles: SanityArticle[]; allGames: SanityGame[]; allGameTags: SanityTag[]; allArticleTypeTags: SanityTag[];
}) {
    const [activeIndex, setActiveIndex] = useState(0);
    const [isMobile, setIsMobile] = useState(false);
    const intersectionRef = useRef(null);
    const isInView = useInView(intersectionRef, { margin: '400px' });

    // OPTIMIZATION: 600px for grid items
    const initialCards = useMemo(() => initialGridArticles.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [initialGridArticles]);
    const [allFetchedArticles, setAllFetchedArticles] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    const [nextOffset, setNextOffset] = useState<number | null>(initialCards.length === 20 ? 20 : null);
    
    useEffect(() => { const checkMobile = () => setIsMobile(window.innerWidth <= 768); checkMobile(); window.addEventListener('resize', checkMobile); return () => window.removeEventListener('resize', checkMobile); }, []);

    const [searchTerm, setSearchTerm] = useState('');
    const [sortOrder, setSortOrder] = useState<'latest' | 'viral'>('latest');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedGameTags, setSelectedGameTags] = useState<SanityTag[]>([]);
    const [selectedArticleType, setSelectedArticleType] = useState<SanityTag | null>(null);
    
    const gridArticles = useMemo(() => {
        let items = [...allFetchedArticles];
        if (searchTerm) { items = items.filter(article => article.title.toLowerCase().includes(searchTerm.toLowerCase())); }
        if (selectedGame) { items = items.filter(article => article.game === selectedGame.title); }
        const allSelectedTags = [...selectedGameTags, ...(selectedArticleType ? [selectedArticleType] : [])];
        if (allSelectedTags.length > 0) { const selectedTagTitles = new Set(allSelectedTags.map(t => t.title)); items = items.filter(article => article.tags.some(t => selectedTagTitles.has(t.title))); }
        return items;
    }, [allFetchedArticles, searchTerm, selectedGame, selectedGameTags, selectedArticleType]);

    const hasActiveFilters = useMemo(() => {
        return !!searchTerm || !!selectedGame || selectedGameTags.length > 0 || !!selectedArticleType || sortOrder !== 'latest';
    }, [searchTerm, selectedGame, selectedGameTags, selectedArticleType, sortOrder]);
    
    const canLoadMore = useMemo(() => {
        return nextOffset !== null && !hasActiveFilters;
    }, [nextOffset, hasActiveFilters]);

    useEffect(() => {
        if (isInView && canLoadMore && !isLoading) {
            const loadMore = async () => {
                setIsLoading(true);
                const params = new URLSearchParams({ offset: String(nextOffset), limit: '20', sort: sortOrder });
                try {
                    const result = await fetchArticles(params);
                    setAllFetchedArticles(prev => [...prev, ...result.data]);
                    setNextOffset(result.nextOffset);
                } catch (error) { console.error("Failed to load more articles:", error); } 
                finally { setIsLoading(false); }
            };
            loadMore();
        }
    }, [isInView, canLoadMore, isLoading, nextOffset, sortOrder]);

    const handleGameTagToggle = (tag: SanityTag) => { setSelectedGameTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]); };
    const handleClearAllFilters = () => { setSelectedGame(null); setSelectedGameTags([]); setSelectedArticleType(null); setSearchTerm(''); setSortOrder('latest'); };
    
    // OPTIMIZATION: 800px for showcase items
    const featuredForShowcase = useMemo(() => featuredArticles.map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[], [featuredArticles]);
    const activeBackgroundUrl = featuredForShowcase[activeIndex]?.imageUrl;

    return (
        <React.Fragment>
            <AnimatedGridBackground />
            <div className={styles.articlesPageContainer}>
                <AnimatePresence>{activeBackgroundUrl && (<motion.div key={activeBackgroundUrl} className={styles.articlesPageBg} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><Image src={activeBackgroundUrl} alt="Dynamic background" fill style={{ objectFit: 'cover' }} /><div className={styles.articlesPageBgOverlay} /></motion.div>)}</AnimatePresence>
                <div className="container" style={{ paddingTop: '4rem', paddingBottom: '6rem', minHeight: '80vh' }}>
                    <h1 className="page-title" style={{ color: '#fff', textShadow: '0 3px 15px rgba(0,0,0,0.5)', fontSize: '5rem', marginTop: '0.7rem', marginBottom: '4rem' }}>أحدث المقالات</h1>
                    <div className={styles.showcaseSection}>{isMobile ? (<MobileShowcase articles={featuredForShowcase} onActiveIndexChange={setActiveIndex} />) : (<HorizontalShowcase articles={featuredForShowcase} onActiveIndexChange={setActiveIndex} />)}</div>
                    <div className={styles.gridSection}>
                        <ArticleFilters sortOrder={sortOrder} onSortChange={setSortOrder} searchTerm={searchTerm} onSearchChange={setSearchTerm} allGames={allGames} selectedGame={selectedGame} onGameSelect={setSelectedGame} allGameTags={allGameTags} selectedGameTags={selectedGameTags} onGameTagToggle={handleGameTagToggle} allArticleTypeTags={allArticleTypeTags} selectedArticleType={selectedArticleType} onArticleTypeSelect={setSelectedArticleType} onClearAllFilters={handleClearAllFilters} />
                        
                        <ContentBlock title="كل المقالات" Icon={ArticleIcon}>
                            <motion.div layout className="content-grid">
                                <AnimatePresence>
                                    {gridArticles.map((article, index) => ( <ArticleCard key={article.id} article={article} layoutIdPrefix="articles-grid" isPriority={index < 3} /> ))}
                                </AnimatePresence>
                            </motion.div>

                            <div ref={intersectionRef} style={{ height: '1px', margin: '1rem 0' }} />

                            <AnimatePresence>
                                {isLoading && ( <motion.div key="loading" style={{display: 'flex', justifyContent: 'center', padding: '4rem'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}> <div className="spinner" /> </motion.div> )}
                            </AnimatePresence>
                            
                            <AnimatePresence>
                                {(!isLoading && gridArticles.length > 0 && (nextOffset === null || hasActiveFilters)) && (
                                    <motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                                        {hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}
                                    </motion.p>
                                )}
                            </AnimatePresence>

                            {gridArticles.length === 0 && !isLoading && ( <motion.p key="no-match" style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}> لم نعثر على مقالاتٍ توافقُ مُرادك. </motion.p> )}
                        </ContentBlock>
                    </div>
                </div>
            </div>
        </React.Fragment>
    );
}

--- END OF FILE app/articles/ArticlesPageClient.tsx ---

================================================================================

--- START OF FILE app/articles/page.tsx ---

// app/articles/page.tsx
import { client } from '@/lib/sanity.client';
import { featuredShowcaseArticlesQuery, allArticlesListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import ArticlesPageClient from './ArticlesPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';
import { enrichContentList } from '@/lib/enrichment';

export const metadata: Metadata = {
  title: 'المقالات',
  description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب من خبراء EternalGames.',
  alternates: {
    canonical: '/articles',
  },
  openGraph: {
    title: 'المقالات | EternalGames',
    description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب.',
  },
  twitter: {
    title: 'المقالات | EternalGames',
    description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allGameTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current, category}`;
const allArticleTypeTagsQuery = groq`*[_type == "tag" && category == "Article"] | order(title asc) {_id, title, "slug": slug.current, category}`;

// Helper function to remove duplicates based on title
const deduplicateTags = (tags: SanityTag[]): SanityTag[] => {
    if (!tags) return [];
    const uniqueMap = new Map<string, SanityTag>();
    tags.forEach(tag => {
        if (tag && tag.title && !uniqueMap.has(tag.title)) {
            uniqueMap.set(tag.title, tag);
        }
    });
    return Array.from(uniqueMap.values());
};

export default async function ArticlesPage() {
  const [featuredArticlesRaw, initialGridArticlesRaw, allGames, allGameTagsRaw, allArticleTypeTagsRaw]: [SanityArticle[], SanityArticle[], SanityGame[], SanityTag[], SanityTag[]] = await Promise.all([
    client.fetch(featuredShowcaseArticlesQuery),
    client.fetch(allArticlesListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allGameTagsQuery),
    client.fetch(allArticleTypeTagsQuery),
  ]);

  const allGameTags = deduplicateTags(allGameTagsRaw);
  const allArticleTypeTags = deduplicateTags(allArticleTypeTagsRaw);

  if (!featuredArticlesRaw || featuredArticlesRaw.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">أحدث المقالات</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>بلغتَ المنتهى. مقالاتٌ أخرى تلوحُ في الأفق.</p>
        </div>
    );
  }

  // Enrich data with usernames server-side
  const featuredArticles = (await enrichContentList(featuredArticlesRaw)) as SanityArticle[];
  const initialGridArticles = (await enrichContentList(initialGridArticlesRaw)) as SanityArticle[];

  const ArticlesPageFallback = () => (
    <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
      <div className="spinner" />
    </div>
  );

  return (
    <Suspense fallback={<ArticlesPageFallback />}>
      <ArticlesPageClient
        featuredArticles={featuredArticles}
        initialGridArticles={initialGridArticles}
        allGames={allGames}
        allGameTags={allGameTags}
        allArticleTypeTags={allArticleTypeTags}
      />
    </Suspense>
  );
}

--- END OF FILE app/articles/page.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/Scene.tsx ---

// app/celestial-almanac/Scene.tsx

import React, { useRef, useMemo, Suspense, useCallback, useState } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Line, Text } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition, Placement, OrbitalSystemData } from './config';
import { ConstellationSettings } from '@/components/constellation/ConstellationControlPanel';

// Background starfield component (repurposed directly from Constellation)
const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
  const positions = useMemo(() => {
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
      pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
    }
    return pos;
  }, [count, radius]);
  return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
  const ref = useRef<THREE.Group>(null!);
  useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 60; });
  return (
    <group ref={ref}>
      <StarLayer count={Math.floor(1500 * countMultiplier)} radius={8} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
      <StarLayer count={Math.floor(1000 * countMultiplier)} radius={12} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
    </group>
  );
};

// Interactive game release "planet" component
const ReleasePlanet = ({ body, colors, onHover, onClick }: {
  body: OrbitalBodyData, colors: typeof THEME_CONFIG.dark,
  onHover: (body: OrbitalBodyData | null) => void,
  onClick: (body: OrbitalBodyData) => void
}) => {
  const ref = useRef<THREE.Mesh>(null!);
  const [isHovered, setIsHovered] = useState(false);

  useFrame(() => {
    ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.8 : 1), 0.2);
  });

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    document.body.style.cursor = 'pointer';
    setIsHovered(true);
    onHover(body);
  };

  const handlePointerOut = () => {
    document.body.style.cursor = 'auto';
    setIsHovered(false);
    onHover(null);
  };

  return (
    <mesh ref={ref} position={body.position} onClick={(e) => { e.stopPropagation(); onClick(body); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
      <sphereGeometry args={[0.04, 16, 16]} />
      <meshBasicMaterial color={isHovered ? colors.hoverStarColor : colors.starColor} toneMapped={false} />
    </mesh>
  );
};

// Main Scene Logic
function InteractiveLayer({ orbitalData, themeColors, setActiveStar, settings }: any) {
  const [hoveredBody, setHoveredBody] = useState<OrbitalBodyData | null>(null);
  const { camera, gl } = useThree();

  const handleBodyClick = useCallback((body: OrbitalBodyData) => {
    const canvasRect = gl.domElement.getBoundingClientRect();
    const vec = new THREE.Vector3().copy(body.position);
    vec.project(camera);
    const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
    const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
    const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
    let finalX = x;
    const cardWidth = 300; const padding = 20;
    if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
    if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
    setActiveStar(body, { top: y, left: finalX, placement });
  }, [camera, gl.domElement, setActiveStar]);

  const controlsRef = useRef<any>(null);
  useFrame(() => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = !hoveredBody;
      controlsRef.current.update();
    }
  });

  const { bloomIntensity } = settings;
  const isBloomEnabled = bloomIntensity > 0;

  return (
    <>
      {isBloomEnabled ? (
        <Selection>
          <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={0}>
            <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
          </EffectComposer>
          <Select enabled>
            <mesh>
              <sphereGeometry args={[0.5, 32, 32]} />
              <meshStandardMaterial color={themeColors.sunColor} emissive={themeColors.sunColor} emissiveIntensity={3} toneMapped={false} />
            </mesh>
          </Select>
        </Selection>
      ) : (
        <mesh>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshBasicMaterial color={themeColors.sunColor} toneMapped={false} />
        </mesh>
      )}

      {orbitalData.map((monthSystem: OrbitalSystemData) => {
        const circlePoints = useMemo(() => {
          const points = [];
          for (let i = 0; i <= 64; i++) {
            const angle = (i / 64) * Math.PI * 2;
            points.push(new THREE.Vector3(Math.cos(angle) * monthSystem.radius, Math.sin(angle) * monthSystem.radius, 0));
          }
          return points;
        }, [monthSystem.radius]);

        return (
          <group key={monthSystem.month}>
            <Line points={circlePoints} color={themeColors.orbitColor} lineWidth={1} />
            <Text
              position={[monthSystem.radius + 0.2, 0, 0]}
              color={themeColors.orbitColor}
              fontSize={0.15}
              anchorX="left"
              anchorY="middle"
            >
              {monthSystem.month}
            </Text>
            {monthSystem.bodies.map(body => (
              <ReleasePlanet key={body.id} body={body} colors={themeColors} onHover={setHoveredBody} onClick={handleBodyClick} />
            ))}
          </group>
        );
      })}

      <OrbitControls
        ref={controlsRef}
        enableZoom
        autoRotate={true}
        autoRotateSpeed={0.1}
        minDistance={3}
        maxDistance={15}
        zoomSpeed={0.5}
        enablePan={false}
      />
    </>
  );
}

// MODIFIED: Added isFeatureLive prop
export const Scene = ({ orbitalData, themeColors, setActiveStar, settings, isFeatureLive }: any) => {
  return (
    <Suspense fallback={null}>
      <color attach="background" args={[themeColors.bgColor]} />
      <ambientLight intensity={0.8} />
      <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
      {/* MODIFIED: Conditionally render the InteractiveLayer */}
      {isFeatureLive && (
        <InteractiveLayer orbitalData={orbitalData} themeColors={themeColors} setActiveStar={setActiveStar} settings={settings} />
      )}
    </Suspense>
  );
};

--- END OF FILE app/celestial-almanac/Scene.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

// app/celestial-almanac/StarPreviewCard.tsx

import React from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { urlFor } from '@/sanity/lib/image';
import { OrbitalBodyData, ScreenPosition } from './config';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

// THE DEFINITIVE FIX: The icon map now handles both legacy and current values.
const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
  'PC': PCIcon,
  'PlayStation': PS5Icon,
  'PlayStation 5': PS5Icon, // Legacy value support
  'Xbox': XboxIcon,
  'Switch': SwitchIcon,
};

export const StarPreviewCard = ({ orbitalBody, position, onClose }: {
    orbitalBody: OrbitalBodyData;
    position: ScreenPosition;
    onClose: () => void;
}) => {
  const { content } = orbitalBody;
  const imageUrl = content.mainImage?.asset ? urlFor(content.mainImage).width(600).height(338).fit('crop').auto('format').url() : null;
  const blurDataURL = content.mainImage?.blurDataURL;
  const linkPath = '/games/' + content.slug;

  const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
  const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const date = new Date(content.releaseDate);
  const day = date.getUTCDate();
  const year = date.getUTCFullYear();
  const monthIndex = date.getUTCMonth();
  const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

  return (
    <motion.div
      onClick={(e) => e.stopPropagation()}
      initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }}
      transition={{ type: 'spring', damping: 25, stiffness: 300 }}
      style={{
        position: 'fixed', top: position.top, left: position.left,
        width: '300px',
        background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px',
        boxShadow: '0 10px 30px rgba(0,0,0,0.3)', overflow: 'hidden', zIndex: 10001,
        transform: position.placement === 'below'
          ? 'translate(-50%, 20px)'
          : 'translate(-50%, calc(-100% - 20px))',
        transformOrigin: position.placement === 'below' ? 'top center' : 'bottom center',
      }}
    >
      <motion.button
        onClick={onClose} whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
        style={{
          position: 'absolute', top: '10px', right: '10px', zIndex: 2, width: '32px', height: '32px',
          borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.3)', color: 'white',
          display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
        }} aria-label="إغلاق"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
      </motion.button>

      <div style={{ position: 'relative', width: '100%', height: '150px' }}>
        {imageUrl ? (
          <Image 
            src={imageUrl} 
            alt={content.title} 
            fill 
            sizes="300px"
            style={{ objectFit: 'cover' }} 
            placeholder={blurDataURL ? 'blur' : 'empty'}
            blurDataURL={blurDataURL || ''}
          />
        ) : (
          <div style={{ width: '100%', height: '100%', backgroundColor: 'var(--border-color)' }} />
        )}
      </div>

      <div style={{ padding: '1.5rem', textAlign: 'right' }}>
        <p style={{ color: 'var(--text-secondary)', fontFamily: 'var(--font-main)', fontSize: '1.3rem', margin: '0 0 0.5rem 0' }}>
          الإصدار:{formattedDate}
        </p>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.7rem' }}>{content.title}</h3>
        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1.5rem', justifyContent: 'flex-end' }}>
          {(content.platforms || []).map(p => {
            const Icon = PlatformIcons[p];
            return Icon ? (
              <div key={p} title={p}>
                <Icon className="platform-icon" />
              </div>
            ) : null;
          })}
        </div>
        <Link href={linkPath} onClick={onClose} className="primary-button no-underline" style={{ display: 'block', textAlign: 'center' }}>
          محور اللعبة
        </Link>
      </div>
    </motion.div>
  );
};

--- END OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/config.ts ---

// app/celestial-almanac/config.ts

import * as THREE from 'three';
import type { SanityGameRelease } from '@/types/sanity';

//  Type Definitions adapted for the Almanac
export type ContentObject = SanityGameRelease;

export type OrbitalBodyData = {
  id: string; // Sanity document _id
  position: THREE.Vector3;
  content: ContentObject;
};

export type OrbitalSystemData = {
  month: string;
  radius: number;
  bodies: OrbitalBodyData[];
};

export type Placement = 'above' | 'below';

export type ScreenPosition = {
  top: number;
  left: number;
  placement: Placement;
};

//  Theme-aware Color & Size Mapping (Retained from Constellation)
export const THEME_CONFIG = {
  dark: {
    sunColor: '#00E5FF', // As requested
    orbitColor: 'rgba(255, 255, 255, 0.2)',
    starColor: '#FFFFFF',
    hoverStarColor: '#00E5FF',
    pathColor: '#FFFFFF',
    bgStarColor: '#FFFFFF',
    bgColor: '#0A0B0F',
  },
  light: {
    sunColor: '#0891B2',
    orbitColor: 'rgba(0, 0, 0, 0.15)',
    starColor: '#1F2937',
    hoverStarColor: '#0891B2',
    pathColor: '#1F2937',
    bgStarColor: '#1F2937',
    bgColor: '#F0F2F5',
  },
};























--- END OF FILE app/celestial-almanac/config.ts ---

================================================================================

--- START OF FILE app/celestial-almanac/index.tsx ---

// app/celestial-almanac/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { useBodyClass } from '@/hooks/useBodyClass';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from '@/components/constellation/ConstellationControlPanel';
import type { SanityGameRelease } from '@/types/sanity';
import styles from '@/components/constellation/ConstellationControlPanel.module.css';

const isFeatureLive = false;

const CelestialGearIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
    <circle cx="12" cy="12" r="8"></circle>
    <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
  </svg>
);

const ComingSoonOverlay = () => {
    return (
        <motion.div
            style={{
                position: 'absolute',
                inset: 0,
                zIndex: 100,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: 'radial-gradient(ellipse at center, color-mix(in srgb, var(--bg-primary) 80%, transparent) 0%, color-mix(in srgb, var(--bg-primary) 98%, transparent) 70%)',
                backdropFilter: 'blur(4px)',
                pointerEvents: 'none',
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 1, delay: 0.5, ease: 'easeOut' }}
        >
            <motion.h1
                style={{
                    fontFamily: 'var(--font-main)',
                    fontSize: 'clamp(4rem, 10vw, 8rem)',
                    fontWeight: 800,
                    color: 'var(--text-primary)',
                    textShadow: '0 0 30px var(--border-color)',
                }}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.8, delay: 1, ease: 'easeOut' }}
            >
                قريبا
            </motion.h1>
        </motion.div>
    );
};


export default function CelestialAlmanac({ releases }: { releases: SanityGameRelease[] }) {
  const [isHydrated, setIsHydrated] = useState(false);
  useEffect(() => { setIsHydrated(true); }, []);

  const [isFullscreen, setIsFullscreen] = useState(false);
  
  useBodyClass('constellation-active');
  useBodyClass('fullscreen-active', isFullscreen);

  const { resolvedTheme } = useTheme();
  const [activeBody, setActiveBody] = useState<OrbitalBodyData | null>(null);
  const [activeBodyPosition, setActiveBodyPosition] = useState<ScreenPosition | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
    'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1 },
    'مُتَّزِن': { activePreset: 'مُتَّزِن', starCountMultiplier: 1.0, bloomIntensity: 1.1, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
    'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.8, alwaysShowOrbits: false, flawlessPathThickness: 2.0 },
  }), []);

  const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['مُتَّزِن']);
  const userIntentBloom = useRef(PRESETS['مُتَّزِن'].bloomIntensity);

  useEffect(() => {
    if (resolvedTheme === 'light') {
        if (settings.bloomIntensity > 0) {
            setSettings(s => ({ ...s, bloomIntensity: 0 }));
        }
    } else {
        if (settings.bloomIntensity !== userIntentBloom.current) {
            setSettings(s => ({ ...s, bloomIntensity: userIntentBloom.current }));
        }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [resolvedTheme]);

  useEffect(() => {
    if (resolvedTheme === 'dark' && settings.activePreset === 'custom') {
        userIntentBloom.current = settings.bloomIntensity;
    }
  }, [settings.bloomIntensity, settings.activePreset, resolvedTheme]);

  const handlePresetChange = (preset: Preset) => {
    let newSettings = { ...PRESETS[preset] };
    userIntentBloom.current = newSettings.bloomIntensity;
    if (resolvedTheme === 'light') {
        newSettings.bloomIntensity = 0;
    }
    setSettings(newSettings);
  };

  const isDark = resolvedTheme === 'dark';
  const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;
  
  const orbitalData = useMemo(() => {
    if (!isHydrated) return [];
    // MODIFIED: Added a placeholder for legacyId in the generated objects
    const releasesToUse = releases.length > 0 ? releases : Array.from({ length: 30 }).map((_, i) => ({
        _id: `placeholder-${i}`,
        legacyId: 9000 + i, // Added placeholder legacyId
        title: `Upcoming Game ${i + 1}`,
        releaseDate: new Date(2025, Math.floor(i / 3), (i % 28) + 1).toISOString(),
        slug: `upcoming-game-${i+1}`,
        synopsis: 'Details to be revealed soon.',
        platforms: [] as any,
        mainImage: {} as any
    }));
    
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    const releasesByMonth = releasesToUse.reduce((acc, release) => {
        const date = new Date(release.releaseDate);
        const year = date.getUTCFullYear();
        const monthIndex = date.getUTCMonth();
        const monthKey = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;
        
        if (!acc[monthKey]) acc[monthKey] = [];
        acc[monthKey].push(release as SanityGameRelease);
        return acc;
    }, {} as Record<string, SanityGameRelease[]>);
    
    const sortedMonths = Object.keys(releasesByMonth).sort((a, b) => {
        const dateA = new Date(a.split(' - ')[1]);
        const dateB = new Date(b.split(' - ')[1]);
        return dateA.getTime() - dateB.getTime();
    });

    const startRadius = 2; const radiusIncrement = 0.8;
    return sortedMonths.map((month, index) => {
      const monthReleases = releasesByMonth[month]; const radius = startRadius + index * radiusIncrement;
      const bodies = monthReleases.map((release, bodyIndex) => {
        const angle = (bodyIndex / monthReleases.length) * Math.PI * 2;
        const position = new THREE.Vector3( radius * Math.cos(angle), radius * Math.sin(angle), (Math.random() - 0.5) * 0.1 );
        return { id: release._id, position, content: release };
      });
      return { month, radius, bodies };
    });
  }, [isHydrated, releases]);

  const handleSetActiveBody = useCallback((body: OrbitalBodyData, position: ScreenPosition) => { setActiveBody(body); setActiveBodyPosition(position); }, []);
  const handleClosePreview = useCallback(() => { setActiveBody(null); setActiveBodyPosition(null); }, []);

  if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

  return (
    <>
      {isFeatureLive && (
          <AnimatePresence>
            {activeBody && activeBodyPosition && (
              <motion.div style={{ position: 'fixed', inset: 0, zIndex: 10000 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                <StarPreviewCard orbitalBody={activeBody} position={activeBodyPosition} onClose={handleClosePreview} />
              </motion.div>
            )}
            {isPanelOpen && <ConstellationControlPanel settings={settings} setSettings={setSettings} onClose={() => setIsPanelOpen(false)} onPresetChange={handlePresetChange} isFullscreen={isFullscreen} onToggleFullscreen={() => setIsFullscreen(!isFullscreen)} />}
          </AnimatePresence>
      )}

      <div style={{ position: 'relative', width: '100%', height: 'calc(100vh - var(--nav-height-scrolled))' }}>
        {isFeatureLive && (
            <motion.button className={styles.settingsButton} onClick={() => setIsPanelOpen(true)} title="فتح إعدادات الفلك" whileHover={{ scale: 1.1, rotate: 90 }} transition={{ type: 'spring', stiffness: 500, damping: 20 }} whileTap={{ scale: 0.9 }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.5 } }}>
                <CelestialGearIcon />
            </motion.button>
        )}
        <Canvas camera={{ position: [0, 0, 8], fov: 60 }}>
          <Scene settings={settings} orbitalData={orbitalData} themeColors={themeColors} setActiveStar={handleSetActiveBody} isFeatureLive={isFeatureLive} />
        </Canvas>

        <ComingSoonOverlay />
      </div>
    </>
  );
}

--- END OF FILE app/celestial-almanac/index.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/page.tsx ---

// app/celestial-almanac/page.tsx
'use client'; // This page is now a client component boundary

import { client } from '@/lib/sanity.client';
import { allReleasesQuery } from '@/lib/sanity.queries';
import type { SanityGameRelease } from '@/types/sanity';
import dynamic from 'next/dynamic';
import { useState, useEffect } from 'react';

// The loader component is removed. We now handle the dynamic import directly here.
const CelestialAlmanac = dynamic(() => import('@/app/celestial-almanac'), {
  ssr: false,
  loading: () => (
    <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <div className="spinner" style={{ width: '60px', height: '60px' }} />
    </div>
  ),
});

export default function CelestialAlmanacPage() {
  const [releases, setReleases] = useState<SanityGameRelease[]>([]);

  useEffect(() => {
    const fetchReleases = async () => {
      const fetchedReleases: SanityGameRelease[] = await client.fetch(allReleasesQuery);
      const sanitizedReleases = (fetchedReleases || []).filter(item =>
        item?.mainImage?.url && item.releaseDate && item.title && item.slug
      );
      setReleases(sanitizedReleases);
    };
    fetchReleases();
  }, []);

  return (
    <div style={{ paddingTop: 'var(--nav-height-scrolled)' }}>
      <CelestialAlmanac releases={releases} />
    </div>
  );
}




--- END OF FILE app/celestial-almanac/page.tsx ---

================================================================================

--- START OF FILE app/constellation/ConstellationWrapper.tsx ---

// app/constellation/ConstellationWrapper.tsx
'use client';

import dynamic from 'next/dynamic';
import type { SanityContentObject } from '@/components/constellation/config';

type InitialData = {
    userContent: SanityContentObject[];
    commentedSlugs: string[];
    isGuest: boolean;
} | null;

// Move the dynamic import here, inside a "use client" file
const Constellation = dynamic(() => import('@/components/constellation'), {
    ssr: false,
    loading: () => (
        <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <div className="spinner" style={{ width: '60px', height: '60px' }} />
        </div>
    ),
});

export default function ConstellationWrapper({ initialData }: { initialData: InitialData }) {
    return <Constellation initialData={initialData} />;
}

--- END OF FILE app/constellation/ConstellationWrapper.tsx ---

================================================================================

--- START OF FILE app/constellation/page.tsx ---

// app/constellation/page.tsx
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import prisma from '@/lib/prisma';
import { client } from '@/lib/sanity.client';
import { contentByIdsQuery } from '@/lib/sanity.queries';
import { enrichContentList } from '@/lib/enrichment';
import ConstellationWrapper from './ConstellationWrapper';
import type { SanityContentObject } from '@/components/constellation/config';

// Force dynamic rendering because this page relies on user session cookies
export const dynamic = 'force-dynamic';

async function getConstellationData() {
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user?.id) {
            return null; // Guest user
        }

        const userId = session.user.id;

        const [engagements, shares, comments] = await Promise.all([
            prisma.engagement.findMany({
                where: { userId },
                select: { contentId: true }
            }),
            prisma.share.findMany({
                where: { userId },
                select: { contentId: true }
            }),
            prisma.comment.findMany({
                where: { authorId: userId },
                select: { contentSlug: true },
                distinct: ['contentSlug']
            })
        ]);

        const contentIds = new Set<number>();
        // THE FIX: Added explicit type annotations
        engagements.forEach((e: { contentId: number }) => contentIds.add(e.contentId));
        shares.forEach((s: { contentId: number }) => contentIds.add(s.contentId));
        
        const uniqueIds = Array.from(contentIds);
        
        let userContent: SanityContentObject[] = [];
        if (uniqueIds.length > 0) {
            const rawContent = await client.fetch(contentByIdsQuery, { ids: uniqueIds });
            userContent = (await enrichContentList(rawContent)) as SanityContentObject[];
        }

        return {
            userContent,
            // THE FIX: Added explicit type annotation
            commentedSlugs: comments.map((c: { contentSlug: string }) => c.contentSlug),
            isGuest: false
        };

    } catch (error) {
        console.error("Failed to fetch server-side constellation data:", error);
        return null;
    }
}

export default async function ConstellationPage() {
    const initialData = await getConstellationData();

    return (
        <div style={{ paddingTop: 'var(--nav-height-scrolled)' }}>
            <ConstellationWrapper initialData={initialData} />
        </div>
    );
}

--- END OF FILE app/constellation/page.tsx ---

================================================================================

--- START OF FILE app/creators/[username]/page.tsx ---

// app/creators/[username]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByCreatorListQuery } from '@/lib/sanity.queries';
import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import Link from 'next/link';
import { cache } from 'react';
import type { Metadata } from 'next';
import { enrichContentList } from '@/lib/enrichment'; // <-- ADDED

export const dynamicParams = true;

type Props = {
  params: Promise<{ username: string }>;
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { username: encodedUsername } = await params;
  const username = decodeURIComponent(encodedUsername);
  
  const user = await getCachedUserByUsername(username);
  if (!user) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `أعمال ${user.name || username}`;
  const description = `استكشف جميع مساهمات ${user.name || username} على منصة EternalGames.`;
  const ogImageUrl = user.image || `${siteUrl}/og-image.png`;
  const canonicalUrl = `/creators/${username}`;

  return {
    title,
    description,
    alternates: {
        canonical: canonicalUrl,
    },
    openGraph: {
      title,
      description,
      url: `${siteUrl}${canonicalUrl}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: user.name || username }],
      type: 'profile',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export const generateStaticParams = cache(async () => {
    try {
        const usersWithUsernames = await prisma.user.findMany({
            where: {
                username: { not: null },
                roles: { some: { name: { in: ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'] } } }
            },
            select: { username: true },
        });

        return usersWithUsernames.map((user: any) => ({
            username: encodeURIComponent(user.username!),
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch usernames for creator pages. Build cannot continue.`, error);
        throw error;
    }
});

const getCachedUserByUsername = cache(async (username: string) => {
    try {
        return await prisma.user.findUnique({
            where: { username: username },
            select: { id: true, name: true, username: true, image: true }, 
        });
    } catch (error) {
        console.warn(`[BUILD WARNING] Database connection failed for creator page: "${username}".`, error);
        return null;
    }
});

export default async function CreatorHubPage({ params }: { params: Promise<{ username: string }> }) {
    const { username: encodedUsername } = await params;
    const username = decodeURIComponent(encodedUsername);

    const user = await getCachedUserByUsername(username);

    if (!user) {
        notFound();
    }

    const creatorDocs = await client.fetch< { _id: string }[] >(
        `*[_type in ["author", "reviewer", "reporter", "designer"] && prismaUserId == $prismaUserId]{_id}`,
        { prismaUserId: user.id }
    );

    if (!creatorDocs || creatorDocs.length === 0) {
        return (
             <div className="container page-container">
                <h1 className="page-title">{user.name || 'Creator'}</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُرَ لهذا المستخدمِ أثرٌ بعد.</p>
                <div style={{textAlign: 'center', marginTop: '2rem'}}>
                    <Link href={`/profile/${user.username}`} className="primary-button">ملف المستخدم</Link>
                </div>
            </div>
        );
    }
    
    const creatorIds = creatorDocs.map(doc => doc._id);
    const allItemsRaw = await client.fetch(allContentByCreatorListQuery, { creatorIds });
    // THE FIX: Enrich with usernames server-side
    const allItems = await enrichContentList(allItemsRaw);

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={user.name || 'Creator'}
            hubType="أعمال"
            headerAction={
                <Link href={`/profile/${user.username}`} className="outline-button no-underline" style={{ backgroundColor: 'color-mix(in srgb, var(--bg-secondary) 80%, transparent)', backdropFilter: 'blur(4px)' }}>
                    → الملف الشخصي
                </Link>
            }
        />
    );
}

--- END OF FILE app/creators/[username]/page.tsx ---

================================================================================

--- START OF FILE app/games/[slug]/page.tsx ---

// app/games/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByGameListQuery } from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';
import { enrichContentList } from '@/lib/enrichment';

export const dynamicParams = true;

type Props = {
  params: Promise<{ slug: string }>;
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params;
  const gameSlug = decodeURIComponent(slug);

  const game = await client.fetch(
    `*[_type == "game" && slug.current == $slug][0]{title, mainImage}`,
    { slug: gameSlug }
  );

  if (!game) return {};
  
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `محور لعبة: ${game.title}`;
  const description = `استكشف كل المحتوى المتعلق بلعبة ${game.title} على EternalGames، من مراجعات ومقالات إلى آخر الأخبار.`;
  const ogImageUrl = game.mainImage 
    ? urlFor(game.mainImage).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;
    const canonicalUrl = `/games/${gameSlug}`;

  return {
    title,
    description,
    alternates: {
        canonical: canonicalUrl,
    },
    openGraph: {
      title,
      description,
      url: `${siteUrl}${canonicalUrl}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: game.title }],
      type: 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "game" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            slug,
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for game hub pages. Build cannot continue.`, error);
        throw error;
    }
}

export default async function GameHubPage({ params }: { params: Promise<{ slug: string }> }) {
    const { slug } = await params;
    const gameSlug = decodeURIComponent(slug);

    const gameMeta = await client.fetch(
        `*[_type == "game" && slug.current == $slug][0]{title}`,
        { slug: gameSlug }
    );

    if (!gameMeta) {
        notFound();
    }

    const allItemsRaw = await client.fetch(allContentByGameListQuery, { slug: gameSlug });
    const allItems = await enrichContentList(allItemsRaw);
    
    if (!allItems || allItems.length === 0) {
        return (
             <div className="container page-container">
                <h1 className="page-title">محور لعبة:&quot;{gameMeta.title}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)', fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto'}}>
                    لم يُخطَّ حرفٌ بعدُ عن هذه اللعبة. الأرشيفُ يترقب.
                </p>
            </div>
        );
    }

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={gameMeta.title}
            hubType="اللعبة"
        />
    );
}

--- END OF FILE app/games/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/lib/authOptions.ts ---

// app/lib/authOptions.ts

import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import TwitterProvider from "next-auth/providers/twitter";
import CredentialsProvider from "next-auth/providers/credentials";

export const authOptions = {
    adapter: PrismaAdapter(prisma as any),
    providers: [
        CredentialsProvider({
            id: 'credentials',
            name: "Credentials",
            credentials: {
                email: { label: "البريد", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) throw new Error("البياناتُ ناقصة.");
                // MODIFIED: Normalize email to lowercase before database query
                const user = await prisma.user.findUnique({ where: { email: credentials.email.toLowerCase() } });
                if (!user) throw new Error("لا حساب بهذا البريد. تفضل بالتسجيل.");
                if (!user.password) throw new Error("هذا الحساب مربوط بمزود خارجي.");
                const isPasswordValid = await bcrypt.compare(credentials.password, user.password);
                if (isPasswordValid) return user;
                else throw new Error("كلمة السر خاطئة.");
            }
        }),
        CredentialsProvider({
            id: 'signup',
            name: "SignUp",
            credentials: {
                email: { label: "البريد", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials) throw new Error("تفاصيل التسجيل ناقصة.");
                // MODIFIED: Normalize email to lowercase
                const { email, password } = credentials;
                const lowercasedEmail = email.toLowerCase();

                if (!lowercasedEmail || !password) throw new Error("الحقولُ كلُّها لازمة.");
                if (!/\S+@\S+\.\S+/.test(lowercasedEmail)) throw new Error('البريد الإلكتروني غير صالح.');
                if (password.length < 8) throw new Error('كلمة السر لا تقل عن ثمانيةِ حروف.');
                
                const existingEmail = await prisma.user.findUnique({ where: { email: lowercasedEmail } });
                if (existingEmail) throw new Error('بريدٌ مسجل.');

                const hashedPassword = await bcrypt.hash(credentials.password, 10);
                const newUser = await prisma.user.create({
                    data: {
                        email: lowercasedEmail, // MODIFIED: Store lowercase email
                        password: hashedPassword,
                    }
                });
                return newUser;
            }
        }),
        GithubProvider({ 
            clientId: process.env.AUTH_GITHUB_ID as string, 
            clientSecret: process.env.AUTH_GITHUB_SECRET as string, 
        }),
        GoogleProvider({ 
            clientId: process.env.GOOGLE_CLIENT_ID as string, 
            clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, 
        }),
        TwitterProvider({ 
            clientId: process.env.TWITTER_CLIENT_ID as string, 
            clientSecret: process.env.TWITTER_CLIENT_SECRET as string, 
            version: "2.0", 
        }),
    ],
    events: {
        createUser: async ({ user }: any) => {
            const userRole = await prisma.role.findUnique({ where: { name: 'USER' } });
            if (userRole) {
                await prisma.user.update({ 
                    where: { id: user.id }, 
                    data: { 
                        roles: { connect: { id: userRole.id } },
                        // MODIFIED: Ensure email is lowercase on creation from any provider
                        email: user.email ? user.email.toLowerCase() : null
                    } 
                });
            }
        }
    },
    session: { strategy: "jwt" as const },
    secret: process.env.NEXTAUTH_SECRET,
    callbacks: {
        async signIn({ user }: any) {
            return true;
        },
        async jwt({ token, user, trigger }: any) {
            if (user || trigger === "update") {
                const dbUser = await prisma.user.findUnique({
                    where: { id: (token.id as string) || user?.id },
                    include: { roles: true }
                });

                if (dbUser) {
                    token.id = dbUser.id;
                    token.picture = dbUser.image;
                    token.name = dbUser.name;
                    token.roles = dbUser.roles.map((role: any) => role.name);
                    token.username = dbUser.username;
                    token.needsOnboarding = !dbUser.name || !dbUser.username;
                }
            }
            return token;
        },
        async session({ session, token }: any) {
            if (token && session.user) {
                session.user.id = token.id;
                session.user.roles = token.roles;
                session.user.name = token.name;
                session.user.email = token.email;
                session.user.image = token.picture;
                session.user.username = token.username;
                session.needsOnboarding = token.needsOnboarding;
            }
            return session;
        },
    },
    pages: { signIn: '/', error: '/', },
};

--- END OF FILE app/lib/authOptions.ts ---

================================================================================

--- START OF FILE app/news/NewsPage.module.css ---

/* app/news/NewsPage.module.css */
.newsPageContainer {
    position: relative;
    padding-top: var(--nav-height-scrolled);
}

.heroSection {
    margin-bottom: 6rem;
}

.gridSection {
    padding-top: 4rem;
}

.loadingSpinner {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 4rem 0;
    color: var(--accent);
}

.endOfFeedMessage {
    text-align: center;
    padding: 3rem 0;
    color: var(--text-secondary);
    font-size: 1.6rem;
    font-style: italic;
    opacity: 0.7;
}




--- END OF FILE app/news/NewsPage.module.css ---

================================================================================

--- START OF FILE app/news/NewsPageClient.tsx ---

// components/news/NewsPageClient.tsx
'use client';

import { useState, useMemo, useRef, useEffect } from 'react';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import NewsHero from '@/components/news/NewsHero';
import NewsFilters from '@/components/filters/NewsFilters';
import NewsGrid from '@/components/news/NewsGrid';
import { ContentBlock } from '@/components/ContentBlock';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from './NewsPage.module.css';
import { NewsIcon } from '@/components/icons';

const fetchNews = async (params: URLSearchParams) => {
    const res = await fetch(`/api/news?${params.toString()}`);
    if (!res.ok) throw new Error('Failed to fetch news');
    return res.json();
};

export default function NewsPageClient({ heroArticles, initialGridArticles, allGames, allTags }: {
  heroArticles: SanityNews[];
  initialGridArticles: SanityNews[];
  allGames: SanityGame[];
  allTags: SanityTag[];
}) {
    const intersectionRef = useRef(null);
    const isInView = useInView(intersectionRef, { margin: '400px' });

    // OPTIMIZATION: 800px for hero
    const adaptedHeroArticles = useMemo(() => heroArticles.map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[], [heroArticles]);
    
    // OPTIMIZATION: 600px for grid
    const initialCards = useMemo(() => initialGridArticles.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [initialGridArticles]);
    const [allFetchedNews, setAllFetchedNews] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    const [nextOffset, setNextOffset] = useState<number | null>(initialCards.length === 50 ? 50 : null);

    const [searchTerm, setSearchTerm] = useState('');
    const [activeSort, setActiveSort] = useState<'latest' | 'viral'>('latest');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedTags, setSelectedTags] = useState<SanityTag[]>([]);
    
    const newsItems = useMemo(() => {
        let items = [...allFetchedNews];

        if (searchTerm) {
            items = items.filter(news => news.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }
        if (selectedGame) {
            items = items.filter(news => news.game === selectedGame.title);
        }
        if (selectedTags.length > 0) {
            const selectedTagTitles = new Set(selectedTags.map(t => t.title));
            items = items.filter(news => news.tags.some(t => selectedTagTitles.has(t.title)));
        }
        
        return items;
    }, [allFetchedNews, searchTerm, selectedGame, selectedTags]);

    const hasActiveFilters = useMemo(() => {
        return !!searchTerm || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest';
    }, [searchTerm, selectedGame, selectedTags, activeSort]);

    const canLoadMore = useMemo(() => {
        return nextOffset !== null && !hasActiveFilters;
    }, [nextOffset, hasActiveFilters]);

    useEffect(() => {
        if (isInView && canLoadMore && !isLoading) {
            const loadMore = async () => {
                setIsLoading(true);
                const params = new URLSearchParams({ offset: String(nextOffset), limit: '50', sort: activeSort });
                try {
                    const result = await fetchNews(params);
                    setAllFetchedNews(prev => [...prev, ...result.data]);
                    setNextOffset(result.nextOffset);
                } catch (error) {
                    console.error("Failed to load more news:", error);
                } finally {
                    setIsLoading(false);
                }
            };
            loadMore();
        }
    }, [isInView, canLoadMore, isLoading, nextOffset, activeSort]);

    const handleTagToggle = (tag: SanityTag) => {
        setSelectedTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]);
    };
    const handleClearAll = () => {
        setSearchTerm('');
        setSelectedGame(null);
        setSelectedTags([]);
        setActiveSort('latest');
    };

    return (
        <div style={{ paddingBottom: '6rem' }}>
            <NewsHero newsItems={adaptedHeroArticles} />
            <div className="container">
                <NewsFilters 
                    activeSort={activeSort}
                    onSortChange={setActiveSort}
                    searchTerm={searchTerm}
                    onSearchChange={setSearchTerm}
                    allGames={allGames}
                    selectedGame={selectedGame}
                    onGameSelect={setSelectedGame}
                    allTags={allTags}
                    selectedTags={selectedTags}
                    onTagToggle={handleTagToggle}
                    onClearAll={handleClearAll}
                />
                <ContentBlock title="كل الأخبار" Icon={NewsIcon}>
                    <NewsGrid news={newsItems} />

                    <div ref={intersectionRef} style={{ height: '1px', margin: '1rem 0' }} />

                    <AnimatePresence>
                        {isLoading && (
                            <motion.div key="loading" style={{display: 'flex', justifyContent: 'center', padding: '4rem'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                                <div className="spinner" />
                            </motion.div>
                        )}
                    </AnimatePresence>
                    
                    <AnimatePresence>
                        {(!isLoading && newsItems.length > 0 && (nextOffset === null || hasActiveFilters)) && (
                            <motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                                {hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}
                            </motion.p>
                        )}
                    </AnimatePresence>

                    {newsItems.length === 0 && !isLoading && (
                        <motion.p key="no-match" style={{textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                            لا أنباءَ توافقُ ما اخترت.
                        </motion.p>
                    )}
                </ContentBlock>
            </div>
        </div>
    );
}

--- END OF FILE app/news/NewsPageClient.tsx ---

================================================================================

--- START OF FILE app/news/page.tsx ---

// app/news/page.tsx
import { client } from '@/lib/sanity.client';
import { newsHeroQuery, newsGridInitialQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import NewsPageClient from './NewsPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';
import { enrichContentList } from '@/lib/enrichment';

export const metadata: Metadata = {
  title: 'الأخبار',
  description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب. ابقَ على اطلاع دائم بكل ما هو جديد ومهم.',
  alternates: {
    canonical: '/news',
  },
  openGraph: {
    title: 'الأخبار | EternalGames',
    description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب.',
  },
  twitter: {
    title: 'الأخبار | EternalGames',
    description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allNewsTagsQuery = groq`*[_type == "tag" && category == "News"] | order(title asc) {_id, title, "slug": slug.current, category}`;

// Helper function to remove duplicates based on title
const deduplicateTags = (tags: SanityTag[]): SanityTag[] => {
    if (!tags) return [];
    const uniqueMap = new Map<string, SanityTag>();
    tags.forEach(tag => {
        if (tag && tag.title && !uniqueMap.has(tag.title)) {
            uniqueMap.set(tag.title, tag);
        }
    });
    return Array.from(uniqueMap.values());
};

export default async function NewsPage() {
  const [heroNewsRaw, initialGridNewsRaw, allGames, allTagsRaw]: [SanityNews[], SanityNews[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(newsHeroQuery),
    client.fetch(newsGridInitialQuery),
    client.fetch(allGamesQuery),
    client.fetch(allNewsTagsQuery),
  ]);

  const allTags = deduplicateTags(allTagsRaw);

  if (!heroNewsRaw || heroNewsRaw.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">موجز الأنباء</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لا أنباءَ تُذكَر. سنوافيكم بالجديد.</p>
        </div>
    );
  }

  // Enrich data with usernames server-side
  const heroArticles = (await enrichContentList(heroNewsRaw)) as SanityNews[];
  const initialGridArticles = (await enrichContentList(initialGridNewsRaw)) as SanityNews[];

  const NewsPageFallback = () => (
    <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center', minHeight: '80vh'}}>
      <div className="spinner" />
    </div>
  );

  return (
    <Suspense fallback={<NewsPageFallback />}>
      <NewsPageClient
        heroArticles={heroArticles}
        initialGridArticles={initialGridArticles}
        allGames={allGames || []}
        allTags={allTags || []}
      />
    </Suspense>
  );
}

--- END OF FILE app/news/page.tsx ---

================================================================================

--- START OF FILE app/profile/ProfilePage.module.css ---

/* app/profile/ProfilePage.module.css */
.profileGrid{display:grid;grid-template-columns:1fr;gap:5rem}
@media (min-width:1024px){.profileGrid{grid-template-columns:300px 1fr}}
.profileAvatar{border-radius:50%;border:4px solid var(--border-color);margin:0 auto 2rem;transition:all .3s ease-out}
.profileAvatar:hover{transform:scale(1.05);filter:drop-shadow(0 0 20px color-mix(in srgb,var(--accent) 50%,transparent))}
.profileName{font-size:3.2rem;font-family:var(--font-main);margin:0;text-align:center}
.profileMeta{font-size:1.6rem;color:var(--text-secondary);margin-top:.5rem;text-align:center}
.profileMain{border-top:1px solid var(--border-color);padding-top:5rem}
@media (min-width:1024px){.profileMain{border-top:none;padding-top:0;border-right:1px solid var(--border-color);border-left: none; padding-right:5rem; padding-left: 0;}}
.profileSection{margin-top:6rem}
.profileSection:first-child{margin-top:0}
.profileSectionTitle{
    font-size:2.8rem;
    font-family:var(--font-main);
    margin-bottom:2rem;
    border-bottom:2px solid var(--accent);
    padding-bottom:1rem;
    display:inline-block;
    box-shadow: 0 5px 15px -5px color-mix(in srgb, var(--accent) 30%, transparent);
    transition: color 0.3s ease;
}
.profileSectionTitle:hover {
    color: var(--accent);
}
.badgeGrid{display:flex;flex-wrap:wrap;gap:1.5rem}
.badgeItem{display:flex;align-items:center;gap:1rem;background-color:var(--bg-secondary);padding:1rem 1.5rem;border-radius:8px;border:1px solid var(--border-color);transition:all .2s ease-out}
.badgeItem:hover{transform:translateY(-2px);border-color:var(--accent)}
.badgeIcon{width:20px;height:20px;color:var(--accent)}
@keyframes glint{0%,100%{transform:scale(1)}50%{transform:scale(1.2) rotate(10deg);filter:brightness(1.5)}}
.badgeItem:hover .badgeIconFOUNDER{animation:glint .7s ease-in-out}

@media (max-width: 768px) {
  .profileSidebar {
    padding-top: 8rem; /* Nudge the content down on mobile to avoid navbar overlap */
  }
}

--- END OF FILE app/profile/ProfilePage.module.css ---

================================================================================

--- START OF FILE app/profile/page.tsx ---

// app/profile/page.tsx
export const maxDuration = 60;
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import ProfileEditForm from '@/components/ProfileEditForm';
import PasswordChangeForm from '@/components/PasswordChangeForm';
import { ContentBlock } from '@/components/ContentBlock';

export default async function ProfilePage() {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) { redirect('/api/auth/signin'); }
    
    // Fetch user and check if they have a password set (i.e., not an OAuth user)
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id }, 
        select: { password: true, id: true, name: true, email: true, username: true, image: true, createdAt: true, bio: true, twitterHandle: true, instagramHandle: true, age: true, country: true, agePublic: true, countryPublic: true, emailVerified: true }
    });

    if (!user) { redirect('/api/auth/signin'); }

    const hasPasswordAuth = !!user.password;

    return (
        <div className="container page-container">
            <h1 className="page-title">إعدادات الحساب</h1>
            <ContentBlock title="تحرير البيانات">
                <ProfileEditForm user={user} />
            </ContentBlock>
            
            {hasPasswordAuth && (
                <ContentBlock title="تغيير كلمة السر">
                    <PasswordChangeForm />
                </ContentBlock>
            )}
        </div>
    );
}




--- END OF FILE app/profile/page.tsx ---

================================================================================

--- START OF FILE app/profile/bookmarks/page.tsx ---

// app/profile/bookmarks/page.tsx
import BookmarksGrid from "@/components/BookmarksGrid";
import { getAuthenticatedSession } from "@/lib/auth";
import { client } from "@/lib/sanity.client";
import { contentByIdsQuery } from "@/lib/sanity.queries";
import prisma from "@/lib/prisma";
import { redirect } from "next/navigation";
import { enrichContentList } from "@/lib/enrichment"; // <-- ADDED

async function getBookmarkedContent() {
    let session;
    try {
        session = await getAuthenticatedSession();
    } catch (error) {
        redirect('/api/auth/signin');
    }

    try {
        const bookmarks = await prisma.engagement.findMany({
            where: { userId: session.user.id, type: 'BOOKMARK' },
            select: { contentId: true },
            orderBy: { createdAt: 'desc' }
        });
        
        const ids = bookmarks.map((b: any) => b.contentId);
        if (ids.length === 0) return [];
        
        const contentRaw = await client.fetch(contentByIdsQuery, { ids });
        // THE FIX: Enrich data server-side before returning
        const content = await enrichContentList(contentRaw);
        
        return content;
    } catch (error) {
        console.error("Failed to fetch bookmarked content:", error);
        return []; 
    }
}

export default async function BookmarksPage() {
    const bookmarkedItems = await getBookmarkedContent();

    return (
        <div className="container page-container">
            <h1 className="page-title">محفوظاتك</h1>
            <BookmarksGrid initialItems={bookmarkedItems} />
        </div>
    );
}

--- END OF FILE app/profile/bookmarks/page.tsx ---

================================================================================

--- START OF FILE app/profile/[username]/page.tsx ---

// app/profile/[username]/page.tsx

import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import Image from 'next/image';
import { getBadgesForUser } from '@/lib/badges';
import Link from 'next/link';
import styles from '../ProfilePage.module.css';
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

function hasCreatorRole(userRoles: string[]): boolean {
    return userRoles.some(role => ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
}

export default async function PublicProfilePage({ params: paramsPromise }: { params: Promise<{ username: string }> }) {
    const { username: encodedUsername } = await paramsPromise;
    const username = decodeURIComponent(encodedUsername);

    const user = await prisma.user.findUnique({
        where: { username: username },
        include: {
            roles: { select: { name: true } },
            _count: { select: { comments: true } },
            comments: { orderBy: { createdAt: 'desc' }, take: 5 },
        },
    });

    if (!user) { notFound(); }
    
    // OPTIMIZED: Parallelize data processing
    let contentTitles: { slug: string, title: string }[] = [];
    
    // 1. Extract content slugs from the user's recent comments.
    const commentSlugs = user.comments.map((c: any) => c.contentSlug);
    
    if (commentSlugs.length > 0) {
        // 2. Fetch the titles for these slugs from Sanity.
        contentTitles = await client.fetch(
            groq`*[_type in ["review", "article", "news"] && slug.current in $slugs]{ "slug": slug.current, title }`,
            { slugs: commentSlugs }
        );
    }
    
    // 3. Create a lookup map for easy access (slug -> title).
    const titleMap = new Map(contentTitles.map(item => [item.slug, item.title]));

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const joinDate = new Date(user.createdAt);
    const year = joinDate.getFullYear();
    const monthIndex = joinDate.getMonth();
    const formattedJoinDate = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;


    const userRoles = user.roles.map((r: any) => r.name);
    const earnedBadges = getBadgesForUser({ createdAt: user.createdAt, _count: user._count, roles: userRoles });
    const avatarSrc = user.image || '/default-avatar.svg';

    return (
        <div className="container page-container">
            <div className={styles.profileGrid}>
                <aside className={styles.profileSidebar}>
                    <Image src={avatarSrc} alt={user.name || 'صورة المستخدم'} width={150} height={150} className={styles.profileAvatar} priority />
                    <h1 className={styles.profileName}>{user.name}</h1>
                    {user.username && <p className={styles.profileMeta} style={{color: 'var(--accent)'}}>@{user.username}</p>}
                    <p className={styles.profileMeta}>عضوٌ منذ {formattedJoinDate}</p>
                    
                    {user.username && hasCreatorRole(userRoles) && (
                         <Link href={`/creators/${user.username}`} className="primary-button" style={{marginTop: '2rem', display: 'block', textAlign: 'center'}}>
                            عرض كل الأعمال
                        </Link>
                    )}
                </aside>

                <main className={styles.profileMain}>
                    {user.bio && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>عن</h2> <p style={{ fontSize: '1.8rem', lineHeight: 1.7 }}>{user.bio}</p> </section> )}
                    {earnedBadges.length > 0 && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>الأوسمة</h2> <div className={styles.badgeGrid}> {earnedBadges.map(badge => ( <div key={badge.id} title={badge.description} className={styles.badgeItem}> <badge.Icon className={`${styles.badgeIcon} ${styles[`badgeIcon${badge.id}`]}`} /> <span>{badge.name}</span> </div> ))} </div> </section> )}
                    <section className={styles.profileSection}>
                        <h2 className={styles.profileSectionTitle}>آخرُ نشاط</h2>
                        {user.comments.length > 0 ? (
                            <ul style={{listStyle: 'none', padding: 0, display: 'flex', flexDirection: 'column', gap: '2rem'}}>
                                {user.comments.map((comment: any) => {
                                    const contentTitle = titleMap.get(comment.contentSlug) || 'تعليقٌ لم يعد متاحًا';
                                    const path = comment.contentSlug.startsWith('review-') ? 'reviews' : comment.contentSlug.startsWith('article-') ? 'articles' : 'news';
                                    const linkHref = `/${path}/${comment.contentSlug}`;

                                    return (
                                        <li key={comment.id}>
                                            <p style={{margin: '0 0 0.5rem 0'}}>
                                                علّق على <Link href={linkHref} className="creator-credit-link">{contentTitle}</Link>
                                            </p>
                                            <blockquote style={{margin: 0, padding: '1rem', background: 'var(--bg-secondary)', borderRight: '3px solid var(--border-color)', borderLeft: 'none', borderRadius: '4px'}}>
                                                &quot;{comment.content.slice(0, 150)}{comment.content.length > 150 ? '...' : ''}&quot;
                                            </blockquote>
                                        </li>
                                    );
                                })}
                            </ul>
                        ) : ( <p>{user.name} لم يخطَّ تعليقًا بعد.</p> )}
                    </section>
                </main>
            </div>
        </div>
    );
}

--- END OF FILE app/profile/[username]/page.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasePageClient.tsx ---

// app/releases/ReleasePageClient.tsx
'use client';

import { useState, useMemo, useRef } from 'react';
import type { SanityGameRelease } from '@/types/sanity';
import TimelineCard from '@/components/TimelineCard';
import { motion, useInView, AnimatePresence } from 'framer-motion';
import styles from './ReleasesPage.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

type Platform = 'الكل' | 'PC' | 'PlayStation' | 'Xbox' | 'Switch';
const PLATFORMS: Platform[] = ['الكل', 'PC', 'PlayStation', 'Xbox', 'Switch'];
const PLATFORM_LABELS: Record<Platform, string> = { 'الكل': 'الكل', 'PC': 'PC', 'PlayStation': 'PlayStation', 'Xbox': 'Xbox', 'Switch': 'Switch' };

const PlatformFilters = ({ activeFilter, onFilterChange }: { activeFilter: Platform, onFilterChange: (platform: Platform) => void }) => {
  const ref = useRef(null);
  const isInView = useInView(ref, { once: true, amount: 0.5 });
  const animationVariants = { 
    hidden: { opacity: 0, y: 50 }, 
    visible: { opacity: 1, y: 0, transition: { duration: 0.6, ease: 'easeOut' as const } } 
  };
  
  const allButton = PLATFORMS[0];
  const otherPlatforms = PLATFORMS.slice(1);

  return (
    <motion.div ref={ref} variants={animationVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'} className={styles.platformFilters}>
      <span>تصفية حسب المنصة:</span>
      <div className={styles.filterLayout}>
        <div className={`${filterStyles.filterButtonsGroup} ${styles.allButtonContainer}`}>
            <motion.button 
                key={allButton} 
                onClick={() => onFilterChange(allButton)} 
                className={`${filterStyles.filterButton} ${activeFilter === allButton ? filterStyles.active : ''}`} 
                whileHover={{ scale: 1.05 }} 
                whileTap={{ scale: 0.95 }}
            >
              {PLATFORM_LABELS[allButton]}
              {activeFilter === allButton && ( <motion.div layoutId="release-filter-highlight" className={filterStyles.filterHighlight} transition={{ type: 'spring', stiffness: 300, damping: 25 }}/> )}
            </motion.button>
        </div>
        <div className={filterStyles.filterButtonsGroup}>
            {otherPlatforms.map(platform => {
              const isActive = activeFilter === platform;
              return (
                <motion.button 
                    key={platform} 
                    onClick={() => onFilterChange(platform)} 
                    className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`} 
                    whileHover={{ scale: 1.05 }} 
                    whileTap={{ scale: 0.95 }}
                >
                  {PLATFORM_LABELS[platform as Platform]}
                  {isActive && ( <motion.div layoutId="release-filter-highlight" className={filterStyles.filterHighlight} transition={{ type: 'spring', stiffness: 300, damping: 25 }}/> )}
                </motion.button>
              );
            })}
        </div>
      </div>
    </motion.div>
  );
};

export default function ReleasePageClient({ releases }: { releases: SanityGameRelease[] }) {
  const [activeFilter, setActiveFilter] = useState<Platform>('الكل');
  const mainRef = useRef(null);
  const isInView = useInView(mainRef, { once: true, amount: 0.1 });
  
  const flatAnimatedContent = useMemo(() => {
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    
    const sortedReleases = [...releases].sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    
    const isFilteringActive = activeFilter !== 'الكل';
    const filteredReleases = isFilteringActive 
        ? sortedReleases.filter(release => {
            if (!release.platforms) return false;
            // THE DEFINITIVE FIX: Check for both "PlayStation" and the legacy "PlayStation 5" value.
            if (activeFilter === 'PlayStation') {
                return release.platforms.includes('PlayStation') || release.platforms.includes('PlayStation 5');
            }
            return release.platforms.includes(activeFilter);
        }) 
        : sortedReleases;
    
    let currentMonth = '';
    let flatList: { type: 'header' | 'card', key: string, data: SanityGameRelease | string }[] = [];

    filteredReleases.forEach(release => {
      const date = new Date(release.releaseDate);
      const monthIndex = date.getUTCMonth();
      const monthLabel = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;
      
      if (monthLabel !== currentMonth) {
        currentMonth = monthLabel;
        flatList.push({ type: 'header', key: `header-${monthLabel}-${date.getFullYear()}`, data: monthLabel });
      }
      flatList.push({ type: 'card', key: `card-${release._id}`, data: release });
    });
    return flatList;
  }, [releases, activeFilter]);

  const cardVariants = { initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, };
  const isListEmpty = flatAnimatedContent.length === 0 && activeFilter !== 'الكل';

  return (
    <div className={styles.chronoStreamLayoutWrapper}>
      <div className={styles.chronoContentWrapper}>
          <h1 className="page-title">إصدارات 2025 المُرتقبة</h1>
          <PlatformFilters activeFilter={activeFilter} onFilterChange={setActiveFilter} />
      </div>
      <div ref={mainRef} className={styles.chronoTimelineSections} style={{ position: 'relative' }}>
          <motion.div layout className={styles.chronoGamesGrid} initial="hidden" animate={isInView ? "visible" : "hidden"} transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
            <AnimatePresence>
              {isListEmpty ? (
                <motion.p key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0', gridColumn: '1 / -1'}}>
                  لا إصدارات لهذه المنصة بعد.
                </motion.p>
              ) : (
                flatAnimatedContent.map(item => {
                  if (item.type === 'header') {
                    return (
                      <motion.div key={item.key} layout style={{ gridColumn: '1 / -1', padding: '1rem 0 0 0', display: 'flex', justifyContent: 'flex-start' }} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                        <h2 className={styles.timelineMonthTitle}>{item.data as string}</h2>
                      </motion.div>
                    );
                  }
                  const release = item.data as SanityGameRelease;
                  return (
                    <motion.div key={item.key} layout variants={cardVariants} initial="initial" animate="animate" exit="exit" transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
                      <TimelineCard release={release} />
                    </motion.div>
                  );
                })
              )}
            </AnimatePresence>
          </motion.div>
      </div>
    </div>
  );
}

--- END OF FILE app/releases/ReleasePageClient.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasesPage.module.css ---

/* app/releases/ReleasesPage.module.css */

.chronoStreamLayoutWrapper {
  position: relative;
  min-height: 80vh;
  padding-bottom: 6rem;
}

.chronoContentWrapper {
  max-width: 1200px;
  margin: 0 auto;
}

.chronoTimelineSections {
  padding-top: 2rem;
  padding-right: 2rem;
  padding-left: 2rem;
}

.platformFilters {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  padding: 2rem 2rem 3rem 2rem;
  font-family: var(--font-ui);
}

.platformFilters > span {
  font-size: 1.6rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.timelineMonthTitle {
  font-size: 3.6rem;
  border-bottom: none;
  padding-bottom: 0.5rem;
  display: block;
  text-align: left;
  margin: 0;
  width: max-content;
  border-bottom: 2px solid var(--accent);
  color: var(--text-primary);
  text-shadow: none;
}

.chronoGamesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 3rem;
  margin: 0 auto;
  width: 100%;
}

.chronoGamesGrid > div[style*="grid-column: 1 / -1"] {
    margin-bottom: 1.5rem; 
}

/* --- NEW MOBILE FILTER LAYOUT STYLES --- */
.filterLayout {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 1.5rem;
    width: 100%;
    justify-content: center;
}

.allButtonContainer {
    flex-shrink: 0;
}

@media (max-width: 768px) {
    .chronoGamesGrid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 2rem;
    }
    .chronoTimelineSections {
        padding-right: 1rem;
        padding-left: 1rem;
    }
    .filterLayout {
        flex-direction: column;
    }
}

--- END OF FILE app/releases/ReleasesPage.module.css ---

================================================================================

--- START OF FILE app/releases/page.tsx ---

// app/releases/page.tsx

import { client } from '@/lib/sanity.client';
import { allReleasesQuery } from '@/lib/sanity.queries';
import type { SanityGameRelease } from '@/types/sanity';
import ReleasePageClient from './ReleasePageClient';

export default async function ReleasesPage() {
  const releases: SanityGameRelease[] = await client.fetch(allReleasesQuery);

  const sanitizedReleases = (releases || []).filter(item =>
    item?.mainImage?.url && item.releaseDate && item.title && item.slug
  );

  return (
    <div className="container page-container" style={{ paddingTop: 'calc(var(--nav-height-scrolled) + 2rem)' }}>
      <ReleasePageClient releases={sanitizedReleases} />
    </div>
  );
}

--- END OF FILE app/releases/page.tsx ---

================================================================================

--- START OF FILE app/reset-password/ResetPasswordClientPage.tsx ---

// app/reset-password/ResetPasswordClientPage.tsx
'use client';

import { useState, useTransition } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { resetPassword } from '@/app/actions/authActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function ResetPasswordClientPage() {
    const router = useRouter();
    const searchParams = useSearchParams();
    const token = searchParams.get('token');
    const toast = useToast();

    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [message, setMessage] = useState<{ type: 'error' | 'success', text: string } | null>(null);
    const [isPending, startTransition] = useTransition();

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);

        if (!token) {
            setMessage({ type: 'error', text: 'Invalid or missing reset token.' });
            return;
        }

        if (newPassword !== confirmPassword) {
            setMessage({ type: 'error', text: 'Passwords do not match.' });
            return;
        }

        startTransition(async () => {
            const result = await resetPassword(token, newPassword);
            if (result.success) {
                toast.success(result.message || 'Password reset successfully!');
                router.push('/'); // Redirect to homepage on success
            } else {
                setMessage({ type: 'error', text: result.message || 'Failed to reset password.' });
            }
        });
    };
    
    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
            <motion.div 
                style={{ maxWidth: '420px', width: '100%' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <form onSubmit={handleSubmit} className="profile-form" style={{ background: 'var(--bg-secondary)', padding: '3rem', borderRadius: '12px', border: '1px solid var(--border-color)' }}>
                    <h1 className="page-title" style={{ fontSize: '2.8rem', marginTop: 0 }}>Reset Your Password</h1>
                    <p style={{ color: 'var(--text-secondary)', textAlign: 'center', marginTop: '-2rem', marginBottom: '3rem' }}>
                        Enter a new password for your account.
                    </p>

                    <div className="profile-form-group">
                        <input id="newPassword" type="password" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} required minLength={8} className="profile-input" placeholder=" " />
                        <label htmlFor="newPassword" className="profile-form-label">كلمة السر الجديدة</label>
                    </div>
                    <div className="profile-form-group">
                        <input id="confirmPassword" type="password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} required className="profile-input" placeholder=" " />
                        <label htmlFor="confirmPassword" className="profile-form-label">تأكيد الجديدة</label>
                    </div>
                    
                    <AnimatePresence>
                        {message && (
                            <motion.p
                                initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}
                                style={{
                                    fontSize: '1.4rem', textAlign: 'center', margin: '0 0 1.5rem 0',
                                    color: message.type === 'error' ? '#DC2626' : '#16A34A'
                                }}
                            >
                                {message.text}
                            </motion.p>
                        )}
                    </AnimatePresence>

                    <button type="submit" className="primary-button" style={{ width: '100%' }} disabled={isPending}>
                        {isPending ? <ButtonLoader /> : 'إعادة تعيين كلمة السر'}
                    </button>
                </form>
            </motion.div>
        </div>
    );
}




--- END OF FILE app/reset-password/ResetPasswordClientPage.tsx ---

================================================================================

--- START OF FILE app/reset-password/page.tsx ---

// app/reset-password/page.tsx
import { Suspense } from 'react';
import ResetPasswordClientPage from './ResetPasswordClientPage';

const ResetPasswordFallback = () => {
    return (
        <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
            <div className="spinner" />
        </div>
    );
};

export default function ResetPasswordPage() {
    return (
        <Suspense fallback={<ResetPasswordFallback />}>
            <ResetPasswordClientPage />
        </Suspense>
    );
}




--- END OF FILE app/reset-password/page.tsx ---

================================================================================

--- START OF FILE app/reviews/ReviewsPage.module.css ---

/* app/reviews/ReviewsPage.module.css */

.reviewHero {
  height: 55vh;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  margin-bottom: -8rem;
  padding-top: var(--nav-height-scrolled);
}

.heroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
}

.heroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 100%);
  z-index: -1;
}

.heroCategory {
    font-family: var(--font-ui);
    font-size: 1.6rem;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent);
    margin: 0;
}

.titleScoreWrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.heroTitle {
  font-size: 4.8rem;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  margin: 0 0 1rem 0;
}

.heroScore {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: var(--accent);
    color: var(--bg-primary);
    font-weight: 800;
    font-size: 2.4rem;
    box-shadow: 0 0 20px 0 color-mix(in srgb, var(--accent) 80%, transparent);
}

.heroGame {
    color: #fff;
    font-weight: 700;
    font-size: 2.4rem;
    margin-top: -0.5rem;
}

/* --- Review Filters Container --- */
.reviewFiltersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-ui);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-ui), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative;
  overflow: hidden;
}
.filterButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.filterButton.active {
  color: #fff;
  z-index: 2;
}
[data-theme="dark"] .filterButton.active {
  color: var(--bg-primary);
}

.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

/* --- Filter Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: left;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-ui);
  transition: background-color 0.1s ease-out;
}
.popoverItemButton:hover {
  background-color: var(--bg-primary);
}
.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem;
  flex-shrink: 0;
  cursor: pointer;
  color: #000000; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
}
.gameClearButton:hover {
  opacity: 1;
}
.gameSelectedButton.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}

@media (max-width: 768px) {
  .reviewHero {
    height: 30vh;
    min-height: 220px;
    margin-bottom: -10rem;
    align-items: flex-end;
    padding-bottom: 8rem;
  }
  .heroCategory {
      font-size: 1.4rem;
  }
  .titleScoreWrapper {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 1rem;
  }
  .heroTitle {
    font-size: 3.2rem !important;
    margin: 0;
  }
  .heroScore {
    width: 50px;
    height: 50px;
    font-size: 2rem;
    flex-shrink: 0;
  }
  .heroGame {
    display: none;
  }
}

--- END OF FILE app/reviews/ReviewsPage.module.css ---

================================================================================

--- START OF FILE app/reviews/ReviewsPageClient.tsx ---

// app/reviews/ReviewsPageClient.tsx
'use client';

import { useState, useMemo, useRef, useCallback, useEffect } from 'react';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import ReviewFilters, { ScoreFilter } from '@/components/filters/ReviewFilters';
import ArticleCard from '@/components/ArticleCard';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from './ReviewsPage.module.css';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useRouter } from 'next/navigation';
import { ContentBlock } from '@/components/ContentBlock';
import { ReviewIcon } from '@/components/icons';

const fetchReviews = async (params: URLSearchParams) => {
    const res = await fetch(`/api/reviews?${params.toString()}`);
    if (!res.ok) throw new Error('Failed to fetch reviews');
    return res.json();
};

export default function ReviewsPageClient({ heroReview, initialGridReviews, allGames, allTags }: { heroReview: SanityReview, initialGridReviews: SanityReview[], allGames: SanityGame[], allTags: SanityTag[] }) {
    const intersectionRef = useRef(null);
    const isInView = useInView(intersectionRef, { margin: '400px' });
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const router = useRouter();

    // OPTIMIZATION: 600px for grid items
    const initialCards = useMemo(() => initialGridReviews.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [initialGridReviews]);
    const [allFetchedReviews, setAllFetchedReviews] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    const [nextOffset, setNextOffset] = useState<number | null>(initialCards.length === 20 ? 20 : null);
    
    const [searchTerm, setSearchTerm] = useState('');
    const [activeSort, setActiveSort] = useState<'latest' | 'score'>('latest');
    const [selectedScoreRange, setSelectedScoreRange] = useState<ScoreFilter>('All');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedTags, setSelectedTags] = useState<SanityTag[]>([]);

    const gridReviews = useMemo(() => {
        let items = [...allFetchedReviews];
        
        if (searchTerm) {
            items = items.filter(review => review.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }
        if (selectedScoreRange !== 'All') {
            const rangeMap = { '9-10': [9, 10], '8-8.9': [8, 8.9], '7-7.9': [7, 7.9], '<7': [0, 6.9] };
            if (rangeMap[selectedScoreRange]) {
                const [min, max] = rangeMap[selectedScoreRange];
                items = items.filter(review => review.score! >= min && review.score! <= max);
            }
        }
        if (selectedGame) {
            items = items.filter(review => review.game === selectedGame.title);
        }
        if (selectedTags.length > 0) {
            const selectedTagTitles = new Set(selectedTags.map(t => t.title));
            items = items.filter(review => review.tags.some(t => selectedTagTitles.has(t.title)));
        }

        if (activeSort === 'score') {
            items.sort((a, b) => (b.score || 0) - (a.score || 0));
        }

        return items;
    }, [allFetchedReviews, searchTerm, activeSort, selectedScoreRange, selectedGame, selectedTags]);
    
    const hasActiveFilters = useMemo(() => {
        return !!searchTerm || selectedScoreRange !== 'All' || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest';
    }, [searchTerm, selectedScoreRange, selectedGame, selectedTags, activeSort]);

    const canLoadMore = useMemo(() => {
        return nextOffset !== null && !hasActiveFilters;
    }, [nextOffset, hasActiveFilters]);

    useEffect(() => {
        if (isInView && canLoadMore && !isLoading) {
            const loadMore = async () => {
                setIsLoading(true);
                const params = new URLSearchParams({ offset: String(nextOffset), limit: '20', sort: activeSort });
                if(selectedScoreRange !== 'All') params.set('score', selectedScoreRange);
                try {
                    const result = await fetchReviews(params);
                    setAllFetchedReviews(prev => [...prev, ...result.data]);
                    setNextOffset(result.nextOffset);
                } catch (error) { 
                    console.error("Failed to load more reviews:", error);
                } finally {
                    setIsLoading(false);
                }
            };
            loadMore();
        }
    }, [isInView, canLoadMore, isLoading, nextOffset, activeSort, selectedScoreRange]);

    const handleTagToggle = (tag: SanityTag) => { setSelectedTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]); };
    const handleClearAll = () => { setSearchTerm(''); setSelectedScoreRange('All'); setSelectedGame(null); setSelectedTags([]); setActiveSort('latest'); };

    const handleHeroClick = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setPrefix('reviews-hero');
        router.push(`/reviews/${heroReview.slug}`, { scroll: false });
    };

    return (
        <>
            <motion.div
                layoutId={`reviews-hero-card-container-${heroReview.legacyId}`}
                className={styles.reviewHero}
            >
                <motion.div layoutId={`reviews-hero-card-image-${heroReview.legacyId}`} className={styles.heroBg}>
                    <Image src={heroReview.mainImage.url} alt={`Background for ${heroReview.title}`} fill style={{ objectFit: 'cover' }} priority placeholder='blur' blurDataURL={heroReview.mainImage.blurDataURL} />
                </motion.div>
                <div className={styles.heroOverlay} />
                <motion.div className="container" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1rem', zIndex: 5, color: '#fff', textAlign: 'center' }} initial={{opacity: 0, y: 20}} animate={{opacity: 1, y: 0}} transition={{duration: 0.5, delay: 0.2}}>
                    <p className={styles.heroCategory}>الأعلى تقييمًا</p>
                    <div className={styles.titleScoreWrapper}>
                        <motion.h1 layoutId={`reviews-hero-card-title-${heroReview.legacyId}`} className={styles.heroTitle}>{heroReview.title}</motion.h1>
                        <span className={styles.heroScore}>{heroReview.score?.toFixed(1)}</span>
                    </div>
                    {heroReview.game?.title && (<span className={styles.heroGame}>{heroReview.game.title}</span>)}
                    <button onClick={handleHeroClick} className="primary-button no-underline" style={{padding: '1rem 2.4rem', fontSize: '1.6rem'}}>
                        اقرأ المراجعة
                    </button>
                </motion.div>
            </motion.div>
            
            <div className="container" style={{paddingTop: '4rem'}}>
                <ReviewFilters activeSort={activeSort} onSortChange={setActiveSort} selectedScoreRange={selectedScoreRange} onScoreSelect={setSelectedScoreRange} allGames={allGames} selectedGame={selectedGame} onGameSelect={setSelectedGame} allTags={allTags} selectedTags={selectedTags} onTagToggle={handleTagToggle} onClearAll={handleClearAll} searchTerm={searchTerm} onSearchChange={setSearchTerm} />
                
                <ContentBlock title="كل المراجعات" Icon={ReviewIcon}>
                    <motion.div layout className="content-grid">
                        {gridReviews.map((review, index) => (
                            <ArticleCard
                                key={review.id}
                                article={review}
                                layoutIdPrefix="reviews"
                                isPriority={index < 3}
                            />
                        ))}
                    </motion.div>
                    
                    <div ref={intersectionRef} style={{ height: '1px', margin: '1rem 0' }} />

                    <AnimatePresence>
                        {isLoading && (
                            <motion.div key="loading" style={{display: 'flex', justifyContent: 'center', padding: '4rem'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                                <div className="spinner" />
                            </motion.div>
                        )}
                    </AnimatePresence>

                    <AnimatePresence>
                        {(!isLoading && gridReviews.length > 0 && (nextOffset === null || hasActiveFilters)) && (
                             <motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                                {hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}
                             </motion.p>
                        )}
                    </AnimatePresence>

                    {gridReviews.length === 0 && !isLoading && (
                        <motion.p key="no-match" style={{textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                            لا مراجعات توافقُ ما اخترت.
                        </motion.p>
                    )}
                </ContentBlock>
            </div>
        </>
    );
}

--- END OF FILE app/reviews/ReviewsPageClient.tsx ---

================================================================================

--- START OF FILE app/reviews/page.tsx ---

// app/reviews/page.tsx
import { client } from '@/lib/sanity.client';
import { featuredHeroReviewQuery, allReviewsListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import ReviewsPageClient from './ReviewsPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';
import { enrichContentList, enrichCreators } from '@/lib/enrichment';

export const metadata: Metadata = {
  title: 'المراجعات',
  description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames. تقييمات شاملة، تحليلات دقيقة، وحكم نهائي.',
  alternates: {
    canonical: '/reviews',
  },
  openGraph: {
    title: 'مراجعات | EternalGames',
    description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames.',
  },
  twitter: {
    title: 'مراجعات | EternalGames',
    description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current}`;

export default async function ReviewsPage() {
  const [heroReviewRaw, initialGridReviewsRaw, allGames, allTags]: [SanityReview, SanityReview[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(featuredHeroReviewQuery),
    client.fetch(allReviewsListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allTagsQuery),
  ]);

  if (!heroReviewRaw) {
    return (
      <div className="container page-container">
        <h1 className="page-title">المراجعات</h1>
        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>الأرشيفُ خالٍ من المراجعاتِ حاليًا. عُد قريبًا.</p>
      </div>
    );
  }

  // Enrich data with usernames server-side to prevent client-side waterfalls
  const heroReview = {
      ...heroReviewRaw,
      authors: await enrichCreators(heroReviewRaw.authors),
      designers: await enrichCreators(heroReviewRaw.designers)
  };
  
  const initialGridReviews = (await enrichContentList(initialGridReviewsRaw)) as SanityReview[];
  const gridReviews = (initialGridReviews || []).filter(review => review._id !== heroReview._id);

  return (
    <Suspense fallback={<div className="spinner page-container" style={{margin: 'auto'}} />}>
      <ReviewsPageClient 
        heroReview={heroReview} 
        initialGridReviews={gridReviews}
        allGames={allGames}
        allTags={allTags}
      />
    </Suspense>
  );
}

--- END OF FILE app/reviews/page.tsx ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.module.css ---

/* app/studio/ActionDrawer.module.css */

.actionDrawerContainer {
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  z-index: 50; /* Kept relatively low to be under Orb (2000) but over card content */
  overflow: hidden;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  backdrop-filter: blur(8px);
  border-top: 1px solid var(--border-color);
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  pointer-events: auto;
}

.actionDrawerButtons {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
}

.actionDrawerButton {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background-color: transparent;
  border: 1px solid transparent;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  position: relative;
  z-index: 51;
}
.actionDrawerButton svg {
  width: 22px;
  height: 22px;
}

.actionDrawerButton:hover {
  background-color: var(--border-color);
  color: var(--accent);
}
.actionDrawerButton.delete:hover {
  background-color: #3f1a1a;
  color: #DC2626;
}

--- END OF FILE app/studio/ActionDrawer.module.css ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.tsx ---

// app/studio/ActionDrawer.tsx
'use client';

import { motion } from 'framer-motion';
import Link from 'next/link';
import { useState } from 'react';
import { EditIcon, PreviewIcon, DeleteIcon } from './StudioIcons';
import { DeleteConfirmationModal } from './DeleteConfirmationModal';
import styles from './ActionDrawer.module.css';

type ContentCanvasItem = { _id: string; _type: string; slug: string; title: string; };

const drawerVariants = {
    hidden: { y: '100%' },
    visible: { y: '0%', transition: { type: 'spring' as const, damping: 25, stiffness: 200 } },
    exit: { y: '100%', transition: { duration: 0.2 } }
};

const itemContainerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.07, delayChildren: 0.2 } },
};

const itemVariants = {
    hidden: { opacity: 0, y: 10 },
    visible: { opacity: 1, y: 0 },
};

export function ActionDrawer({ item, onDelete }: { item: ContentCanvasItem, onDelete: (id: string) => Promise<void> }) {
    const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);

    const getPaths = () => {
        // Use item.slug if available, otherwise fallback to empty string to prevent URL errors
        const safeSlug = item.slug || '';
        switch (item._type) {
            case 'review': return { plural: 'reviews', live: `/reviews/${safeSlug}` };
            case 'article': return { plural: 'articles', live: `/articles/${safeSlug}` };
            case 'news': return { plural: 'news', live: `/news/${safeSlug}` };
            case 'gameRelease': return { plural: 'releases', live: `/releases` };
            default: return { plural: '', live: '/' };
        }
    };

    const { plural, live } = getPaths();
    const studioEditUrl = `/studio/${plural}/${item._id}`;
    const livePreviewUrl = live;

    const handleDeleteConfirm = async () => {
        await onDelete(item._id);
        setDeleteModalOpen(false);
    };

    // Explicit type handling for actions
    type ActionItem = {
        label: string;
        icon: React.ReactNode;
        href?: string;
        onClick?: () => void;
        isLink: boolean;
    };

    const actions: ActionItem[] = [
        { label: 'تحرير', icon: <EditIcon />, href: studioEditUrl, isLink: true },
        { label: 'معاينة', icon: <PreviewIcon />, href: livePreviewUrl, isLink: true },
        { label: 'حذف', icon: <DeleteIcon />, onClick: () => setDeleteModalOpen(true), isLink: false },
    ];

    return (
        <>
            <DeleteConfirmationModal
                isOpen={isDeleteModalOpen}
                onClose={() => setDeleteModalOpen(false)}
                onConfirm={handleDeleteConfirm}
                itemName={item.title}
            />
            <motion.div
                className={styles.actionDrawerContainer}
                variants={drawerVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
                // Important: Stop propagation on click/hover to prevent bubbling to card
                onClick={(e) => e.stopPropagation()}
                onMouseEnter={(e) => e.stopPropagation()}
            >
                <motion.div className={styles.actionDrawerButtons} variants={itemContainerVariants}>
                    {actions.map((action) => (
                        <motion.div key={action.label} variants={itemVariants}>
                            {action.isLink ? (
                                <Link 
                                    href={action.href!} 
                                    className={styles.actionDrawerButton} 
                                    aria-label={action.label} 
                                    target={action.label === 'معاينة' ? '_blank' : '_self'}
                                    prefetch={false} // Disable prefetch to reduce load
                                    onClick={(e) => e.stopPropagation()} // Extra safety
                                >
                                    {action.icon}
                                </Link>
                            ) : (
                                <button 
                                    className={`${styles.actionDrawerButton} ${styles.delete}`} 
                                    onClick={(e) => { e.stopPropagation(); action.onClick?.(); }} 
                                    aria-label={action.label}
                                >
                                    {action.icon}
                                </button>
                            )}
                        </motion.div>
                    ))}
                </motion.div>
            </motion.div>
        </>
    );
}

--- END OF FILE app/studio/ActionDrawer.tsx ---

================================================================================

--- START OF FILE app/studio/DeleteConfirmationModal.tsx ---

// app/studio/DeleteConfirmationModal.tsx
'use client';

import { useState } from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';

interface DeleteConfirmationModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => Promise<void>;
    itemName: string;
}

export function DeleteConfirmationModal({ isOpen, onClose, onConfirm, itemName }: DeleteConfirmationModalProps) {
    const [isPending, setIsPending] = useState(false);

    const handleConfirm = async () => {
        setIsPending(true);
        await onConfirm();
        // No need to set isPending back to false if the modal closes on success
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '450px' }}>
            <h3 style={{ marginTop: 0, fontFamily: 'var(--font-main)', fontSize: '2rem' }}>تأكيد الحذف</h3>
            <p style={{ color: 'var(--text-secondary)', margin: '1rem 0 2rem 0' }}>
                هل أنت متأكد من رغبتك في حذف <strong style={{ color: 'var(--text-primary)' }}>&quot;{itemName}&quot;</strong>? لا رجعةَ في هذا.
            </p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                <motion.button
                    onClick={handleConfirm}
                    className="primary-button delete-forever"
                    style={{ backgroundColor: '#DC2626', boxShadow: 'none' }}
                    disabled={isPending}
                >
                    {isPending ? 'جارٍ الحذف...' : 'حذفٌ نهائي'}
                </motion.button>
            </div>
        </Modal>
    );
}

--- END OF FILE app/studio/DeleteConfirmationModal.tsx ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.module.css ---

/* app/studio/GenesisOrb.module.css */

.genesisContainer {
  position: fixed;
  /* --- CUSTOMIZATION POINT (Desktop) --- */
  /* Adjust these values to change the orb's position on larger screens */
  bottom: 2rem;
  right: 2rem;
  /* --- END CUSTOMIZATION --- */
  left: auto;
  z-index: 2000; /* THE FIX: Increased from 10 to 2000 to float above drawers */
  width: 80px;
  height: 80px;
}

.genesisOrb {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background-color: var(--accent);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--accent) 50%, transparent);
  z-index: 2002; /* THE FIX: Higher than container */
  /* --- THE FIX: Centering styles applied directly to the button --- */
  display: flex;
  /* --- CUSTOMIZATION POINT (Icon Alignment) --- */
  align-items: center; /* Vertical alignment */
  justify-content: center; /* Horizontal alignment */
  /* --- END CUSTOMIZATION --- */
}
/* THE FIX: Added a rule to style the PlusIcon inside */
.genesisOrb svg {
    width: 32px;
    height: 32px;
    stroke-width: 3; /* Increased stroke width for better visibility */
}
[data-theme="dark"] .genesisOrb {
  color: var(--bg-primary);
}

.genesisSatellites {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  z-index: 2001; /* THE FIX: Layer between orb and container */
  pointer-events: none;
}

.satelliteWrapper {
  position: absolute;
  margin-left: -28px;
  margin-top: -28px;
  pointer-events: auto;
  display: flex;
  align-items: center;
}

.satelliteOrb {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  flex-shrink: 0;
}

[data-theme="dark"] .satelliteOrb {
  color: var(--text-primary);
}

.satelliteOrb:hover {
  border-color: var(--accent);
  color: var(--accent);
  transform: scale(1.1);
}

.satelliteOrb svg {
  color: currentColor;
  filter: grayscale(0) opacity(1) !important;
}

.satelliteLabel {
  position: absolute;
  left: calc(100% + 1rem); /* RTL */
  right: auto;
  font-family: var(--font-main);
  font-size: 1.4rem;
  font-weight: 500;
  color: var(--text-primary);
  background: var(--bg-secondary);
  padding: 0.4rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out;
}

.satelliteWrapper:hover .satelliteLabel {
  opacity: 1;
}

.closeIcon {
  color: #fff !important;
}
[data-theme="dark"] .closeIcon {
  color: var(--bg-primary) !important;
}

.closeIcon:hover {
  filter: drop-shadow(0 0 10px #DC2626); /* Red glow on hover */
}

@media (max-width: 768px) {
    .genesisContainer {
        /* --- CUSTOMIZATION POINT (Mobile) --- */
        /* Adjust these values for smaller screens */
        bottom: 2rem;
        right: 2rem;
        /* --- END CUSTOMIZATION --- */
        width: 64px;
        height: 64px;
    }
    /* THE FIX: Adjusted the SVG size for mobile */
    .genesisOrb svg {
        width: 24px;
        height: 24px;
        stroke-width: 3;
    }
    .satelliteWrapper {
        margin-left: -24px;
        margin-top: -24px;
    }
    .satelliteOrb {
        width: 48px;
        height: 48px;
    }
}

--- END OF FILE app/studio/GenesisOrb.module.css ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.tsx ---

// app/studio/GenesisOrb.tsx
'use client';

import { useState, useTransition, useMemo, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
// REMOVED: useSession import is no longer the primary source of truth
import { createDraftAction } from './actions';
import { ReviewIcon, ArticleIcon, NewsIcon, ReleaseIcon } from '@/components/icons/index';
import { useToast } from '@/lib/toastStore';
import styles from './GenesisOrb.module.css';

// THE FIX: Modified viewBox and paths to ensure perfect center alignment of the '+' sign.
const PlusIcon = () => ( <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"> <line x1="12" y1="5" x2="12" y2="19"></line> <line x1="5" y1="12" x2="19" y2="12"></line> </svg> );

const allContentTypes = [
    { type: 'review' as const, label: 'مراجعة جديدة', icon: <ReviewIcon />, requiredRole: 'REVIEWER' },
    { type: 'article' as const, label: 'مقالة جديدة', icon: <ArticleIcon />, requiredRole: 'AUTHOR' },
    { type: 'news' as const, label: 'خبر جديد', icon: <NewsIcon />, requiredRole: 'REPORTER' },
    { type: 'gameRelease' as const, label: 'إصدار جديد', icon: <ReleaseIcon />, requiredRole: 'ADMIN' }, // Restricted
];

const orbContainerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.08, delayChildren: 0.1 } }, };
const satelliteVariants = { hidden: { scale: 0, opacity: 0, x: 0, y: 0 }, visible: (custom: { x: number; y: number }) => ({ scale: 1, opacity: 1, x: custom.x, y: custom.y, transition: { type: 'spring' as const, stiffness: 400, damping: 18 }, }), };
const backdropVariants = { hidden: { scale: 0, opacity: 0, transition: { duration: 0.2, ease: "easeOut" as const } }, visible: { scale: 1, opacity: 1, transition: { type: "spring" as const, stiffness: 400, damping: 25 } }, };

// THE FIX: Accept userRoles as a prop
export function GenesisOrb({ userRoles }: { userRoles: string[] }) {
    const [isOpen, setIsOpen] = useState(false);
    const [isPending, startTransition] = useTransition();
    const router = useRouter();
    const toast = useToast();
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    
    const creationPermissions = useMemo(() => new Set( allContentTypes.filter(item => isAdminOrDirector || userRoles.includes(item.requiredRole)).map(item => item.type) ), [isAdminOrDirector, userRoles]);

    const handleCreate = (contentType: 'review' | 'article' | 'news' | 'gameRelease') => {
        if (isPending) return;
        if (!creationPermissions.has(contentType)) { toast.error("ليس لكَ إذنُ الإنشاء.", "left"); return; }
        setIsOpen(false);
        startTransition(async () => {
            try {
                const newDraft = await createDraftAction(contentType);
                const contentTypePlural = newDraft._type === 'news' ? 'news' : (newDraft._type === 'gameRelease' ? 'releases' : `${newDraft._type}s`);
                const route = contentType === 'gameRelease' ? `/studio/releases/${newDraft._id}` : `/studio/${contentTypePlural}/${newDraft._id}`;
                router.push(route);
            } catch (error: any) {
                toast.error(error.message || "أخفق إنشاء المسودة.", "left");
            }
        });
    };
    
    if (creationPermissions.size === 0 && !isAdminOrDirector) { return null; }

    const availableTypes = allContentTypes.filter(item => creationPermissions.has(item.type));
    const radius = isMobile ? 85 : 100;

    return (
        <div className={styles.genesisContainer}>
            <AnimatePresence>
                {isOpen && (
                    <>
                        <motion.div variants={backdropVariants} initial="hidden" animate="visible" exit="hidden" onClick={() => setIsOpen(false)} style={{ position: 'absolute', top: '-110px', right: '-110px', width: '300px', height: '300px', backgroundColor: 'transparent', borderRadius: '50%', zIndex: 10, cursor: 'default' }} />
                        <motion.div className={styles.genesisSatellites} variants={orbContainerVariants} initial="hidden" animate="visible" exit="hidden" >
                            {availableTypes.map((item, i) => {
                                const totalAngle = 110;
                                const startAngle = 170;
                                const angleInDegrees = startAngle + (i * (totalAngle / (availableTypes.length -1 || 1) ));
                                const angleInRadians = angleInDegrees * (Math.PI / 180);
                                const x = Math.cos(angleInRadians) * radius;
                                const y = Math.sin(angleInRadians) * radius;

                                return (
                                    <motion.div key={item.type} className={styles.satelliteWrapper} custom={{ x, y }} variants={satelliteVariants} >
                                        <button className={styles.satelliteOrb} onClick={() => handleCreate(item.type)} disabled={isPending} title={item.label}>
                                            {item.icon}
                                        </button>
                                    </motion.div>
                                );
                            })}
                        </motion.div>
                    </>
                )}
            </AnimatePresence>
            <motion.button onClick={() => setIsOpen(!isOpen)} disabled={isPending} className={styles.genesisOrb} whileHover={{ scale: 1.05, boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} whileTap={{ scale: 0.95 }} transition={{ type: 'spring' as const, stiffness: 300, damping: 20 }} animate={{ scale: isOpen ? 1.1 : 1, backgroundColor: isOpen ? '#DC2626' : 'var(--accent)', boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} >
                <motion.div animate={{ rotate: isOpen ? 45 : 0 }} className={isOpen ? styles.closeIcon : ''}>
                    <PlusIcon />
                </motion.div>
            </motion.button>
        </div>
    );
}

--- END OF FILE app/studio/GenesisOrb.tsx ---

================================================================================

--- START OF FILE app/studio/StudioDashboard.module.css ---

/* app/studio/StudioDashboard.module.css */
.studioHeader {
    text-align: center;
    margin-bottom: 3rem;
}

.studioTitle {
    margin-bottom: 1rem;
}

.studioSubtitle {
    font-size: 1.8rem;
    color: var(--text-secondary);
    max-width: 600px;
    margin: 0 auto;
}

.searchWrapper {
    display: flex;
    justify-content: center;
    margin-bottom: 3rem;
}

.searchInput {
    width: 100%;
    max-width: 500px;
}

/* --- NEW: Director Gate Button Styles --- */
.directorGateButton {
    margin-top: 2.5rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 1.2rem;
    padding: 1.2rem 3.5rem;
    border: 2px solid #FFD700; /* Gold Border */
    border-radius: 999px;
    color: #FFD700;
    background-color: transparent;
    font-family: var(--font-main);
    font-size: 1.8rem;
    font-weight: 800;
    transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.1);
    text-decoration: none; /* Failsafe against global link styles */
}

.directorGateButton:hover {
    background-color: #FFD700;
    color: #121212; /* Dark text for contrast against gold */
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
    border-color: #FFD700;
}

.directorGateButton svg {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}

.directorGateButton:hover svg {
    transform: rotate(-15deg) scale(1.1);
}

/* --- Mobile Overrides --- */
@media (max-width: 768px) {
    .studioHeader {
        padding-top: calc(var(--nav-height-scrolled) + 2rem);
        margin-bottom: 2rem;
        padding-right: 1rem;
        padding-left: 1rem;
    }
    .studioTitle {
        font-size: 3.8rem;
    }
    .studioSubtitle {
        font-size: 1.6rem;
    }
    .searchWrapper {
        margin-bottom: 2rem;
        padding: 0 1rem;
    }
    .searchInput {
        max-width: 100%;
    }
    .directorGateButton {
        padding: 1rem 2.5rem;
        font-size: 1.6rem;
    }
}

--- END OF FILE app/studio/StudioDashboard.module.css ---

================================================================================

--- START OF FILE app/studio/StudioDashboard.tsx ---

// app/studio/StudioDashboard.tsx

'use client';

import { useState, useMemo, useTransition, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { StudioTabs, ContentType } from './StudioTabs';
import { ActionDrawer } from './ActionDrawer';
import { GenesisOrb } from './GenesisOrb';
import { deleteDocumentAction } from './actions';
import { useToast } from '@/lib/toastStore';
import { urlFor } from '@/sanity/lib/image';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader';
import styles from './StudioDashboard.module.css';
import { useSession } from 'next-auth/react';
import Link from 'next/link';

type ContentStatus = 'all' | 'draft' | 'published' | 'scheduled';
type ContentCanvasItem = { _id: string; _type: 'review' | 'article' | 'news' | 'gameRelease'; _updatedAt: string; title: string; slug: string; status: ContentStatus; mainImage?: any; blurDataURL?: string; };

const ContentCanvas = ({ item, onDelete, isActive, onCardClick }: {
    item: ContentCanvasItem;
    onDelete: (id: string) => Promise<void>;
    isActive: boolean;
    onCardClick: () => void;
}) => {
    const [isHovered, setIsHovered] = useState(false);
    const justClickedToClose = useRef(false);

    const handleClick = () => {
        if (isActive) {
            justClickedToClose.current = true;
            setIsHovered(false);
        }
        onCardClick();
    };

    const handleMouseEnter = () => {
        if (justClickedToClose.current) {
            return;
        }
        setIsHovered(true);
    };

    const handleMouseLeave = () => {
        justClickedToClose.current = false;
        setIsHovered(false);
    };

    // Drawer is visible if Active (Clicked) OR Hovered
    const isDrawerVisible = isActive || isHovered;

    const imageUrlWithBuster = useMemo(() => {
        if (!item.mainImage?.asset) return null;
        const url = urlFor(item.mainImage).width(800).height(500).fit('crop').auto('format').url();
        return `${url}&buster=${new Date(item._updatedAt).getTime()}`;
    }, [item.mainImage, item._updatedAt]);

    return (
        <motion.div
            layoutId={`canvas-card-${item._id}`}
            style={{ position: 'relative', backgroundColor: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px', overflow: 'hidden', aspectRatio: '16 / 10', cursor: 'pointer' }}
            onMouseEnter={handleMouseEnter}
            onMouseLeave={handleMouseLeave}
            onClick={handleClick}
        >
            <motion.div
                className="canvas-image-container"
                animate={{ scale: isDrawerVisible ? 1.05 : 1, filter: isDrawerVisible ? 'brightness(0.8)' : 'brightness(1)' }}
                transition={{ type: 'spring' as const, damping: 20, stiffness: 150 }}
                style={{ width: '100%', height: '100%', position: 'absolute', inset: 0, backgroundColor: 'var(--border-color)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
            >
                {imageUrlWithBuster ? (
                    <Image 
                        src={imageUrlWithBuster} 
                        alt={item.title} 
                        fill
                        sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 350px"
                        style={{ objectFit: 'cover' }}
                        loader={sanityLoader}
                    />
                ) : (<span style={{color: 'var(--text-secondary)', fontSize: '1.2rem', fontWeight: 600}}>بلا صورة</span>)}
            </motion.div>
            <div style={{ position: 'absolute', inset: 0, background: 'linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 60%)', pointerEvents: 'none' }} />
            <div style={{ position: 'absolute', bottom: 0, left: 0, padding: '1.25rem', color: 'white', pointerEvents: 'none' }}>
                <span style={{ display: 'inline-block', padding: '0.25rem 0.75rem', fontSize: '0.75rem', fontWeight: 600, borderRadius: '9999px', backgroundColor: item.status === 'published' ? 'rgba(22, 163, 74, 0.8)' : 'rgba(107, 114, 128, 0.8)' }}>{item.status === 'draft' ? 'مسودة' : item.status === 'published' ? 'منشورة' : 'مجدولة'}</span>
                <h3 style={{ marginTop: '0.5rem', fontSize: '1.25rem', fontWeight: 700, fontFamily: 'var(--font-heading)' }}>{item.title}</h3>
            </div>
            <AnimatePresence>{isDrawerVisible && <ActionDrawer item={item} onDelete={onDelete} />}</AnimatePresence>
        </motion.div>
    );
};

export function StudioDashboard({ initialContent, userRoles }: { initialContent: ContentCanvasItem[], userRoles: string[] }) {
    const [content, setContent] = useState(initialContent);
    const [activeTab, setActiveTab] = useState<ContentType>('all');
    const [searchTerm, setSearchTerm] = useState('');
    const [activeCardId, setActiveCardId] = useState<string | null>(null);
    const toast = useToast();
    const [isPending, startTransition] = useTransition();
    
    const { data: session, update: updateSession } = useSession();
    useEffect(() => {
        const clientRoles = (session?.user as any)?.roles || [];
        if (userRoles.length > 0 && JSON.stringify(userRoles.sort()) !== JSON.stringify(clientRoles.sort())) {
            console.log("Syncing session roles with server...");
            updateSession(); 
        }
    }, [userRoles, session, updateSession]);

    const availableTabs = useMemo(() => {
        const tabs: { label: string; value: ContentType }[] = [];
        const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
        
        if (isAdminOrDirector || userRoles.includes('REVIEWER')) tabs.push({ label: 'المراجعات', value: 'review' });
        if (isAdminOrDirector || userRoles.includes('AUTHOR')) tabs.push({ label: 'المقالات', value: 'article' });
        if (isAdminOrDirector || userRoles.includes('REPORTER')) tabs.push({ label: 'الأخبار', value: 'news' });
        if (isAdminOrDirector) tabs.push({ label: 'الإصدارات', value: 'gameRelease' });
        
        return tabs;
    }, [userRoles]);
    
    useEffect(() => {
        if (availableTabs.length === 1 && activeTab === 'all') {
            setActiveTab(availableTabs[0].value);
        }
    }, [availableTabs, activeTab]);

    const shouldShowTabs = availableTabs.length > 1;

    const filteredContent = useMemo(() => {
        let filtered = content;
        if (activeTab !== 'all' && shouldShowTabs) {
            filtered = filtered.filter(item => item._type === activeTab);
        } else if (!shouldShowTabs && availableTabs.length === 1) {
            filtered = content.filter(item => item._type === availableTabs[0].value);
        }

        if (searchTerm) {
            filtered = filtered.filter(item => item.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }
        return filtered;
    }, [activeTab, content, searchTerm, shouldShowTabs, availableTabs]);
    
    const handleDelete = async (docId: string) => {
        startTransition(async () => {
            const originalContent = content;
            setContent(prev => prev.filter(item => item._id !== docId));
            const result = await deleteDocumentAction(docId);
            if (!result.success) {
                toast.error(result.message || 'فشل الحذف.');
                setContent(originalContent);
            } else {
                toast.success('تم حذف المستند.');
            }
        });
    };
    
    const handleCardClick = (cardId: string) => {
        setActiveCardId(prevId => (prevId === cardId ? null : cardId));
    };

    const isDirector = userRoles.includes('DIRECTOR');

    return (
        <>
            <header className={styles.studioHeader}>
                <h1 className={`${styles.studioTitle} page-title`}>ديوان الصنعة</h1>
                <p className={styles.studioSubtitle}>قُد دفّة محتواك في رحاب EternalGames.</p>
                {isDirector && (
                    <Link 
                        href="/studio/director" 
                        className={`${styles.directorGateButton} no-underline`}
                    >
                         <span>بوابة الإدارة</span>
                         <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2L15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2z"/></svg>
                    </Link>
                )}
            </header>

            <div className={styles.searchWrapper}>
                <input type="search" placeholder="استنطق المحفوظات..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className={`${styles.searchInput} profile-input`} />
            </div>

            {shouldShowTabs && (
                <StudioTabs tabs={availableTabs} activeTab={activeTab} setActiveTab={setActiveTab} />
            )}

            <motion.div layout className="content-grid" style={{gap: '1.5rem'}}>
                <AnimatePresence>
                    {filteredContent.map(item => (
                        <motion.div key={item._id} layout initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }} transition={{ type: 'spring' as const, damping: 20, stiffness: 200 }} >
                            <ContentCanvas
                                item={item}
                                onDelete={handleDelete}
                                isActive={activeCardId === item._id}
                                onCardClick={() => handleCardClick(item._id)}
                            />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </motion.div>
            {filteredContent.length === 0 && <p style={{ textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}}>لا محتوى.</p>}

            <GenesisOrb userRoles={userRoles} />
        </>
    );
}

--- END OF FILE app/studio/StudioDashboard.tsx ---

================================================================================

--- START OF FILE app/studio/StudioIcons.tsx ---

// app/studio/StudioIcons.tsx
'use client'

export const GameDetailsIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
    <line x1="3" y1="10" x2="21" y2="10"></line>
    <line x1="9" y1="4" x2="9" y2="20"></line>
  </svg>
)

export const TableIcon = (props: React.SVGProps<SVGSVGElement>) => (
  // ADDED
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <line x1="3" y1="9" x2="21" y2="9"></line>
    <line x1="3" y1="15" x2="21" y2="15"></line>
    <line x1="9" y1="3" x2="9" y2="21"></line>
    <line x1="15" y1="3" x2="15" y2="21"></line>
  </svg>
)

export const YoutubeIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>
  </svg>
)

export const SingleImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <circle cx="8.5" cy="8.5" r="1.5"></circle>
    <polyline points="21 15 16 10 5 21"></polyline>
  </svg>
)

export const ImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <circle cx="8.5" cy="8.5" r="1.5"></circle>
    <polyline points="21 15 16 10 5 21"></polyline>
  </svg>
)
export const CompareIcon = () => (
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M12 2v20M3 12h18M21 12l-3-3m3 3l-3 3M3 12l3-3m-3 3l3 3" />
  </svg>
)
export const TwoImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="7" height="18"></rect>
    <rect x="14" y="3" width="7" height="18"></rect>
  </svg>
)
export const FourImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="7" height="7"></rect>
    <rect x="14" y="3" width="7" height="7"></rect>
    <rect x="14" y="14" width="7" height="7"></rect>
    <rect x="3" y="14" width="7" height="7"></rect>
  </svg>
)
export const ReleaseIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M6 2L3 6v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6l-3-4H6zM3.5 6h17M8 11l4 4 4-4" />{' '}
  </svg>
)
export const ReviewIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>{' '}
  </svg>
)
export const ArticleIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>{' '}
    <polyline points="14 2 14 8 20 8"></polyline>{' '}
    <line x1="16" y1="13" x2="8" y2="13"></line> <line x1="16" y1="17" x2="8" y2="17"></line>{' '}
  </svg>
)
export const NewsIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <circle cx="12" cy="12" r="10"></circle> <line x1="2" y1="12" x2="22" y2="12"></line>{' '}
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>{' '}
  </svg>
)
export const EditIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>{' '}
    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>{' '}
  </svg>
)
export const PreviewIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>{' '}
    <circle cx="12" cy="12" r="3"></circle>{' '}
  </svg>
)
export const DeleteIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <polyline points="3 6 5 6 21 6"></polyline>{' '}
    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>{' '}
    <line x1="10" y1="11" x2="10" y2="17"></line> <line x1="14" y1="11" x2="14" y2="17"></line>{' '}
  </svg>
)

--- END OF FILE app/studio/StudioIcons.tsx ---

================================================================================

--- START OF FILE app/studio/StudioTabs.module.css ---

/* app/studio/StudioTabs.module.css */

.studioTabsContainer {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 3rem;
    border-bottom: 1px solid var(--border-color);
  }
  
  .studioTabButton {
    position: relative;
    padding: 1rem 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    font-size: 1.6rem;
    color: var(--text-secondary);
    transition: color 0.2s ease-in-out;
    flex-shrink: 0; /* Prevent buttons from shrinking */
  }
  
  .studioTabButton:hover {
    color: var(--text-primary);
  }
  
  .studioTabButton.active {
    color: var(--accent);
  }
  
  .studioTabUnderline {
    position: absolute;
    bottom: -1px;
    right: 0;
    left: 0;
    height: 2px;
    background: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
  }

/* --- Mobile Overrides --- */
@media (max-width: 768px) {
    .studioTabsContainer {
        justify-content: flex-start; /* Align to the start for scrolling */
        overflow-x: auto;
        padding: 0 1rem; /* Add some padding so items don't touch the edge */
        margin: 0 -1.5rem 2rem -1.5rem; /* Negative margin to bleed to edges of .container */

        /* Hide scrollbar */
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }
    .studioTabsContainer::-webkit-scrollbar {
        display: none; /* Chrome, Safari, and Opera */
    }
}

--- END OF FILE app/studio/StudioTabs.module.css ---

================================================================================

--- START OF FILE app/studio/StudioTabs.tsx ---

// app/studio/StudioTabs.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './StudioTabs.module.css';

export type ContentType = 'review' | 'article' | 'news' | 'gameRelease' | 'all';

interface StudioTabsProps {
    tabs: { label: string; value: ContentType }[];
    activeTab: ContentType;
    setActiveTab: (tab: ContentType) => void;
}

export function StudioTabs({ tabs, activeTab, setActiveTab }: StudioTabsProps) {
    const allTabs = [{ label: 'كل المحتوى', value: 'all' as ContentType }, ...tabs];

    return (
        <div className={styles.studioTabsContainer}>
            {allTabs.map((tab) => (
                <button
                    key={tab.value}
                    onClick={() => setActiveTab(tab.value)}
                    className={`${styles.studioTabButton} ${activeTab === tab.value ? styles.active : ''}`}
                >
                    {tab.label}
                    {activeTab === tab.value && (
                        <motion.div className={styles.studioTabUnderline} layoutId="studioTabUnderline" />
                    )}
                </button>
            ))}
        </div>
    );
}







--- END OF FILE app/studio/StudioTabs.tsx ---

================================================================================

--- START OF FILE app/studio/actions.ts ---

// app/studio/actions.ts
'use server';

import { getAuthenticatedSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { revalidatePath, revalidateTag } from 'next/cache';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';
import { slugify } from 'transliteration';
import { tiptapToPortableText } from './utils/tiptapToPortableText';
import { portableTextToTiptap } from './utils/portableTextToTiptap';
import { editorDocumentQuery } from '@/lib/sanity.queries';
import type { IdentifiedSanityDocumentStub } from '@sanity/client';
import { v4 as uuidv4 } from 'uuid';

function revalidateContentPaths(docType: string, slug?: string) {
    console.log(`[CACHE] Aggressive revalidation triggered for type: ${docType}, slug: ${slug}`);
    
    revalidatePath('/studio', 'layout');
    revalidatePath('/', 'layout');

    let sectionPath = '';
    switch (docType) {
        case 'review': sectionPath = '/reviews'; break;
        case 'article': sectionPath = '/articles'; break;
        case 'news': sectionPath = '/news'; break;
        case 'gameRelease': sectionPath = '/releases'; break;
    }

    if (sectionPath) {
        revalidatePath(sectionPath, 'layout'); 
        if (slug) {
            revalidatePath(`${sectionPath}/${slug}`, 'layout'); 
        }
    }

    // THE FIX: Added 'max' profile argument
    revalidateTag(docType, 'max');
    revalidateTag('layout', 'max');
}

export async function translateTitleToAction(title: string): Promise<string> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isAuthorized = userRoles.some((role: string) =>
      ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role)
    );

    if (!isAuthorized) {
        throw new Error('غير مُصرَّح به.');
    }
    
    const apiUrl = process.env.TRANSLATION_API_URL;
    if (!apiUrl) {
        return slugify(title);
    }
    
    try {
        const url = `${apiUrl}?q=${encodeURIComponent(title)}&langpair=ar|en`;
        const response = await fetch(url);

        if (!response.ok) {
            throw new Error(`Translation API responded with status: ${response.status}`);
        }
        const data = await response.json();
        
        const translatedText = data?.responseData?.translatedText;
        if (!translatedText || typeof translatedText !== 'string') {
            throw new Error("Invalid response structure from translation API.");
        }

        return slugify(translatedText, {
            lowercase: true,
            separator: '-',
            allowedChars: 'a-zA-Z0-9-',
        });

    } catch (error) {
        return slugify(title, {
            lowercase: true,
            separator: '-',
            allowedChars: 'a-zA-Z0-9-',
        });
    }
}


export async function createDraftAction(contentType: 'review' | 'article' | 'news' | 'gameRelease') {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    
    const canCreate = (userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR')) || (contentType === 'review' && userRoles.includes('REVIEWER')) || (contentType === 'article' && userRoles.includes('AUTHOR')) || (contentType === 'news' && userRoles.includes('REPORTER'));
    if (!canCreate) throw new Error('صلاحياتٌ قاصرة.');

    const highestIdQuery = groq`*[_type in ["review", "article", "news", "gameRelease"] && defined(legacyId)] | order(legacyId desc)[0].legacyId`;
    const lastId = await sanityWriteClient.fetch<number>(highestIdQuery, {}, { perspective: 'previewDrafts' });
    const newLegacyId = (lastId || 0) + 1;

    let doc: any = { _type: contentType, title: `Untitled ${contentType.charAt(0).toUpperCase() + contentType.slice(1)}`, legacyId: newLegacyId };

    if (contentType === 'review' || contentType === 'article' || contentType === 'news') {
        let sanityCreator;
        const creatorTypeMap: Record<string, string> = { 'review': 'reviewer', 'article': 'author', 'news': 'reporter' };
        const sanityDocType = creatorTypeMap[contentType];
        const user = session.user;
        if (!user || !user.name) throw new Error("المستخدمُ مفقودٌ أو الاسمُ غائب.");
        
        const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityDocType}" && prismaUserId == $userId][0]`, { userId: user.id });
        if (existingCreator) {
            sanityCreator = existingCreator;
        } else {
            const newCreatorPayload: any = { _type: sanityDocType, _id: `${sanityDocType}-${user.id}`, name: user.name, prismaUserId: user.id };
            if (user.image) {
                try {
                    const response = await fetch(user.image);
                    const imageBlob = await response.blob();
                    const imageAsset = await sanityWriteClient.assets.upload('image', imageBlob, {
                        contentType: imageBlob.type,
                        filename: `${user.id}-avatar.jpg`
                    });
                    newCreatorPayload.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAsset._id }};
                } catch (e) { console.warn('Image upload on draft creation failed', e); }
            }
            sanityCreator = await sanityWriteClient.create(newCreatorPayload);
        }
        if (contentType === 'review' || contentType === 'article') { doc.authors = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
        if (contentType === 'news') { doc.reporters = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
    }
    
    if (contentType === 'review') { doc.score = 0; doc.verdict = '...'; doc.pros = []; doc.cons = []; }
    if (contentType === 'gameRelease') { doc.releaseDate = new Date().toISOString().split('T')[0]; doc.synopsis = '...'; doc.platforms = []; }
    
    const result = await sanityWriteClient.create(doc, { autoGenerateArrayKeys: true });
    revalidatePath('/studio', 'layout');
    return { _id: result._id, _type: result._type };
}

export async function updateDocumentAction(docId: string, patchData: Record<string, any>): Promise<{ success: boolean; message?: string; updatedDocument?: any }> {
    const session = await getAuthenticatedSession();
    if (!session) return { success: false, message: 'غير مُخَوَّل.' };

    const publicId = docId.replace('drafts.', '');
    const draftId = `drafts.${publicId}`;

    try {
        const tx = sanityWriteClient.transaction();
        const existingDraft = await sanityWriteClient.getDocument(draftId);

        if (existingDraft) {
            tx.patch(draftId, (p) => p.set(patchData));
        } else {
            const originalDoc = await sanityWriteClient.getDocument(publicId);
            if (!originalDoc) {
                const docTypeQuery = groq`*[_id == $id][0]._type`;
                const docType = await sanityWriteClient.fetch(docTypeQuery, { id: publicId });
                if (!docType) throw new Error("لم يُعثر على نوع الوثيقة لإنشائها.");
                const newDoc = { _id: draftId, _type: docType, ...patchData };
                tx.create(newDoc);
            } else {
                const { _rev, _updatedAt, _createdAt, ...restOfOriginalDoc } = originalDoc;
                const newDraftPayload = { ...restOfOriginalDoc, ...patchData, _id: draftId };
                tx.create(newDraftPayload);
            }
        }

        await tx.commit({ autoGenerateArrayKeys: true, returnDocuments: false });
        
        const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId });
        if (!finalDoc) throw new Error("الوثيقةُ مفقودةٌ بعد تحديثها.");
        
        revalidateContentPaths(finalDoc._type, finalDoc.slug?.current);
        
        const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
        return { success: true, updatedDocument: docWithTiptap };

    } catch (error: any) {
        console.error("Error during document update:", error);
        return { success: false, message: error.message || "أصابنا خطبٌ أثناء الحفظ." };
    }
}

export async function deleteDocumentAction(docId: string): Promise<{ success: boolean; message?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    
    const baseId = docId.replace(/^drafts\./, '');
    const draftId = `drafts.${baseId}`;

    const docToDelete = await sanityWriteClient.fetch(
        groq`*[_id in [$baseId, $draftId]][0]{_type, "slug": slug.current}`, 
        { baseId, draftId }
    );
    
    if (!docToDelete) return { success: false, message: 'الوثيقةُ مفقودة.' };
    
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const docType = docToDelete._type;
    
    const canDelete = 
        isAdminOrDirector || 
        (docType === 'review' && userRoles.includes('REVIEWER')) || 
        (docType === 'article' && userRoles.includes('AUTHOR')) || 
        (docType === 'news' && userRoles.includes('REPORTER'));

    if (!canDelete) return { success: false, message: 'أذوناتٌ قاصرة.' };
    
    try {
        const tx = sanityWriteClient.transaction();
        tx.delete(baseId);
        tx.delete(draftId);
        await tx.commit();

        revalidateContentPaths(docType, docToDelete.slug);

        return { success: true };
    } catch (error) {
        console.error("Delete failed:", error);
        return { success: false, message: 'تأبى الحذف.' };
    }
}

export async function searchCreatorsAction(query: string, roleName: 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER'): Promise<{ _id: string; name: string }[]> {
    const usersWithRole = await prisma.user.findMany({ where: { roles: { some: { name: roleName } }, name: { contains: query, mode: 'insensitive' } }, select: { id: true }, take: 10 });
    if (usersWithRole.length === 0) return [];
    const prismaUserIds = usersWithRole.map((u: any) => u.id);
    const sanityTypeMap = { REVIEWER: 'reviewer', AUTHOR: 'author', REPORTER: 'reporter', DESIGNER: 'designer' };
    const sanityType = sanityTypeMap[roleName];
    const sanityQuery = `*[_type == $sanityType && prismaUserId in $prismaUserIds]{_id, name}`;
    return await sanityWriteClient.fetch(sanityQuery, { sanityType, prismaUserIds }) as {_id: string, name: string}[];
}

export async function publishDocumentAction(docId: string, publishTime?: string | null): Promise<{ success: boolean; updatedDocument?: any; message?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    
    const doc = await sanityWriteClient.fetch(groq`*[_id == $docId || _id == 'drafts.' + $docId] | order(_updatedAt desc)[0]{_id, _type, "slug": slug.current}`, { docId });
    if (!doc) return { success: false, message: 'الوثيقةُ مفقودة.' };
    
    const docType = doc._type;
    
    const canPublish = isAdminOrDirector || (docType === 'review' && userRoles.includes('REVIEWER')) || (docType === 'article' && userRoles.includes('AUTHOR')) || (docType === 'news' && userRoles.includes('REPORTER')) || (docType === 'gameRelease' && isAdminOrDirector);
    if (!canPublish) return { success: false, message: 'صلاحياتٌ قاصرة.' };

    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;

        if (publishTime === null) {
            const tx = sanityWriteClient.transaction();
            tx.delete(publicId);
            tx.patch(draftId, (p) => p.unset(['publishedAt']));
            await tx.commit({ returnDocuments: false });

            revalidateContentPaths(docType, doc.slug);

            const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId });
            if (!finalDoc) throw new Error("Document not found after unpublish.");
            const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
            return { success: true, updatedDocument: docWithTiptap, message: 'أُلغيَ نشرُ الوثيقة.' };
        }

        const draft = await sanityWriteClient.getDocument(draftId);
        
        let finalTime = publishTime || new Date().toISOString();
        if (docType !== 'gameRelease') {
            const publishedDocForDateCheck = await sanityWriteClient.fetch(groq`*[_id == $id][0]{publishedAt}`, { id: publicId });
            if (publishTime) {
                finalTime = publishTime;
            } else if (publishedDocForDateCheck?.publishedAt) {
                finalTime = publishedDocForDateCheck.publishedAt;
            }
        }
        
        if (draft) {
            const publishedDocPayload: IdentifiedSanityDocumentStub = { ...draft, _id: publicId };
            if (docType !== 'gameRelease') {
                publishedDocPayload.publishedAt = finalTime;
            }
            const tx = sanityWriteClient.transaction();
            tx.createOrReplace(publishedDocPayload);
            tx.delete(draftId);
            await tx.commit({ returnDocuments: false });
        } else if (docType !== 'gameRelease') {
            await sanityWriteClient.patch(publicId).set({ publishedAt: finalTime }).commit();
        }

        revalidateContentPaths(docType, doc.slug);
        if (docType === 'gameRelease') {
            revalidatePath('/celestial-almanac', 'layout');
        }

        const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId });
        const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
        const message = docType === 'gameRelease' ? 'نُشِرَ الإصدار.' : (publishTime ? 'جُدولت الوثيقة.' : 'نُشِرت الوثيقة.');
        return { success: true, updatedDocument: docWithTiptap, message: message };

    } catch (error) {
        console.error('Failed to publish/unpublish document:', error);
        return { success: false, message: 'أخفق تنفيذ حالة النشر.' };
    }
}

export async function searchGamesAction(query: string): Promise<{_id: string, title: string}[]> {
    if (query.length < 2) return [];
    try {
        const results = await sanityWriteClient.fetch(
            `*[_type == "game" && title match $searchTerm + "*"][0...10]{_id, title}`, 
            { searchTerm: query }
        ) as {_id: string, title: string}[];
        return results;
    } catch (error) { console.error("أخفق البحث عن اللعبة:", error); return []; }
}

export async function createGameAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try {
        const newGame = await sanityWriteClient.create({ _type: 'game', title, slug: { _type: 'slug', current: slugify(title.toLowerCase(), { separator: '-' }) } });
        return { _id: newGame._id, title: newGame.title };
    } catch (error) { console.error("أخفق إنشاء اللعبة:", error); return null; }
}

export async function searchTagsAction(query: string): Promise<{_id: string, title: string}[]> {
    if (query.length < 1) return [];
    try {
        const results = await sanityWriteClient.fetch(
            `*[_type == "tag" && title match $searchTerm + "*"][0...10]{_id, title}`, 
            { searchTerm: query }
        ) as {_id: string, title: string}[];
        return results;
    } catch (error) { console.error("أخفق البحث عن الوسم:", error); return []; }
}

export async function createTagAction(title: string, category: 'Game' | 'Article' | 'News'): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try {
        const newTag = await sanityWriteClient.create({ _type: 'tag', title, category, slug: { _type: 'slug', current: slugify(title.toLowerCase()) } });
        return { _id: newTag._id, title: newTag.title };
    } catch (error) { console.error("أخفق إنشاء الوسم:", error); return null; }
}

export async function getRecentTagsAction(): Promise<{_id: string, title: string}[]> {
    try {
        const results = await sanityWriteClient.fetch(groq`*[_type == "tag"] | order(_createdAt desc)[0...50]{_id, title}`);
        return results;
    } catch (error) { console.error("أخفق جلب آخر الوسوم:", error); return []; }
}

export async function validateSlugAction(slug: string, docId: string): Promise<{ isValid: boolean; message: string }> {
    if (!docId) return { isValid: false, message: 'بانتظار مُعرِّف الوثيقة...' };
    if (!slug || slug.trim() === '') return { isValid: false, message: 'لا يكُن المُعرِّفُ خاويًا.' };
    const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    if (!slugRegex.test(slug)) return { isValid: false, message: 'المُعرِّف: حروفٌ وأرقامٌ وشَرْطاتٌ لا غير.' };
    
    const query = groq`!defined(*[_type in ["review", "article", "news", "gameRelease"] && slug.current == $slug && !(_id in [$draftId, $publicId])][0])`;
    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;
        const isUnique = await sanityWriteClient.fetch(query, { slug, draftId, publicId });
        if (isUnique) return { isValid: true, message: 'المُعرِّفُ صالح.' };
        return { isValid: false, message: 'مُعرِّفٌ مُستعمل.' };
    } catch (error) { console.error('Sanity slug validation failed:', error); return { isValid: false, message: 'أخفق التحقق لخطبٍ في الخادم.' }; }
}

export async function uploadSanityAssetAction(formData: FormData): Promise<{ success: boolean; asset?: { _id: string; url: string }; error?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isCreatorOrAdmin = userRoles.some((role: string) => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));

    if (!isCreatorOrAdmin) return { success: false, error: 'غير مُصرَّح به' };
    
    const file = formData.get('file') as File | null;
    if (!file) return { success: false, error: 'لم يُقدَّم ملف.' };

    try {
        const asset = await sanityWriteClient.assets.upload('image', file, { filename: file.name, contentType: file.type });
        return { success: true, asset: { _id: asset._id, url: asset.url } };
    } catch (error: any) { console.error("Sanity asset upload failed:", error); return { success: false, error: 'أخفق رفع الملف.' }; }
}

export async function addOrUpdateColorDictionaryAction(newMapping: { word: string; color: string }) {
  try {
    await getAuthenticatedSession();
    const newEntry = { ...newMapping, _key: uuidv4() };
    const tx = sanityWriteClient.transaction();
    tx.createIfNotExists({ _id: 'colorDictionary', _type: 'colorDictionary', title: 'Color Dictionary' });
    tx.patch('colorDictionary', (p) => p.setIfMissing({ autoColors: [] }));
    tx.patch('colorDictionary', (p) => p.insert('before', 'autoColors[0]', [newEntry]) );
    await tx.commit({ returnDocuments: false });
    const updatedDictionary = await sanityWriteClient.fetch(groq`*[_id == "colorDictionary"][0]`);
    return { success: true, updatedDictionary };
  } catch (error: any) { console.error("Failed to update dictionary:", error); return { success: false, message: error.message || 'Failed to update dictionary.' }; }
}

export async function removeColorDictionaryAction(keyToRemove: string) {
  try {
    await getAuthenticatedSession();
    await sanityWriteClient.patch('colorDictionary').unset([`autoColors[_key=="${keyToRemove}"]`]).commit({ returnDocuments: false, autoGenerateArrayKeys: true });
    const updatedDictionary = await sanityWriteClient.fetch(groq`*[_id == "colorDictionary"][0]`);
    return { success: true, updatedDictionary };
  } catch (error: any) { console.error("Failed to remove from dictionary:", error); return { success: false, message: error.message || 'Failed to remove from dictionary.' }; }
}

--- END OF FILE app/studio/actions.ts ---

================================================================================

--- START OF FILE app/studio/page.tsx ---

// app/studio/page.tsx

import { groq } from 'next-sanity';
import { StudioDashboard } from './StudioDashboard';
import { sanityWriteClient } from '@/lib/sanity.server';
import { unstable_noStore as noStore } from 'next/cache';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';

export const runtime = 'nodejs';

const allEditableContentQuery = groq`
*[_type in $allowedTypes] | order(_updatedAt desc) {
    _id,
    _type,
    _updatedAt,
    title,
    "slug": slug.current,
    "status": select(
        _id in path("drafts.**") => "draft",
        _type == "gameRelease" => "published",
        defined(publishedAt) && publishedAt > now() => "scheduled",
        defined(publishedAt) && publishedAt < now() => "published",
        "draft"
    ),
    "mainImage": mainImage,
    "blurDataURL": mainImage.asset->metadata.lqip
}
`;

export default async function StudioPage() {
    noStore();
    
    const session = await getServerSession(authOptions);
    
    // THE DEFINITIVE FIX: Fetch fresh roles from DB
    let userRoles: string[] = [];
    if (session?.user?.id) {
        const user = await prisma.user.findUnique({ 
            where: { id: session.user.id },
            select: { roles: { select: { name: true } } }
        });
        userRoles = user?.roles.map((r: any) => r.name) || [];
    }
    
    const isAdminOrDirector =
        userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

    const allowedContentTypes: string[] = [];

    if (isAdminOrDirector) {
        allowedContentTypes.push('review', 'article', 'news', 'gameRelease');
    } else {
        if (userRoles.includes('REVIEWER')) allowedContentTypes.push('review');
        if (userRoles.includes('AUTHOR')) allowedContentTypes.push('article');
        if (userRoles.includes('REPORTER')) allowedContentTypes.push('news');
    }

    if (allowedContentTypes.length === 0 && !userRoles.includes('DESIGNER')) {
        redirect('/');
    }

    const content =
        allowedContentTypes.length > 0
            ? await sanityWriteClient.fetch(allEditableContentQuery, {
                  allowedTypes: allowedContentTypes,
              })
            : [];

    return (
        <div className="container page-container">
            <StudioDashboard
                initialContent={content}
                userRoles={userRoles}
            />
        </div>
    );
}

--- END OF FILE app/studio/page.tsx ---

================================================================================

--- START OF FILE app/studio/tiptap.d.ts ---

// app/studio/tiptap.d.ts
import '@tiptap/core';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    youtube: {
      /**
       * Inserts a YouTube video embed.
       */
      setYoutubeVideo: (options: { src: string }) => ReturnType;
    };
  }
}

--- END OF FILE app/studio/tiptap.d.ts ---

================================================================================

--- START OF FILE app/studio/director/EditRolesModal.tsx ---

// app/studio/director/EditRolesModal.tsx
'use client';

import { useState, useTransition, useMemo } from 'react';
import { updateUserRolesAction } from './actions';
import { useToast } from '@/lib/toastStore';
import type { User, Role } from '@/lib/generated/client';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { translateRole } from '@/lib/translations';

type UserWithRoles = User & { roles: { name: string }[] };

export function EditRolesModal({ user, allRoles, onClose, onUpdate }: { user: UserWithRoles, allRoles: Role[], onClose: () => void, onUpdate: (userId: string, newRoles: Role[]) => void }) {
    // CORRECTED: Removed the duplicate 'const [' and ensured correct type annotations for map
    const [selectedRoleIds, setSelectedRoleIds] = useState<Set<number>>(() => new Set(user.roles.map((r: any) => allRoles.find(ar => ar.name === r.name)!.id)));
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    const router = useRouter();
    
    const { data: session, update: updateSession } = useSession();
    
    const manageableRoles = useMemo(() => allRoles.filter(role => role.name !== 'USER'), [allRoles]);
    const userRoleId = useMemo(() => allRoles.find(role => role.name === 'USER')?.id, [allRoles]);

    const handleRoleToggle = (roleId: number) => {
        setSelectedRoleIds(prev => {
            const newSet = new Set(prev);
            if (newSet.has(roleId)) {
                newSet.delete(roleId);
            } else {
                newSet.add(roleId);
            }
            return newSet;
        });
    };

    const handleSave = () => {
        startTransition(async () => {
            const finalRoleIds = new Set(selectedRoleIds);
            if (userRoleId) {
                finalRoleIds.add(userRoleId);
            }

            const result = await updateUserRolesAction(user.id, Array.from(finalRoleIds));
            if (result.success && result.updatedRoles) {
                onUpdate(user.id, result.updatedRoles);
                
                // If editing self...
                const currentUserId = (session?.user as any)?.id;
                if (currentUserId && currentUserId === user.id) {
                    await updateSession();
                    router.refresh();
                }

                toast.success(`أدوار ${user.name} حُدِّثت.`);
                onClose();
            } else {
                toast.error(result.message || 'أخفق تحديث الأدوار.');
            }
        });
    };

    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0 }}>تعديل رُتَب {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem' }}>اختر المهام الموكلة لهذا العضو.</p>
            <div className="roles-checklist" style={{ 
                display: 'grid', 
                gridTemplateColumns: '1fr 1fr', 
                gap: '1rem', 
                margin: '2rem 0' 
            }}>
                {manageableRoles.map(role => (
                    <label key={role.id} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', cursor: 'pointer', fontFamily: 'var(--font-main)' }}>
                        <input
                            type="checkbox"
                            checked={selectedRoleIds.has(role.id)}
                            onChange={() => handleRoleToggle(role.id)}
                            style={{ width: '1.6rem', height: '1.6rem' }}
                        />
                        <span style={{ fontWeight: role.name === 'DIRECTOR' ? 700 : 500, color: role.name === 'DIRECTOR' ? 'gold' : 'inherit' }}>
                            {translateRole(role.name)}
                        </span>
                    </label>
                ))}
            </div>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                <button onClick={handleSave} className="primary-button" disabled={isPending}>
                    {isPending ? 'جار الحفظ...' : 'حفظ التغييرات'}
                </button>
            </div>
        </Modal>
    );
}

--- END OF FILE app/studio/director/EditRolesModal.tsx ---

================================================================================

--- START OF FILE app/studio/director/UserManagementClient.tsx ---

// app/studio/director/UserManagementClient.tsx
'use client';

import { useState, useMemo, useTransition } from 'react';
import Image from 'next/image';
import { AnimatePresence, motion } from 'framer-motion';
import { EditRolesModal } from './EditRolesModal';
import type { User, Role } from '@/lib/generated/client';
import { translateRole } from '@/lib/translations';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { toggleUserBanAction } from '@/app/actions/banActions';
import { useToast } from '@/lib/toastStore';
import { useRouter } from 'next/navigation';

// Extended type to include ban status
type UserWithRoles = User & { roles: { name: string }[] };

const BanModal = ({ user, onClose, onConfirm }: { user: UserWithRoles, onClose: () => void, onConfirm: (reason: string) => void }) => {
    const [reason, setReason] = useState('');

    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0, color: '#DC2626' }}>حظر المستخدم: {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem' }}>سيتم منع هذا المستخدم من الوصول إلى الموقع.</p>
            
            <div style={{ margin: '2rem 0' }}>
                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>سبب الحظر:</label>
                <textarea 
                    className="profile-input" 
                    rows={3} 
                    value={reason} 
                    onChange={(e) => setReason(e.target.value)} 
                    placeholder="مثال: مخالفة شروط المجتمع..."
                />
            </div>

            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button 
                    onClick={() => onConfirm(reason)} 
                    className="primary-button delete-forever"
                    disabled={!reason.trim()}
                >
                    تأكيد الحظر
                </button>
            </div>
        </Modal>
    );
};

const UnbanModal = ({ user, onClose, onConfirm }: { user: UserWithRoles, onClose: () => void, onConfirm: () => void }) => {
    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0 }}>رفع الحظر عن {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)' }}>هل أنت متأكد من استعادة صلاحيات هذا المستخدم؟</p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={onConfirm} className="primary-button">تأكيد رفع الحظر</button>
            </div>
        </Modal>
    );
};

const UserRow = ({ user, allRoles, onEdit, onBanClick }: { user: UserWithRoles, allRoles: Role[], onEdit: (user: UserWithRoles) => void, onBanClick: (user: UserWithRoles) => void }) => {
    const currentRoleNames = user.roles.map((r: any) => r.name);
    const rolesToDisplay = currentRoleNames.filter((name: string) => name !== 'USER').sort();
    const displayString = rolesToDisplay.length > 0 ? rolesToDisplay.map(translateRole).join('، ') : 'عضو (افتراضي)';
    
    const isBanned = user.isBanned;

    return (
        <motion.div
            layout
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className={`user-row ${isBanned ? 'banned' : ''}`}
        >
            <div className="user-info">
                <div style={{ position: 'relative' }}>
                    <Image src={user.image || '/default-avatar.svg'} alt={user.name || 'avatar'} width={40} height={40} className="user-avatar" style={{ filter: isBanned ? 'grayscale(100%)' : 'none' }} />
                    {isBanned && <div style={{ position: 'absolute', bottom: -2, right: -2, width: 14, height: 14, background: '#DC2626', borderRadius: '50%', border: '2px solid var(--bg-secondary)' }} />}
                </div>
                <div>
                    <p className="user-name" style={{ color: isBanned ? '#DC2626' : 'inherit', textDecoration: isBanned ? 'line-through' : 'none' }}>{user.name}</p>
                    <p className="user-email">{user.email}</p>
                </div>
            </div>
            <div className="user-roles">
                <span className="roles-badge">{displayString}</span>
            </div>
            <div className="user-actions">
                <button className="outline-button" onClick={() => onEdit(user)} disabled={isBanned} style={{ opacity: isBanned ? 0.5 : 1 }}>الرتب</button>
                <button 
                    className="outline-button" 
                    onClick={() => onBanClick(user)}
                    style={{ 
                        borderColor: isBanned ? 'var(--border-color)' : '#DC2626', 
                        color: isBanned ? 'var(--text-secondary)' : '#DC2626',
                        backgroundColor: isBanned ? 'transparent' : 'rgba(220, 38, 38, 0.05)'
                    }}
                >
                    {isBanned ? 'رفع الحظر' : 'حظر'}
                </button>
            </div>
        </motion.div>
    );
};

export function UserManagementClient({ initialUsers, allRoles }: { initialUsers: UserWithRoles[], allRoles: Role[] }) {
    const [users, setUsers] = useState<UserWithRoles[]>(initialUsers);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedUser, setSelectedUser] = useState<UserWithRoles | null>(null);
    
    // Ban Modal State
    const [userToBan, setUserToBan] = useState<UserWithRoles | null>(null);
    const [userToUnban, setUserToUnban] = useState<UserWithRoles | null>(null);
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    const router = useRouter();

    const filteredUsers = useMemo(() => {
        if (!searchTerm) return users;
        return users.filter(u =>
            u.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
            u.email?.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [users, searchTerm]);

    const handleUpdateUserRoles = (userId: string, newRoles: Role[]) => {
        setUsers(currentUsers => currentUsers.map(u => 
            u.id === userId ? { ...u, roles: newRoles.map(r => ({ name: r.name })) } : u
        ));
    };
    
    // Ban Handlers
    const handleBan = (reason: string) => {
        if (!userToBan) return;
        const userId = userToBan.id;
        
        startTransition(async () => {
            const result = await toggleUserBanAction(userId, reason, true);
            if (result.success) {
                setUsers(current => current.map(u => u.id === userId ? { ...u, isBanned: true, banReason: reason } : u));
                toast.success(result.message);
                setUserToBan(null);
                router.refresh(); // Update server components to reflect changes
            } else {
                toast.error(result.message);
            }
        });
    };

    const handleUnban = () => {
        if (!userToUnban) return;
        const userId = userToUnban.id;

        startTransition(async () => {
            const result = await toggleUserBanAction(userId, '', false);
            if (result.success) {
                setUsers(current => current.map(u => u.id === userId ? { ...u, isBanned: false, banReason: null } : u));
                toast.success(result.message);
                setUserToUnban(null);
                router.refresh();
            } else {
                toast.error(result.message);
            }
        });
    };

    const onBanButtonClick = (user: UserWithRoles) => {
        if (user.isBanned) {
            setUserToUnban(user);
        } else {
            setUserToBan(user);
        }
    };

    return (
        <>
            <style jsx>{`
                .user-management-container { max-width: 960px; margin: 0 auto; }
                .search-input { width: 100%; margin-bottom: 2rem; }
                .user-list-header, .user-row { 
                    display: grid; 
                    grid-template-columns: 2fr 1.5fr 1fr; /* Increased last col width */
                    align-items: center; 
                    gap: 1rem; 
                    padding: 1rem; 
                    border-bottom: 1px solid var(--border-color); 
                }
                .user-row.banned {
                    background-color: rgba(220, 38, 38, 0.05);
                }
                .user-list-header { font-weight: 600; color: var(--text-secondary); font-family: var(--font-main); }
                .user-info { display: flex; align-items: center; gap: 1rem; }
                .user-name { font-weight: 600; margin: 0; }
                .user-email { font-size: 1.4rem; color: var(--text-secondary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
                .roles-badge { 
                    background-color: var(--bg-secondary); 
                    padding: 0.4rem 0.8rem; 
                    border-radius: 6px; 
                    font-size: 1.3rem; 
                    border: 1px solid var(--border-color); 
                    white-space: nowrap; 
                    overflow: hidden; 
                    text-overflow: ellipsis;
                }
                .user-actions { text-align: left; display: flex; justify-content: flex-end; gap: 0.5rem; }

                @media (max-width: 768px) {
                    .user-list-header { display: none; }
                    .user-row { grid-template-columns: 1fr; gap: 1.5rem; padding: 1.5rem; }
                    .user-info { grid-column: 1; }
                    .user-roles { grid-column: 1; justify-self: start; }
                    .user-actions { grid-column: 1; width: 100%; justify-content: space-between; }
                }
            `}</style>
            <div className="user-management-container">
                <input type="search" placeholder="ابحث بالاسم أو البريد..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="profile-input search-input" />
                <div className="user-list">
                    <div className="user-list-header">
                        <span>العضو</span>
                        <span>الرتب</span>
                        <span>الإجراءات</span>
                    </div>
                    <AnimatePresence>
                        {filteredUsers.map(user => (
                            <UserRow key={user.id} user={user} allRoles={allRoles} onEdit={setSelectedUser} onBanClick={onBanButtonClick} />
                        ))}
                    </AnimatePresence>
                </div>
            </div>
            
            <AnimatePresence>
                {selectedUser && ( <EditRolesModal user={selectedUser} allRoles={allRoles} onClose={() => setSelectedUser(null)} onUpdate={handleUpdateUserRoles} /> )}
                {userToBan && ( <BanModal user={userToBan} onClose={() => setUserToBan(null)} onConfirm={handleBan} /> )}
                {userToUnban && ( <UnbanModal user={userToUnban} onClose={() => setUserToUnban(null)} onConfirm={handleUnban} /> )}
            </AnimatePresence>
        </>
    );
}

--- END OF FILE app/studio/director/UserManagementClient.tsx ---

================================================================================

--- START OF FILE app/studio/director/actions.ts ---

// app/studio/director/actions.ts

'use server';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";
import prisma from "@/lib/prisma";
import { revalidatePath, revalidateTag } from "next/cache";
import { Role } from "@/lib/generated/client";
import { sanityWriteClient } from "@/lib/sanity.server";

const ROLE_TO_SANITY_TYPE: Record<string, string> = {
    REVIEWER: 'reviewer',
    AUTHOR: 'author',
    REPORTER: 'reporter',
    DESIGNER: 'designer',
};

async function findOrCreateSanityCreator(userId: string, sanityType: string) {
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { id: true, name: true, image: true } });
    if (!user || !user.name) throw new Error('بيانات العضو غير مكتملة.');

    const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityType}" && prismaUserId == $userId][0]`, { userId });

    if (existingCreator) {
        return; 
    }

    const newCreator: any = {
        _type: sanityType,
        _id: `${sanityType}-${userId}`,
        name: user.name,
        prismaUserId: user.id,
    };
    
    if (user.image) {
        try {
            const response = await fetch(user.image);
            const imageBlob = await response.blob();
            const imageAsset = await sanityWriteClient.assets.upload('image', imageBlob, {
                contentType: imageBlob.type,
                filename: `${user.id}-avatar.jpg`
            });
            newCreator.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAsset._id } };
        } catch (e) {
            console.warn(`Could not upload user image to Sanity for ${user.name}:`, e);
        }
    }

    await sanityWriteClient.create(newCreator);
    console.log(`Created Sanity ${sanityType} for ${user.name}.`);
}

export async function updateUserRolesAction(userId: string, roleIds: number[]) {
    const session = await getServerSession(authOptions);
    
    // Use safe access or DB verification here if strict security is needed, 
    // but for the action message itself:
    if (!session?.user?.roles.includes('DIRECTOR')) {
        return { success: false, message: "غير مُصرَّح لك بهذا الإجراء." };
    }

    try {
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { roles: { set: roleIds.map(id => ({ id })) } },
            include: { roles: true }
        });

        const userRoles = updatedUser.roles.map((r: any) => r.name);
        
        for (const roleName of userRoles) {
            const sanityType = ROLE_TO_SANITY_TYPE[roleName];
            if (sanityType) {
                try {
                    await findOrCreateSanityCreator(userId, sanityType);
                } catch (sanityError: any) {
                    console.error(`Failed to sync Sanity ${sanityType} for user ${userId}:`, sanityError.message);
                }
            }
        }
        
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');

        revalidatePath('/studio/director');
        revalidatePath(`/profile/${userId}`);
        if(updatedUser.username) {
            revalidatePath(`/creators/${updatedUser.username}`);
        }

        return { success: true, updatedRoles: updatedUser.roles as Role[] };
    } catch (error) {
        console.error("Failed to update user roles:", error);
        return { success: false, message: "حدث خطأ أثناء التحديث في قاعدة البيانات." };
    }
}

--- END OF FILE app/studio/director/actions.ts ---

================================================================================

--- START OF FILE app/studio/director/page.tsx ---

// app/studio/director/page.tsx

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import { UserManagementClient } from './UserManagementClient';
import { unstable_noStore as noStore } from 'next/cache';

export default async function DirectorPage() {
    noStore(); 

    const session = await getServerSession(authOptions);
    
    let userRoles: string[] = [];
    if (session?.user?.id) {
        const user = await prisma.user.findUnique({ 
            where: { id: session.user.id },
            select: { roles: { select: { name: true } } }
        });
        userRoles = user?.roles.map((r: any) => r.name) || [];
    }

    if (!userRoles.includes('DIRECTOR')) {
        redirect('/studio');
    }

    const users = await prisma.user.findMany({
        include: {
            roles: {
                select: { name: true }
            }
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    const allRoles = await prisma.role.findMany();

    return (
        <div className="container page-container">
            <header style={{ textAlign: 'center', marginBottom: '3rem' }}>
                <h1 className="page-title">إدارة الديوان</h1>
                <p className="sidebar-subtitle" style={{ fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto' }}>
                    تحكَّم في رُتَب الأعضاء وصلاحياتهم. التغييراتُ نافذةٌ فورًا.
                </p>
            </header>
            <UserManagementClient initialUsers={users} allRoles={allRoles} />
        </div>
    );
}

--- END OF FILE app/studio/director/page.tsx ---

================================================================================

--- START OF FILE app/studio/utils/portableTextToTiptap.ts ---

// app/studio/utils/portableTextToTiptap.ts

import {PortableTextBlock} from '@portabletext/types'
import type {SanityImageObject as SanityImage} from '@sanity/image-url/lib/types/types'

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
  type: string
  attrs?: Record<string, any>
  content?: TiptapNode[]
  text?: string
  marks?: {type: string; attrs?: Record<string, any>}[]
}

/**
 * Converts a Sanity Portable Text array to Tiptap's JSON format.
 * @param blocks The array of Portable Text blocks from Sanity.
 * @returns A Tiptap-compatible JSON object representing the document content.
 */
export function portableTextToTiptap(blocks: PortableTextBlock[] = []): Record<string, any> {
  const content: TiptapNode[] = []
  let currentList: TiptapNode | null = null

  const validBlocks = (blocks || []).filter(Boolean)

  validBlocks.forEach((block: any) => {
    // Use 'any' here to accommodate custom table type
    // --- HANDLE LIST ITEMS ---
    if (block._type === 'block' && block.listItem === 'bullet') {
      if (!currentList) {
        currentList = {type: 'bulletList', content: []}
      }
      const listItemContent = processBlockChildren(block)
      currentList.content?.push({
        type: 'listItem',
        content: [{type: 'paragraph', content: listItemContent}],
      })
      return
    }

    if (currentList) {
      content.push(currentList)
      currentList = null
    }

    // --- HANDLE CUSTOM BLOCKS ---
    if (block._type === 'youtube') {
      content.push({
        type: 'youtube',
        attrs: {
          src: block.url,
        },
      })
      return
    }
    if (block._type === 'gameDetails') {
      content.push({
        type: 'gameDetails',
        attrs: {
          details: block.details || [],
        },
      })
      return
    }
    if (block._type === 'table') {
      // THE DEFINITIVE FIX
      const tableContent: TiptapNode[] = []
      ;(block.rows || []).forEach((row: any) => {
        const rowContent: TiptapNode[] = []
        ;(row.cells || []).forEach((cell: any) => {
          const cellType = cell.isHeader ? 'tableHeader' : 'tableCell'
          // The cell content from Sanity is already a Portable Text array.
          // We need to recursively call this function to convert it.
          const cellContent = portableTextToTiptap(cell.content || []).content
          rowContent.push({type: cellType, content: cellContent})
        })
        tableContent.push({type: 'tableRow', content: rowContent})
      })
      // The structure is `table` > `tableRow`s. No `tableContent` wrapper is needed.
      content.push({type: 'table', content: tableContent})
      return
    }
    if (block._type === 'imageCompare') {
      const {image1, image2, size} = block as any
      content.push({
        type: 'imageCompare',
        attrs: {
          src1: image1?.asset?.url,
          assetId1: image1?.asset?._id,
          src2: image2?.asset?.url,
          assetId2: image2?.asset?._id,
          'data-size': size || 'large',
        },
      })
      return
    }
    if (block._type === 'twoImageGrid') {
      const {image1, image2} = block as any
      content.push({
        type: 'twoImageGrid',
        attrs: {
          src1: image1?.asset?.url,
          assetId1: image1?.asset?._id,
          src2: image2?.asset?.url,
          assetId2: image2?.asset?._id,
        },
      })
      return
    }
    if (block._type === 'fourImageGrid') {
      const {image1, image2, image3, image4} = block as any
      content.push({
        type: 'fourImageGrid',
        attrs: {
          src1: image1?.asset?.url,
          assetId1: image1?.asset?._id,
          src2: image2?.asset?.url,
          assetId2: image2?.asset?._id,
          src3: image3?.asset?.url,
          assetId3: image3?.asset?._id,
          src4: image4?.asset?.url,
          assetId4: image4?.asset?._id,
        },
      })
      return
    }
    if (block._type === 'image') {
      const imageBlock = block as unknown as SanityImage & {asset: {_id: string; url: string}}
      if (imageBlock.asset?._id && imageBlock.asset?.url) {
        content.push({
          type: 'image',
          attrs: {
            src: imageBlock.asset.url,
            assetId: imageBlock.asset._id,
          },
        })
      }
      return
    }

    // --- HANDLE TEXT BLOCKS ---
    if (block._type === 'block' && block.style) {
      const children = processBlockChildren(block)

      const isEffectivelyEmpty = children.length === 1 && children[0].text === ''
      const nodeContent = isEffectivelyEmpty ? {} : {content: children}

      switch (block.style) {
        case 'h1':
          content.push({type: 'heading', attrs: {level: 1}, ...nodeContent})
          break
        case 'h2':
          content.push({type: 'heading', attrs: {level: 2}, ...nodeContent})
          break
        case 'h3':
          content.push({type: 'heading', attrs: {level: 3}, ...nodeContent})
          break
        case 'blockquote':
          content.push({type: 'blockquote', content: [{type: 'paragraph', ...nodeContent}]})
          break
        default:
          content.push({type: 'paragraph', ...nodeContent})
      }
    }
  })

  if (currentList) {
    content.push(currentList)
  }

  return {type: 'doc', content}
}

function processBlockChildren(block: PortableTextBlock): TiptapNode[] {
  const children = Array.isArray(block.children) ? block.children : []

  const processedChildren = children
    .filter((span) => span && span._type === 'span')
    .map((span) => {
      const marks = (Array.isArray(span.marks) ? span.marks : []).map((mark) => {
          const markDefs = Array.isArray(block.markDefs) ? block.markDefs : []
          const markDef = markDefs.find((def) => def._key === mark)
          if (markDef?._type === 'link') {
            return {type: 'link', attrs: {href: (markDef as any).href}}
          }
          if (markDef?._type === 'color') {
            return {type: 'textStyle', attrs: {color: (markDef as any).hex}}
          }
          if (mark === 'strong') return {type: 'bold'}
          if (mark === 'em') return {type: 'italic'}
          return null
        })
        .filter(Boolean) as {type: string; attrs?: any}[]

      return {
        type: 'text',
        text: span.text ?? '',
        marks,
      }
    })

  return processedChildren
}

--- END OF FILE app/studio/utils/portableTextToTiptap.ts ---

================================================================================

--- START OF FILE app/studio/utils/tiptapToPortableText.ts ---

// app/studio/utils/tiptapToPortableText.ts

import {v4 as uuidv4} from 'uuid'

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
  type: string
  attrs?: Record<string, any>
  content?: TiptapNode[]
  text?: string
  marks?: {type: string; attrs?: Record<string, any>}[]
}

/**
 * Converts a Tiptap JSON object to a Sanity Portable Text array.
 * @param tiptapJSON The Tiptap JSON object.
 * @returns An array of Portable Text blocks.
 */
export function tiptapToPortableText(tiptapJSON: TiptapNode): any[] {
  if (!tiptapJSON || tiptapJSON.type !== 'doc' || !tiptapJSON.content) {
    return []
  }

  const portableTextBlocks: any[] = []

  tiptapJSON.content.forEach((node) => {
    // --- YOUTUBE ---
    if (node.type === 'youtube') {
      const {src} = node.attrs || {}
      if (src) {
        portableTextBlocks.push({
          _type: 'youtube',
          _key: uuidv4(),
          url: src,
        })
      }
      return
    }

    // --- IMAGE COMPARE ---
    if (node.type === 'imageCompare') {
      const {assetId1, assetId2, 'data-size': size} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'imageCompare',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
        size: size || 'large',
      })
      return
    }

    // --- TWO IMAGE GRID ---
    if (node.type === 'twoImageGrid') {
      const {assetId1, assetId2} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'twoImageGrid',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
      })
      return
    }

    // --- FOUR IMAGE GRID ---
    if (node.type === 'fourImageGrid') {
      const {assetId1, assetId2, assetId3, assetId4} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'fourImageGrid',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
        image3: assetId3 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId3}} : undefined,
        image4: assetId4 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId4}} : undefined,
      })
      return
    }

    // --- GAME DETAILS ---
    if (node.type === 'gameDetails') {
      portableTextBlocks.push({
        _type: 'gameDetails',
        _key: uuidv4(),
        details: node.attrs?.details || [],
      })
      return
    }

    // --- TABLE (THE DEFINITIVE FIX) ---
    if (node.type === 'table') {
      const tableRows: any[] = []
      // Tiptap's table content is an array of 'tableRow' nodes.
      // The previous implementation had an extra incorrect level of nesting.
      ;(node.content || []).forEach((rowNode: TiptapNode) => {
        const tableCells: any[] = []
        ;(rowNode.content || []).forEach((cellNode: TiptapNode) => {
          tableCells.push({
            _key: uuidv4(),
            _type: 'cell',
            isHeader: cellNode.type === 'tableHeader',
            // Recursively convert the cell's content.
            content: tiptapToPortableText({type: 'doc', content: cellNode.content || []}),
          })
        })
        tableRows.push({_key: uuidv4(), _type: 'row', cells: tableCells})
      })
      portableTextBlocks.push({_type: 'table', _key: uuidv4(), rows: tableRows})
      return
    }

    // --- IMAGE (DEFINITIVE FIX) ---
    if (node.type === 'image') {
      const assetId = node.attrs?.assetId
      if (assetId) {
        portableTextBlocks.push({
          _type: 'image',
          _key: uuidv4(),
          asset: {_type: 'reference', _ref: assetId},
        })
      } else if (node.attrs?.src) {
        const matches = node.attrs.src.match(/image-([a-fA-F0-9]+-[0-9]+x[0-9]+-[a-z]+)/)
        if (matches && matches[1]) {
          const parsedId = `image-${matches[1]}`
          portableTextBlocks.push({
            _type: 'image',
            _key: uuidv4(),
            asset: {_type: 'reference', _ref: parsedId},
          })
        }
      }
      return
    }

    // --- BULLET LISTS ---
    if (node.type === 'bulletList') {
      node.content?.forEach((listItem) => {
        const paragraph = listItem.content?.[0]
        if (paragraph && paragraph.type === 'paragraph') {
          const block = processTextBlock(paragraph)
          if (block) {
            block.level = 1
            block.listItem = 'bullet'
            portableTextBlocks.push(block)
          }
        }
      })
      return
    }

    // --- STANDARD TEXT BLOCKS ---
    const block = processTextBlock(node)
    if (block) {
      portableTextBlocks.push(block)
    }
  })

  return portableTextBlocks
}

// Helper function to process paragraphs, headings, blockquotes
function processTextBlock(node: TiptapNode): any | null {
  const block: any = {
    _type: 'block',
    _key: uuidv4(),
    children: [],
    markDefs: [],
  }

  switch (node.type) {
    case 'heading':
      block.style = `h${node.attrs?.level || 2}`
      break
    case 'blockquote':
      if (node.content && node.content.length > 0) {
        const blockquoteParagraph = processTextBlock({type: 'paragraph', content: node.content})
        if (blockquoteParagraph) {
          blockquoteParagraph.style = 'blockquote'
          return blockquoteParagraph
        }
      }
      return null
    default:
      block.style = 'normal'
  }

  ;(node.content || []).forEach((span) => {
    if (span.type !== 'text' || typeof span.text === 'undefined') return

    const spanMarks: string[] = []
    span.marks?.forEach((mark) => {
      if (mark.type === 'bold') spanMarks.push('strong')
      if (mark.type === 'italic') spanMarks.push('em')
      if (mark.type === 'link') {
        const markDef = {_key: uuidv4(), _type: 'link', href: mark.attrs?.href}
        block.markDefs.push(markDef)
        spanMarks.push(markDef._key)
      }
      if (mark.type === 'textStyle' && mark.attrs?.color) {
        const markDef = {_key: uuidv4(), _type: 'color', hex: mark.attrs.color}
        block.markDefs.push(markDef)
        spanMarks.push(markDef._key)
      }
    })

    block.children.push({
      _type: 'span',
      _key: uuidv4(),
      text: span.text,
      marks: spanMarks,
    })
  })

  if (block.children.length === 0) {
    block.children.push({_type: 'span', _key: uuidv4(), text: '', marks: []})
  }

  return block
}

--- END OF FILE app/studio/utils/tiptapToPortableText.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

/* app/studio/[contentType]/[id]/BlockToolbar.module.css */

.blockToolbarContainer {
    position: fixed; /* THE FIX: Lock to viewport */
    bottom: 1rem;
    left: 10rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}

.optionButtonWrapper {
    position: relative;
}

.optionButton {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 46px;
    height: 46px;
}

.optionTooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 0.75rem;
    padding: 0.4rem 0.8rem;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    transform-origin: bottom center;
}

.optionButtonWrapper:hover .optionTooltip {
    opacity: 1;
    transform: translateY(-5px) translateX(-50%);
}

@media (max-width: 1024px) {
    .blockToolbarContainer {
        left: 50%;
        transform: translateX(-50%);
        bottom: 2rem;
    }
}

--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

// app/studio/[contentType]/[id]/BlockToolbar.tsx
'use client'

import {Editor} from '@tiptap/react'
import {motion} from 'framer-motion'
import {
  CompareIcon,
  TwoImageIcon,
  FourImageIcon,
  SingleImageIcon,
  GameDetailsIcon,
  YoutubeIcon,
} from '../../StudioIcons'
import {QualityToggle} from './editor-components/QualityToggle'
import {UploadQuality} from '@/lib/image-optimizer'
import styles from './BlockToolbar.module.css'
import bubbleStyles from './Editor.module.css'

interface BlockToolbarProps {
  editor: Editor | null
  onFileUpload: (file: File) => void
  uploadQuality: UploadQuality
  onUploadQualityChange: (quality: UploadQuality) => void
}

const TooltipButton = ({
  onClick,
  title,
  children,
  disabled,
}: {
  onClick: () => void
  title: string
  children: React.ReactNode
  disabled?: boolean
}) => (
  <div className={styles.optionButtonWrapper}>
    <motion.button
      onClick={onClick}
      className={`${bubbleStyles.bubbleMenuButton} ${styles.optionButton}`}
      whileHover={{scale: 1.1}}
      whileTap={{scale: 0.9}}
      title={title}
      disabled={disabled}
    >
      {children}
    </motion.button>
    <div className={styles.optionTooltip}>{title}</div>
  </div>
)

export function BlockToolbar({
  editor,
  onFileUpload,
  uploadQuality,
  onUploadQualityChange,
}: BlockToolbarProps) {
  const addBlock = (
    type: 'image' | 'imageCompare' | 'twoImageGrid' | 'fourImageGrid' | 'gameDetails' | 'youtube',
  ) => {
    if (!editor) return
    if (type === 'image') {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = 'image/*'
      input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0]
        if (file) {
          onFileUpload(file)
        }
      }
      input.click()
    } else {
      editor.chain().focus().insertContent({type}).run()
    }
  }

  return (
    <motion.div
      className={styles.blockToolbarContainer}
      initial={{opacity: 0, y: 20}}
      animate={{opacity: 1, y: 0}}
      exit={{opacity: 0, y: 20}}
      transition={{type: 'spring' as const, stiffness: 300, damping: 25}}
    >
      <TooltipButton onClick={() => addBlock('gameDetails')} title="تفاصيل اللعبة" disabled={!editor}>
        <GameDetailsIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('youtube')} title="فيديو يوتيوب" disabled={!editor}>
        <YoutubeIcon />
      </TooltipButton>
      <div className={bubbleStyles.toolbarDivider} />
      <TooltipButton onClick={() => addBlock('image')} title="صورة مفردة" disabled={!editor}>
        <SingleImageIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('imageCompare')} title="مضاهاة صورتين" disabled={!editor}>
        <CompareIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('twoImageGrid')} title="شبكة صورتين" disabled={!editor}>
        <TwoImageIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('fourImageGrid')} title="شبكة 4 صور" disabled={!editor}>
        <FourImageIcon />
      </TooltipButton>
      <div className={bubbleStyles.toolbarDivider} />
      <QualityToggle currentQuality={uploadQuality} onQualityChange={onUploadQualityChange} />
    </motion.div>
  )
}

--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ColorPicker.module.css ---

/* app/studio/[contentType]/[id]/ColorPicker.module.css */

.colorPickerPopover {
    position: absolute;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    box-shadow: 0 5px 25px rgba(0,0,0,0.15);
    width: 300px; /* Adjusted width for the new layout */
}

.categoryGrid {
    display: grid;
    grid-template-columns: repeat(8, 1fr); /* 8 categories */
    gap: 0.75rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.categoryButton {
    position: relative;
    width: 28px;
    height: 28px;
    border-radius: 8px; /* Square tabs */
    border: none;
    cursor: pointer;
    transition: transform 0.2s ease-out;
}

.categoryButton:hover {
    transform: scale(1.1);
}

.activeCategoryHighlight {
    position: absolute;
    inset: -3px; /* Creates an outer border effect */
    border: 2px solid var(--accent);
    border-radius: 10px; /* Slightly more rounded than the button */
    pointer-events: none;
}

.swatchGrid {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 0.5rem;
}

.swatchButton {
    position: relative;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid var(--border-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.activeIndicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    box-shadow: 0 0 2px rgba(0,0,0,0.5);
}

.customColorSection {
    border-top: 1px solid var(--border-color);
    padding-top: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sectionTitle {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.customColorButton {
    position: relative;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid var(--border-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.customColorInput {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 50%;
    left: 50%;
}

--- END OF FILE app/studio/[contentType]/[id]/ColorPicker.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ColorPicker.tsx ---

// app/studio/[contentType]/[id]/ColorPicker.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRef, useState } from 'react';
import styles from './ColorPicker.module.css';

// MODIFIED: Added a 'representative' color for each category to be used as the visual tab.
const COLOR_PALETTE = [
    { title: 'Grays', representative: '#9CA3AF', colors: ['#FFFFFF', '#F9FAFB', '#F3F4F6', '#E5E7EB', '#D1D5DB', '#9CA3AF', '#6B7280', '#4B5563', '#374151', '#1F2937'] },
    { title: 'Reds', representative: '#F87171', colors: ['#FEF2F2', '#FEE2E2', '#FECACA', '#F87171', '#EF4444', '#DC2626', '#B91C1C', '#991B1B', '#7F1D1D', '#450A0A'] },
    { title: 'Oranges', representative: '#FB923C', colors: ['#FFF7ED', '#FFEDD5', '#FED7AA', '#FB923C', '#F97316', '#EA580C', '#C2410C', '#9A3412', '#7C2D12', '#431407'] },
    { title: 'Yellows', representative: '#FACC15', colors: ['#FEFCE8', '#FEF9C3', '#FEF08A', '#FACC15', '#EAB308', '#CA8A04', '#A16207', '#854D0E', '#713F12', '#422006'] },
    { title: 'Greens', representative: '#4ADE80', colors: ['#F0FDF4', '#DCFCE7', '#BBF7D0', '#4ADE80', '#22C55E', '#16A34A', '#15803D', '#166534', '#14532D', '#052e16'] },
    { title: 'Cyans', representative: '#22D3EE', colors: ['#ECFEFF', '#CFFAFE', '#A5F3FC', '#22D3EE', '#06B6D4', '#0891B2', '#0E7490', '#155E75', '#164E63', '#083344'] },
    { title: 'Blues', representative: '#60A5FA', colors: ['#EFF6FF', '#DBEAFE', '#BFDBFE', '#60A5FA', '#3B82F6', '#2563EB', '#1D4ED8', '#1E40AF', '#1E3A8A', '#172554'] },
    { title: 'Purples', representative: '#A78BFA', colors: ['#F5F3FF', '#EDE9FE', '#DDD6FE', '#A78BFA', '#8B5CF6', '#7C3AED', '#6D28D9', '#5B21B6', '#4C1D95', '#2E1065'] },
];

const PlusIcon = () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
);

const Swatch = ({ color, isActive, onClick, className = '' }: { color: string, isActive: boolean, onClick: () => void, className?: string }) => (
    <motion.button
        type="button"
        onClick={onClick}
        className={`${styles.swatchButton} ${className}`}
        style={{ backgroundColor: color }}
        animate={{ scale: isActive ? 1.2 : 1, zIndex: isActive ? 1 : 0 }}
        whileHover={{ scale: 1.3, zIndex: 2 }}
        transition={{ type: 'spring', stiffness: 500, damping: 20 }}
    >
        {isActive && <motion.div className={styles.activeIndicator} layoutId="color-picker-active-swatch" />}
    </motion.button>
);

export function ColorPicker({ editor, popoverStyle }: { editor: Editor, popoverStyle: React.CSSProperties }) {
    const colorInputRef = useRef<HTMLInputElement>(null);
    const [activeTab, setActiveTab] = useState(COLOR_PALETTE[0].title);

    const currentColor = editor.getAttributes('textStyle').color || '#FFFFFF'; // Default to white
    const activePalette = COLOR_PALETTE.find(p => p.title === activeTab);
    const isCustomColor = !COLOR_PALETTE.flatMap(s => s.colors).some(c => c.toLowerCase() === currentColor.toLowerCase());

    const handleSetColor = (color: string) => {
        if (color === '#FFFFFF') {
            editor.chain().focus().unsetColor().run();
        } else {
            editor.chain().focus().setColor(color).run();
        }
    };

    const handleCustomColorChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        editor.chain().focus().setColor(event.target.value).run();
    };

    return (
        <motion.div
            className={styles.colorPickerPopover}
            style={{ ...popoverStyle, left: '50%', transform: 'translateX(-50%)' }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
        >
            <div className={styles.categoryGrid}>
                {COLOR_PALETTE.map(section => (
                    <button
                        key={section.title}
                        onClick={() => setActiveTab(section.title)}
                        className={styles.categoryButton}
                        style={{ backgroundColor: section.representative }}
                        aria-label={`Select ${section.title} colors`}
                    >
                        {activeTab === section.title && (
                            <motion.div className={styles.activeCategoryHighlight} layoutId="color-picker-active-category" />
                        )}
                    </button>
                ))}
            </div>

            <AnimatePresence mode="wait">
                <motion.div
                    key={activeTab}
                    className={styles.swatchGrid}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.15 }}
                >
                    {activePalette?.colors.map(color => (
                        <Swatch
                            key={color}
                            color={color}
                            isActive={!isCustomColor && currentColor.toLowerCase() === color.toLowerCase()}
                            onClick={() => handleSetColor(color)}
                        />
                    ))}
                </motion.div>
            </AnimatePresence>

            <div className={styles.customColorSection}>
                <p className={styles.sectionTitle}>Custom Color</p>
                <div style={{ position: 'relative' }}>
                    <motion.button
                        type="button"
                        onClick={() => colorInputRef.current?.click()}
                        className={styles.customColorButton}
                        style={{ background: isCustomColor ? currentColor : 'var(--bg-primary)', color: isCustomColor ? '#fff' : 'var(--text-secondary)' }}
                        whileHover={{ scale: 1.1 }}
                        transition={{ type: 'spring', stiffness: 500, damping: 20 }}
                    >
                        <PlusIcon />
                    </motion.button>
                    <input
                        ref={colorInputRef}
                        type="color"
                        onInput={handleCustomColorChange}
                        value={currentColor}
                        className={styles.customColorInput}
                    />
                </div>
            </div>
        </motion.div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/ColorPicker.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

/* app/studio/[contentType]/[id]/Editor.module.css (COMPLETE AND CORRECTED) */

.editorHeader { position: relative; z-index: 10; height: 60px; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; width: 100%; flex-shrink: 0; }
.headerLeft, .headerRight { display: flex; align-items: center; gap: 1.5rem; }
.headerTitle { font-family: var(--font-main); color: var(--text-primary); margin: 0; font-size: 1.6rem; font-weight: 600; white-space: nowrap; }
.documentStatus { font-family: var(--font-main); font-size: 1.4rem; padding: 0.4rem 1rem; border-radius: 999px; font-weight: 500; }
.statusDraft { background-color: color-mix(in srgb, var(--text-secondary) 15%, transparent); color: var(--text-secondary); }
.statusPublished { background-color: color-mix(in srgb, #16A34A 15%, transparent); color: #16A34A; }
.statusScheduled { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); }
.headerIconGroup { display: flex; align-items: center; gap: 0.5rem; }
.iconButton { display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; color: var(--text-secondary); background-color: transparent; border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-out; }
.iconButton:hover:not(:disabled) { color: var(--accent); background-color: var(--bg-primary); border-color: var(--border-color); }
.iconButtonDisabled { pointer-events: none; color: var(--border-color); }
.mobileHeaderIcons { display: none; } /* Hidden by default */
.sanctumContainer { position: fixed; top: var(--nav-height-scrolled); right: 0; bottom: 0; left: 0; z-index: 1060; background-color: var(--bg-primary); overflow: hidden; display: flex; flex-direction: column; --sidebar-width: 380px; }
.sanctumMain { display: flex; flex-grow: 1; height: 100%; }
.sanctumSidebar { background-color: var(--bg-secondary); border-left: 1px solid var(--border-color); flex-shrink: 0; height: 100%; overflow-y: auto; display: flex; flex-direction: column; width: var(--sidebar-width); }
.sanctumSidebar fieldset { border: none; padding: 0; margin: 0; display: contents; }
.sanctumSidebar fieldset:disabled { opacity: 0.6; pointer-events: none; }
.sidebarContent { padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
.sidebarTitle { font-family: var(--font-main); font-size: 2rem; margin: 0; color: var(--text-primary); }
.sidebarSubtitle { font-family: var(--font-main); color: var(--text-secondary); margin-top: 0.25rem; font-size: 1.4rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.sidebarSection { padding: 1.5rem; }
.sidebarLabel { display: block; font-family: var(--font-main); font-size: 1.3rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; }
.sidebarInput { width: 100%; background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.8rem 1rem; font-family: var(--font-main); font-size: 1.5rem; color: var(--text-primary); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
.sidebarInput:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent); }
.sidebarFooter { margin-top: auto; padding: 1.5rem; border-top: 1px solid var(--border-color); background-color: var(--bg-secondary); display: flex; justify-content: center; align-items: center; }
.sanctumCanvas { flex-grow: 1; height: 100%; overflow-y: auto; background-color: var(--bg-primary); min-width: 0; }
.canvasContent { max-width: 960px; margin: 0 auto; padding: 4rem 2rem 8rem 2rem; }
.canvasTitleInput { font-family: var(--font-main); font-size: 2.8rem; font-weight: 800; line-height: 1.3; color: var(--text-primary); border: none; background: none; outline: none; width: 100%; padding: 0; margin-bottom: 3rem; text-align: right; resize: none; overflow: hidden; }
.canvasTitleInput::placeholder { color: var(--border-color); }
.canvasTitleInput:focus { box-shadow: 0 2px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent); border-radius: 4px; }
.canvasEditorWrapper { position: relative; padding: 3rem; border: 1px solid var(--border-color); border-radius: 12px; background-color: var(--bg-secondary); box-shadow: 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); transition: border-color 0.3s ease, box-shadow 0.3s ease; }
.canvasEditorWrapper:focus-within { border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent), 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); }
.tiptap { outline: none; text-align: right; }
.tiptap > * + * { margin-top: 1.25em; }
.tiptap h2 { font-family: var(--font-main), sans-serif; font-size: 2.8rem; line-height: 1.2; margin: 4rem 0 2rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
.tiptap p.is-editor-empty:first-child::before { content: attr(data-placeholder); float: right; color: var(--text-secondary); opacity: 0.7; pointer-events: none; height: 0; }

/* --- TABLE STYLES --- */
/* This is the outer wrapper for the custom node view */
.tiptap .imageGridContainer table {
    min-width: 100%; /* Ensure the table inside our custom component takes full width */
    border-collapse: collapse;
}

/* This targets the default tiptap table rendering, which is now HIDDEN */
.tiptap > table {
    display: none;
}

/* New styling for content inside our custom table component cells */
.tiptap .imageGridContainer th,
.tiptap .imageGridContainer td {
    position: relative;
}

.tiptap .imageGridContainer th:not(:last-child)::after,
.tiptap .imageGridContainer td:not(:last-child)::after {
    content: '';
    position: absolute;
    top: 25%;
    bottom: 25%;
    left: 0;
    width: 2px;
    background-color: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
}

.tiptap .imageGridContainer tr:not(:last-child) {
    border-bottom: 1px solid var(--border-color);
}


.tiptap .imageGridContainer th p,
.tiptap .imageGridContainer td p {
    margin: 0;
    padding: 1.5rem 2rem;
    font-size: 1.6rem;
    outline: none;
}
.tiptap .imageGridContainer th p {
    color: var(--accent);
    font-weight: 700;
}
.tiptap .imageGridContainer td p {
    color: var(--text-primary);
}


.formattingToolbar { 
    display: flex; 
    align-items: center;
    background-color: var(--bg-secondary); 
    border: 1px solid var(--border-color); 
    border-radius: 8px; 
    box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--text-primary) 15%, transparent); 
    padding: 0.4rem; 
    z-index: 10; 
}
.formattingToolbar.docked {
    position: fixed !important;
    top: calc(var(--nav-height-scrolled) + 1rem) !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: max-content;
    max-width: calc(100vw - 2rem);
    animation: slideInDown 0.3s ease-out;
}
@keyframes slideInDown {
    from { transform: translate(-50%, -20px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}


.toolbarDivider { width: 1px; height: 20px; background-color: var(--border-color); margin: 0 0.4rem; }
.dragHandle { cursor: grab; color: var(--text-secondary); padding: 0.4rem; display: flex; align-items: center; border-right: 1px solid var(--border-color); margin-right: -0.4rem; }
.dragHandle:active { cursor: grabbing; }

.bubbleMenuButton { display: flex; align-items: center; justify-content: center; height: 36px; padding: 0 0.8rem; border-radius: 6px; background-color: transparent; border: none; cursor: pointer; color: var(--text-secondary); transition: background-color 0.15s ease-out, color 0.15s ease-out; font-family: var(--font-main); font-weight: 500; font-size: 1.4rem; }
.bubbleMenuButton:hover { background-color: var(--bg-primary); color: var(--accent); }
.bubbleMenuButton.active { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); font-weight: 600; }
.tiptap .image-node-container, .tiptap .image-compare-container, .tiptap .image-grid-container { position: relative; }
.image-node-menu { position: absolute; top: 0.75rem; right: 0.75rem; z-index: 5; display: flex; gap: 0.5rem; background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent); backdrop-filter: blur(4px); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.4rem; }
.deleteButton:hover { background-color: color-mix(in srgb, #DC2626 15%, transparent); color: #DC2626; }
.tiptap .image-node-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-node-container { box-shadow: 0 0 0 3px var(--accent); }
.tiptap img { max-width: 100%; height: auto; border-radius: 8px; display: block; }
.tiptap .image-compare-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-compare-container { box-shadow: 0 0 0 3px var(--accent); }
.image-compare-container[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="large"] { max-width: 100%; }
.image-grid-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; padding: 1rem; border: 1px solid var(--border-color); background: var(--bg-primary); }
.tiptap .ProseMirror-selectednode .image-grid-container { box-shadow: 0 0 0 3px var(--accent); }

@media (max-width: 1024px) {
    .sanctumMain { position: relative; overflow: hidden; height: calc(100% - 60px); }
    .sanctumSidebar { 
        position: absolute; 
        top: 0; 
        right: 0; 
        width: 100%; 
        max-width: none; 
        z-index: 10; 
        border-left: none; 
        height: 100%;
        /* THE DEFINITIVE FIX: Add padding to prevent overlap with the bottom toggle bar */
        padding-bottom: 80px;
    }
    .canvasContent { padding: 3rem 1.5rem 10rem 1.5rem; }
    .canvasTitleInput { font-size: 2.4rem; }
    .canvasEditorWrapper { padding: 1.5rem; }
    .headerRight { display: none; }
    .headerLeft { flex-grow: 1; justify-content: space-between; }
    .mobileHeaderIcons { display: flex; align-items: center; gap: 1rem; }
}

--- END OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

// app/studio/[contentType]/[id]/EditorCanvas.tsx
'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Editor } from '@tiptap/react';
import React, { useRef, useLayoutEffect } from 'react';
import styles from './Editor.module.css';

type ColorMapping = { // ADDED TYPE
  _key?: string;
  word: string;
  color: string;
}

const RichTextEditor = dynamic(() => import('./RichTextEditor'), { ssr: false, loading: () => <div className={styles.canvasBodyPlaceholder}><p>جارٍ تحميل المحرر...</p></div> });

interface EditorCanvasProps { 
    document: any; 
    title: string; 
    onTitleChange: (newTitle: string) => void; 
    onEditorCreated: (editor: Editor) => void; 
    editor: Editor | null;
    colorDictionary: ColorMapping[]; // ADDED PROP
}

export function EditorCanvas({ document, title, onTitleChange, onEditorCreated, editor, colorDictionary }: EditorCanvasProps) {
    const isRelease = document._type === 'gameRelease';
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    // Auto-resize the textarea height based on content
    useLayoutEffect(() => {
        const textarea = textareaRef.current;
        if (textarea) {
            textarea.style.height = 'auto'; // Reset height
            textarea.style.height = `${textarea.scrollHeight}px`; // Set to scroll height
        }
    }, [title]);

    return (
        <motion.div className={styles.sanctumCanvas} style={{position: 'relative'}} transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}>
            <div className={styles.canvasContent}>
                <textarea
                    ref={textareaRef}
                    value={title}
                    onChange={(e) => onTitleChange(e.target.value)}
                    placeholder="عنوان بلا عنوان"
                    className={styles.canvasTitleInput}
                    rows={1}
                />
                
                <div className={styles.canvasEditorWrapper}>
                    {isRelease ? (
                        <div style={{ minHeight: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', textAlign: 'center' }}>
                            <p>لا نصَّ للإصدارات.<br />تُحرَّرُ البياناتُ من الشريط الجانبي.</p>
                        </div>
                    ) : (
                        <RichTextEditor onEditorCreated={onEditorCreated} initialContent={document.tiptapContent} colorDictionary={colorDictionary} />
                    )}
                </div>
            </div>
        </motion.div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

// app/studio/[contentType]/[id]/EditorClient.tsx

'use client';
import { useState, useMemo, useEffect, useReducer, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { EditorSidebar } from './EditorSidebar';
import { EditorCanvas } from './EditorCanvas';
import { BlockToolbar } from './BlockToolbar';
import { MobileViewToggle } from './editor-components/MobileViewToggle';
import { MobileBlockCreator } from './editor-components/MobileBlockCreator';
import { Editor } from '@tiptap/react';
import { updateDocumentAction, publishDocumentAction, validateSlugAction } from '../../actions';
import { useToast } from '@/lib/toastStore';
import { useDebounce } from '@/hooks/useDebounce';
import { useBodyClass } from '@/hooks/useBodyClass';
import { uploadFile } from './RichTextEditor';
import { UploadQuality } from '@/lib/image-optimizer';
import { tiptapToPortableText } from '../../utils/tiptapToPortableText';
import { useEditorStore } from '@/lib/editorStore';
import styles from './Editor.module.css';
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';

type EditorDocument = {
    _id: string; _type: string; _updatedAt: string; title: string; slug?: { current: string }; score?: number; verdict?: string; pros?: string[]; cons?: string[]; game?: { _id: string; title: string } | null; publishedAt?: string | null; mainImage?: { _ref: string | null; url: string | null; metadata?: any }; authors?: any[]; reporters?: any[]; designers?: any[]; tags?: any[]; releaseDate?: string; platforms?: string[]; synopsis?: string; tiptapContent?: any; content?: any; category?: { _id: string; title: string } | null;
};

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
}

const clientSlugify = (text: string): string => { if (!text) return ''; return text.toLowerCase().trim().replace(/[^a-z0-9\s-]/g, '').replace(/[\s-]+/g, '-'); };

const initialState = { _id: null, _type: null, title: '', slug: '', score: 0, verdict: '', pros: [], cons: [], game: null, tags: [], mainImage: { assetId: null, assetUrl: null }, authors: [], reporters: [], designers: [], publishedAt: null, isSlugManual: false, releaseDate: '', platforms: [], synopsis: '', category: null };

function editorReducer(state: any, action: { type: string; payload: any }) {
    switch (action.type) {
        case 'INITIALIZE_STATE': return { ...state, ...action.payload, isSlugManual: !!action.payload.slug, };
        case 'UPDATE_FIELD': return { ...state, [action.payload.field]: action.payload.value };
        case 'UPDATE_SLUG': return { ...state, slug: clientSlugify(action.payload.slug), isManual: action.payload.isManual };
        default: throw new Error(`Unhandled action type: ${action.type}`);
    }
}

const generateDiffPatch = (currentState: any, sourceOfTruth: any, editorContentJson: string) => {
    const patch: Record<string, any> = {};
    const normalize = (val: any, defaultVal: any) => val ?? defaultVal;
    const compareIds = (arr1: any[], arr2: any[]) => JSON.stringify(normalize(arr1, []).map((i: any) => i._id).sort()) === JSON.stringify(normalize(arr2, []).map((i: any) => i._id).sort());
    if (normalize(currentState.title, '') !== normalize(sourceOfTruth.title, '')) patch.title = currentState.title;
    if (sourceOfTruth._type !== 'gameRelease' && normalize(currentState.slug, '') !== normalize(sourceOfTruth.slug?.current, '')) patch.slug = { _type: 'slug', current: currentState.slug };
    if (normalize(currentState.score, 0) !== normalize(sourceOfTruth.score, 0)) patch.score = currentState.score;
    if (normalize(currentState.verdict, '') !== normalize(sourceOfTruth.verdict, '')) patch.verdict = currentState.verdict;
    if (normalize(currentState.releaseDate, '') !== normalize(sourceOfTruth.releaseDate, '')) patch.releaseDate = currentState.releaseDate;
    if (normalize(currentState.synopsis, '') !== normalize(sourceOfTruth.synopsis, '')) patch.synopsis = currentState.synopsis;
    if (normalize(currentState.category?._id, null) !== normalize(sourceOfTruth.category?._id, null)) {
        patch.category = currentState.category ? { _type: 'reference', _ref: currentState.category._id } : undefined;
    }
    if (JSON.stringify(normalize(currentState.pros, [])) !== JSON.stringify(normalize(sourceOfTruth.pros, []))) patch.pros = currentState.pros;
    if (JSON.stringify(normalize(currentState.cons, [])) !== JSON.stringify(normalize(sourceOfTruth.cons, []))) patch.cons = currentState.cons;
    if (JSON.stringify(normalize(currentState.platforms, [])) !== JSON.stringify(normalize(sourceOfTruth.platforms, []))) patch.platforms = currentState.platforms;
    if (normalize(currentState.game?._id, null) !== normalize(sourceOfTruth.game?._id, null)) patch.game = currentState.game ? { _type: 'reference', _ref: currentState.game._id } : undefined;
    if (normalize(currentState.mainImage.assetId, null) !== normalize(sourceOfTruth.mainImage?._ref, null)) patch.mainImage = currentState.mainImage.assetId ? { _type: 'image', asset: { _type: 'reference', _ref: currentState.mainImage.assetId } } : undefined;
    if (!compareIds(currentState.tags, (sourceOfTruth.tags || []).filter(Boolean))) patch.tags = normalize(currentState.tags, []).map((t: any) => ({ _type: 'reference', _ref: t._id, _key: t._id }));
    if (!compareIds(currentState.authors, (sourceOfTruth.authors || []).filter(Boolean))) patch.authors = normalize(currentState.authors, []).map((a: any) => ({ _type: 'reference', _ref: a._id, _key: a._id }));
    if (!compareIds(currentState.reporters, (sourceOfTruth.reporters || []).filter(Boolean))) patch.reporters = normalize(currentState.reporters, []).map((r: any) => ({ _type: 'reference', _ref: r._id, _key: r._id }));
    if (!compareIds(currentState.designers, (sourceOfTruth.designers || []).filter(Boolean))) patch.designers = normalize(currentState.designers, []).map((d: any) => ({ _type: 'reference', _ref: d._id, _key: d._id }));
    
    const sourceContentSanity = sourceOfTruth.content || []; 
    const currentContentSanity = tiptapToPortableText(JSON.parse(editorContentJson));
    if (sourceOfTruth._type !== 'gameRelease' && JSON.stringify(currentContentSanity) !== JSON.stringify(sourceContentSanity)) {
        patch.content = currentContentSanity;
    }

    return patch;
};


export function EditorClient({ document: initialDocument, allGames, allTags, allCreators, colorDictionary: initialColorDictionary }: { document: EditorDocument, allGames: any[], allTags: any[], allCreators: any[], colorDictionary: ColorMapping[] }) {
    const [sourceOfTruth, setSourceOfTruth] = useState<EditorDocument>(initialDocument);
    const [state, dispatch] = useReducer(editorReducer, initialState);
    const { title, slug, isSlugManual } = state;
    const toast = useToast();
    const [isSidebarOpen, setIsSidebarOpen] = useState(false);
    const [isMobile, setIsMobile] = useState(false);
    const [editorInstance, setEditorInstance] = useState<Editor | null>(null);
    const [mainImageUploadQuality, setMainImageUploadQuality] = useState<UploadQuality>('1080p');
    const { blockUploadQuality, setBlockUploadQuality, setEditorActive, setLiveUrl } = useEditorStore();
    const [slugValidationStatus, setSlugValidationStatus] = useState<'pending' | 'valid' | 'invalid'>('pending');
    const [slugValidationMessage, setSlugValidationMessage] = useState('جارٍ التحقق...');
    const debouncedSlug = useDebounce(slug, 500);
    const [editorContentJson, setEditorContentJson] = useState(JSON.stringify(initialDocument.tiptapContent || {}));
    const [colorDictionary, setColorDictionary] = useState<ColorMapping[]>(initialColorDictionary);
    
    useBodyClass('sidebar-open', isSidebarOpen && isMobile);
    
    useEffect(() => {
        setEditorActive(true);
        return () => {
            setEditorActive(false);
            setLiveUrl(null);
        };
    }, [setEditorActive, setLiveUrl]);

    useEffect(() => {
        const { _type, slug: docSlug, publishedAt } = sourceOfTruth;
        const isPublished = publishedAt && new Date(publishedAt) <= new Date();

        if (isPublished && docSlug?.current && _type !== 'gameRelease') {
            const contentTypePlural = _type === 'review' ? 'reviews' : _type === 'article' ? 'articles' : 'news';
            const url = `/${contentTypePlural}/${docSlug.current}`;
            setLiveUrl(url);
        } else {
            setLiveUrl(null);
        }
    }, [sourceOfTruth, setLiveUrl]);
    
    useEffect(() => {
        const viewport = document.querySelector('meta[name="viewport"]');
        if (viewport) {
            const originalContent = viewport.getAttribute('content');
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            return () => {
                if (originalContent) {
                    viewport.setAttribute('content', originalContent);
                }
            };
        }
    }, []);

    useEffect(() => { const handleResize = () => { const mobile = window.innerWidth <= 1024; setIsMobile(mobile); if (!mobile) setIsSidebarOpen(true); }; handleResize(); window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize); }, []);
    const patch = useMemo(() => generateDiffPatch(state, sourceOfTruth, editorContentJson), [state, sourceOfTruth, editorContentJson]);
    const hasChanges = Object.keys(patch).length > 0;
    useEffect(() => { if (editorInstance) editorInstance.storage.uploadQuality = blockUploadQuality; }, [blockUploadQuality, editorInstance]);
    
    useEffect(() => { 
        const currentSlug = sourceOfTruth.slug?.current ?? '';
        dispatch({ 
            type: 'INITIALIZE_STATE', 
            payload: { 
                _id: sourceOfTruth._id, 
                _type: sourceOfTruth._type, 
                title: sourceOfTruth.title ?? '', 
                slug: currentSlug, 
                score: sourceOfTruth.score ?? 0, 
                verdict: sourceOfTruth.verdict ?? '', 
                pros: sourceOfTruth.pros ?? [], 
                cons: sourceOfTruth.cons ?? [], 
                game: sourceOfTruth.game || null, 
                publishedAt: sourceOfTruth.publishedAt || null, 
                mainImage: { 
                    assetId: sourceOfTruth.mainImage?._ref || null, 
                    assetUrl: sourceOfTruth.mainImage?.url || null 
                }, 
                authors: (sourceOfTruth.authors || []).filter(Boolean), 
                reporters: (sourceOfTruth.reporters || []).filter(Boolean), 
                designers: (sourceOfTruth.designers || []).filter(Boolean), 
                tags: (sourceOfTruth.tags || []).filter(Boolean), 
                releaseDate: sourceOfTruth.releaseDate || '', 
                platforms: sourceOfTruth.platforms || [], 
                synopsis: sourceOfTruth.synopsis || '', 
                category: sourceOfTruth.category || null, 
            } 
        }); 
        
        const imageWidth = sourceOfTruth?.mainImage?.metadata?.dimensions?.width; 
        if (imageWidth && imageWidth >= 3840) { 
            setMainImageUploadQuality('4k'); 
        } else { 
            setMainImageUploadQuality('1080p'); 
        } 
        
        if (editorInstance) { 
            const freshTiptapContent = portableTextToTiptap(sourceOfTruth.content || []);
            const editorJSON = JSON.stringify(editorInstance.getJSON()); 
            const sourceJSON = JSON.stringify(freshTiptapContent); 
            
            if (editorJSON !== sourceJSON) { 
                editorInstance.commands.setContent(freshTiptapContent, false); 
            } 
        } 
    }, [sourceOfTruth._id, sourceOfTruth._updatedAt, editorInstance, sourceOfTruth.slug]);

    useEffect(() => { if (editorInstance) { const updateJson = () => setEditorContentJson(JSON.stringify(editorInstance.getJSON())); editorInstance.on('update', updateJson); return () => { editorInstance.off('update', updateJson); }; } }, [editorInstance]);
    useEffect(() => { if (!isSlugManual && title !== sourceOfTruth.title) { dispatch({ type: 'UPDATE_SLUG', payload: { slug: clientSlugify(title), isManual: false } }); } }, [title, isSlugManual, sourceOfTruth.title]);
    useEffect(() => {
        if (state._type === 'gameRelease') {
            setSlugValidationStatus('valid');
            setSlugValidationMessage('');
            return;
        }
        if (!state._id || !debouncedSlug) { setSlugValidationStatus('invalid'); setSlugValidationMessage(!state._id ? 'بانتظار مُعرِّف الوثيقة...' : 'لا يكُن المُعرِّفُ خاويًا.'); return; } setSlugValidationStatus('pending'); setSlugValidationMessage('جارٍ التحقق...'); const checkSlug = async () => { const result = await validateSlugAction(debouncedSlug, state._id); setSlugValidationStatus(result.isValid ? 'valid' : 'invalid'); setSlugValidationMessage(result.message); }; checkSlug();
    }, [debouncedSlug, state._id, state._type]);
    const isDocumentValid = useMemo(() => { const { title, slug, mainImage, game, score, verdict, authors, reporters, releaseDate, platforms, synopsis, category } = state; const type = sourceOfTruth._type; const baseValid = title.trim() && mainImage.assetId; if (!baseValid) return false; if (type !== 'gameRelease' && !slug.trim()) return false; if (type === 'review') return game?._id && (authors || []).length > 0 && score > 0 && verdict.trim(); if (type === 'article') return game?._id && (authors || []).length > 0; if (type === 'news') return (reporters || []).length > 0 && category; if (type === 'gameRelease') return game?._id && releaseDate.trim() && synopsis.trim() && (platforms || []).length > 0; return false; }, [state, sourceOfTruth._type]);
    
    const saveWorkingCopy = async (): Promise<boolean> => { 
        if (!hasChanges) return true; 
        if (sourceOfTruth._type !== 'gameRelease' && slugValidationStatus !== 'valid') { 
            toast.error('لا يمكن الحفظ بمُعرِّف غير صالح.', 'left'); 
            return false; 
        } 

        const optimisticSOT: EditorDocument = {
            ...sourceOfTruth,
            title: state.title,
            slug: { current: state.slug },
            score: state.score,
            verdict: state.verdict,
            pros: state.pros,
            cons: state.cons,
            game: state.game,
            tags: state.tags,
            mainImage: state.mainImage.assetId ? { _ref: state.mainImage.assetId, url: state.mainImage.assetUrl } : undefined,
            authors: state.authors,
            reporters: state.reporters,
            designers: state.designers,
            releaseDate: state.releaseDate,
            platforms: state.platforms,
            synopsis: state.synopsis,
            category: state.category,
            content: tiptapToPortableText(JSON.parse(editorContentJson)),
            _updatedAt: new Date().toISOString(),
        };
        
        const result = await updateDocumentAction(sourceOfTruth._id, patch); 
        
        if (result.success && result.updatedDocument) { 
            setSourceOfTruth({ ...optimisticSOT, _updatedAt: result.updatedDocument._updatedAt });
            return true; 
        } else { 
            toast.error(result.message || 'أخفق حفظ التغييرات.', 'left'); 
            return false; 
        } 
    };
    
    const handlePublish = async (publishTime?: string | null): Promise<boolean> => { const didSave = await saveWorkingCopy(); if (!didSave) { if (hasChanges) toast.error('احفظ التغييرات أولاً.', 'left'); return false; } const result = await publishDocumentAction(sourceOfTruth._id, publishTime); if (result.success && result.updatedDocument) { setSourceOfTruth(result.updatedDocument); toast.success(result.message || 'تجددت حالة النشر!', 'left'); return true; } else { toast.error(result.message || 'أخفق تحديث الحالة.', 'left'); return false; } };
    useEffect(() => { if (hasChanges) { document.title = `*لم يُحفظ* ${title || 'بلا عنوان'}`; window.onbeforeunload = () => "أَتَغادرُ وما كتبت لم يُحفظ؟"; } else { document.title = title || "EternalGames الديوان"; window.onbeforeunload = null; } return () => { window.onbeforeunload = null; }; }, [hasChanges, title]);
    useEffect(() => { document.body.classList.add('editor-active'); return () => { document.body.classList.remove('editor-active'); } }, []);
    
    const isRelease = initialDocument._type === 'gameRelease';

    return (
        <div className={styles.sanctumContainer}>
            <div className={styles.sanctumMain}>
                <motion.div
                    style={{
                        position: isMobile ? 'absolute' : 'relative',
                        top: 0,
                        right: 0,
                        bottom: 0,
                        width: isMobile ? '100%' : 'auto',
                        pointerEvents: isMobile && !isSidebarOpen ? 'none' : 'auto',
                    }}
                    animate={{ x: isMobile ? (isSidebarOpen ? '0%' : '100%') : '0%' }}
                    transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}
                >
                    <EditorSidebar 
                        document={sourceOfTruth} 
                        isOpen={isSidebarOpen} 
                        documentState={state} 
                        dispatch={dispatch} 
                        onSave={saveWorkingCopy} 
                        hasChanges={hasChanges} 
                        onPublish={handlePublish} 
                        slugValidationStatus={slugValidationStatus} 
                        slugValidationMessage={slugValidationMessage} 
                        isDocumentValid={isDocumentValid} 
                        mainImageUploadQuality={mainImageUploadQuality} 
                        onMainImageUploadQualityChange={setMainImageUploadQuality} 
                        allGames={allGames} 
                        allTags={allTags} 
                        allCreators={allCreators} 
                        colorDictionary={colorDictionary}
                        onColorDictionaryUpdate={setColorDictionary} // CORRECTED: Pass the setter function
                    />
                </motion.div>
                <motion.div
                    style={{
                        position: isMobile ? 'absolute' : 'relative',
                        top: 0,
                        left: 0,
                        bottom: 0,
                        width: '100%',
                        pointerEvents: isMobile && isSidebarOpen ? 'none' : 'auto',
                    }}
                    animate={{ x: isMobile ? (isSidebarOpen ? '-100%' : '0%') : '0%' }}
                    transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}
                >
                    <EditorCanvas 
                        document={sourceOfTruth} 
                        title={title} 
                        onTitleChange={(newTitle) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'title', value: newTitle } })} 
                        onEditorCreated={setEditorInstance} 
                        editor={editorInstance} 
                        colorDictionary={colorDictionary} // CORRECTED: Pass the state down
                    />
                </motion.div>
            </div>
            
            <AnimatePresence>
                {!isRelease && !isMobile && (
                    <BlockToolbar key="block-toolbar-desktop" editor={editorInstance} onFileUpload={(file) => { if (editorInstance) { uploadFile(file, editorInstance, toast, blockUploadQuality); } }} uploadQuality={blockUploadQuality} onUploadQualityChange={setBlockUploadQuality} />
                )}
                {!isRelease && isMobile && !isSidebarOpen && (
                    <MobileBlockCreator key="block-creator-mobile" editor={editorInstance} onFileUpload={(file) => { if (editorInstance) { uploadFile(file, editorInstance, toast, blockUploadQuality); } }} />
                )}
            </AnimatePresence>
             {isMobile && (
                <MobileViewToggle isSidebarOpen={isSidebarOpen} setIsSidebarOpen={setIsSidebarOpen} />
            )}
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

// components/studio/[contentType]/[id/EditorSidebar.tsx]
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { useState, useMemo, useTransition, useCallback } from 'react';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { ProsConsInput } from './metadata/ProsConsInput';
import { GameInput } from './metadata/GameInput';
import { TagInput } from './metadata/TagInput';
import { MainImageInput } from './metadata/MainImageInput';
import { CreatorInput } from './metadata/CreatorInput';
import { PlatformInput } from './metadata/PlatformInput';
import { SlugInput } from './metadata/SlugInput';
import ColorDictionaryManager from './metadata/color-dictionary/ColorDictionaryManager';
import { UploadQuality } from '@/lib/image-optimizer';
import styles from './Editor.module.css';

type Tag = { _id: string; title: string; category: 'Game' | 'Article' | 'News' };

const sidebarVariants = { hidden: { opacity: 0, x: 50 }, visible: { opacity: 1, x: 0, transition: { type: 'spring' as const, stiffness: 400, damping: 40 } }, exit: { opacity: 0, x: 50, transition: { duration: 0.2, ease: 'easeInOut' as const } } };
const itemVariants = { hidden: { opacity: 0, y: 10 }, visible: { opacity: 1, y: 0 } };
const ToggleSwitch = ({ checked, onChange, name }: { checked: boolean, onChange: (checked: boolean) => void, name?: string }) => ( <button type="button" role="switch" aria-checked={checked} onClick={() => onChange(!checked)} className={`toggle ${checked ? 'active' : ''}`}> <motion.div className="toggle-handle" layout transition={{ type: 'spring' as const, stiffness: 700, damping: 30 }} /> {name && <input type="checkbox" name={name} checked={checked} readOnly style={{ display: 'none' }} />} </button> );

export function EditorSidebar({ 
    document, isOpen, documentState, dispatch, onSave, hasChanges, onPublish, 
    slugValidationStatus, slugValidationMessage, isDocumentValid, 
    mainImageUploadQuality, onMainImageUploadQualityChange,
    allGames, allTags, allCreators, colorDictionary
}: any) {
    const { title, slug, score, verdict, pros, cons, game, tags, mainImage, authors, reporters, designers, releaseDate, platforms, synopsis, category, isSlugManual } = documentState;
    const [scheduledDateTime, setScheduledDateTime] = useState('');
    const [isSaving, startSaveTransition] = useTransition();
    const [isPublishing, startPublishTransition] = useTransition();
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success'>('idle');

    const publishedAt = document.publishedAt;

    const isReview = document._type === 'review';
    const isArticle = document._type === 'article';
    const isNews = document._type === 'news';
    const isRelease = document._type === 'gameRelease';

    const primaryCreatorConfig = useMemo(() => {
        if (isReview) return { label: 'المراجعون', sanityType: 'reviewer', field: 'authors' };
        if (isArticle) return { label: 'الكتّاب', sanityType: 'author', field: 'authors' };
        if (isNews) return { label: 'المراسلون', sanityType: 'reporter', field: 'reporters' };
        return { label: 'المنشئون', sanityType: 'author', field: 'authors' };
    }, [isReview, isArticle, isNews]);

    const getUniqueTagsByCategory = useCallback((categoryToFilter: 'Game' | 'Article' | 'News'): Tag[] => {
        if (!allTags) return [];
        const filtered = allTags.filter((t: any) => t && t.category === categoryToFilter);
        const uniqueMap = new Map<string, Tag>(filtered.map((item: any) => [item.title, item]));
        return Array.from(uniqueMap.values());
    }, [allTags]);

    const uniqueNewsCategories = useMemo(() => getUniqueTagsByCategory('News'), [getUniqueTagsByCategory]);
    const uniqueArticleCategories = useMemo(() => getUniqueTagsByCategory('Article'), [getUniqueTagsByCategory]);
    const uniqueGameTags = useMemo(() => getUniqueTagsByCategory('Game'), [getUniqueTagsByCategory]);

    const handleSave = () => { startSaveTransition(async () => { setSaveStatus('saving'); const success = await onSave(); setSaveStatus(success ? 'success' : 'idle'); if(success) setTimeout(() => setSaveStatus('idle'), 2000); }); };
    
    const isPublished = useMemo(() => publishedAt && new Date(publishedAt) <= new Date(), [publishedAt]);
    const isScheduled = useMemo(() => publishedAt && new Date(publishedAt) > new Date(), [publishedAt]);

    const isSlugValid = slugValidationStatus === 'valid';
    const isSlugPending = slugValidationStatus === 'pending';

    const handlePublishClick = () => { startPublishTransition(async () => { const publishDate = isRelease ? '' : (scheduledDateTime || ''); if (hasChanges) { const saveSuccess = await onSave(); if (saveSuccess) { await onPublish(publishDate); } } else { await onPublish(publishDate); } }); };
    
    const publishButtonText = useMemo(() => {
        if (isRelease) { return "تحديث الإصدار"; }
        if (scheduledDateTime) return hasChanges ? "حفظ وجدولة" : "جدولة";
        if (isPublished) return hasChanges ? "حفظ وتحديث" : "تحديث";
        return hasChanges ? "حفظ ونشر" : "نشر";
    }, [isRelease, isPublished, scheduledDateTime, hasChanges]);

    const isSaveDisabled = isSaving || !hasChanges || !isSlugValid || isSlugPending || isPublishing;
    const isPublishDisabled = isPublishing || !isDocumentValid || !isSlugValid || isSlugPending || isSaving;
    const isUnpublishDisabled = isPublishing || !isSlugValid || isSlugPending || isSaving;
    const handleFieldChange = (field: string, value: any) => { dispatch({ type: 'UPDATE_FIELD', payload: { field, value } }); };
    const creatorsForRole = (sanityType: string) => allCreators.filter((c: any) => c._type === sanityType);

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.aside className={styles.sanctumSidebar} variants={sidebarVariants} initial="hidden" animate="visible" exit="exit">
                    <motion.div variants={itemVariants} className={styles.sidebarContent}>
                        <h2 className={styles.sidebarTitle}>منصة التحرير</h2>
                        <p className={styles.sidebarSubtitle}>تحرير: {title}</p>
                    </motion.div>
                    
                    <motion.div className={styles.sidebarSection} variants={itemVariants}>
                        {!isRelease && ( <> <label className={styles.sidebarLabel} style={{ marginBottom: '0.75rem' }}>جدولة (اختياري)</label> <input type="datetime-local" value={scheduledDateTime} onChange={(e) => setScheduledDateTime(e.target.value)} className={styles.sidebarInput} disabled={isPublishing || isSaving} /> </> )}
                        <motion.button onClick={handlePublishClick} className="primary-button" style={{ width: '100%', marginTop: '1rem', height: '44px', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} disabled={isPublishDisabled} animate={{ width: isPublishing ? '44px' : '100%', borderRadius: isPublishing ? '50%' : '5px', paddingLeft: isPublishing ? 0 : '2.4rem', paddingRight: isPublishing ? 0 : '2.4rem' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                            <AnimatePresence mode="wait">{isPublishing ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}} style={{whiteSpace: 'nowrap'}}>{publishButtonText}</motion.span>}</AnimatePresence>
                        </motion.button>
                        {!isRelease && (isPublished || isScheduled) && (<motion.button onClick={() => onPublish(null)} className="outline-button" style={{ width: '100%', marginTop: '0.5rem', color: '#DC2626', borderColor: '#DC2626' }} disabled={isUnpublishDisabled}>إلغاء النشر</motion.button>)}
                        <p style={{ marginTop: '0.5rem', color: 'var(--text-secondary)', fontSize: '1.4rem', textAlign: 'right' }}> {!isDocumentValid && <span style={{ color: '#DC2626' }}>الحقول الإلزامية ناقصة.</span>}</p>
                    </motion.div>

                    <fieldset disabled={isSaving || isPublishing} style={{border: 'none', padding: 0, margin: 0, minWidth: 0}}>
                        <motion.div className={styles.sidebarSection} variants={itemVariants}>
                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem'}}>
                                <label className={styles.sidebarLabel} style={{marginBottom: 0}}>جودة الصورة الرئيسية</label>
                                <div style={{display: 'flex', alignItems: 'center', gap: '1rem', fontFamily: 'var(--font-main)', fontSize: '1.4rem'}}>
                                    <span>1080p</span>
                                    <ToggleSwitch checked={mainImageUploadQuality === '4k'} onChange={(isChecked) => onMainImageUploadQualityChange(isChecked ? '4k' : '1080p')} />
                                    <span>4K</span>
                                </div>
                            </div>
                            <MainImageInput currentAssetId={mainImage.assetId} currentAssetUrl={mainImage.assetUrl} onImageChange={(assetId, assetUrl) => handleFieldChange('mainImage', { assetId, assetUrl })} uploadQuality={mainImageUploadQuality} />
                        </motion.div>
                        
                        {!isRelease && (
                            <SlugInput 
                                slug={slug}
                                title={title}
                                docId={document._id}
                                isSlugManual={isSlugManual}
                                slugValidationStatus={slugValidationStatus}
                                slugValidationMessage={slugValidationMessage}
                                dispatch={dispatch}
                            />
                        )}
                        
                        {isRelease ? ( <> 
                            <motion.div variants={itemVariants}><GameInput allGames={allGames} selectedGame={game} onGameSelect={(g: any) => handleFieldChange('game', g)} /></motion.div>
                            <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>تاريخ الإصدار</label> <input type="date" value={releaseDate} onChange={(e) => handleFieldChange('releaseDate', e.target.value)} className={styles.sidebarInput} /> </motion.div> 
                            <motion.div variants={itemVariants}><PlatformInput selectedPlatforms={platforms} onPlatformsChange={(p: any) => handleFieldChange('platforms', p)} /></motion.div>
                             <motion.div variants={itemVariants}><TagInput label="الوسوم" placeholder="ابحث أو أنشئ وسمًا..." allTags={uniqueGameTags} selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game" /></motion.div>
                            <motion.div variants={itemVariants}><CreatorInput allCreators={creatorsForRole('designer')} label="المصممون (اختياري)" selectedCreators={designers} onCreatorsChange={(c: any) => handleFieldChange('designers', c)} /></motion.div>
                            <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>نبذة</label> <textarea value={synopsis} onChange={(e) => handleFieldChange('synopsis', e.target.value)} className={styles.sidebarInput} rows={5} /> </motion.div> 
                        </> ) : ( <> 
                            <div><CreatorInput allCreators={creatorsForRole(primaryCreatorConfig.sanityType)} label={primaryCreatorConfig.label} selectedCreators={documentState[primaryCreatorConfig.field]} onCreatorsChange={(c: any) => handleFieldChange(primaryCreatorConfig.field, c)} /></div> 
                            <div><GameInput allGames={allGames} selectedGame={game} onGameSelect={(g: any) => handleFieldChange('game', g)} /></div> 
                            
                            {isNews && (
                                <motion.div variants={itemVariants}>
                                    <TagInput
                                        label="التصنيف"
                                        placeholder="اختر تصنيف الخبر..."
                                        allTags={uniqueNewsCategories}
                                        selectedTags={category ? [category] : []}
                                        onTagsChange={(newCategoryArr: any) => handleFieldChange('category', newCategoryArr[0] || null)}
                                        singleSelection={true}
                                        categoryForCreation="News"
                                    />
                                </motion.div>
                            )}

                            {isArticle && (
                                <>
                                    <div><TagInput label="نوع المقال" placeholder="اختر نوع المقال..." allTags={uniqueArticleCategories} selectedTags={category ? [category] : []} onTagsChange={(newCategoryArr: any) => handleFieldChange('category', newCategoryArr[0] || null)} singleSelection={true} categoryForCreation="Article" /></div>
                                    <div><TagInput label="الوسوم" placeholder="ابحث أو أنشئ وسمًا..." allTags={uniqueGameTags} selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game" /></div>
                                </>
                            )}

                            {isReview && (
                                <div><TagInput label="الوسوم" placeholder="ابحث أو أنشئ وسمًا..." allTags={uniqueGameTags} selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game"/></div>
                            )}

                            <div><CreatorInput allCreators={creatorsForRole('designer')} label="المصممون (اختياري)" selectedCreators={designers} onCreatorsChange={(c: any) => handleFieldChange('designers', c)} /></div>
                        </> )}
                        
                        {isReview && (<> <motion.hr variants={itemVariants} style={{ border: 'none', borderTop: '1px solid var(--border-color)', margin: '1rem 0' }} /> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>التقييم (0-10) {score <= 0 && <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>}</label> <input type="number" value={score} onChange={(e) => handleFieldChange('score', parseFloat(e.target.value) || 0)} className={styles.sidebarInput} min="0" max="10" step="0.1" /> </motion.div> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>الخلاصة {!verdict.trim() && <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>}</label> <textarea value={verdict} onChange={(e) => handleFieldChange('verdict', e.target.value)} className={styles.sidebarInput} rows={3} /> </motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المحاسن" items={pros} setItems={(p: any) => handleFieldChange('pros', p)} /></motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المساوئ" items={cons} setItems={(c: any) => handleFieldChange('cons', c)} /></motion.div> </>)}
                    </fieldset>

                    <ColorDictionaryManager initialMappings={colorDictionary || []} />
                    
                    <div className={styles.sidebarFooter}>
                        <motion.button onClick={handleSave} disabled={isSaveDisabled} className="primary-button" style={{ width: '100%', height: '44px', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} title={isSaveDisabled ? (hasChanges ? 'المُعرّف غير صالح' : 'لا تغييرات للحفظ') : 'حفظ التغييرات'} animate={{ backgroundColor: saveStatus === 'success' ? '#16A34A' : 'var(--accent)', color: saveStatus === 'success' ? '#fff' : 'inherit', width: isSaving ? '44px' : '100%', borderRadius: isSaving ? '50%' : '5px', paddingLeft: isSaving ? 0 : '2.4rem', paddingRight: isSaving ? 0 : '2.4rem' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                            <AnimatePresence mode="wait">
                                {isSaving && <ButtonLoader key="loader" />}
                                {saveStatus === 'success' && <motion.span key="success" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>حُفِظ!</motion.span>}
                                {saveStatus === 'idle' && <motion.span key="idle" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}} style={{whiteSpace: 'nowrap'}}>حفظ التغييرات</motion.span>}
                            </AnimatePresence>
                        </motion.button>
                    </div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorStateSync.tsx ---

// app/studio/[contentType]/[id]/EditorStateSync.tsx
'use client';

import { useLayoutEffect } from 'react';
import { useEditorStore } from '@/lib/editorStore';

export function EditorStateSync() {

    useLayoutEffect(() => {

        document.body.classList.add('editor-active');
        

        useEditorStore.setState({ isEditorActive: true });

        return () => {
            document.body.classList.remove('editor-active');
            useEditorStore.setState({ isEditorActive: false, liveUrl: null });
        };
    }, []);

    return null;
}

--- END OF FILE app/studio/[contentType]/[id]/EditorStateSync.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

// app/studio/[contentType]/[id]/FormattingToolbar.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useState, useRef, useLayoutEffect, RefObject } from 'react';
import { useClickOutside } from '@/hooks/useClickOutside';
import styles from './Editor.module.css';
import { ColorPicker } from './ColorPicker';

// --- Icon Components (with new DragIcon) ---
const DragIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="20" viewBox="0 0 24 24" fill="none" {...props}>
        <path d="M20.964 4H16.9719M20.964 4C20.964 4.56018 19.4727 5.60678 18.9679 6M20.964 4C20.964 3.43982 19.4727 2.39322 18.9679 2" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M2.99921 4H6.99136M2.99921 4C2.99921 3.43982 4.49058 2.39322 4.99529 2M2.99921 4C2.99921 4.56018 4.49058 5.60678 4.99529 6" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M9.81505 22.0006V21.0595C9.81505 20.4116 9.60526 19.781 9.21707 19.2622L5.39435 14.1534C5.07668 13.7288 4.83978 13.2141 4.98565 12.7043C5.34585 11.4454 6.76792 10.3261 8.35901 12.2974L9.95917 14.0049V3.59381C10.0573 1.76459 13.1325 1.18685 13.4504 3.59381V9.52698C14.933 9.33608 21.9162 10.378 20.9003 14.7917C20.8517 15.0026 20.8032 15.2167 20.7557 15.4279C20.5493 16.346 19.9407 17.98 19.2696 18.9355C18.5705 19.9309 18.897 21.5353 18.8172 22.0019" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
);
const BoldIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>;
const ItalicIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>;
const LinkIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>;
const ListIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;
const QuoteIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"><path d="M22 11.5667C22 16.8499 17.5222 21.1334 12 21.1334C11.3507 21.1343 10.7032 21.0742 10.0654 20.9545C9.60633 20.8682 9.37678 20.8251 9.21653 20.8496C9.05627 20.8741 8.82918 20.9948 8.37499 21.2364C7.09014 21.9197 5.59195 22.161 4.15111 21.893C4.69874 21.2194 5.07275 20.4112 5.23778 19.5448C5.33778 19.0148 5.09 18.5 4.71889 18.1231C3.03333 16.4115 2 14.1051 2 11.5667C2 6.28357 6.47778 2 12 2C17.5222 2 22 6.28357 22 11.5667Z" /><path d="M10.7456 10C10.7456 9.05719 10.7456 8.58579 10.4347 8.29289C10.1239 8 9.62351 8 8.62281 8C7.62211 8 7.12176 8 6.81088 8.29289C6.5 8.58579 6.5 9.05719 6.5 10C6.5 10.9428 6.5 11.4142 6.81088 11.7071C7.12176 12 7.62211 12 8.62281 12C9.62351 12 10.1239 12 10.4347 11.7071C10.7456 11.4142 10.7456 10.9428 10.7456 10ZM10.7456 10L10.7456 12.0687C10.7456 13.9022 9.41052 15.4571 7.5614 16M17.5 10C17.5 9.05719 17.5 8.58579 17.1891 8.29289C16.8782 8 16.3779 8 15.3772 8C14.3765 8 13.8761 8 13.5653 8.29289C13.2544 8.58579 13.2544 9.05719 13.2544 10C13.2544 10.9428 13.2544 11.4142 13.5653 11.7071C13.8761 12 14.3765 12 15.3772 12C16.3779 12 16.8782 12 17.1891 11.7071C17.5 11.4142 17.5 10.9428 17.5 10ZM17.5 10V12.0687C17.5 13.9022 16.1649 15.4571 14.3158 16" strokeLinecap="round" /></svg>;
const HeadingIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M5 20V4H7V20H5Z" /><path fillRule="evenodd" clipRule="evenodd" d="M17 20V4H19V20H17Z" /><path fillRule="evenodd" clipRule="evenodd" d="M18 13H6V11H18V13Z" /></svg>;
const H1Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2.74996 19V5H4.74996V19H2.74996Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12.75 19V5H14.75V19H12.75Z" /><path fillRule="evenodd" clipRule="evenodd" d="M18.3358 9H20.25V17H21.25V19H17.25V17H18.25V11.9142L17.9572 12.2071L16.5429 10.7929L18.3358 9Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13.75 13L3.74996 13L3.74996 11L13.75 11V13Z" /></svg>;
const H2Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2 19V5H4V19H2Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12 19V5H14V19H12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M16 12C16 10.3431 17.3431 9 19 9C20.6569 9 22 10.3431 22 12V12.214C22 13.1191 21.6184 13.982 20.9494 14.5909L18.443 17H22V19H16V16.5742L19.5859 13.1273L19.5981 13.1163C19.8539 12.8861 20 12.5581 20 12.214V12C20 11.4477 19.5523 11 19 11C18.4477 11 18 11.4477 18 12V12.4H16V12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13 13L3 13L3 11L13 11V13Z" /></svg>;
const H3Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2 19V5H4V19H2Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12 19V5H14V19H12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M19 11C18.4477 11 18 11.4477 18 12H16C16 10.3431 17.3431 9 19 9C20.6569 9 22 10.3431 22 12C22 12.7684 21.7111 13.4692 21.2361 14C21.7111 14.5308 22 15.2316 22 16C22 17.6569 20.6569 19 19 19C17.3431 19 16 17.6569 16 16H18C18 16.5523 18.4477 17 19 17C19.5523 17 20 16.5523 20 16C20 15.4477 19.5523 15 19 15H18V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13 13L3 13L3 11L13 11L13 13Z" /></svg>;
const ColorPickerIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M21.1353 8.18318L20.7826 8.53589L21.5396 9.29289C21.9302 9.68342 21.9302 10.3166 21.5396 10.7071C21.1491 11.0976 20.5159 11.0976 20.1254 10.7071L13.2929 3.87458C12.9024 3.48405 12.9024 2.85089 13.2929 2.46036C13.6834 2.06984 14.3166 2.06984 14.7071 2.46036L15.4641 3.21737L15.8168 2.86467C16.9697 1.71178 18.8389 1.71178 19.9918 2.86466L21.1353 4.00821C22.2882 5.1611 22.2882 7.0303 21.1353 8.18318Z" /><path d="M13.7071 7.70711C14.0976 7.31658 14.0976 6.68342 13.7071 6.29289C13.3166 5.90237 12.6834 5.90237 12.2929 6.29289L1.87868 16.7071C1.31607 17.2697 1 18.0328 1 18.8284V22C1 22.5523 1.44772 23 2 23H5.17157C5.96722 23 6.73028 22.6839 7.29289 22.1213L17.7071 11.7071C18.0976 11.3166 18.0976 10.6834 17.7071 10.2929C17.3166 9.90237 16.6834 9.90237 16.2929 10.2929L13.5858 13H8.41421L13.7071 7.70711Z" /></svg>;

const headingOptions = [
    { level: 3, icon: <H3Icon /> },
    { level: 2, icon: <H2Icon /> },
    { level: 1, icon: <H1Icon /> },
];

interface FormattingToolbarProps { editor: Editor; onLinkClick: () => void; platform: 'ios' | 'android' | 'desktop' }

export function FormattingToolbar({ editor, onLinkClick, platform }: FormattingToolbarProps) {
    const [isHeadingMenuOpen, setIsHeadingMenuOpen] = useState(false);
    const [isColorMenuOpen, setIsColorMenuOpen] = useState(false);
    const toolbarRef = useRef<HTMLDivElement>(null); 
    const headingMenuRef = useRef<HTMLDivElement>(null);
    const colorMenuRef = useRef<HTMLDivElement>(null);
    const [popoverStyle, setPopoverStyle] = useState<React.CSSProperties>({});

    useClickOutside(headingMenuRef, () => setIsHeadingMenuOpen(false));
    useClickOutside(colorMenuRef, () => setIsColorMenuOpen(false));
    
    const calculatePopoverPosition = (parentRef: RefObject<HTMLDivElement | null>, popoverWidth: number, popoverHeight: number) => {
        if (parentRef.current && toolbarRef.current) { 
            const parentRect = parentRef.current.getBoundingClientRect();
            const toolbarRect = toolbarRef.current.getBoundingClientRect(); 
            const spaceAbove = parentRect.top;
            const spaceBelow = window.innerHeight - parentRect.bottom;
            
            let finalStyle: React.CSSProperties = {};

            // --- Vertical Positioning ---
            let openUp = platform !== 'android';
            if (openUp && spaceAbove < popoverHeight && spaceBelow > popoverHeight) {
                openUp = false;
            } else if (!openUp && spaceBelow < popoverHeight && spaceAbove > popoverHeight) {
                openUp = true;
            }

            if (openUp) {
                finalStyle.bottom = '100%';
                finalStyle.marginBottom = '0.5rem';
            } else {
                finalStyle.top = '100%';
                finalStyle.marginTop = '0.5rem';
            }

            // --- Horizontal Positioning ---
            const triggerCenter = parentRect.left + parentRect.width / 2;
            const spaceLeft = triggerCenter;
            const spaceRight = window.innerWidth - triggerCenter;

            if (spaceLeft > popoverWidth / 2 && spaceRight > popoverWidth / 2) {
                finalStyle.left = '50%';
                finalStyle.transform = 'translateX(-50%)';
            } else if (spaceLeft < popoverWidth / 2) {
                finalStyle.left = 0;
            } else {
                finalStyle.right = 0;
            }

            setPopoverStyle(finalStyle);
        }
    };

    useLayoutEffect(() => {
        if (isHeadingMenuOpen) calculatePopoverPosition(headingMenuRef, 150, 60);
        if (isColorMenuOpen) calculatePopoverPosition(colorMenuRef, 300, 260);
    }, [isHeadingMenuOpen, isColorMenuOpen]);


    const isAnyHeadingActive = editor.isActive('heading', { level: 1 }) || editor.isActive('heading', { level: 2 }) || editor.isActive('heading', { level: 3 });
    const isAnyColorActive = !!editor.getAttributes('textStyle').color;

    return (
        <motion.div
            drag
            dragMomentum={false}
            className={styles.formattingToolbar}
            ref={toolbarRef}
            onMouseDown={(e) => e.preventDefault()}
        >
            <div className={styles.dragHandle}>
                <DragIcon />
            </div>
            <div ref={headingMenuRef} style={{ position: 'relative' }}>
                <motion.button onClick={() => setIsHeadingMenuOpen(prev => !prev)} className={`${styles.bubbleMenuButton} ${isAnyHeadingActive ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
                    <HeadingIcon />
                </motion.button>
                <AnimatePresence>
                    {isHeadingMenuOpen && (
                        <motion.div
                            style={{ 
                                position: 'absolute', 
                                display: 'flex', 
                                gap: '0.2rem', 
                                background: 'var(--bg-secondary)', 
                                padding: '0.4rem', 
                                borderRadius: '8px', 
                                border: '1px solid var(--border-color)', 
                                ...popoverStyle 
                            }}
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: 10 }}
                        >
                            {headingOptions.map(({ level, icon }) => (
                                <motion.button
                                    key={level}
                                    onClick={() => {
                                        editor.chain().focus().toggleHeading({ level: level as 1 | 2 | 3 }).run();
                                        setIsHeadingMenuOpen(false);
                                    }}
                                    className={`${styles.bubbleMenuButton} ${editor.isActive('heading', { level }) ? styles.active : ''}`}
                                    whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}
                                >
                                    {icon}
                                </motion.button>
                            ))}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
            <motion.button onClick={() => editor.chain().focus().toggleBold().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bold') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><BoldIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleItalic().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('italic') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ItalicIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBulletList().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bulletList') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ListIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBlockquote().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('blockquote') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} title="اقتباس"><QuoteIcon /></motion.button>
            <motion.button onClick={onLinkClick} className={`${styles.bubbleMenuButton} ${editor.isActive('link') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><LinkIcon /></motion.button>
            <div ref={colorMenuRef} style={{ position: 'relative', display: 'flex' }}>
                <motion.button onClick={() => setIsColorMenuOpen(prev => !prev)} className={`${styles.bubbleMenuButton} ${isAnyColorActive ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
                    <ColorPickerIcon />
                </motion.button>
                <AnimatePresence>
                    {isColorMenuOpen && <ColorPicker editor={editor} popoverStyle={popoverStyle} />}
                </AnimatePresence>
            </div>
        </motion.div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

// app/studio/[contentType]/[id]/ImageCompareComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { useState, useRef, useCallback } from 'react';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../actions';
import { useToast } from '@/lib/toastStore';
import styles from '@/components/ImageCompare.module.css';
import editorStyles from './Editor.module.css';
import Image from 'next/image';

const UploadIcon = () => <svg className={styles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg>;
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const SizeSmallIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="6" rx="1"/><rect x="3" y="15" width="18" height="6" rx="1"/></svg>;
const SizeMediumIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="10" rx="1"/><rect x="3" y="17" width="18" height="4" rx="1"/></svg>;
const SizeLargeIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="1"/></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: 'left' | 'right', src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) { onUpload(file); } }; 
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); }; 
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); }; 
    return ( <div className={`${styles.dropzone} ${isDragging ? styles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}> <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} /> {src && <Image src={src} alt={`Image ${side}`} fill className={styles.imagePreview} />} <div className={styles.dropzoneContent}> <UploadIcon /> <span>{src ? `تغيير الصورة ${side === 'left' ? 1 : 2}` : `أفلت صورةً أو انقر للرفع`}</span> </div> </div> ); 
};

export const ImageCompareComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, side: 'left' | 'right') => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
            
            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({
                    [side === 'left' ? 'src1' : 'src2']: result.asset.url,
                    [side === 'left' ? 'assetId1' : 'assetId2']: result.asset._id,
                });
                toast.success('رُفِعت الصورة.', 'left');
            } else {
                throw new Error(result.error || 'أخفق رفع أصل الصورة.');
            }
        } catch (error: any) {
            toast.error(error.message || 'أخفقت معالجة الصورة.', 'left');
        }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();
    const handleSizeChange = (size: 'small' | 'medium' | 'large') => updateAttributes({ 'data-size': size });
    const currentSize = node.attrs['data-size'] || 'large';

    return (
        <NodeViewWrapper as="div" className={editorStyles.imageCompareContainer} data-size={currentSize} data-drag-handle>
            {(node.attrs.src1 && node.attrs.src2) ? (
                <div className={styles.compareWrapper}>
                    <ReactCompareSlider itemOne={<ReactCompareSliderImage src={node.attrs.src1} alt="Image 1" />} itemTwo={<ReactCompareSliderImage src={node.attrs.src2} alt="Image 2" />} />
                </div>
            ) : (
                <div className={styles.compareWrapper}>
                    <div className={styles.placeholder}>
                        <Dropzone side="left" src={node.attrs.src1} onUpload={(file) => handleUpload(file, 'left')} />
                        <Dropzone side="right" src={node.attrs.src2} onUpload={(file) => handleUpload(file, 'right')} />
                    </div>
                </div>
            )}
             <div className={editorStyles.imageNodeMenu} contentEditable={false}>
                <button onClick={() => handleSizeChange('small')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'small' ? editorStyles.active : ''}`}><SizeSmallIcon /></button>
                <button onClick={() => handleSizeChange('medium')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'medium' ? editorStyles.active : ''}`}><SizeMediumIcon /></button>
                <button onClick={() => handleSizeChange('large')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'large' ? editorStyles.active : ''}`}><SizeLargeIcon /></button>
                <div style={{width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.4rem'}} />
                <button onClick={handleDelete} className={`${editorStyles.bubbleMenuButton} ${editorStyles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

// app/studio/[contentType]/[id]/ImageResizeComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import styles from './Editor.module.css';

const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export const ImageResizeComponent = ({ editor, node, updateAttributes, getPos }: NodeViewProps) => {
    
    const handleDelete = () => {
        editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run()
    }

    // Removed data-size and assetId from props to be passed down
    const { assetId, 'data-size': dataSize, ...imgAttributes } = node.attrs;

    return (
        <NodeViewWrapper 
            className={styles.imageNodeContainer} 
            data-drag-handle
        >
            <img {...imgAttributes} alt={imgAttributes.alt || ''} />

            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

// app/studio/[contentType]/[id]/LinkEditorModal.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import editorStyles from './Editor.module.css'; // <-- IMPORTED for input styles
import modalStyles from '@/components/modals/Modals.module.css'; // <-- IMPORTED for modal layout

interface LinkEditorModalProps { isOpen: boolean; onClose: () => void; onSubmit: (url: string) => void; onRemove: () => void; initialUrl?: string; }
const modalVariants = { hidden: { opacity: 0, scale: 0.9, y: 20 }, visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring' as const, damping: 20, stiffness: 250 } }, exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } }, };

export function LinkEditorModal({ isOpen, onClose, onSubmit, onRemove, initialUrl }: LinkEditorModalProps) {
    const [url, setUrl] = useState('');

    useEffect(() => { if (isOpen) { setUrl(initialUrl || ''); } }, [isOpen, initialUrl]);
    const handleSubmit = (e: React.FormEvent) => { e.preventDefault(); if (url.trim()) { onSubmit(url); } };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div onMouseDown={(e) => e.preventDefault()} className={modalStyles.modalOverlay} style={{ zIndex: 5001, backgroundColor: 'transparent', backdropFilter: 'none' }} onClick={onClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={modalStyles.modalContent} style={{ padding: '2rem', maxWidth: '400px' }} variants={modalVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
                        <form onSubmit={handleSubmit}>
                            <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-ui)' }}>تعديل الرابط</h3>
                            <input type="url" value={url} onChange={(e) => setUrl(e.target.value)} placeholder="https://example.com" className={editorStyles.sidebarInput} autoFocus style={{ marginBottom: '1.5rem' }} />
                            <div className={modalStyles.modalActions} style={{ justifyContent: 'space-between' }}>
                                {initialUrl && (<button type="button" onClick={onRemove} className="outline-button" style={{ borderColor: '#DC2626', color: '#DC2626' }}>إزالة الرابط</button>)}
                                <div style={{ display: 'flex', gap: '1rem', marginLeft: 'auto' }}>
                                    <button type="button" onClick={onClose} className="outline-button">إلغاء</button>
                                    <button type="submit" className="primary-button">تطبيق</button>
                                </div>
                            </div>
                        </form>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

// app/studio/[contentType]/[id]/RichTextEditor.tsx
'use client'

import {
  useEditor,
  EditorContent,
  Editor,
  ReactNodeViewRenderer,
  BubbleMenu,
} from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Placeholder from '@tiptap/extension-placeholder'
import Link from '@tiptap/extension-link'
import Heading from '@tiptap/extension-heading'
import BulletList from '@tiptap/extension-bullet-list'
import ListItem from '@tiptap/extension-list-item'
import Bold from '@tiptap/extension-bold'
import Blockquote from '@tiptap/extension-blockquote'
import TextStyle from '@tiptap/extension-text-style'
import {Color} from '@tiptap/extension-color'
import {InputRule, Node, mergeAttributes, Extension} from '@tiptap/core'
import {Plugin, PluginKey} from '@tiptap/pm/state'
import {slugify} from 'transliteration'
import {useState, useEffect, useCallback, useRef} from 'react'
import React from 'react'
import {motion, AnimatePresence} from 'framer-motion'
import {useToast} from '@/lib/toastStore'
import {optimizeImageForUpload, UploadQuality} from '@/lib/image-optimizer'
import {uploadSanityAssetAction} from '../../actions'
import {FormattingToolbar} from './FormattingToolbar'
import {LinkEditorModal} from './LinkEditorModal'
import {ImageResizeComponent} from './ImageResizeComponent'
import {ImageCompareComponent} from './ImageCompareComponent'
import {TwoImageGridComponent} from './editor-components/TwoImageGridComponent'
import {FourImageGridComponent} from './editor-components/FourImageGridComponent'
import {GameDetailsNode} from './extensions/GameDetailsNode'
import Table from '@tiptap/extension-table'
import TableRow from '@tiptap/extension-table-row'
import TableCell from '@tiptap/extension-table-cell'
import TableHeader from '@tiptap/extension-table-header'
import {TableComponent} from './editor-components/TableComponent'
import {AutoColorExtension} from './extensions/AutoColorExtension'
import {YoutubeNode} from './extensions/YoutubeNode'
import { DeactivateMarksExtension } from './extensions/DeactivateMarksExtension'; // <-- IMPORT THE NEW EXTENSION
import styles from './Editor.module.css'

const DragIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" fill="none" {...props}>
    <path
      d="M20.964 4H16.9719M20.964 4C20.964 4.56018 19.4727 5.60678 18.9679 6M20.964 4C20.964 3.43982 19.4727 2.39322 18.9679 2"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
    <path
      d="M2.99921 4H6.99136M2.99921 4C2.99921 3.43982 4.49058 2.39322 4.99529 2M2.99921 4C2.99921 4.56018 4.49058 5.60678 4.99529 6"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
    <path
      d="M9.81505 22.0006V21.0595C9.81505 20.4116 9.60526 19.781 9.21707 19.2622L5.39435 14.1534C5.07668 13.7288 4.83978 13.2141 4.98565 12.7043C5.34585 11.4454 6.76792 10.3261 8.35901 12.2974L9.95917 14.0049V3.59381C10.0573 1.76459 13.1325 1.18685 13.4504 3.59381V9.52698C14.933 9.33608 21.9162 10.378 20.9003 14.7917C20.8517 15.0026 20.8032 15.2167 20.7557 15.4279C20.5493 16.346 19.9407 17.98 19.2696 18.9355C18.5705 19.9309 18.897 21.5353 18.8172 22.0019"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
  </svg>
)

const formatFileSize = (bytes: number): string => {
  if (bytes < 1024) return `${bytes} B`
  const kb = bytes / 1024
  if (kb < 1024) return `${kb.toFixed(1)} KB`
  const mb = kb / 1024
  return `${mb.toFixed(2)} MB`
}

export const uploadFile = async (
  file: File,
  editor: Editor,
  toast: ReturnType<typeof useToast>,
  quality: UploadQuality,
) => {
  try {
    toast.info('جارٍ تهيئة الصورة للرفع...', 'left')
    const {file: optimizedFile, finalQuality} = await optimizeImageForUpload(file, quality)

    const reader = new FileReader()
    reader.readAsDataURL(optimizedFile)
    reader.onload = async () => {
      const {tr} = editor.state
      const node = editor.state.schema.nodes.image.create({src: reader.result as string})
      const transaction = tr.replaceSelectionWith(node)
      editor.view.dispatch(transaction)

      toast.info(
        `جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(
          finalQuality * 100,
        )}%)...`,
        'left',
      )

      const formData = new FormData()
      formData.append('file', optimizedFile)
      const result = await uploadSanityAssetAction(formData)

      let imagePos: number | null = null
      editor.state.doc.descendants((node, pos) => {
        if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
          imagePos = pos
          return false
        }
        return true
      })

      if (imagePos !== null) {
        if (result.success && result.asset) {
          const finalTransaction = editor.state.tr.setNodeMarkup(imagePos, undefined, {
            ...editor.state.doc.nodeAt(imagePos)?.attrs,
            src: result.asset.url,
            assetId: result.asset._id,
          })
          editor.view.dispatch(finalTransaction)
          toast.success('رُفِعت الصورة.', 'left')
        } else {
          throw new Error(result.error || 'أخفق رفع أصل الصورة.')
        }
      }
    }
  } catch (error: any) {
    toast.error(error.message || 'أخفق رفع الصورة.', 'left')
    let imagePos: number | null = null
    editor.state.doc.descendants((node, pos) => {
      if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
        imagePos = pos
        return false
      }
      return true
    })
    if (imagePos !== null) {
      const failedTransaction = editor.state.tr.delete(imagePos, imagePos + 1)
      editor.view.dispatch(failedTransaction)
    }
  }
}

const TrailingNode = Extension.create({
  name: 'trailingNode',
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('trailingNode'),
        appendTransaction: (transactions, oldState, newState) => {
          const {doc, tr} = newState
          const shouldInsertNodeAtEnd = transactions.some((transaction) => transaction.docChanged)
          if (!shouldInsertNodeAtEnd) return

          const endPosition = doc.content.size
          const lastNode = doc.lastChild

          const nodeTypesThatNeedTrailingNode = [
            'image',
            'imageCompare',
            'twoImageGrid',
            'fourImageGrid',
            'gameDetails',
            'heading',
            'blockquote',
            'table',
            'youtube',
          ]

          if (lastNode && nodeTypesThatNeedTrailingNode.includes(lastNode.type.name)) {
            const paragraph = newState.schema.nodes.paragraph.create()
            return tr.insert(endPosition, paragraph)
          }
          return
        },
      }),
    ]
  },
})

const ImageCompareNode = Node.create({
  name: 'imageCompare',
  group: 'block',
  atom: true,
  addAttributes() {
    return {
      src1: {default: null},
      assetId1: {default: null},
      src2: {default: null},
      assetId2: {default: null},
      'data-size': {default: 'large'},
    }
  },
  parseHTML() {
    return [{tag: 'div[data-type="image-compare"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'image-compare'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(ImageCompareComponent)
  },
})
const CustomImage = Node.create({
  name: 'image',
  group: 'block',
  atom: true,
  draggable: true,
  addAttributes() {
    return {
      src: {default: null},
      alt: {default: null},
      title: {default: null},
      assetId: {default: null},
    }
  },
  parseHTML() {
    return [{tag: 'img[src]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', {'data-type': 'custom-image'}, ['img', HTMLAttributes]]
  },
  addNodeView() {
    return ReactNodeViewRenderer(ImageResizeComponent)
  },
})
const TwoImageGridNode = Node.create({
  name: 'twoImageGrid',
  group: 'block',
  atom: true,
  addAttributes() {
    return {src1: null, assetId1: null, src2: null, assetId2: null}
  },
  parseHTML() {
    return [{tag: 'div[data-type="two-image-grid"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'two-image-grid'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(TwoImageGridComponent)
  },
})
const FourImageGridNode = Node.create({
  name: 'fourImageGrid',
  group: 'block',
  atom: true,
  addAttributes() {
    return {
      src1: null,
      assetId1: null,
      src2: null,
      assetId2: null,
      src3: null,
      assetId3: null,
      src4: null,
      assetId4: null,
    }
  },
  parseHTML() {
    return [{tag: 'div[data-type="four-image-grid"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'four-image-grid'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(FourImageGridComponent)
  },
})

interface RichTextEditorProps {
  onEditorCreated: (editor: Editor) => void
  initialContent?: any
  colorDictionary?: {word: string; color: string}[]
}

export default function RichTextEditor({
  onEditorCreated,
  initialContent,
  colorDictionary = [],
}: RichTextEditorProps) {
  const toast = useToast()
  const [isLinkModalOpen, setIsLinkModalOpen] = useState(false)
  const [currentLinkUrl, setCurrentLinkUrl] = useState<string | undefined>(undefined)
  const [isMobile, setIsMobile] = useState(false)
  const [platform, setPlatform] = useState<'ios' | 'android' | 'desktop'>('desktop')
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false)
  const bubbleMenuRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)

    const ua = navigator.userAgent
    if (/iPad|iPhone|iPod/.test(ua)) setPlatform('ios')
    else if (/Android/.test(ua)) setPlatform('android')
    else setPlatform('desktop')

    const visualViewport = window.visualViewport
    if (visualViewport) {
      const handleViewportChange = () => {
        const isKeyboardVisible = visualViewport.height < window.innerHeight * 0.9
        setIsKeyboardOpen(isKeyboardVisible)
      }
      visualViewport.addEventListener('resize', handleViewportChange)
      return () => visualViewport.removeEventListener('resize', handleViewportChange)
    }
  }, [])

  const editor = useEditor(
    {
      extensions: [
        StarterKit.configure({heading: false, bulletList: false, listItem: false, bold: false, blockquote: false}),
        TextStyle,
        Color,
        AutoColorExtension.configure({
          colorMappings: colorDictionary,
        }),
        DeactivateMarksExtension, // <-- USE THE NEW, CORRECT EXTENSION
        Bold.extend({
          addInputRules() {
            return [
              new InputRule({
                find: /(?:^|\s)(\*\*(?!\s+\*\*).+\*\*(?!\s+\*\*))$/,
                handler: ({state, range, match}) => {
                  const {tr} = state
                  const text = match[1]
                  const start = range.from
                  const end = range.to
                  tr.delete(start, end)
                  tr.insertText(text.slice(2, -2), start)
                  tr.addMark(start, start + text.length - 4, this.type.create())
                },
              }),
            ]
          },
        }),
        Heading.configure({levels: [1, 2, 3]}).extend({
          onCreate() {
            const editor = this.editor
            const transaction = editor.state.tr
            editor.state.doc.descendants((node, pos) => {
              if (node.type.name === 'heading' && !node.attrs.id) {
                const id = slugify(node.textContent)
                transaction.setNodeMarkup(pos, undefined, {...node.attrs, id})
              }
            })
            transaction.setMeta('addToHistory', false)
            editor.view.dispatch(transaction)
          },
          addAttributes() {
            return {
              ...this.parent?.(),
              id: {
                default: null,
                parseHTML: (element) => element.getAttribute('id'),
                renderHTML: (attributes) => {
                  if (!attributes.id) {
                    return {}
                  }
                  return {id: attributes.id}
                },
              },
            }
          },
        }),
        Link.configure({
          openOnClick: false,
          autolink: true,
          HTMLAttributes: {class: 'editor-link'},
        }),
        Placeholder.configure({placeholder: 'خُطَّ ما في نفسِكَ هنا...'}),
        CustomImage,
        BulletList,
        ListItem,
        ImageCompareNode,
        TwoImageGridNode,
        FourImageGridNode,
        GameDetailsNode,
        Blockquote,
        TrailingNode,
        Table.configure({resizable: false, cellMinWidth: 100}).extend({
          addNodeView() {
            return ReactNodeViewRenderer(TableComponent)
          },
        }),
        TableRow,
        TableHeader,
        TableCell,
        YoutubeNode,
      ],
      editorProps: {
        attributes: {class: styles.tiptap},
        handlePaste(view, event, slice) {
          if (!editor) return false
          const text = event.clipboardData?.getData('text/plain')
          if (text) {
            const youtubeRegex = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
            const match = text.match(youtubeRegex)
            if (match && match[2].length === 11) {
              editor.chain().focus().setYoutubeVideo({src: text}).run()
              return true
            }
          }

          const items = Array.from(event.clipboardData?.items || [])
          const imageItem = items.find((item) => item.type.startsWith('image/'))
          if (imageItem) {
            const file = imageItem.getAsFile()
            if (file) {
              uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p')
              return true
            }
          }
          return false
        },
        handleDrop(view, event, slice, moved) {
          if (!editor || moved) return false
          const file = event.dataTransfer?.files[0]
          if (file && file.type.startsWith('image/')) {
            uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p')
            return true
          }
          return false
        },
      },
      immediatelyRender: false,
      content: initialContent || '',
      onSelectionUpdate: ({editor}) => {
        if (editor.isActive('link')) {
          setCurrentLinkUrl(editor.getAttributes('link').href)
        } else {
          setCurrentLinkUrl(undefined)
        }
      },
    },
    [colorDictionary],
  ) 

  const handleOpenLinkModal = useCallback(() => {
    setIsLinkModalOpen(true)
  }, [])
  const handleCloseLinkModal = useCallback(() => {
    setIsLinkModalOpen(false)
    setCurrentLinkUrl(undefined)
    editor?.chain().focus().run()
  }, [editor])
  const handleSetLink = useCallback(
    (url: string) => {
      if (editor) {
        editor.chain().focus().extendMarkRange('link').setLink({href: url}).run()
      }
      handleCloseLinkModal()
    },
    [editor, handleCloseLinkModal],
  )
  const handleRemoveLink = useCallback(() => {
    if (editor) {
      editor.chain().focus().extendMarkRange('link').unsetLink().run()
    }
    handleCloseLinkModal()
  }, [editor, handleCloseLinkModal])
  useEffect(() => {
    if (editor) {
      onEditorCreated(editor)
    }
  }, [editor, onEditorCreated])
  if (!editor) {
    return null
  }

  return (
    <div
      onClick={(e) => {
        const target = e.target as HTMLElement
        if (target.tagName === 'A' && target.classList.contains('editor-link')) {
          e.preventDefault()
        }
      }}
    >
      <style jsx global>{`
        .tiptap a.editor-link {
          color: var(--accent);
          text-decoration: underline;
          text-decoration-color: color-mix(in srgb, var(--accent) 50%, transparent);
          cursor: default;
        }
        .tiptap h1 {
          font-family: var(--font-main), sans-serif;
          font-size: 3.6rem;
          line-height: 1.2;
          margin: 4rem 0 2rem 0;
          padding-bottom: 0.5rem;
          border-bottom: 1px solid var(--border-color);
        }
        .tiptap h2 {
          font-family: var(--font-main), sans-serif;
          font-size: 2.8rem;
          line-height: 1.2;
          margin: 4rem 0 2rem 0;
          padding-bottom: 0.5rem;
          border-bottom: 1px solid var(--border-color);
        }
        .tiptap h3 {
          font-family: var(--font-main), sans-serif;
          font-size: 2.2rem;
          line-height: 1.2;
          margin: 3rem 0 1.5rem 0;
        }
        .tiptap blockquote {
          margin: 2rem 0;
          padding-right: 1.5rem;
          border-right: 3px solid var(--accent);
          font-style: italic;
          color: var(--text-secondary);
        }
        .tiptap p.is-empty::before {
          content: '';
          display: inline-block;
        }
        .tiptap p.is-empty {
          min-height: 1rem;
        }
      `}</style>

      <BubbleMenu
        editor={editor}
        tippyOptions={{
          duration: 100,
          placement: platform === 'android' ? 'bottom' : 'top',
          offset: [0, 8],
          appendTo: () => document.body,
        }}
        shouldShow={({editor, state}) => {
          const {from, to} = state.selection
          const isTextSelection = from !== to
          return isTextSelection
        }}
      >
        <div ref={bubbleMenuRef} className={isKeyboardOpen && isMobile ? styles.docked : ''}>
          <FormattingToolbar editor={editor} onLinkClick={handleOpenLinkModal} platform={platform} />
        </div>
      </BubbleMenu>

      <LinkEditorModal
        isOpen={isLinkModalOpen}
        onClose={handleCloseLinkModal}
        onSubmit={handleSetLink}
        onRemove={handleRemoveLink}
        initialUrl={currentLinkUrl}
      />
      <EditorContent editor={editor} />
    </div>
  )
}

--- END OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

// app/studio/[contentType]/[id]/StatefulSaveButton.tsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from '@/components/ui/StatefulButton.module.css';

const SaveIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
const CheckIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>;

type SaveStatus = 'idle' | 'saving' | 'success' | 'error';

export function StatefulSaveButton({ onSave, hasChanges }: { onSave: () => Promise<boolean>; hasChanges: boolean }) {
    const [saveStatus, setSaveStatus] = useState<SaveStatus>('idle');
    const toast = useToast();

    const handleSave = async () => {
        if (saveStatus === 'saving') return;
        setSaveStatus('saving');
        const success = await onSave();
        if (success) {
            setSaveStatus('success');
            toast.success('حُفظت التغييرات!', 'left'); // Position toast on the left for studio
            setTimeout(() => setSaveStatus('idle'), 2000);
        } else {
            setSaveStatus('error');
            toast.error('أخفق حفظ التغييرات.', 'left');
            setTimeout(() => setSaveStatus('idle'), 3000);
        }
    };

    const isSaving = saveStatus === 'saving';

    return (
        <motion.button
            onClick={handleSave}
            className={`primary-button ${styles.statefulButton} ${styles.saveButton} ${styles[saveStatus]}`}
            disabled={isSaving || !hasChanges}
            animate={{
                width: isSaving || saveStatus === 'success' ? '48px' : '100%',
                height: '48px',
                borderRadius: isSaving || saveStatus === 'success' ? '50%' : '5px',
            }}
            transition={{ type: 'spring', stiffness: 300, damping: 20 }}
        >
            <AnimatePresence mode="wait">
                {saveStatus === 'saving' && <ButtonLoader key="loader" />}
                {saveStatus === 'success' && <motion.div key="success" initial={{ scale: 0 }} animate={{ scale: 1 }} exit={{ scale: 0 }}><CheckIcon /></motion.div>}
                {saveStatus === 'idle' && <motion.span key="idle" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
                {saveStatus === 'error' && <motion.span key="error" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
            </AnimatePresence>
        </motion.button>
    );
}










--- END OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/TableControlMenu.tsx ---



--- END OF FILE app/studio/[contentType]/[id]/TableControlMenu.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/page.tsx ---

// app/studio/[contentType]/[id]/page.tsx
import { sanityWriteClient } from '@/lib/sanity.server';
import { editorDocumentQuery, allGamesForStudioQuery, allTagsForStudioQuery, allCreatorsForStudioQuery } from '@/lib/sanity.queries';
import { EditorClient } from "./EditorClient";
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';
import { notFound } from 'next/navigation';
import { unstable_noStore as noStore } from 'next/cache';
import { groq } from 'next-sanity';

export const runtime = 'nodejs';

// ADDED: Query to fetch the color dictionary
const colorDictionaryQuery = groq`*[_type == "colorDictionary" && _id == "colorDictionary"][0]{ autoColors }`;

export default async function EditorPage({ params: paramsPromise }: { params: Promise<{ contentType: string; id: string }> }) {
    noStore();
    const params = await paramsPromise;
    
    if (!params || !params.id) {
        notFound();
    }
    
    const publicId = params.id.replace('drafts.', '');
    
    try {
        const [document, allGames, allTags, allCreators, colorDictionary] = await Promise.all([
            sanityWriteClient.fetch(editorDocumentQuery, { id: publicId }),
            sanityWriteClient.fetch(allGamesForStudioQuery),
            sanityWriteClient.fetch(allTagsForStudioQuery),
            sanityWriteClient.fetch(allCreatorsForStudioQuery),
            sanityWriteClient.fetch(colorDictionaryQuery), // ADDED: Fetch call
        ]);
        
        if (!document) {
            notFound();
        }
        
        const tiptapContent = portableTextToTiptap(document.content ?? []);
        
        const documentWithTiptapContent = { 
            ...document, 
            tiptapContent 
        };
        
        return (
            <EditorClient 
                document={documentWithTiptapContent} 
                allGames={allGames}
                allTags={allTags}
                allCreators={allCreators}
                colorDictionary={colorDictionary?.autoColors || []} // ADDED: Pass data to client
            />
        );
    } catch (err: any) {
        console.error("Failed to load editor data:", err);
        return (
            <div className="container page-container" style={{ textAlign: 'center' }}>
                <h1 className="page-title">Error Loading Editor</h1>
                <p style={{color: 'var(--text-secondary)'}}>Failed to load editor data. Please check the deployment logs for details.</p>
            </div>
        );
    }
}

--- END OF FILE app/studio/[contentType]/[id]/page.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };
    
    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && <Image src={src} alt={`Image ${side}`} fill className={compareStyles.imagePreview} />}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة ${side}` : `أفلت صورةً أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const FourImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2 | 3 | 4) => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({ [`src${slot}`]: result.asset.url, [`assetId${slot}`]: result.asset._id });
                toast.success('رُفِعت الصورة.', 'left');
            } else { throw new Error(result.error || 'فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);
    
    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.fourImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
                <Dropzone side={3} src={node.attrs.src3} onUpload={(file) => handleUpload(file, 3)} />
                <Dropzone side={4} src={node.attrs.src4} onUpload={(file) => handleUpload(file, 4)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                 <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="حذف الشبكة"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css ---

/* app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css */
.buttonContainer {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
}

.actionButton {
    /* Inherits from global .outline-button but allows for overrides */
    flex-shrink: 0;
}

@media (max-width: 768px) {
    .actionButton {
        padding: 0.6rem 1.2rem;
        font-size: 1.3rem;
    }
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import editorStyles from '../Editor.module.css';
import gameDetailsStyles from '@/components/content/GameDetails.module.css';
import componentStyles from './GameDetailsComponent.module.css'; // MODIFIED: Import new CSS module

const isRTL = (s: string) => {
  if (!s) return true;
  const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
  return rtlChars.test(s);
};

export const GameDetailsComponent = ({ node, updateAttributes, deleteNode }: NodeViewProps) => {
  const details = Array.isArray(node.attrs.details) ? node.attrs.details : [];

  const handleValueChange = (index: number, value: string) => {
    const newDetails = [...details];
    newDetails[index] = { ...newDetails[index], value };
    updateAttributes({ details: newDetails });
  };

  const handleLabelChange = (index: number, label: string) => {
    const newDetails = [...details];
    newDetails[index] = { ...newDetails[index], label };
    updateAttributes({ details: newDetails });
  };

  const addRow = () => {
    updateAttributes({ details: [...details, { label: '', value: '' }] });
  };

  const removeRow = (index: number) => {
    const newDetails = details.filter((_: any, i: number) => i !== index);
    updateAttributes({ details: newDetails });
  };

  return (
    <NodeViewWrapper as="div" className={editorStyles.imageGridContainer} data-drag-handle>
      <div className={gameDetailsStyles.detailsContainer}>
        {details.map((detail: { label: string; value: string }, index: number) => (
          <div key={index} className={gameDetailsStyles.detailRow}>
            <input
              type="text"
              value={detail.label}
              onChange={(e) => handleLabelChange(index, e.target.value)}
              placeholder="التصنيف (مثال: الناشر)"
              className={`${gameDetailsStyles.detailLabel} ${editorStyles.sidebarInput}`}
              style={{
                background: 'transparent',
                border: 'none',
                boxShadow: 'none',
                padding: '1.5rem 2rem',
                fontSize: '1.6rem',
                color: 'var(--accent)',
              }}
            />
            <input
              type="text"
              value={detail.value}
              onChange={(e) => handleValueChange(index, e.target.value)}
              placeholder="القيمة (مثال: Sony)"
              className={`${gameDetailsStyles.detailValue} ${editorStyles.sidebarInput}`}
              dir={isRTL(detail.value) ? 'rtl' : 'ltr'}
              style={{
                background: 'transparent',
                border: 'none',
                boxShadow: 'none',
                padding: '1.5rem 2rem',
                fontSize: '1.6rem',
              }}
            />
            <button
              onClick={() => removeRow(index)}
              style={{
                position: 'absolute',
                top: '50%',
                left: '10px',
                transform: 'translateY(-50%)',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                color: 'var(--text-secondary)',
              }}
            >
              <svg width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
            </button>
          </div>
        ))}
      </div>
      {/* MODIFIED: Translated text and applied responsive styling */}
      <div className={componentStyles.buttonContainer}>
        <button onClick={addRow} className={`outline-button ${componentStyles.actionButton}`}>
          + إضافة صف
        </button>
        <button onClick={deleteNode} className={`outline-button ${componentStyles.actionButton}`} style={{ borderColor: '#DC2626', color: '#DC2626' }}>
          حذف الجدول
        </button>
      </div>
    </NodeViewWrapper>
  );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css ---

/* app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css */

.creatorContainer {
    position: fixed;
    bottom: 8rem; /* Position above the MobileViewToggle */
    left: 2rem;
    right: auto;
    z-index: 2001;
}

.creatorOrb {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: var(--accent);
    color: white;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 122;
    position: relative;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

.creatorOrb.open {
    background-color: #DC2626;
    box-shadow: 0 8px 25px -5px rgba(220, 38, 38, 0.5);
}


[data-theme="dark"] .creatorOrb {
    color: var(--bg-primary);
}

.iconContainer {
    display: flex;
    align-items: center;
    justify-content: center;
}

.creatorSatellites {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 150px;
    height: 150px;
    z-index: 121;
    pointer-events: none;
}

.satelliteWrapper {
    position: absolute;
    bottom: 0;
    left: 0;
    pointer-events: auto;
    display: flex; 
    align-items: center;
    justify-content: center;
}

.satelliteOrb {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease-out;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}

.satelliteOrb:hover {
    border-color: var(--accent);
    color: var(--accent);
    transform: scale(1.1);
}

.satelliteLabel {
    display: none;
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx ---

// app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx
'use client'

import {useState, useEffect} from 'react'
import {Editor} from '@tiptap/react'
import {motion, AnimatePresence} from 'framer-motion'
import {
  CompareIcon,
  TwoImageIcon,
  FourImageIcon,
  SingleImageIcon,
  GameDetailsIcon,
  YoutubeIcon,
} from '../../../StudioIcons'
import styles from './MobileBlockCreator.module.css'

interface MobileBlockCreatorProps {
  editor: Editor | null
  onFileUpload: (file: File) => void
}

type MenuState = 'root' | 'image'

type MenuAction = {type: 'submenu'; state: MenuState} | {type: 'command'; command: string}

const menuConfig: Record<
  MenuState,
  {id: string; title: string; icon: React.ReactNode; action: MenuAction}[]
> = {
  root: [
    {id: 'image', title: 'صورة', icon: <SingleImageIcon />, action: {type: 'submenu', state: 'image'}},
    {id: 'youtube', title: 'يوتيوب', icon: <YoutubeIcon />, action: {type: 'command', command: 'youtube'}},
    {id: 'gameDetails', title: 'تفاصيل', icon: <GameDetailsIcon />, action: {type: 'command', command: 'gameDetails'}},
    {id: 'compare', title: 'مقارنة', icon: <CompareIcon />, action: {type: 'command', command: 'imageCompare'}},
  ],
  image: [
    {id: 'singleImage', title: 'صورة مفردة', icon: <SingleImageIcon />, action: {type: 'command', command: 'image'}},
    {id: 'twoImageGrid', title: 'شبكة ثنائية', icon: <TwoImageIcon />, action: {type: 'command', command: 'twoImageGrid'}},
    {id: 'fourImageGrid', title: 'شبكة رباعية', icon: <FourImageIcon />, action: {type: 'command', command: 'fourImageGrid'}},
  ],
}

const PlusIcon = () => (
  <svg
    width="28"
    height="28"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2.5"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <line x1="12" y1="5" x2="12" y2="19"></line> <line x1="5" y1="12" x2="19" y2="12"></line>{' '}
  </svg>
)

const orbContainerVariants = {
  hidden: {opacity: 0},
  visible: {opacity: 1, transition: {staggerChildren: 0.06, delayChildren: 0.1}},
  exit: {opacity: 0, transition: {staggerChildren: 0.04, staggerDirection: -1}},
}
const satelliteVariants = {
  hidden: (isRoot: boolean) => ({scale: 0, opacity: 0, x: isRoot ? 0 : -30}),
  visible: (custom: {x: number; y: number}) => ({
    scale: 1,
    opacity: 1,
    x: custom.x,
    y: custom.y,
    transition: {type: 'spring' as const, stiffness: 400, damping: 20},
  }),
  exit: (isRoot: boolean) => ({scale: 0, opacity: 0, x: isRoot ? 0 : -30, transition: {duration: 0.15}}),
}

export function MobileBlockCreator({editor, onFileUpload}: MobileBlockCreatorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [menuState, setMenuState] = useState<MenuState>('root')

  const handleAction = (action: MenuAction) => {
    if (!editor) return

    if (action.type === 'submenu' && action.state) {
      setMenuState(action.state)
    } else if (action.type === 'command' && action.command) {
      const cmd = action.command
      if (cmd === 'image') {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'image/*'
        input.onchange = (e) => {
          const file = (e.target as HTMLInputElement).files?.[0]
          if (file) {
            onFileUpload(file)
          }
        }
        input.click()
      } else if (cmd === 'table') {
        editor.chain().focus().insertTable({rows: 2, cols: 2, withHeaderRow: true}).run()
      } else {
        editor.chain().focus().insertContent({type: cmd}).run()
      }
      setIsOpen(false)
    }
  }

  const handleMainOrbClick = () => {
    if (!isOpen) {
      setIsOpen(true)
      setMenuState('root')
    } else {
      setIsOpen(false)
    }
  }

  useEffect(() => {
    if (!isOpen) {
      const timer = setTimeout(() => setMenuState('root'), 200)
      return () => clearTimeout(timer)
    }
  }, [isOpen])

  const currentMenuItems = menuConfig[menuState]

  return (
    <div className={styles.creatorContainer}>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            key={menuState}
            className={styles.creatorSatellites}
            variants={orbContainerVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
          >
            {currentMenuItems.map((item, i) => {
              const numItems = currentMenuItems.length
              const angleIncrement = 90 / (numItems > 1 ? numItems - 1 : 1)
              const angleInDegrees = -90 + i * angleIncrement
              const angleInRadians = angleInDegrees * (Math.PI / 180)
              const radius = 85
              const x = Math.cos(angleInRadians) * radius
              const y = Math.sin(angleInRadians) * radius
              return (
                <motion.div
                  key={item.id}
                  className={styles.satelliteWrapper}
                  custom={{x, y}}
                  variants={satelliteVariants}
                  custom-isRoot={menuState === 'root'}
                >
                  <button
                    className={styles.satelliteOrb}
                    onClick={() => handleAction(item.action)}
                    disabled={!editor}
                    title={item.title}
                  >
                    {item.icon}
                  </button>
                </motion.div>
              )
            })}
          </motion.div>
        )}
      </AnimatePresence>
      <motion.button
        onClick={handleMainOrbClick}
        className={`${styles.creatorOrb} ${isOpen ? styles.open : ''}`}
        whileHover={{scale: 1.1}}
        whileTap={{scale: 0.95}}
        transition={{type: 'spring' as const, stiffness: 400, damping: 20}}
      >
        <motion.div animate={{rotate: isOpen ? 45 : 0}} className={styles.iconContainer}>
          <PlusIcon />
        </motion.div>
      </motion.button>
    </div>
  )
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileFormattingToolbar.tsx ---



--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileFormattingToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css ---

/* app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css */

.toggleContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background-color: var(--bg-secondary);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-around;
    align-items: center;
    z-index: 150; /* Above editor, below sidebar overlay */
}

.toggleButton {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-secondary);
    transition: color 0.2s ease, background-color 0.2s ease;
}

.toggleButton.active {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.divider {
    width: 1px;
    height: 24px;
    background-color: var(--border-color);
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx ---

// components/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './MobileViewToggle.module.css';

interface MobileViewToggleProps {
    isSidebarOpen: boolean;
    setIsSidebarOpen: (isOpen: boolean) => void;
}

const PenIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>;
const SettingsIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;

export function MobileViewToggle({ isSidebarOpen, setIsSidebarOpen }: MobileViewToggleProps) {
    return (
        <motion.div 
            className={styles.toggleContainer}
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: 'spring', stiffness: 400, damping: 30 }}
        >
            <button className={`${styles.toggleButton} ${isSidebarOpen ? styles.active : ''}`} onClick={() => setIsSidebarOpen(true)}>
                <SettingsIcon />
                <span>الشريط الجانبي</span>
            </button>
            <div className={styles.divider}></div>
            <button className={`${styles.toggleButton} ${!isSidebarOpen ? styles.active : ''}`} onClick={() => setIsSidebarOpen(false)}>
                <PenIcon />
                <span>المحتوى</span>
            </button>
        </motion.div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

// app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx
'use client';

import { UploadQuality } from '@/lib/image-optimizer';
import styles from '../BlockToolbar.module.css';
import bubbleStyles from '../Editor.module.css';
import editorStyles from '../Editor.module.css';

interface QualityToggleProps {
    currentQuality: UploadQuality;
    onQualityChange: (quality: UploadQuality) => void;
    isMobile?: boolean;
}

const qualityCycle: UploadQuality[] = ['1080p', '4k', '8k'];
const qualityLabels: Record<UploadQuality, string> = {
    '1080p': 'FHD',
    '4k': '4K',
    '8k': '8K'
};
const qualityTooltips: Record<UploadQuality, string> = {
    '1080p': 'Full HD (1080p)',
    '4k': 'Ultra HD (4K)',
    '8k': 'Full Ultra HD (8K)'
};

export function QualityToggle({ currentQuality, onQualityChange, isMobile = false }: QualityToggleProps) {
    
    const cycleQuality = () => {
        const currentIndex = qualityCycle.indexOf(currentQuality);
        const nextIndex = (currentIndex + 1) % qualityCycle.length;
        onQualityChange(qualityCycle[nextIndex]);
    };

    if (isMobile) {
        return (
             <button
                onClick={cycleQuality}
                className={editorStyles.iconButton}
                style={{ width: '36px', height: '36px' }}
                title={`جودة الرفع: ${qualityTooltips[currentQuality]}`}
            >
                <span style={{ fontSize: '12px', fontWeight: 700, color: 'var(--accent)' }}>
                    {qualityLabels[currentQuality]}
                </span>
            </button>
        );
    }

    return (
        <div className={styles.optionButtonWrapper}>
            <button
                onClick={cycleQuality}
                className={bubbleStyles.bubbleMenuButton}
                title={`Cycle upload quality`}
            >
                <span style={{ fontSize: '13px', fontWeight: 700, color: 'var(--accent)' }}>
                    {qualityLabels[currentQuality]}
                </span>
            </button>
            <div className={styles.optionTooltip}>
                جودة الرفع: {qualityTooltips[currentQuality]}
            </div>
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.module.css ---



--- END OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/TableComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps, NodeViewContent } from '@tiptap/react';
import styles from '../Editor.module.css';
import gameDetailsStyles from '@/components/content/GameDetails.module.css';

export const TableComponent = ({ editor, getPos, deleteNode }: NodeViewProps) => {
    
    const addColumn = () => {
        editor.chain().focus().addColumnAfter().run();
    };

    const deleteColumn = () => {
        editor.chain().focus().deleteColumn().run();
    };

    const addRow = () => {
        editor.chain().focus().addRowAfter().run();
    };

    return (
        <NodeViewWrapper as="div" className={`${styles.imageGridContainer} imageGridContainer`} data-drag-handle>
            <div className={gameDetailsStyles.detailsContainer}>
                {/* NodeViewContent will render the table's `tbody` content here */}
                <NodeViewContent as="table" />
            </div>
            <div style={{ display: 'flex', justifyContent: 'center', gap: '1rem', marginTop: '1rem' }}>
                <button onClick={addRow} className="outline-button">
                    + Add Row
                </button>
                <button onClick={addColumn} className="outline-button">
                    + Add Column
                </button>
                <button onClick={deleteColumn} className="outline-button">
                    - Delete Column
                </button>
                <button onClick={deleteNode} className="outline-button" style={{ borderColor: '#DC2626', color: '#DC2626' }}>
                    Delete Block
                </button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };

    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && <Image src={src} alt={`Image ${side}`} fill className={compareStyles.imagePreview} />}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة` : `أفلت صورةً أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const TwoImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2) => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({ [`src${slot}`]: result.asset.url, [`assetId${slot}`]: result.asset._id });
                toast.success('رُفِعت الصورة.', 'left');
            } else { throw new Error(result.error || 'فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.twoImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="حذف الشبكة"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css ---

/* app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css */
.youtubeContainer {
  position: relative;
  margin: 2rem 0;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  padding: 1rem;
  background-color: var(--bg-primary);
  transition: box-shadow 0.2s ease-out;
}

.ProseMirror-selectednode .youtubeContainer {
  box-shadow: 0 0 0 3px var(--accent);
}

.urlInputContainer {
  padding: 2rem;
}

.iframeContainer {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  border-radius: 8px;
  overflow: hidden;
}

.iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: none;
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx
'use client'

import {NodeViewWrapper, NodeViewProps} from '@tiptap/react'
import {useState} from 'react'
import styles from './YoutubeComponent.module.css'
import editorStyles from '../Editor.module.css'

const getYouTubeId = (url: string): string | null => {
  if (!url) return null
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
  const match = url.match(regExp)
  return match && match[2].length === 11 ? match[2] : null
}

export const YoutubeComponent = ({
  node,
  updateAttributes,
  deleteNode,
}: NodeViewProps) => {
  const [urlInput, setUrlInput] = useState(node.attrs.src || '')
  const videoId = getYouTubeId(node.attrs.src)

  const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setUrlInput(e.target.value)
  }

  const handleUpdate = () => {
    updateAttributes({src: urlInput})
  }

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleUpdate()
    }
  }

  return (
    <NodeViewWrapper as="div" className={styles.youtubeContainer} data-drag-handle>
      {!videoId ? (
        <div className={styles.urlInputContainer}>
          <input
            type="text"
            value={urlInput}
            onChange={handleUrlChange}
            onKeyDown={handleKeyDown}
            onBlur={handleUpdate}
            placeholder="ألصق رابط يوتيوب هنا ثم اضغط إدخال"
            className={editorStyles.sidebarInput}
            autoFocus
          />
        </div>
      ) : (
        <div className={styles.iframeContainer}>
          <iframe
            src={`https://www.youtube.com/embed/${videoId}`}
            title="YouTube video player"
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            className={styles.iframe}
          ></iframe>
        </div>
      )}

      <div className={editorStyles.imageNodeMenu} contentEditable={false}>
        <button
          onClick={deleteNode}
          className={`${editorStyles.bubbleMenuButton} ${editorStyles.deleteButton}`}
          title="Delete Video"
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
        </button>
      </div>
    </NodeViewWrapper>
  )
}

--- END OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts ---

// app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { Node as ProsemirrorNode } from 'prosemirror-model';

type ColorMapping = {
  word: string;
  color: string;
};

export interface AutoColorOptions {
  colorMappings: ColorMapping[];
}

function escapeRegExp(string: string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

export const AutoColorExtension = Extension.create<AutoColorOptions>({
  name: 'autoColor',

  addOptions() {
    return {
      colorMappings: [],
    };
  },

  addProseMirrorPlugins() {
    const { colorMappings } = this.options;
    
    // THE DEFINITIVE FIX: This new implementation is more performant and less disruptive.
    // It scans the document only for words that *should* be colored but currently aren't.
    // It avoids removing and re-adding marks on every change, which was causing the editor
    // to lose track of the active color mark at the cursor position.
    return [
      new Plugin({
        key: new PluginKey('autoColorApply'),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanged = transactions.some(transaction => transaction.docChanged);
          if (!docChanged || colorMappings.length === 0) {
            return null;
          }

          const tr = newState.tr;
          let modified = false;

          const wordsToFind = colorMappings.map(m => escapeRegExp(m.word)).join('|');
          const searchRegex = new RegExp(`\\b(${wordsToFind})\\b`, 'gi');
          const colorMap = new Map(colorMappings.map(item => [item.word.toLowerCase(), item.color]));
          
          const textStyleMark = this.editor.schema.marks.textStyle;

          newState.doc.forEach((node: ProsemirrorNode, pos: number) => {
            if (!node.isBlock || !node.textContent) {
              return;
            }

            node.forEach((childNode: ProsemirrorNode, offset: number) => {
              if (!childNode.isText) return;

              const text = childNode.text ?? '';
              let match;

              while ((match = searchRegex.exec(text)) !== null) {
                const matchedWord = match[0];
                const from = pos + 1 + offset + match.index;
                const to = from + matchedWord.length;

                const hasColorMark = newState.doc.rangeHasMark(from, to, textStyleMark);
                
                // Only apply the mark if one doesn't already exist.
                if (!hasColorMark) {
                  const color = colorMap.get(matchedWord.toLowerCase());
                  if (color) {
                    tr.addMark(from, to, textStyleMark.create({ color }));
                    modified = true;
                  }
                }
              }
            });
          });

          if (!modified) {
            return null;
          }

          // Return the transaction without setting 'addToHistory' to false,
          // allowing the changes to be part of the undo stack.
          return tr;
        },
      }),
    ];
  },
});

--- END OF FILE app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts ---

// app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { Step } from 'prosemirror-transform';
import { EditorView } from 'prosemirror-view'; // <-- IMPORT THE NECESSARY TYPE

export const DeactivateMarksExtension = Extension.create({
    name: 'deactivateMarks',

    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('deactivateMarks'),

                // This handles the spacebar press directly.
                // THE FIX: Added explicit types for all parameters.
                handleTextInput: (view: EditorView, from: number, to: number, text: string) => {
                    // Check if the input is a space and if there are stored marks.
                    if (text === ' ' && view.state.storedMarks && view.state.storedMarks.length > 0) {
                        // If yes, dispatch a transaction to clear the stored marks.
                        view.dispatch(view.state.tr.setStoredMarks([]));
                    }
                    // Return false to allow the default input handling to proceed (i.e., inserting the space).
                    return false;
                },

                // This handles moving the cursor with arrow keys or mouse clicks.
                appendTransaction: (transactions, oldState, newState) => {
                    const hasSelectionChanged = !oldState.selection.eq(newState.selection);

                    // If the selection changed to a single cursor point and there are stored marks...
                    if (hasSelectionChanged && newState.selection.empty && newState.storedMarks && newState.storedMarks.length > 0) {
                        // ...create and return a new transaction that clears them.
                        return newState.tr.setStoredMarks([]);
                    }

                    return null;
                },
            }),
        ];
    },
});

--- END OF FILE app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts ---

// app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts
import { Node, mergeAttributes } from '@tiptap/core';
import { ReactNodeViewRenderer } from '@tiptap/react';
import { GameDetailsComponent } from '../editor-components/GameDetailsComponent';

export const GameDetailsNode = Node.create({
  name: 'gameDetails',
  group: 'block',
  atom: true,
  draggable: true,

  addAttributes() {
    return {
      details: {
        default: [{ label: 'الناشر', value: '' }],
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="game-details"]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', mergeAttributes({ 'data-type': 'game-details' }, HTMLAttributes)];
  },

  addNodeView() {
    return ReactNodeViewRenderer(GameDetailsComponent);
  },
});

--- END OF FILE app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/YoutubeNode.ts ---

// app/studio/[contentType]/[id]/extensions/YoutubeNode.ts
import {Node, mergeAttributes} from '@tiptap/core'
import {ReactNodeViewRenderer} from '@tiptap/react'
import {YoutubeComponent} from '../editor-components/YoutubeComponent'

export interface YoutubeOptions {
    src: string;
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        youtube: {
            setYoutubeVideo: (options: YoutubeOptions) => ReturnType,
        }
    }
}

export const YoutubeNode = Node.create({
  name: 'youtube',
  group: 'block',
  atom: true,
  draggable: true,

  addAttributes() {
    return {
      src: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-youtube-video]',
        getAttrs: (dom) => {
          const iframe = (dom as HTMLElement).querySelector('iframe')
          return {src: iframe?.src}
        },
      },
    ]
  },

  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-youtube-video': ''}, HTMLAttributes)]
  },

  addNodeView() {
    return ReactNodeViewRenderer(YoutubeComponent)
  },

  addCommands() {
    return {
      setYoutubeVideo: (options: YoutubeOptions) => ({ commands }) => {
          return commands.insertContent({
            type: this.name,
            attrs: options,
          })
        },
    }
  },
})

--- END OF FILE app/studio/[contentType]/[id]/extensions/YoutubeNode.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddGameModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from '@/components/modals/Modals.module.css';

interface AddGameModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddGameModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddGameModalProps) {
    const [gameTitle, setGameTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setGameTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (gameTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(gameTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
             <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إنشاء لعبة جديدة</h3>
                <input
                    type="text"
                    value={gameTitle}
                    onChange={(e) => setGameTitle(e.target.value)}
                    placeholder="مثال: Elden Ring"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !gameTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddTagModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from '@/components/modals/Modals.module.css';

interface AddTagModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddTagModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddTagModalProps) {
    const [tagTitle, setTagTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setTagTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (tagTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(tagTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
            <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إضافة وسم جديد</h3>
                <input
                    type="text"
                    value={tagTitle}
                    onChange={(e) => setTagTitle(e.target.value)}
                    placeholder="مثال: RPG"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !tagTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

// app/studio/[contentType]/[id]/metadata/CreatorInput.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';
import filterStyles from '@/components/filters/Filters.module.css'; // Import for backdrop

type Creator = { _id: string; name: string };
interface CreatorInputProps { label: string; allCreators: Creator[]; selectedCreators: Creator[]; onCreatorsChange: (creators: Creator[]) => void; }

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};

const CreatorChip = ({ creator, onRemove }: { creator: Creator, onRemove: (creatorId: string) => void }) => {
    return (
        <motion.div onClick={(e) => { e.stopPropagation(); onRemove(creator._id); }} layout variants={{ initial: { opacity: 0, scale: 0.5 }, visible: { opacity: 1, scale: 1 }, exiting: { opacity: 0, scale: 0.6 } }} initial="initial" animate="visible" exit="exiting" style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 1, cursor: 'pointer' }} title={`Click to remove "${creator.name}"`} whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}>
            <span>{creator.name}</span>
            <svg width="12" height="12" viewBox="0 0 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function CreatorInput({ label, allCreators = [], selectedCreators = [], onCreatorsChange }: CreatorInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const validSelectedCreators = (selectedCreators || []).filter(Boolean);
    const filteredResults = (searchTerm
        ? allCreators.filter(c => c.name.toLowerCase().includes(searchTerm.toLowerCase()))
        : allCreators
    ).filter(res => !validSelectedCreators.some(sel => sel._id === res._id));
    
    useEffect(() => { if (isPopoverOpen) { setTimeout(() => inputRef.current?.focus(), 100); } else { setSearchTerm(''); } }, [isPopoverOpen]);

    const addCreator = (creator: Creator) => {
        if (!validSelectedCreators.some(c => c._id === creator._id)) {
            onCreatorsChange([...validSelectedCreators, creator]);
        }
        setSearchTerm('');
        inputRef.current?.focus();
    };
    
    const removeCreator = (creatorIdToRemove: string) => {
        onCreatorsChange(validSelectedCreators.filter(c => c._id !== creatorIdToRemove));
    };

    return (
        <div className={styles.sidebarSection} ref={wrapperRef}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                <div 
                    className={styles.sidebarInput} 
                    style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text' }} 
                    onClick={() => setIsPopoverOpen(true)}
                >
                    <AnimatePresence>
                        {validSelectedCreators.map(creator => (<CreatorChip key={creator._id} creator={creator} onRemove={removeCreator} />))}
                    </AnimatePresence>
                    
                    {validSelectedCreators.length === 0 && !isPopoverOpen && (
                        <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>{`انقر لإضافة ${label.toLowerCase()}`}</span>
                    )}
                </div>
                
                <AnimatePresence>
                    {isPopoverOpen && (
                        <>
                            <div className={filterStyles.popoverBackdrop} onClick={() => setIsPopoverOpen(false)}></div>
                            <motion.div 
                                onClick={(e) => e.stopPropagation()} 
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, 
                                    width: '100%',
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 10, 
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)', marginTop: '0.5rem'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder={`ابحث بالاسم...`} className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredResults.length > 0 ? (
                                        filteredResults.map(creator => ( <button type="button" key={creator._id} onClick={() => addCreator(creator)} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} className={styles.popoverItemButton}> {creator.name} </button> ))
                                    ) : (
                                        <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>لا يوجد نتائج.</div>
                                    )}
                                </div>
                            </motion.div>
                        </>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

// app/studio/[contentType]/[id]/metadata/GameInput.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createGameAction } from '../../../actions';
import { AddGameModal } from './AddGameModal';
import ActionButton from '@/components/ActionButton';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Game = { _id: string; title: string };
interface GameInputProps { allGames: Game[]; selectedGame: Game | null; onGameSelect: (game: Game | null) => void; }
const popoverVariants = { hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, };
const itemVariants = { hidden: { opacity: 0, x: -10 }, visible: { opacity: 1, x: 0 }, };

export function GameInput({ allGames, selectedGame, onGameSelect }: GameInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddGameModalOpen, setIsAddGameModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const filteredResults = searchTerm
        ? allGames.filter(game => game.title.toLowerCase().includes(searchTerm.toLowerCase()))
        : allGames;

    useEffect(() => { 
        if (isPopoverOpen) { 
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else {
            setSearchTerm('');
        }
    }, [isPopoverOpen]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const handleSelect = (game: Game) => { onGameSelect(game); setIsPopoverOpen(false); };
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddGameModalOpen(true); };
    const handleCreateGame = async (title: string) => { const newGame = await createGameAction(title); if (newGame) { onGameSelect(newGame); } setIsAddGameModalOpen(false); setSearchTerm(''); };
    
    const showCreateOption = searchTerm.trim().length > 1 && !filteredResults.some(r => r.title.toLowerCase() === searchTerm.toLowerCase());
    
    return (
        <>
            <AddGameModal isOpen={isAddGameModalOpen} onClose={() => setIsAddGameModalOpen(false)} onSubmit={handleCreateGame} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>اللعبة</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', justifyContent: 'space-between', 
                            cursor: selectedGame ? 'default' : 'text',
                            paddingRight: '0.5rem',
                        }} 
                        onClick={() => {if (!selectedGame) setIsPopoverOpen(true)}}
                    >
                        <span>{selectedGame ? selectedGame.title : 'ابحث عن لعبة أو أنشئها...'}</span>
                    </div>
                    
                    {selectedGame ? (
                        <ActionButton type="button" onClick={() => onGameSelect(null)} aria-label="Remove selected game">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </ActionButton>
                    ) : (
                        <ActionButton type="button" onClick={handleOpenModal} aria-label="إضافة لعبة جديدة">
                             <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </ActionButton>
                    )}
                    
                    <AnimatePresence>
                        {isPopoverOpen && !selectedGame && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()} 
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, right: 0,
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 10, marginTop: '0.5rem',
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search for a game..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredResults.map(game => (<motion.button type="button" key={game._id} variants={itemVariants} onClick={() => handleSelect(game)} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)' }} whileHover={{ backgroundColor: 'var(--bg-primary)' }}>{game.title}</motion.button>))}
                                    {showCreateOption && (
                                        <motion.button type="button" variants={itemVariants} onClick={handleOpenModal} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic' }} whileHover={{ backgroundColor: 'var(--bg-primary)' }}>
                                            + Create new game: "{searchTerm.trim()}"
                                        </motion.button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

// app/studio/[contentType]/[id]/metadata/MainImageInput.tsx
'use client';

import { useState, useRef, useTransition, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload, UploadQuality } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import avatarStyles from '../../../../components/ProfileEditForm.module.css';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

export function MainImageInput({ currentAssetId, currentAssetUrl, onImageChange, uploadQuality }: {
    currentAssetId: string | null;
    currentAssetUrl: string | null;
    onImageChange: (assetId: string | null, url: string | null) => void;
    uploadQuality: UploadQuality;
}) {
    const [isDragging, setIsDragging] = useState(false);
    const [previewUrl, setPreviewUrl] = useState<string | null>(currentAssetUrl);
    const [isUploading, startUpload] = useTransition();
    const fileInputRef = useRef<HTMLInputElement>(null);
    const toast = useToast();

    useEffect(() => {
        setPreviewUrl(currentAssetUrl);
    }, [currentAssetUrl]);

    const handleFile = useCallback(async (file: File) => {
        if (!file.type.startsWith('image/')) {
            toast.error('نوع ملف غير صالح. يرجى رفع صورة.', 'left');
            return;
        }

        startUpload(async () => {
            try {
                toast.info('جارٍ تهيئة الصورة...', 'left');
                const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, uploadQuality);
                const localUrl = URL.createObjectURL(optimizedFile);
                setPreviewUrl(localUrl);

                toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
                
                const formData = new FormData();
                formData.append('file', optimizedFile);
                const result = await uploadSanityAssetAction(formData);
                
                if (result.success && result.asset) {
                    onImageChange(result.asset._id, result.asset.url);
                    toast.success('رُفِعت الصورة الرئيسية.', 'left');
                } else {
                    throw new Error(result.error || 'فشل رفع الصورة إلى Sanity.');
                }
            } catch (error: any) {
                setPreviewUrl(currentAssetUrl);
                onImageChange(currentAssetId, currentAssetUrl);
                toast.error(error.message || 'أخفقت تهيئة الصورة.', 'left');
            }
        });
    }, [onImageChange, toast, currentAssetUrl, currentAssetId, uploadQuality]);
    
    const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        setIsDragging(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            handleFile(e.dataTransfer.files[0]);
        }
    }, [handleFile]);

    const handleClear = () => {
        setPreviewUrl(null);
        onImageChange(null, null);
        if (fileInputRef.current) fileInputRef.current.value = '';
        toast.info('أُزيلت الصورة الرئيسية.', 'left');
    };

    return (
        <>
            <input type="file" ref={fileInputRef} onChange={(e) => e.target.files && handleFile(e.target.files[0])} accept="image/*" style={{ display: 'none' }} disabled={isUploading} />
            <motion.div
                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                onDragLeave={() => setIsDragging(false)}
                onDrop={handleDrop}
                onClick={() => !isUploading && fileInputRef.current?.click()}
                style={{
                    aspectRatio: '16/9',
                    border: `2px dashed ${isDragging ? 'var(--accent)' : 'var(--border-color)'}`,
                    backgroundColor: isDragging ? 'color-mix(in srgb, var(--accent) 10%, transparent)' : 'var(--bg-primary)',
                    borderRadius: '8px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: isUploading ? 'progress' : 'pointer',
                    position: 'relative',
                    overflow: 'hidden',
                    transition: 'all 0.2s ease',
                }}
            >
                <AnimatePresence>
                    {previewUrl ? (
                        <motion.div key="image" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ width: '100%', height: '100%' }}>
                            <Image src={previewUrl} alt="معاينة الصورة المصغرة" fill sizes="300px" style={{ objectFit: 'cover' }} />
                            {isUploading && <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}><div className="spinner" style={{ width: '30px', height: '30px' }}/></div>}
                        </motion.div>
                    ) : (
                        <motion.div key="placeholder" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                            {isUploading ? ( <div className="spinner" /> ) : (
                                <>
                                    <p style={{ margin: 0 }}>أفلت أو انقر للرفع</p>
                                    <p style={{ fontSize: '1.2rem', margin: '0.5rem 0 0 0' }}>الصورُ الكبيرةُ تُهَيَّأُ تلقائيًا</p>
                                </>
                            )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </motion.div>

            {previewUrl && (
                <button type="button" onClick={handleClear} className="outline-button" style={{ width: '100%', marginTop: '1rem', color: '#DC2626', borderColor: '#DC2626' }}>
                    إزالة الصورة
                </button>
            )}
        </>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

/* app/studio/[contentType]/[id]/metadata/Metadata.module.css */

.inputWrapper {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.inputWrapper > input,
.inputWrapper > div[class*="sidebarInput"] {
    flex-grow: 1;
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

// app/studio/[contentType]/[id]/metadata/PlatformInput.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Editor.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

const PLATFORMS = ['PC', 'PlayStation 5', 'Xbox', 'Switch'];

interface PlatformInputProps {
    selectedPlatforms: string[];
    onPlatformsChange: (platforms: string[]) => void;
}

export function PlatformInput({ selectedPlatforms = [], onPlatformsChange }: PlatformInputProps) {
    
    const handleToggle = (platform: string) => {
        const newSelection = selectedPlatforms.includes(platform)
            ? selectedPlatforms.filter(p => p !== platform)
            : [...selectedPlatforms, platform];
        onPlatformsChange(newSelection);
    };

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>المنصات</label>
            <div className={filterStyles.filterButtonsGroup}>
                {PLATFORMS.map(platform => {
                    const isActive = selectedPlatforms.includes(platform);
                    return (
                        <motion.button
                            key={platform}
                            type="button"
                            onClick={() => handleToggle(platform)}
                            className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`}
                        >
                            {platform}
                            {isActive && <motion.div layoutId="platform-highlight" className={filterStyles.filterHighlight} />}
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

// app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from '@/components/ActionButton';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

interface ProsConsInputProps { label: 'المحاسن' | 'المساوئ'; items: string[]; setItems: (newItems: string[]) => void; }
const itemVariants = { hidden: { opacity: 0, x: 20 }, visible: { opacity: 1, x: 0 }, exit: { opacity: 0, x: -20, transition: { duration: 0.2 } }, };
const RemoveIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

export function ProsConsInput({ label, items, setItems }: ProsConsInputProps) {
    const handleAddItem = () => { setItems([...items, '']); };
    const handleRemoveItem = (index: number) => { setItems(items.filter((_, i) => i !== index)); };
    const handleItemChange = (index: number, value: string) => { const newItems = [...items]; newItems[index] = value; setItems(newItems); };

    const buttonText = label === 'المحاسن' ? '+ إضافة حَسَنة' : '+ إضافة سيئة';
    const ariaLabel = label === 'المحاسن' ? 'إزالة المحسن' : 'إزالة المأخذ';

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                <AnimatePresence>
                    {items.map((item, index) => (
                        <motion.div key={index} layout variants={itemVariants} initial="hidden" animate="visible" exit="exit" transition={{ type: 'spring' as const, stiffness: 400, damping: 25 }} className={metadataStyles.inputWrapper}>
                            <ActionButton type="button" onClick={() => handleRemoveItem(index)} aria-label={ariaLabel}>
                                <RemoveIcon />
                            </ActionButton>
                            <input type="text" value={item} onChange={(e) => handleItemChange(index, e.target.value)} className={styles.sidebarInput} />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </div>
            <button type="button" onClick={handleAddItem} className="outline-button" style={{ width: '100%', marginTop: '1rem' }}>
                {buttonText}
            </button>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/SlugInput.tsx ---

// app/studio/[contentType]/[id]/metadata/SlugInput.tsx
'use client';

import { useState, useEffect, useTransition, useCallback } from 'react';
import { useDebounce } from '@/hooks/useDebounce';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../Editor.module.css';

// THE DEFINITIVE FIX: Added `overflow: 'visible'` to the SVG style.
const AnimatedLockIcon = ({ isLocked }: { isLocked: boolean }) => (
    <svg 
        width="18" 
        height="18" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="2.5" 
        strokeLinecap="round" 
        strokeLinejoin="round" 
        style={{ overflow: 'visible' }}
    >
        {/* Lock Body - Static */}
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
        {/* Shackle - Animated */}
        <motion.path
            d="M7 11V7a5 5 0 0 1 10 0v4"
            initial={false}
            animate={{
                rotate: isLocked ? 0 : -25,
                y: isLocked ? 0 : -2,
            }}
            style={{ transformOrigin: '7px 11px' }} // Pivot around the left base of the shackle
            transition={{ type: 'spring', stiffness: 400, damping: 18 }}
        />
    </svg>
);

const AlertIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
const CheckIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#16A34A" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ClockIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--text-secondary)" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;

interface SlugInputProps {
    slug: string;
    title: string;
    docId: string;
    isSlugManual: boolean;
    slugValidationStatus: 'pending' | 'valid' | 'invalid';
    slugValidationMessage: string;
    dispatch: (action: { type: string; payload: any }) => void;
}

export function SlugInput({
    slug, title, docId, isSlugManual,
    slugValidationStatus, slugValidationMessage, dispatch
}: SlugInputProps) {
    const [isTranslating, startTranslation] = useTransition();
    const debouncedTitle = useDebounce(title, 800);

    const translateAndSetSlug = useCallback(async (currentTitle: string) => {
        if (!currentTitle.trim()) return;
        startTranslation(async () => {
            try {
                const response = await fetch('/api/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: currentTitle }),
                });
                if (!response.ok) throw new Error('Translation failed');
                const data = await response.json();
                dispatch({ type: 'UPDATE_SLUG', payload: { slug: data.slug, isManual: false } });
            } catch (error) {
                console.error("Translation error:", error);
            }
        });
    }, [dispatch]);

    useEffect(() => {
        if (!isSlugManual && debouncedTitle) {
            translateAndSetSlug(debouncedTitle);
        }
    }, [debouncedTitle, isSlugManual, translateAndSetSlug]);

    const handleLockToggle = () => {
        const currentlyManual = !isSlugManual;
        dispatch({ type: 'UPDATE_FIELD', payload: { field: 'isSlugManual', value: currentlyManual } });
        // If we are locking it back, re-translate immediately
        if (!currentlyManual) {
            translateAndSetSlug(title);
        }
    };

    const isSlugValid = slugValidationStatus === 'valid';
    const isSlugPending = slugValidationStatus === 'pending';

    const getSlugIcon = () => {
        if (isTranslating || isSlugPending) return <ClockIcon />;
        if (isSlugValid) return <CheckIcon />;
        return <AlertIcon />;
    };

    return (
        <motion.div className={styles.sidebarSection} layout>
            <label className={styles.sidebarLabel}>
                المُعرِّف (Slug)
            </label>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <motion.button
                    type="button"
                    onClick={handleLockToggle}
                    className={styles.iconButton}
                    style={{ flexShrink: 0, width: '42px', height: '42px' }}
                    aria-label={isSlugManual ? "Lock to auto-translate" : "Unlock to enable manual editing"}
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.9 }}
                >
                    <AnimatedLockIcon isLocked={!isSlugManual} />
                </motion.button>
                <input
                    type="text"
                    value={slug}
                    onChange={(e) => dispatch({ type: 'UPDATE_SLUG', payload: { slug: e.target.value, isManual: true } })}
                    className={styles.sidebarInput}
                    style={{
                        flexGrow: 1,
                        borderColor: isSlugValid && !isSlugPending ? '#16A34A' : isSlugPending ? 'var(--border-color)' : '#DC2626',
                        direction: 'ltr',
                        textAlign: 'left',
                        backgroundColor: isSlugManual ? 'var(--bg-primary)' : 'var(--bg-secondary)'
                    }}
                    readOnly={!isSlugManual}
                />
            </div>
            <AnimatePresence>
                {(slugValidationMessage && (slugValidationStatus !== 'valid' || isTranslating)) && (
                    <motion.p
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        style={{
                            display: 'flex', alignItems: 'center', gap: '0.5rem',
                            color: isTranslating || isSlugPending ? 'var(--text-secondary)' : '#DC2626',
                            fontSize: '1.2rem', marginTop: '0.5rem', textAlign: 'right'
                        }}
                    >
                        {getSlugIcon()}
                        <span>{isTranslating ? 'جارٍ الترجمة...' : slugValidationMessage}</span>
                    </motion.p>
                )}
            </AnimatePresence>
        </motion.div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/SlugInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

// app/studio/[contentType]/[id]/metadata/TagInput.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createTagAction } from '../../../actions';
import { AddTagModal } from './AddTagModal';
import ActionButton from '@/components/ActionButton';
import { translateTag } from '@/lib/translations';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Tag = { _id: string; title: string };
interface TagInputProps { 
    label: string; 
    allTags: Tag[]; 
    selectedTags: Tag[]; 
    onTagsChange: (tags: any) => void;
    placeholder?: string;
    singleSelection?: boolean;
    categoryForCreation: 'Game' | 'Article' | 'News';
}

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};

const AnimatedTag = ({ tag, onRemove }: { tag: Tag, onRemove: (tagId: string) => void }) => {
    // Safeguard against malformed tag objects
    if (!tag || typeof tag.title !== 'string') {
        return null;
    }
    return (
        <motion.div 
            layout 
            initial={{ opacity: 0, scale: 0.5 }} 
            animate={{ opacity: 1, scale: 1 }} 
            exit={{ opacity: 0, scale: 0.6 }} 
            onClick={(e) => { e.stopPropagation(); onRemove(tag._id); }} 
            style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 1, cursor: 'pointer' }} 
            title={`Click to remove "${translateTag(tag.title)}"`} 
            whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}
        >
            <span>{translateTag(tag.title)}</span>
            <svg width="12" height="12" viewBox="0 0 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function TagInput({ label, allTags, selectedTags = [], onTagsChange, placeholder = "ابحث أو أنشئ وسمًا...", singleSelection = false, categoryForCreation }: TagInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddTagModalOpen, setIsAddTagModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const safeSelectedTags = (selectedTags || []).filter(Boolean);

    const filteredResults = (searchTerm
        ? allTags.filter(tag => 
            tag.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
            translateTag(tag.title).toLowerCase().includes(searchTerm.toLowerCase())
          )
        : allTags
    ).filter(tag => !safeSelectedTags.some(st => st._id === tag._id));
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { 
            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } 
        }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);
    
    useEffect(() => { 
        if (isPopoverOpen) { setTimeout(() => inputRef.current?.focus(), 100); } 
        else { setSearchTerm(''); } 
    }, [isPopoverOpen]);

    const handleSelectTag = (tag: Tag) => {
        if (singleSelection) {
            onTagsChange([tag]);
            setIsPopoverOpen(false);
        } else {
            if (!safeSelectedTags.some(t => t._id === tag._id)) {
                onTagsChange([...safeSelectedTags, tag]);
            }
        }
        setSearchTerm('');
        if (inputRef.current) inputRef.current.focus();
    };
    
    const handleRemoveTag = (tagIdToRemove: string) => {
        if (singleSelection) {
            onTagsChange([]);
        } else {
            onTagsChange(safeSelectedTags.filter(tag => tag._id !== tagIdToRemove));
        }
    };
    
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddTagModalOpen(true); };
    const handleCreateTag = async (title: string) => { 
        const newTag = await createTagAction(title, categoryForCreation); 
        if (newTag) { handleSelectTag(newTag); } 
        setIsAddTagModalOpen(false); 
        setSearchTerm(''); 
    };
    
    const showCreateOption = searchTerm.trim().length > 1 && !allTags.some(r => r.title.toLowerCase() === searchTerm.toLowerCase());
    
    const hasSelection = safeSelectedTags.length > 0;

    return (
        <>
            <AddTagModal isOpen={isAddTagModalOpen} onClose={() => setIsAddTagModalOpen(false)} onSubmit={handleCreateTag} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>{label}</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', 
                            minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text',
                        }} 
                        onClick={() => setIsPopoverOpen(true)}
                    >
                        <AnimatePresence>
                            {safeSelectedTags.map(tag => (
                                tag && tag._id ? <AnimatedTag key={tag._id} tag={tag} onRemove={handleRemoveTag} /> : null
                            ))}
                        </AnimatePresence>
                        {!hasSelection && !isPopoverOpen && (
                            <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>{placeholder}</span>
                        )}
                    </div>
                     <ActionButton type="button" onClick={handleOpenModal} aria-label="Add new tag or category">
                        <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </ActionButton>
                    
                    <AnimatePresence>
                        {isPopoverOpen && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()} 
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, 
                                    width: '100%',
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 10, 
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)', marginTop: '0.5rem'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder={placeholder} className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredResults.map(tag => ( <button type="button" key={tag._id} onClick={() => handleSelectTag(tag)} style={{ display: 'block', width: '100%', textAlign: 'right', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} className={styles.popoverItemButton}> {translateTag(tag.title)} </button> ))}
                                    {showCreateOption && (
                                        <button type="button" onClick={handleOpenModal} style={{ display: 'block', width: '100%', textAlign: 'right', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic' }} className={styles.popoverItemButton}>
                                            + إنشاء جديد: "{searchTerm.trim()}"
                                        </button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css ---

/* app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css */
.managerContainer {
  border-top: 1px solid var(--border-color);
}

.toggleHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 1.5rem;
  background: none;
  border: none;
  cursor: pointer;
  text-align: right;
  color: var(--text-primary);
}

.headerTitle {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  font-weight: 600;
}

.collapsibleContent {
  overflow: visible; /* THE DEFINITIVE FIX: Allow popover to display outside bounds */
}

.addForm {
  display: grid;
  grid-template-columns: auto auto 1fr; /* MODIFIED GRID LAYOUT */
  gap: 1rem;
  padding: 0 1.5rem 1.5rem 1.5rem;
  border-bottom: 1px solid var(--border-color);
}

.addForm .primary-button {
  padding: 0 1.5rem;
}

.colorPickerTriggerContainer { /* ADDED */
  position: relative;
}

.colorInputWrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 90px;
  height: 42px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  overflow: hidden;
  cursor: pointer; /* ADDED */
  transition: border-color 0.2s ease; /* ADDED */
}

.colorInputWrapper:hover { /* ADDED */
  border-color: var(--accent);
}


.colorInput {
  position: absolute;
  inset: -5px; /* Make it larger to hide borders */
  width: 150%;
  height: 150%;
  cursor: pointer;
  border: none;
  background: none;
  padding: 0;
}

.colorInputText {
  font-family: monospace;
  font-size: 1.3rem;
  color: var(--text-secondary);
  pointer-events: none;
  mix-blend-mode: difference;
  filter: invert(1) grayscale(1);
}

.mappingsList {
  max-height: 250px;
  overflow-y: auto;
  padding: 1rem 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.mappingItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--bg-primary);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
}

.itemInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-weight: 500;
}

.itemColorPreview {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid var(--border-color);
}

.removeButton {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s, background-color 0.2s;
}

.removeButton:hover {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx ---

// app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx
'use client'

import React, { useState } from 'react';
import { ColorWheelIcon } from '@sanity/icons';
import ColorDictionaryModal from './ColorDictionaryModal'; // Import the new modal
import styles from './ColorDictionaryManager.module.css';

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
};

interface ColorDictionaryManagerProps {
  initialMappings: ColorMapping[];
}

export default function ColorDictionaryManager({ initialMappings }: ColorDictionaryManagerProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [mappings, setMappings] = useState<ColorMapping[]>(initialMappings);

  const handleUpdateMappings = (newMappings: ColorMapping[]) => {
    setMappings(newMappings);
    // Here you could also trigger a re-render of the Tiptap editor if needed,
    // for example by updating its extensions config, though it's complex.
    // For now, updating the local state is sufficient.
  };

  return (
    <>
      <div className={styles.managerContainer}>
        <button className={styles.toggleHeader} onClick={() => setIsModalOpen(true)}>
          <div className={styles.headerTitle}>
            <ColorWheelIcon />
            <span>ألوان الكلمات التلقائية</span>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <span style={{ fontSize: '1.4rem', color: 'var(--text-secondary)' }}>{mappings.length} words</span>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </div>
        </button>
      </div>

      <ColorDictionaryModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        initialMappings={mappings}
        onUpdate={handleUpdateMappings}
      />
    </>
  );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css ---

/* app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css */
.addForm {
  display: grid;
  grid-template-columns: auto auto 1fr;
  gap: 1rem;
  padding-bottom: 2rem;
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--border-color);
}

.addForm .primary-button {
  padding: 0 1.5rem;
}

.colorPickerTriggerContainer {
  position: relative;
}

.colorInputWrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 90px;
  height: 42px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  overflow: hidden;
  cursor: pointer;
  transition: border-color 0.2s ease;
}

.colorInputWrapper:hover {
  border-color: var(--accent);
}

.colorInputText {
  font-family: monospace;
  font-size: 1.3rem;
  color: var(--text-secondary);
  pointer-events: none;
  mix-blend-mode: difference;
  filter: invert(1) grayscale(1);
}

.collapsibleSection {
  /* This outer container is no longer needed for styling, but kept for structure */
}

.collapsibleHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 1.2rem 1.5rem;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  font-family: var(--font-main);
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-primary);
  transition: background-color 0.2s ease-out, border-radius 0.2s ease-out, border-color 0.2s ease-out;
}

.collapsibleHeader:hover {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
}

.collapsibleHeader.open {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  background-color: var(--bg-secondary);
  border-bottom-color: transparent;
}


.headerInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.arrowIcon {
  transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}

.collapsibleContent {
  overflow: hidden;
  border: 1px solid var(--border-color);
  border-top: none;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  background-color: var(--bg-primary);
}

.mappingsList {
  max-height: 35vh;
  overflow-y: auto;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.mappingItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--bg-secondary);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
}

.itemInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-weight: 500;
}

.itemColorPreview {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid var(--border-color);
}

.removeButton {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s, background-color 0.2s;
}

.removeButton:hover {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx ---

// app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx
'use client';

import React, { useState, useTransition, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { addOrUpdateColorDictionaryAction, removeColorDictionaryAction } from '@/app/studio/actions';
import { useToast } from '@/lib/toastStore';
import { useClickOutside } from '@/hooks/useClickOutside';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { ColorPicker } from '../../ColorPicker';
import styles from './ColorDictionaryModal.module.css';
import editorStyles from '../../Editor.module.css';

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
};

interface ColorDictionaryModalProps {
  isOpen: boolean;
  onClose: () => void;
  initialMappings: ColorMapping[];
  onUpdate: (updatedMappings: ColorMapping[]) => void;
}

const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: 20, transition: { duration: 0.2 } },
};

export default function ColorDictionaryModal({ isOpen, onClose, initialMappings, onUpdate }: ColorDictionaryModalProps) {
  const [mappings, setMappings] = useState<ColorMapping[]>(initialMappings);
  const [newWord, setNewWord] = useState('');
  const [newColor, setNewColor] = useState('#00E5FF');
  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);
  const [isListOpen, setIsListOpen] = useState(true); // State for the new accordion
  const [isPending, startTransition] = useTransition();
  const toast = useToast();
  const colorPickerRef = useRef<HTMLDivElement>(null);

  useClickOutside(colorPickerRef, () => setIsColorPickerOpen(false));

  useEffect(() => {
    if (isOpen) {
        setMappings(initialMappings);
    }
  }, [isOpen, initialMappings]);

  const handleAdd = () => {
    if (!newWord.trim() || !newColor.trim()) {
      toast.error('الكلمة واللون مطلوبان.', 'left');
      return;
    }

    startTransition(async () => {
      const newMapping = { word: newWord, color: newColor };
      const result = await addOrUpdateColorDictionaryAction(newMapping);
      if (result.success && result.updatedDictionary) {
        const newMappings = result.updatedDictionary.autoColors || [];
        setMappings(newMappings);
        onUpdate(newMappings);
        setNewWord('');
        toast.success(`أضيفت '${newWord}' إلى القاموس.`, 'left');
      } else {
        toast.error(result.message || 'فشلت إضافة الكلمة.', 'left');
      }
    });
  };

  const handleRemove = (key: string) => {
    startTransition(async () => {
      const removedWord = mappings.find((m) => m._key === key)?.word;
      const result = await removeColorDictionaryAction(key);
      if (result.success && result.updatedDictionary) {
        const newMappings = result.updatedDictionary.autoColors || [];
        setMappings(newMappings);
        onUpdate(newMappings);
        toast.info(`أزيلت '${removedWord}' من القاموس.`, 'left');
      } else {
        toast.error(result.message || 'فشلت إزالة الكلمة.', 'left');
      }
    });
  };
  
  const dummyEditor = {
    chain: () => ({
      focus: () => ({
        setColor: (color: string) => {
          setNewColor(color);
          setIsColorPickerOpen(false);
          return { run: () => {} };
        },
        unsetColor: () => {
          setNewColor('#FFFFFF');
          setIsColorPickerOpen(false);
          return { run: () => {} };
        }
      })
    }),
    getAttributes: () => ({ color: newColor }),
  } as any;

  return (
    <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '500px' }}>
        <h3 style={{ marginTop: 0 }}>إدارة ألوان الكلمات التلقائية</h3>
        <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem', marginBottom: '2rem' }}>
            عرّف الكلمات التي يجب تلوينها تلقائيًا عند كتابتها في المحرر.
        </p>
        
        <div className={styles.addForm}>
            <button onClick={handleAdd} className="primary-button" disabled={isPending}>إضافة</button>
            <div ref={colorPickerRef} className={styles.colorPickerTriggerContainer}>
                <button 
                type="button" 
                onClick={() => setIsColorPickerOpen(prev => !prev)} 
                className={styles.colorInputWrapper}
                style={{ backgroundColor: newColor }}
                >
                <span className={styles.colorInputText}>{newColor.toUpperCase()}</span>
                </button>
                <AnimatePresence>
                    {isColorPickerOpen && (
                        <ColorPicker editor={dummyEditor} popoverStyle={{ bottom: 'calc(100% + 8px)', right: '50%', transform: 'translateX(50%)', zIndex: 5001 }} />
                    )}
                </AnimatePresence>
            </div>
            <input
                type="text"
                placeholder="كلمة (مثال: Xbox)"
                value={newWord}
                onChange={(e) => setNewWord(e.target.value)}
                className={editorStyles.sidebarInput}
                disabled={isPending}
            />
        </div>

        <div className={styles.collapsibleSection}>
            <button className={`${styles.collapsibleHeader} ${isListOpen ? styles.open : ''}`} onClick={() => setIsListOpen(!isListOpen)}>
                <div className={styles.headerInfo}>
                    <span>الكلمات الحالية</span>
                    <span style={{color: 'var(--text-secondary)'}}>({mappings.length})</span>
                </div>
                <motion.div animate={{ rotate: isListOpen ? 90 : 0 }} className={styles.arrowIcon}>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </motion.div>
            </button>
            <AnimatePresence initial={false}>
                {isListOpen && (
                    <motion.div
                        key="content"
                        className={styles.collapsibleContent}
                        initial="collapsed"
                        animate="open"
                        exit="collapsed"
                        variants={{
                            open: { opacity: 1, height: 'auto' },
                            collapsed: { opacity: 0, height: 0 }
                        }}
                        transition={{ duration: 0.3, ease: [0.04, 0.62, 0.23, 0.98] }}
                    >
                        <div className={styles.mappingsList}>
                            {mappings.length > 0 ? mappings.map((mapping) => (
                                mapping._key && (
                                    <motion.div
                                        key={mapping._key}
                                        className={styles.mappingItem}
                                        variants={itemVariants}
                                        initial="hidden"
                                        animate="visible"
                                        exit="exit"
                                        layout
                                    >
                                        <div className={styles.itemInfo}>
                                            <div className={styles.itemColorPreview} style={{ backgroundColor: mapping.color }} />
                                            <span>{mapping.word}</span>
                                        </div>
                                        <button
                                            className={styles.removeButton}
                                            onClick={() => mapping._key && handleRemove(mapping._key)}
                                            disabled={isPending}
                                            aria-label={`Remove ${mapping.word}`}
                                        >
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                                        </button>
                                    </motion.div>
                                )
                            )) : <p style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '1rem 0'}}>لا توجد كلمات مُعرفة.</p>}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
      
        <div className={modalStyles.modalActions} style={{marginTop: '2rem'}}>
            <button onClick={onClose} className="outline-button">إغلاق</button>
        </div>
    </Modal>
  );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx ---

================================================================================

--- START OF FILE app/tags/[tag]/page.tsx ---

// app/tags/[tag]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByTagListQuery } from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import { translateTag } from '@/lib/translations';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';
import { enrichContentList } from '@/lib/enrichment'; // <-- ADDED

export const dynamicParams = true;

type Props = {
  params: Promise<{ tag: string }>;
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { tag } = await params;
  const tagSlug = decodeURIComponent(tag);

  const data = await client.fetch(
    `{
      "tag": *[_type == "tag" && slug.current == $slug][0]{title},
      "latestItem": *[_type in ["review", "article", "news"] && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc)[0]{mainImage}
    }`,
    { slug: tagSlug }
  );

  if (!data.tag) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const translatedTitle = translateTag(data.tag.title);
  const title = `وسم: ${translatedTitle}`;
  const description = `تصفح كل المحتوى الموسوم بـ "${translatedTitle}" على EternalGames واكتشف أحدث المقالات والمراجعات.`;
  const ogImageUrl = data.latestItem?.mainImage
    ? urlFor(data.latestItem.mainImage).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/tags/${tagSlug}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: title }],
      type: 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}


export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "tag" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            tag: slug,
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for tag hub pages. Build cannot continue.`, error);
        throw error;
    }
}

export default async function TagPage({ params }: { params: Promise<{ tag: string }> }) {
    const { tag } = await params;
    const tagSlug = decodeURIComponent(tag);

    const tagMeta = await client.fetch(
        `*[_type == "tag" && slug.current == $slug][0]{title}`,
        { slug: tagSlug }
    );

    if (!tagMeta) {
        notFound();
    }

    const allItemsRaw = await client.fetch(allContentByTagListQuery, { slug: tagSlug });
    // THE FIX: Enrich with usernames server-side
    const allItems = await enrichContentList(allItemsRaw);

    if (!allItems || allItems.length === 0) {
        return (
            <div className="container page-container">
                <h1 className="page-title">وسم: &quot;{translateTag(tagMeta.title)}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُنشر عملٌ بهذا الوسم بعد.</p>
            </div>
        );
    }
    
    return (
         <HubPageClient
            initialItems={allItems}
            hubTitle={translateTag(tagMeta.title)}
            hubType="وسم"
        />
    );
}

--- END OF FILE app/tags/[tag]/page.tsx ---

================================================================================

--- START OF FILE app/tools/upscaler/page.tsx ---

// app/tools/upscaler/page.tsx
import UpscalerClient from '@/components/upscaler/UpscalerClient';
import { ContentBlock } from '@/components/ContentBlock';
import { SparklesIcon } from '@/components/icons/index';
import { Metadata } from 'next';

export const metadata: Metadata = {
    title: 'المسبك البصري | AI Upscaler',
    description: 'أداة رفع دقة الصور باستخدام الذكاء الاصطناعي مباشرة في متصفحك. خصوصية تامة وأداء عالٍ.',
};

export default function UpscalerPage() {
    return (
        <div className="container page-container">
            <div style={{ textAlign: 'center', marginBottom: '6rem' }}>
                <h1 className="page-title">المسبك البصري</h1>
                <p style={{ fontSize: '1.8rem', color: 'var(--text-secondary)', maxWidth: '600px', margin: '0 auto' }}>
                    تقنية تحسين الصور بالذكاء الاصطناعي (Swin2SR). تعمل كلياً على جهازك لضمان الخصوصية والسرعة. مثالية للقطات الألعاب الفنية.
                </p>
            </div>
            
            <ContentBlock title="محطة المعالجة" Icon={SparklesIcon}>
                <UpscalerClient />
            </ContentBlock>
        </div>
    );
}

--- END OF FILE app/tools/upscaler/page.tsx ---

================================================================================

--- START OF FILE app/welcome/WelcomePageClient.tsx ---

// app/welcome/WelcomePageClient.tsx
'use client';

import { useState, useTransition, useEffect, useMemo } from 'react';
import { completeOnboardingAction, checkUsernameAvailability } from '@/app/actions/userActions';
import { useSession } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAsyncValidation } from '@/hooks/useAsyncValidation';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useToast } from '@/lib/toastStore';
import { countries } from '@/lib/countries';
import Link from 'next/link';

const InfoTooltip = ({ text }: { text: string }) => (
    <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', marginLeft: '0.5rem', cursor: 'pointer' }} className="info-tooltip-container">
        <svg width="16" height="16" viewBox="0 0 20 20" fill="var(--text-secondary)"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" /></svg>
        <div className="info-tooltip-text">{text}</div>
    </div>
);

export default function WelcomePageClient() {
    const { data: session, status: sessionStatus, update } = useSession();
    const router = useRouter();
    const searchParams = useSearchParams();
    const toast = useToast();

    const [fullName, setFullName] = useState('');
    const [username, setUsername] = useState('');
    const [age, setAge] = useState('');
    const [country, setCountry] = useState('');
    const [countrySearch, setCountrySearch] = useState('');
    const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);
    const [termsAccepted, setTermsAccepted] = useState(false);

    const [isPending, startTransition] = useTransition();

    const hasInitialUsername = !!(session?.user as any)?.username;

    const usernameValidation = useAsyncValidation(username, checkUsernameAvailability, (session?.user as any)?.username ?? undefined);
    
    const filteredCountries = useMemo(() => 
        countries.filter(c => c.toLowerCase().includes(countrySearch.toLowerCase())),
    [countrySearch]);
    
    useEffect(() => {
        if (sessionStatus === 'authenticated') {
            if (!(session as any)?.needsOnboarding) {
                const callbackUrl = searchParams.get('callbackUrl') || '/';
                router.replace(callbackUrl);
                return;
            }
            setFullName(session.user?.name ?? '');
            if ((session.user as any)?.username) {
                setUsername((session.user as any).username);
            }
        }
    }, [sessionStatus, session, router, searchParams]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (isButtonDisabled) return;

        const formData = new FormData(e.target as HTMLFormElement);
        startTransition(async () => {
            const result = await completeOnboardingAction(formData);
            if (result.success) {
                toast.success('اكتمل ملفك. أهلًا بك في EternalGames.');
                await update(); 
                const callbackUrl = searchParams.get('callbackUrl') || '/';
                router.push(callbackUrl);
            } else {
                toast.error(result.message || 'أخفق إكمال الملف.');
            }
        });
    };

    if (sessionStatus === 'loading' || !session || (sessionStatus === 'authenticated' && !(session as any)?.needsOnboarding)) {
        return (
            <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
                <div className="spinner" />
            </div>
        );
    }
    
    const isButtonDisabled = isPending || (!hasInitialUsername && usernameValidation.type !== 'valid') || !fullName || !termsAccepted;

    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'flex-start', paddingTop: '10vh' }}>
            <motion.div 
                style={{ maxWidth: '500px', width: '100%', textAlign: 'center' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <h1 className="page-title">أهلاً بك في رحاب EternalGames!</h1>
                <p style={{ color: 'var(--text-secondary)', fontSize: '1.8rem', marginTop: '-2rem', marginBottom: '3rem' }}>خطوةٌ أخيرة تفصلك. أكمل ملفك الشخصي لتدخل مَعيَّتنا.</p>
                <form onSubmit={handleSubmit} style={{ textAlign: 'left' }}>
                    <div className="profile-form-group">
                        <input id="fullName" name="fullName" type="text" value={fullName} onChange={(e) => setFullName(e.target.value)} className="profile-input" placeholder=" " required />
                        <label htmlFor="fullName" className="profile-form-label">الاسم الكامل</label>
                    </div>

                    {!hasInitialUsername && (
                        <div className="profile-form-group">
                            <input id="username" name="username" type="text" value={username} onChange={(e) => setUsername(e.target.value.toLowerCase())} className="profile-input" placeholder=" " autoFocus required />
                            <label htmlFor="username" className="profile-form-label">اختر اسمًا للمستخدم</label>
                            <AnimatePresence>
                                {usernameValidation.type !== 'idle' && <motion.p initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} style={{ fontSize: '1.4rem', margin: '0.5rem 0 0 0', color: usernameValidation.type === 'invalid' ? '#DC2626' : (usernameValidation.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameValidation.message}</motion.p>}
                            </AnimatePresence>
                        </div>
                    )}
                    
                    {hasInitialUsername && (
                        <input type="hidden" name="username" value={username} />
                    )}

                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem' }}>
                        <div className="profile-form-group">
                            <input 
                                id="age" 
                                name="age" 
                                type="text"
                                inputMode="numeric"
                                pattern="[0-9]*"
                                value={age} 
                                onChange={(e) => {
                                    if (e.target.value === '' || /^[0-9]+$/.test(e.target.value)) {
                                        setAge(e.target.value);
                                    }
                                }} 
                                className="profile-input" 
                                placeholder=" " 
                            />
                            <label htmlFor="age" className="profile-form-label">العمر (اختياري)<InfoTooltip text="عمرك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                        </div>
                        <div className="profile-form-group" style={{ position: 'relative' }}>
                            <input id="country" name="country" type="text" value={country} onFocus={() => setIsCountryDropdownOpen(true)} onBlur={() => setTimeout(() => setIsCountryDropdownOpen(false), 150)} onChange={(e) => { setCountry(e.target.value); setCountrySearch(e.target.value); }} className="profile-input" placeholder=" " autoComplete="off" />
                            <label htmlFor="country" className="profile-form-label">البلد (اختياري)<InfoTooltip text="بلدك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                            {isCountryDropdownOpen && (
                                <div style={{ position: 'absolute', top: '100%', left: 0, right: 0, maxHeight: '200px', overflowY: 'auto', background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '8px', zIndex: 10, marginTop: '0.5rem' }}>
                                    {filteredCountries.map(c => 
                                        <button type="button" key={c} onMouseDown={() => { setCountry(c); setIsCountryDropdownOpen(false); }} 
                                        className="country-picker-button">
                                            {c}
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="profile-form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                        <input type="checkbox" id="terms" name="terms" checked={termsAccepted} onChange={(e) => setTermsAccepted(e.target.checked)} style={{ width: '1.6rem', height: '1.6rem' }}/>
                        <label htmlFor="terms" style={{ fontSize: '1.4rem', color: 'var(--text-secondary)' }}>أوافق على<Link href="/terms-of-service" target="_blank">شروط الخدمة</Link>.
                        </label>
                    </div>

                    <motion.button type="submit" className="primary-button" style={{ width: '100%', marginTop: '1rem', height: '48px' }} disabled={isButtonDisabled} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '5px' }} transition={{ type: 'spring' as const, stiffness: 400, damping: 25 }}>
                        <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إكمال الملف الشخصي</motion.span>}</AnimatePresence>
                    </motion.button>
                </form>
            </motion.div>
        </div>
    );
}




--- END OF FILE app/welcome/WelcomePageClient.tsx ---

================================================================================

--- START OF FILE app/welcome/page.tsx ---

// app/welcome/page.tsx
import { Suspense } from 'react';
import WelcomePageClient from './WelcomePageClient';

// A simple fallback component to show while the client component loads
const WelcomePageFallback = () => {
    return (
        <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
            <div className="spinner" />
        </div>
    );
};

export default function WelcomePage() {
    return (
        <Suspense fallback={<WelcomePageFallback />}>
            <WelcomePageClient />
        </Suspense>
    );
}




--- END OF FILE app/welcome/page.tsx ---

================================================================================

--- START OF FILE components/ActionButton.module.css ---

/* components/ActionButton.module.css */

.actionButton {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    width: 36px;
    height: 36px;
    aspect-ratio: 1 / 1;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-secondary);
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out, color 0.2s ease-out, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    z-index: 10;
}

.actionButton:hover:not(:disabled) {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
    transform: scale(1.15);
}

[data-theme="dark"] .actionButton:hover:not(:disabled) {
    color: var(--bg-primary);
}

--- END OF FILE components/ActionButton.module.css ---

================================================================================

--- START OF FILE components/ActionButton.tsx ---

// components/ActionButton.tsx
'use client';

import { motion } from 'framer-motion';
import React, { useState } from 'react';
import styles from './ActionButton.module.css';

// THE DEFINITIVE FIX: Create a more precise props type that omits conflicting properties.
type ConflictingProps = 'onAnimationStart' | 'onDragStart' | 'onDragEnd' | 'onDrag';
interface ActionButtonProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, ConflictingProps> {
    children: React.ReactNode;
    'aria-label': string;
}

const ActionButton = ({ children, ...props }: ActionButtonProps) => {
    const [isHovered, setIsHovered] = useState(false);

    return (
        <motion.button
            className={styles.actionButton}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            animate={{ scale: isHovered ? 1.15 : 1 }}
            whileTap={{ scale: 0.9, y: 0 }}
            transition={{ type: 'spring', stiffness: 400, damping: 15 }}
            {...props}
        >
            {children}
        </motion.button>
    );
};

export default ActionButton;

--- END OF FILE components/ActionButton.tsx ---

================================================================================

--- START OF FILE components/AnimatedGridBackground.tsx ---

// components/AnimatedGridBackground.tsx

'use client';

import React from 'react';
import { motion } from 'framer-motion';

export default function AnimatedGridBackground() {
  return (
    <motion.div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        zIndex: -1,
        '--grid-size': '60px',
        '--grid-color': 'rgba(125, 128, 140, 0.1)',
        backgroundImage:
          'linear-gradient(to right, var(--grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px)',
        backgroundSize: 'var(--grid-size) var(--grid-size)',
      } as React.CSSProperties}
      animate={{
        backgroundPosition: ['0px 0px', 'var(--grid-size) var(--grid-size)'],
      }}
      transition={{
        duration: 10,
        repeat: Infinity,
        ease: 'linear',
      }}
    />
  );
}




--- END OF FILE components/AnimatedGridBackground.tsx ---

================================================================================

--- START OF FILE components/AnimatedNumber.tsx ---

// components/AnimatedNumber.tsx
'use client';

import { motion, useAnimate } from 'framer-motion';
import { useEffect } from 'react';

const DIGIT_MAP: { [key: string]: number } = { '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, };

const Digit = ({ digit, isInView }: { digit: string; isInView: boolean }) => {
    const [scope, animate] = useAnimate();
    const digitHeight = 90;

    useEffect(() => {
        if (isInView) {
            animate(scope.current, { y: -DIGIT_MAP[digit] * digitHeight }, { duration: 1.5, ease: [0.22, 1, 0.36, 1] as const });
        }
    }, [digit, isInView, animate, scope, digitHeight]);

    return (
        <div style={{ height: `${digitHeight}px`, overflow: 'hidden' }}>
            <motion.div ref={scope} style={{ y: 0 }}>
                {Object.keys(DIGIT_MAP).map(d => <div key={d} style={{ height: `${digitHeight}px` }}>{d}</div>)}
            </motion.div>
        </div>
    );
};

export const AnimatedNumber = ({ value, isInView, className }: { value: number; isInView: boolean; className: string; }) => {
    const [scope, animate] = useAnimate();

    useEffect(() => {
        if (isInView) {
            const popAnimation = animate(scope.current, { scale: [1, 1.15, 1], }, { duration: 0.4, delay: 1.5, ease: "easeOut" as const, });
            return () => { popAnimation.stop(); };
        }
    }, [isInView, animate, scope]);

    const stringValue = value.toFixed(1);
    const [integerPart, decimalPart] = stringValue.split('.');
    const integerDigits = Array.from(integerPart);

    return (
        // --- THE DEFINITIVE FIX ---
        // Numbers are always displayed Left-to-Right, even in an RTL context.
        // By adding `direction: 'ltr'`, we isolate the number component from the global
        // RTL styling, ensuring its parts (integer, decimal) are laid out correctly.
        // We then write the JSX in the natural LTR order.
        <div ref={scope} className={className} style={{ display: 'flex', justifyContent: 'center', direction: 'ltr' }}>
            {integerDigits.map((digit, i) => <Digit key={i} digit={digit} isInView={isInView} />)}
            <div style={{ lineHeight: '8rem' }}>.</div>
            <Digit digit={decimalPart} isInView={isInView} />
        </div>
    );
};




--- END OF FILE components/AnimatedNumber.tsx ---

================================================================================

--- START OF FILE components/AnimatedReleases.tsx ---

// components/AnimatedReleases.tsx
'use client';

import { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import KineticReleaseTimeline from '@/components/KineticReleaseTimeline';

export default function AnimatedReleases({ releases }: { releases: any[] }) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.2 });

    return (
        <div 
            ref={ref}
            style={{
                opacity: isInView ? 1 : 0,
                transform: isInView ? 'translateY(0)' : 'translateY(50px)',
                transition: 'opacity 0.8s ease-out, transform 0.8s ease-out'
            }}
        >
            <KineticReleaseTimeline releases={releases} />
        </div>
    );
}

--- END OF FILE components/AnimatedReleases.tsx ---

================================================================================

--- START OF FILE components/ArticleCard.module.css ---

/* components/ArticleCard.module.css */

.livingCardWrapper {
    height: 100%;
}

.articleCard {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 100%;
    border: 1px solid var(--border-color);
    will-change: transform;
    transition: box-shadow 0.4s ease-out, border-color 0.4s ease-out;
}

.livingCardWrapper:hover .articleCard {
    border-color: color-mix(in srgb, var(--text-primary) 20%, transparent);
}

.imageContainer {
    overflow: hidden;
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9;
    flex-shrink: 0;
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.score {
    position: absolute;
    top: 1rem;
    left: 1rem;
    right: auto;
    background-color: var(--accent);
    color: #FFFFFF;
    font-family: var(--font-main), sans-serif;
    font-weight: 800;
    font-size: 1.6rem;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    box-shadow: 0 0 10px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 2;
    opacity: 1;
    transform: translateY(0);
    transition: opacity 0.3s ease, transform 0.3s ease;
}

[data-theme="dark"] .score {
    color: var(--bg-primary);
}

.cardContent {
    padding: 2rem;
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-height: 0;
    text-align: right;
    transition: transform 0.4s ease; /* Added for subtle hover effect */
}

.livingCardWrapper:hover .cardContent {
    transform: translateY(-4px); /* Subtle lift effect instead of 3D */
}


.cardTitleLink { /* This class is no longer used for a link, but for styling the H3 */
    color: var(--text-primary);
    transition: color 0.2s ease;
    text-decoration: none;
}

/* Make the title change color on card hover */
.cardTitleLink:hover h3 {
    color: var(--accent);
}

.cardTitleLink h3 {
    font-size: 2rem;
    margin-bottom: 1rem;
    margin-top: 0;
}

.cardMetadata {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    font-family: var(--font-main), sans-serif;
    font-size: 1.4rem;
    color: var(--text-secondary);
}

.cardDate {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 1.3rem;
}

.metadataIcon {
    width: 16px;
    height: 16px;
    color: var(--accent);
}

.tagContainer {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

--- END OF FILE components/ArticleCard.module.css ---

================================================================================

--- START OF FILE components/ArticleCard.tsx ---

// components/ArticleCard.tsx
'use client';

import React, { memo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import TagLinks from './TagLinks';
import { m } from 'framer-motion'; 
import { useRouter } from 'next/navigation';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import CreatorCredit from './CreatorCredit';
import { CardProps } from '@/types';
import { sanityLoader } from '@/lib/sanity.loader';
import { Calendar03Icon } from '@/components/icons/index';
import styles from './ArticleCard.module.css';

type ArticleCardProps = {
    article: CardProps & { width?: number; height?: number; mainImageRef?: any; };
    layoutIdPrefix: string;
    isPriority?: boolean;
    disableLivingEffect?: boolean; 
};

const ArticleCardComponent = ({ article, layoutIdPrefix, isPriority = false, disableLivingEffect = false }: ArticleCardProps) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix); 
    
    // THE FIX: Explicitly typed for HTMLAnchorElement
    const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLAnchorElement>();

    const type = article.type;
    const isReview = type === 'review';

    const getLinkBasePath = () => {
        switch (type) {
            case 'review': return '/reviews/';
            case 'article': return '/articles/';
            case 'news': return '/news/';
            default: return '/';
        }
    };

    const linkPath = `${getLinkBasePath()}${article.slug}`;
    
    const handleClick = (e: React.MouseEvent) => {
        if ((e.target as HTMLElement).closest('a, button, [role="button"]')) {
            return;
        }
        if (e.ctrlKey || e.metaKey) return;
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    const handleMouseEnter = () => {
        router.prefetch(linkPath);
    };

    const hasScore = isReview && typeof article.score === 'number';
    
    const imageSource = article.imageUrl;
    if (!imageSource) return null;

    const wrapperProps = disableLivingEffect ? {} : {
        ref: livingCardRef,
        onMouseMove: livingCardAnimation.onMouseMove,
        onMouseEnter: () => { livingCardAnimation.onMouseEnter(); handleMouseEnter(); },
        onMouseLeave: livingCardAnimation.onMouseLeave,
        onTouchStart: livingCardAnimation.onTouchStart,
        onTouchEnd: livingCardAnimation.onTouchEnd,
        onTouchCancel: livingCardAnimation.onTouchCancel,
    };
    
    const motionStyle = disableLivingEffect 
        ? { cursor: 'pointer' } 
        : { ...livingCardAnimation.style, cursor: 'pointer' };

    return (
        <m.a
            href={linkPath}
            layoutId={`${layoutIdPrefix}-card-container-${article.legacyId}`}
            onClick={handleClick}
            className={`${styles.livingCardWrapper} no-underline`}
            {...wrapperProps}
            style={{ ...motionStyle, display: 'block' }}
        >
            <div
                className={styles.articleCard}
            >
                <m.div className={styles.imageContainer} layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`}>
                    {hasScore && ( <m.div className={styles.score}>{article.score!.toFixed(1)}</m.div> )}
                    <Image 
                        loader={sanityLoader}
                        src={imageSource}
                        alt={article.title}
                        width={800}
                        height={450}
                        sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 350px"
                        className={styles.cardImage}
                        style={{ objectFit: 'cover' }}
                        placeholder="blur" 
                        blurDataURL={article.blurDataURL}
                        priority={isPriority}
                    />
                </m.div>
                <m.div className={styles.cardContent}>
                    <div className={styles.cardTitleLink}>
                        <m.h3 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`}>{article.title}</m.h3>
                    </div>
                    <div className={styles.cardMetadata}>
                        <CreatorCredit label="بقلم" creators={article.authors} />
                        {article.date && (
                            <p className={styles.cardDate}>
                                <Calendar03Icon className={styles.metadataIcon} />
                                <span>{article.date}</span>
                            </p>
                        )}
                    </div>
                    <div className={styles.tagContainer}>
                        <TagLinks tags={article.tags.slice(0, 5).map(tag => tag.title)} small={true} />
                    </div>
                </m.div>
            </div>
        </m.a>
    );
};

const ArticleCard = memo(ArticleCardComponent);
export default ArticleCard;

--- END OF FILE components/ArticleCard.tsx ---

================================================================================

--- START OF FILE components/AuthOrb.module.css ---

.authOrb {
  position: relative;
  width: 80px;
  height: 80px;
  background-color: var(--bg-secondary);
  border: 2px solid var(--border-color);
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.2s ease-out;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--text-primary) 10%, transparent);
}
.large {
  width: 120px;
  height: 120px;
}
.authOrb:hover:not(:disabled) {
  border-color: var(--accent);
}
.iconWrapper {
  width: 50%;
  height: 50%;
}
.large .iconWrapper {
  width: 45%;
  height: 45%;
}
.icon {
  width: 100%;
  height: 100%;
  color: var(--text-primary);
  filter: grayscale(1) opacity(0.7);
  transition: filter 0.3s ease, color 0.3s ease;
}
.authOrb:hover:not(:disabled) .icon {
  filter: grayscale(0) opacity(1);
  color: var(--accent);
}
.loaderExternal {
  position: absolute;
  width: 130%;
  height: 130%;
  top: 50%;
  left: 50%; /* THE DEFINITIVE FIX: Changed from 'right' to 'left' for correct centering. */
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* ADDED: Mobile responsiveness for orbs */
@media (max-width: 480px) {
  .authOrb {
    width: 64px;
    height: 64px;
  }
  .large {
    width: 96px;
    height: 96px;
  }
  .iconWrapper {
    width: 45%;
    height: 45%;
  }
  .large .iconWrapper {
    width: 40%;
    height: 40%;
  }
}

--- END OF FILE components/AuthOrb.module.css ---

================================================================================

--- START OF FILE components/AuthOrb.tsx ---

// components/AuthOrb.tsx

import { motion, AnimatePresence } from 'framer-motion';
import styles from './AuthOrb.module.css';

const OrbLoader = () => (
    <motion.svg
        className={styles.loaderExternal}
        viewBox="0 0 60 60"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.3 }}
    >
        <motion.circle
            cx="30"
            cy="30"
            r="28"
            fill="none"
            stroke="var(--accent)"
            strokeWidth="2.5"
            strokeLinecap="round"
            pathLength="1"
            strokeDasharray="1"
            strokeDashoffset="0.75"
            initial={{ rotate: -90 }}
            animate={{ rotate: 270 }}
            transition={{ duration: 1.2, repeat: Infinity, ease: "linear" }}
        />
    </motion.svg>
);

interface AuthOrbProps {
    Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
    onClick: () => void;
    ariaLabel: string;
    isLarge?: boolean;
    isLoading?: boolean;
    isDisabled?: boolean;
}

export const AuthOrb = ({ Icon, onClick, ariaLabel, isLarge = false, isLoading = false, isDisabled = false }: AuthOrbProps) => {
    return (
        <motion.button
            onClick={onClick}
            aria-label={ariaLabel}
            disabled={isDisabled}
            className={`${styles.authOrb} ${isLarge ? styles.large : ''}`}
            animate={{
                scale: isLoading ? 1.2 : (isDisabled ? 0.8 : 1),
                opacity: isLoading ? 1 : (isDisabled ? 0.4 : 1),
            }}
            whileHover={!isDisabled ? { scale: 1.1, y: -5 } : {}}
            whileTap={!isDisabled ? { scale: 0.95 } : {}}
            transition={{ type: 'spring' as const, stiffness: 500, damping: 20 }}
            style={{ cursor: isDisabled ? 'default' : 'pointer' }}
        >
            <motion.div
                className={styles.iconWrapper}
                animate={{ opacity: isLoading ? 0.5 : 1 }}
            >
                <Icon className={styles.icon} />
            </motion.div>

            <AnimatePresence>
                {isLoading && <OrbLoader key="loader" />}
            </AnimatePresence>
        </motion.button>
    );
};

--- END OF FILE components/AuthOrb.tsx ---

================================================================================

--- START OF FILE components/AvatarCropperModal.tsx ---

'use client';

import { useState, useRef } from 'react';
import ReactCrop, { type Crop, type PixelCrop } from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import Modal from './modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from './modals/Modals.module.css'; // <-- THE FIX: Import modal styles

interface AvatarCropperModalProps {
    isOpen: boolean;
    onClose: () => void;
    imageSrc: string;
    onCropComplete: (file: File) => void;
}

function canvasToFile(canvas: HTMLCanvasElement, fileName: string): Promise<File> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (!blob) {
                reject(new Error('Canvas is empty'));
                return;
            }
            resolve(new File([blob], fileName, { type: 'image/png' }));
        }, 'image/png');
    });
}

export default function AvatarCropperModal({ isOpen, onClose, imageSrc, onCropComplete }: AvatarCropperModalProps) {
    const imgRef = useRef<HTMLImageElement>(null);
    const [crop, setCrop] = useState<Crop>({ unit: '%', width: 50, height: 50, x: 25, y: 25 });
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();

    const handleCrop = async () => {
        if (!completedCrop || !imgRef.current) return;
        const image = imgRef.current;
        const canvas = document.createElement('canvas');
        const scaleX = image.naturalWidth / image.width;
        const scaleY = image.naturalHeight / image.height;
        canvas.width = completedCrop.width;
        canvas.height = completedCrop.height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.drawImage(image, completedCrop.x * scaleX, completedCrop.y * scaleY, completedCrop.width * scaleX, completedCrop.height * scaleY, 0, 0, completedCrop.width, completedCrop.height);
        try {
            const croppedFile = await canvasToFile(canvas, 'avatar.png');
            onCropComplete(croppedFile);
        } catch (error) {
            console.error("Error creating cropped file:", error);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '600px', width: '100%' }}>
            <h3 style={{ marginTop: 0, marginBottom: '2rem' }}>Crop Your Avatar</h3>
            <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '2rem' }}>
                <ReactCrop crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)} aspect={1} circularCrop>
                    {/* eslint-disable-next-line @next/next/no-img-element */}
                    <img ref={imgRef} alt="Crop me" src={imageSrc} style={{ maxHeight: '70vh' }} />
                </ReactCrop>
            </div>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={handleCrop} className="primary-button">تأكيد</button>
            </div>
        </Modal>
    );
}




--- END OF FILE components/AvatarCropperModal.tsx ---

================================================================================

--- START OF FILE components/BookmarkButton.tsx ---

// components/BookmarkButton.tsx
'use client';

import React from 'react';
import { useUserStore } from '@/lib/store';
import { motion } from 'framer-motion';
import { useSession } from 'next-auth/react';
import ActionButton from './ActionButton';

const iconVariants = {
    unmarked: { scale: 1, rotate: 0 },
    marked: {
        rotate: [0, -5, 5, -2, 2, 0],
        scale: 1,
        transition: { rotate: { duration: 0.5, ease: 'easeInOut' as const } }
    },
};

const fillVariants = {
    unmarked: { opacity: 0, transition: { duration: 0.2 } },
    marked: { opacity: 1, transition: { duration: 0.3, ease: 'easeIn' as const } },
};

const BookmarkIcon = () => (
    <div style={{ position: 'relative', display: 'flex' }}>
        <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </svg>
        <motion.svg
            width="24" height="24" viewBox="0 0 24"
            fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
            style={{ position: 'absolute' }}
            variants={fillVariants}
        >
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </motion.svg>
    </div>
);

const BookmarkButton = ({ contentId, contentType }: { contentId: number; contentType: string; }) => {
    const { status } = useSession();
    const { bookmarks, toggleBookmark, setSignInModalOpen } = useUserStore();
    
    const contentKey = `${contentType}-${contentId}`;
    const isBookmarked = bookmarks.includes(contentKey);

    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        if (status !== 'authenticated') {
            setSignInModalOpen(true);
            return;
        }
        toggleBookmark(contentId, contentType);
    };

    return (
        <ActionButton
            onClick={handleClick}
            aria-label="إحفظ"
        >
            <motion.div
                initial={false}
                animate={isBookmarked ? "marked" : "unmarked"}
                variants={iconVariants}
            >
                <BookmarkIcon />
            </motion.div>
        </ActionButton>
    );
};

export default BookmarkButton;




--- END OF FILE components/BookmarkButton.tsx ---

================================================================================

--- START OF FILE components/BookmarksGrid.tsx ---

// components/BookmarksGrid.tsx

'use client';

import { useUserStore } from '@/lib/store';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';

export default function BookmarksGrid({ initialItems }: { initialItems: any[] }) {
    const bookmarksFromStore = useUserStore(state => state.bookmarks);
    
    // THE FIX: Wrap in arrow function and apply width optimization for grid
    const initialBookmarkedItems = initialItems
        .map(item => adaptToCardProps(item, { width: 600 }))
        .filter(Boolean) as CardProps[];
    
    const [bookmarkedItems, setBookmarkedItems] = useState<CardProps[]>(initialBookmarkedItems);

    useEffect(() => {
        // The keys being compared must use the numeric `legacyId`
        // to match the format used in the Zustand store (e.g., 'review-101').
        const currentKeysInGrid = new Set(bookmarkedItems.map(item => `${item.type}-${item.legacyId}`));
        
        if (bookmarksFromStore.length < currentKeysInGrid.size) {
            // An item was removed from the store, so remove it from the displayed grid.
            setBookmarkedItems(prev => prev.filter(item => bookmarksFromStore.includes(`${item.type}-${item.legacyId}`)));
        }
    }, [bookmarksFromStore, bookmarkedItems]);

    if (initialItems.length === 0 && bookmarkedItems.length === 0) {
        return <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>لم تحفظ شيئًا بعد.</p>;
    }

    return (
        <motion.div layout className="content-grid">
            <AnimatePresence>
                {bookmarkedItems.map(item => (
                    <motion.div
                        key={`bookmark-${item.id}`}
                        layout
                        initial={{ opacity: 0, scale: 0.8 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.8 }}
                        transition={{ type: 'spring' as const, stiffness: 250, damping: 25 }}
                        style={{ height: '100%' }}
                    >
                        <ArticleCard
                            article={item}
                            layoutIdPrefix="bookmark"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </motion.div>
    );
}

--- END OF FILE components/BookmarksGrid.tsx ---

================================================================================

--- START OF FILE components/ConfirmationModal.tsx ---

'use client';

import Modal from './modals/Modal';
import modalStyles from './modals/Modals.module.css';

interface ConfirmationModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => void;
    title: string;
    message: string;
}

export default function ConfirmationModal({ 
    isOpen, 
    onClose, 
    onConfirm, 
    title, 
    message 
}: ConfirmationModalProps) {
    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '450px' }}>
            <h3 style={{ marginTop: 0, fontFamily: 'var(--font-main)', fontSize: '2rem' }}>{title}</h3>
            <p style={{ color: 'var(--text-secondary)', margin: '1rem 0 2rem 0' }}>{message}</p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={onConfirm} className="primary-button delete-forever">
                    تأكيد
                </button>
            </div>
        </Modal>
    );
}

--- END OF FILE components/ConfirmationModal.tsx ---

================================================================================

--- START OF FILE components/ContentActionBar.tsx ---

// components/ContentActionBar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import BookmarkButton from './BookmarkButton';
import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from './ActionButton';

const iconVariants = { unliked: { scale: 1 }, liked: { scale: [1, 1.4, 1.1], transition: { duration: 0.4, ease: "easeOut" as const } }, };
const fillVariants = { unliked: { fill: 'rgba(0,0,0,0)', transition: { duration: 0.2 } }, liked: { fill: 'currentColor', transition: { duration: 0.25, delay: 0.1 } }, };
const shockwaveVariants = { unliked: { scale: 0, opacity: 0 }, liked: { scale: 1, opacity: [1, 0], transition: { duration: 0.5, ease: "easeOut" as const } } };
const HeartIcon = ({ isLiked }: { isLiked: boolean }) => ( <motion.div initial={false} animate={isLiked ? "liked" : "unliked"} variants={iconVariants} style={{ position: 'relative', display: 'flex' }}> <motion.div variants={shockwaveVariants} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, border: '2px solid var(--accent)', borderRadius: '50%' }} /> <svg width="24" height="24" viewBox="0 0 24" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <motion.path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" variants={fillVariants} /> </svg> </motion.div> );
const ShareIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>);
const CheckIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>);

interface ContentActionBarProps { contentId: number; contentType: 'review' | 'article' | 'news'; contentSlug: string; }

export default function ContentActionBar({ contentId, contentType, contentSlug }: ContentActionBarProps) {
    const { status } = useSession();
    const { setSignInModalOpen, likes, toggleLike, addShare } = useUserStore();
    const [justCopied, setJustCopied] = useState(false);
    const [hasMounted, setHasMounted] = useState(false);
    
    useEffect(() => { setHasMounted(true); }, []);

    const contentKey = `${contentType}-${contentId}`;
    const isLiked = hasMounted && likes.includes(contentKey);

    const handleLike = () => { if (status !== 'authenticated') { setSignInModalOpen(true); return; } toggleLike(contentId, contentType, contentSlug); };
    const handleShare = async () => { const shareData = { title: `EternalGames: ${document.title}`, text: `Check out this ${contentType} on EternalGames!`, url: window.location.href }; if (navigator.share) { try { await navigator.share(shareData); if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } } catch (error) { console.log('Web Share API canceled or failed.', error); } } else { await navigator.clipboard.writeText(window.location.href); setJustCopied(true); if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } setTimeout(() => setJustCopied(false), 2000); } };

    if (!hasMounted) { return <div style={{display: 'flex', gap: '1rem', height: '44px'}}><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div></div>; }

    return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <ActionButton onClick={handleLike} aria-label={isLiked ? 'Unlike' : 'Like'}><HeartIcon isLiked={isLiked} /></ActionButton>
            <ActionButton onClick={handleShare} aria-label="مشاركة"><AnimatePresence mode="wait" initial={false}><motion.div key={justCopied ? 'check' : 'share'} initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }} transition={{ duration: 0.2 }}>{justCopied ? <CheckIcon /> : <ShareIcon />}</motion.div></AnimatePresence></ActionButton>
            <BookmarkButton contentId={contentId} contentType={contentType} />
        </div>
    );
}




--- END OF FILE components/ContentActionBar.tsx ---

================================================================================

--- START OF FILE components/ContentBlock.module.css ---

/* components/ContentBlock.module.css */
.contentBlock {
    margin-bottom: 6rem;
}

.contentBlockTitle {
    position: relative; 
    font-size: clamp(2.8rem, 4vw, 3.6rem);
    margin-bottom: 3rem;
    font-weight: 700;
    text-align: right;
    padding-right: 1.5rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
    /* Remove the static border properties */
}

.titleIcon {
    color: var(--accent);
    width: 28px;
    height: 28px;
    flex-shrink: 0;
}

.contentBlockTitle span {
    transform: translateY(-2px); 
}

/* --- NEW: Kinetic Border and Bloom Pseudo-elements --- */
.contentBlockTitle::before,
.contentBlockTitle::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 4px;
    height: 100%;
    pointer-events: none;
}

.contentBlockTitle::before {
    background-color: var(--accent);
    transform-origin: top;
}

.contentBlockTitle::after {
    box-shadow: 0 0 12px var(--accent);
    transform-origin: top;
}
/* --- END NEW --- */


.contentBlockBody {
    /* Default body styles */
}

.variantFullbleed {
    width: 100vw;
    position: relative;
    left: 50%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    padding-top: 4rem;
    padding-bottom: 4rem;
    background-color: var(--bg-secondary);
}

.variantFullbleed .contentBlockTitle {
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
    padding-right: 3.5rem;
    padding-left: 2rem;
}

.variantFullbleed .contentBlockBody {
    padding: 0;
    max-width: none;
}

@media (max-width: 480px) {
    .contentBlockTitle {
        font-size: 2.6rem;
    }
}

--- END OF FILE components/ContentBlock.module.css ---

================================================================================

--- START OF FILE components/ContentBlock.tsx ---

// components/ContentBlock.tsx
'use client';

import React, { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import styles from './ContentBlock.module.css';

type ContentBlockProps = {
    title: string;
    children?: React.ReactNode;
    variant?: 'default' | 'fullbleed';
    Icon?: React.ComponentType<{ className?: string }>;
};

const blockVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.1, // Faster stagger between title and body
        },
    },
};

const titleContainerVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.06, // Stagger between icon and words
            delayChildren: 0.3, // Wait for border to draw
        },
    },
};

const borderVariant = {
    hidden: { scaleY: 0 },
    // THE DEFINITIVE FIX: Added 'as const' to the ease array.
    visible: { scaleY: 1, transition: { duration: 0.4, ease: [0.6, 0.01, -0.05, 0.95] as const } }
};

const titleIconVariant = {
    hidden: { opacity: 0, scale: 0.5 },
    visible: { opacity: 1, scale: 1, transition: { type: 'spring' as const, stiffness: 200, damping: 20 } }
};

const titleWordVariant = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { type: 'spring' as const, stiffness: 120, damping: 14 } }
};

const bodyVariants = {
    hidden: { opacity: 0, y: 30 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            duration: 0.7,
            ease: 'easeOut' as const,
            staggerChildren: 0.08,
        },
    },
};

export function ContentBlock({ title, children, variant = 'default', Icon }: ContentBlockProps) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0 });

    const blockClasses = `${styles.contentBlock} ${variant === 'fullbleed' ? styles.variantFullbleed : ''}`;

    return (
        <motion.section
            ref={ref}
            className={blockClasses}
            variants={blockVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            <motion.h2 className={styles.contentBlockTitle} variants={titleContainerVariants}>
                <motion.div className={styles.contentBlockTitle_before} variants={borderVariant} style={{'--pseudo-selector': '::before'} as any} />
                <motion.div className={styles.contentBlockTitle_after} variants={borderVariant} style={{'--pseudo-selector': '::after'} as any} />
                
                {Icon && (
                    <motion.div variants={titleIconVariant} style={{ display: 'flex' }}>
                        <Icon className={styles.titleIcon} />
                    </motion.div>
                )}
                <span style={{ display: 'inline-block' }}>
                    {title.split(' ').map((word, index) => (
                        <motion.span
                            key={index}
                            variants={titleWordVariant}
                            style={{ display: 'inline-block', marginRight: '0.7rem' }}
                        >
                            {word}
                        </motion.span>
                    ))}
                </span>
            </motion.h2>
            {children && (
                <motion.div className={styles.contentBlockBody} variants={bodyVariants}>
                    {children}
                </motion.div>
            )}
        </motion.section>
    );
}

--- END OF FILE components/ContentBlock.tsx ---

================================================================================

--- START OF FILE components/CreatorCredit.module.css ---

/* components/CreatorCredit.module.css */

.creatorCreditContainer {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.25rem;
}

.creatorCredit {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    line-height: 1.6;
    color: var(--text-primary);
}

.metadataIcon {
    width: 16px;
    height: 16px;
    color: var(--accent);
    flex-shrink: 0;
    order: -1; /* THE DEFINITIVE FIX: Forces icon to the left */
}

.label {
    font-weight: 500;
    color: var(--text-primary);
}

.dateText {
    font-size: 1.3rem;
    color: var(--text-secondary);
    margin: 0;
}

.creatorLinkContainer {
    position: relative;
    display: inline-block;
}

/* --- Small Variant Styles --- */
.creatorCredit.small {
    gap: 0.5rem;
}
.creatorCredit.small .metadataIcon {
    width: 14px;
    height: 14px;
}
.creatorCredit.small .label,
.creatorCredit.small span {
    font-size: 1.2rem;
}

.hoverCard {
    position: absolute;
    bottom: calc(100% + 10px);
    right: 50%; /* Center relative to the link */
    transform: translateX(50%);
    width: 280px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
    padding: 1.5rem;
    z-index: 10;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    transform-origin: bottom center;
}

.cardHeader {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.cardAvatar {
    border-radius: 50%;
}

.cardName {
    font-size: 1.6rem;
    font-weight: 700;
    color: var(--text-primary);
}

.cardUsername {
    font-size: 1.4rem;
    color: var(--text-secondary);
}

.cardBio {
    font-size: 1.4rem;
    color: var(--text-secondary);
    line-height: 1.5;
    margin: 0;
    /* Clamp to 3 lines */
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;  
    overflow: hidden;
}

--- END OF FILE components/CreatorCredit.module.css ---

================================================================================

--- START OF FILE components/CreatorCredit.tsx ---

// components/CreatorCredit.tsx
'use client';

import Link from 'next/link';
import React, { useState, useEffect } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { getCreatorUsernames } from '@/app/actions/creatorActions';
import type { SanityAuthor } from '@/types/sanity';
import { PenEdit02Icon, ColorPaletteIcon } from '@/components/icons/index';
import { urlFor } from '@/sanity/lib/image';
import styles from './CreatorCredit.module.css';

const hoverCardVariants = {
    hidden: { opacity: 0, y: 10, scale: 0.95 },
    visible: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.2, ease: 'easeOut' as const } },
    exit: { opacity: 0, y: 10, scale: 0.95, transition: { duration: 0.15, ease: 'easeIn' as const } }
};

const CreatorHoverCard = ({ creator }: { creator: SanityAuthor }) => {
    let imageUrl = '/default-avatar.svg';
    if (creator.image) {
        if (typeof creator.image === 'string') {
            imageUrl = creator.image;
        } else if (typeof creator.image === 'object' && (creator.image as any).asset) {
            imageUrl = urlFor(creator.image as any).width(96).height(96).fit('crop').url();
        }
    }

    return (
        <motion.div className={styles.hoverCard} variants={hoverCardVariants} initial="hidden" animate="visible" exit="exit">
            <div className={styles.cardHeader}>
                <Image 
                    src={imageUrl} 
                    alt={creator.name}
                    width={48}
                    height={48}
                    className={styles.cardAvatar}
                />
                <div>
                    <p className={styles.cardName}>{creator.name}</p>
                    {creator.username && <p className={styles.cardUsername}>@{creator.username}</p>}
                </div>
            </div>
            {creator.bio && <p className={styles.cardBio}>{creator.bio}</p>}
        </motion.div>
    );
};

const CreatorLink = ({ creator, disableLink }: { creator: SanityAuthor, disableLink?: boolean }) => {
    const [isHovered, setIsHovered] = useState(false);
    
    // THE DEFINITIVE FIX: Stop event propagation on touch to prioritize link navigation over card tilt.
    const handleTouch = (e: React.TouchEvent) => {
        e.stopPropagation();
    };

    return (
        <div 
            className={styles.creatorLinkContainer}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
        >
            <AnimatePresence>
                {isHovered && <CreatorHoverCard creator={creator} />}
            </AnimatePresence>

            {creator.username && !disableLink ? (
                <Link 
                    href={`/creators/${creator.username}`} 
                    className="creator-credit-link no-underline"
                    onClick={(e) => e.stopPropagation()}
                    onTouchStart={handleTouch}
                >
                    {creator.name}
                </Link>
            ) : (
                <span className={creator.username ? "creator-credit-link" : ""}>{creator.name}</span>
            )}
        </div>
    );
};

export default function CreatorCredit({ label, creators, small = false, disableLink = false }: { 
    label: string; 
    creators: SanityAuthor[] | null | undefined;
    small?: boolean;
    disableLink?: boolean;
}) {
    const [enrichedCreators, setEnrichedCreators] = useState(creators || []);

    useEffect(() => {
        const creatorsWithoutUsername = (creators || []).filter(c => c && c.prismaUserId && !c.username);

        if (creatorsWithoutUsername.length > 0) {
            const idsToFetch = creatorsWithoutUsername.map(c => c.prismaUserId);
            getCreatorUsernames(idsToFetch).then(usernameMap => {
                setEnrichedCreators(prevCreators => 
                    prevCreators.map(creator => {
                        if (creator.prismaUserId && usernameMap[creator.prismaUserId]) {
                            return { ...creator, username: usernameMap[creator.prismaUserId] };
                        }
                        return creator;
                    })
                );
            });
        } else {
            setEnrichedCreators(creators || []);
        }
    }, [creators]);
    
    const hasCreators = enrichedCreators && enrichedCreators.length > 0;

    if (!hasCreators) {
        return null;
    }

    const formattedNames = enrichedCreators.map((creator, i) => (
        <React.Fragment key={`${creator._id}-${i}`}>
            {i > 0 && (i === enrichedCreators.length - 1 ? ' و ' : '، ')}
            <CreatorLink creator={creator} disableLink={disableLink} />
        </React.Fragment>
    ));

    const IconComponent = label === 'تصميم' ? ColorPaletteIcon : PenEdit02Icon;

    return (
        <div className={`${styles.creatorCredit} ${small ? styles.small : ''}`}>
             <IconComponent className={styles.metadataIcon} />
            <div>
                <span className={styles.label}>{label}: </span>
                <span>{formattedNames}</span>
            </div>
        </div>
    );
}

--- END OF FILE components/CreatorCredit.tsx ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.module.css ---

/* components/DigitalAtriumHomePage.module.css */
.atriumPageContainer {
  position: relative;
  width: 100%;
  padding-top: var(--nav-height-scrolled);
}

.vanguardFullBleedContainer {
    background-color: var(--bg-secondary);
    padding-top: 4rem;
    margin-bottom: 5rem;
    overflow-x: clip; /* THE DEFINITIVE FIX: Contain overflow here */
}

.atriumMainContent {
  padding-bottom: 8rem;
}

.homeGrid {
  display: grid;
  grid-template-columns: 1fr 1.75fr;
  gap: 4rem;
  margin-bottom: 8rem;
}

@media (max-width: 1024px) {
  .homeGrid {
    grid-template-columns: 1fr;
    gap: 8rem;
  }
}

@media (max-width: 768px) {
    .vanguardFullBleedContainer {
        margin-bottom: 3rem;
    }
    .atriumMainContent {
        padding-bottom: 4rem;
    }
}

--- END OF FILE components/DigitalAtriumHomePage.module.css ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.tsx ---

// components/DigitalAtriumHomePage.tsx
'use client';

import { Suspense } from 'react';
import { ContentBlock } from './ContentBlock';
import VanguardReviews from './VanguardReviews/VanguardReviews';
import { adaptToCardProps } from '@/lib/adapters';
import AnimatedGridBackground from './AnimatedGridBackground';
import { ReviewIcon, ReleaseIcon } from '@/components/icons/index';
import styles from './DigitalAtriumHomePage.module.css';
import { CardProps } from '@/types';

export default function DigitalAtriumHomePage({
    reviews,
    feedsContent,
    releasesSection
}: {
    reviews: any[];
    feedsContent: React.ReactNode;
    releasesSection: React.ReactNode;
}) {
  // OPTIMIZATION: Vanguard cards are large, request 800px
  const adaptedReviews = (reviews || []).map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[];
  
  return (
    <div className={styles.atriumPageContainer}>
      <AnimatedGridBackground />
      <div className={styles.vanguardFullBleedContainer}>
        <div className="container">
            <ContentBlock title="أحدث المراجعات" Icon={ReviewIcon} />
        </div>
        <VanguardReviews reviews={adaptedReviews} />
      </div>
      
      <div className={styles.atriumMainContent}>
          <div className="container">
              {/* SKELETON REMOVED */}
              {feedsContent}
          </div>
          
          <ContentBlock title="إصدارات هذا الشهر" Icon={ReleaseIcon} variant="fullbleed">
              <div className="container">
                  <p style={{textAlign: 'center', maxWidth: '600px', margin: '-2rem auto 4rem auto', color: 'var(--text-secondary)'}}>
                      نظرة على الألعاب التي ترى النور هذا الشهر. ما صدر منها قد وُسِمَ بعلامة.
                  </p>
                  {/* SKELETON REMOVED */}
                  <Suspense fallback={null}>
                      {releasesSection}
                  </Suspense>
              </div>
          </ContentBlock>
      </div>
    </div>
  );
}

--- END OF FILE components/DigitalAtriumHomePage.tsx ---

================================================================================

--- START OF FILE components/Footer.module.css ---

/* components/Footer.module.css */

.footer {
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--border-color);
}
.newFooterLayout {
  padding: 4rem 0;
}
.footerContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2.5rem;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem;
}
.footerSocialsWrapper {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
}
.footerDivider {
  width: 60px;
  height: 1px;
  background-color: var(--border-color);
  margin: 0 auto;
}
.footerInfo {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem;
  font-size: 1.4rem;
  color: var(--text-secondary);
  flex-wrap: wrap;
}
.footerCopyright, .footerInfo a {
  margin: 0;
}
.designerCredit {
  display: inline-flex;
  align-items: center;
  gap: 0.7rem;
  color: var(--text-primary); /* THE FIX: Changed from --text-secondary */
  transition: color 0.3s ease, transform 0.3s ease;
}
.designerCredit:hover {
  color: var(--accent);
  transform: translateY(-2px);
}
.designerIcon {
  width: 14px;
  height: 14px;
}
.infoSeparator {
  font-weight: 300;
}
.footerSocialsWrapper a {
  transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}
.footerSocialsWrapper a:hover {
  filter: none !important;
  transform: translateY(-4px); 
}
.socialLinkFrame {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  background-color: transparent;
  transition: all 0.2s ease-out;
  flex-shrink: 0;
}
.footerSocialsWrapper a:hover .socialLinkFrame {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  color: var(--accent);
}
.socialIconSvg {
  width: 20px;
  height: 20px;
}

@media (max-width: 768px) {
  .newFooterLayout {
    padding: 3rem 0;
  }
  .footerContainer {
    gap: 2rem;
  }
  .footerInfo {
    flex-direction: column;
    gap: 4rem;
  }
  .infoSeparator {
    display: none;
  }
  .footerSocialsWrapper {
    gap: 1rem;
  }
}

--- END OF FILE components/Footer.module.css ---

================================================================================

--- START OF FILE components/Footer.tsx ---

'use client';

import React from 'react';
import styles from './Footer.module.css';

//  Dedicated, Correctly Scaled Icon Components
const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 1200 1227" fill="currentColor" {...props}>
<g transform="scale(0.8) translate(150, 150)">
<path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
</g>
</svg>
);
const TikTokIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="80 80 320 320" fill="currentColor" {...props}>
<path d="M207.26,200.54c3.77,0,7.48.28,11.1.81v43.65c-3.47-1.22-7.21-1.88-11.1-1.88-18.55,0-33.59,15.04-33.59,33.59s15.04,33.59,33.59,33.59,33.59-15.04,33.59-33.59V113.28h42.83c-.06,1.09-.1,2.19-.1,3.3,0,30.64,24.84,55.48,55.48,55.48v40.79c-20.73,0-39.92-6.55-55.63-17.7v81.57c0,42.07-34.11,76.17-76.17,76.17s-76.17-34.11-76.17-76.17,34.1-76.17,76.17-76.17"/>
</svg>
);
const YouTubeIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M21.58 7.19a2.5 2.5 0 0 0-1.76-1.77C18.25 5 12 5 12 5s-6.25 0-7.82.42a2.5 2.5 0 0 0-1.76 1.77A26.12 26.12 0 0 0 2 12s0 4.25.42 5.81a2.5 2.5 0 0 0 1.76 1.77C5.75 20 12 20 12 20s6.25 0 7.82-.42a2.5 2.5 0 0 0 1.76-1.77A26.12 26.12 0 0 0 22 12s0-4.25-.42-4.81zM9.75 15.5v-7l6 3.5-6 3.5z"/>
</svg>
);
const InstagramIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M7.8 2h8.4C19.4 2 22 4.6 22 7.8v8.4a5.8 5.8 0 0 1-5.8 5.8H7.8C4.6 22 2 19.4 2 16.2V7.8A5.8 5.8 0 0 1 7.8 2m-.2 2A3.6 3.6 0 0 0 4 7.6v8.8C4 18.39 5.61 20 7.6 20h8.8a3.6 3.6 0 0 0 3.6-3.6V7.6C20 5.61 18.39 4 16.4 4H7.6m9.65 1.5a1.25 1.25 0 0 1 1.25 1.25A1.25 1.25 0 0 1 17.25 8 1.25 1.25 0 0 1 16 6.75a1.25 1.25 0 0 1 1.25-1.25M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z"/>
</svg>
);
const FacebookIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
</svg>
);

const Footer = () => {
return (
<footer className={`${styles.footer} ${styles.newFooterLayout}`}>
<div className={`container ${styles.footerContainer}`}>
<div className={`${styles.footerSocialsWrapper}`}>
<a href="https://x.com/1EternalGames" target="_blank" rel="noopener noreferrer" aria-label="X / Twitter" className="no-underline">
<div className={styles.socialLinkFrame}><XIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.tiktok.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="TikTok" className="no-underline">
<div className={styles.socialLinkFrame}><TikTokIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.youtube.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="YouTube" className="no-underline">
<div className={styles.socialLinkFrame}><YouTubeIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.instagram.com/1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="Instagram" className="no-underline">
<div className={styles.socialLinkFrame}><InstagramIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.facebook.com/people/Eternal-Games/61574132488834/" target="_blank" rel="noopener noreferrer" aria-label="Facebook" className="no-underline">
<div className={styles.socialLinkFrame}><FacebookIcon className={styles.socialIconSvg} /></div>
</a>
</div>

<div className={styles.footerDivider}></div>

<div className={styles.footerInfo}>
<p className={styles.footerCopyright}>&copy; {new Date().getFullYear()} EternalGames</p>
<span className={styles.infoSeparator}>•</span>
<a href="https://x.com/MoVisionX" target="_blank" rel="noopener noreferrer" className={`${styles.designerCredit} no-underline`}>
<span>تطوير محمد السعد - @MoVisionX</span>
<XIcon className={styles.designerIcon} />
</a>
</div>
</div>
</footer>
);
};

export default Footer;

--- END OF FILE components/Footer.tsx ---

================================================================================

--- START OF FILE components/GameLink.module.css ---

/* components/GameLink.module.css */

.kineticGameTag {
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.6rem 1.4rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 600;
    border: 1px solid var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
    color: var(--accent);
    transition: all 0.25s ease-out;
    white-space: nowrap;
    flex-direction: row-reverse;
    /* MODIFIED: Add max-width to constrain the button on small screens */
    max-width: 100%;
}
  
.kineticGameTag:hover {
    transform: translateY(-2px);
    background-color: var(--accent);
    border-color: var(--accent);
    color: #FFFFFF;
    box-shadow: 0 4px 15px color-mix(in srgb, var(--accent) 20%, transparent);
}
  
[data-theme="dark"] .kineticGameTag:hover {
    color: var(--bg-primary);
}
  
.gameTagArrow {
    display: inline-block;
    opacity: 0;
    transform: translateX(8px);
    transition: opacity 0.25s ease-out, transform 0.25s ease-out;
}
  
.kineticGameTag:hover .gameTagArrow {
    opacity: 1;
    transform: translateX(-0);
}

/* MODIFIED: Add mobile-specific styles for smart text wrapping */
@media (max-width: 768px) {
    .kineticGameTag {
        /* Allow text to wrap if it exceeds the button's width */
        white-space: normal;
        /* Center content vertically when it wraps */
        justify-content: center;
        /* Ensure text alignment is centered when it wraps */
        text-align: center;
    }
}

--- END OF FILE components/GameLink.module.css ---

================================================================================

--- START OF FILE components/GameLink.tsx ---

// components/GameLink.tsx
import Link from 'next/link';
import React from 'react';
import styles from './GameLink.module.css';

type GameLinkProps = {
    gameName?: string | null;
    gameSlug?: string | null;
    className?: string;
};

const GameLink = ({ gameName, gameSlug, className = '' }: GameLinkProps) => {
    if (!gameName || !gameSlug) {
        return null;
    }
    
    const finalClassName = `${styles.kineticGameTag} ${className} no-underline`;

    return (
        <Link href={`/games/${gameSlug}`} className={finalClassName}>
            <span>{gameName}</span>
            <span className={styles.gameTagArrow}>→</span>
        </Link>
    );
};

export default GameLink;

--- END OF FILE components/GameLink.tsx ---

================================================================================

--- START OF FILE components/HorizontalShowcase.module.css ---

/* components/HorizontalShowcase.module.css */

/* --- Page Structure & Background --- */
.articlesPageContainer {
  position: relative;
  padding-top: var(--nav-height-scrolled);
}

.articlesPageBg {
  position: fixed;
  top: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}
.articlesPageBgOverlay {
  position: absolute;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 80%, transparent);
  backdrop-filter: blur(16px) saturate(120%);
}

.showcaseSection {
  margin-bottom: 6rem;
}
.gridSection {
  margin-top: 0;
}

/* --- Desktop Horizontal Showcase --- */
.horizontalShowcaseWrapper {
  position: relative;
  height: 450px;
  display: flex;
  align-items: center;
  overflow: hidden;
  cursor: grab;
}
.horizontalShowcaseWrapper:active {
  cursor: grabbing;
}

.horizontalShowcaseList {
  display: flex;
  align-items: center;
  --showcase-card-width: 50vw;
  --showcase-card-max-width: 600px;
  --showcase-card-gap: 2rem;
}

.showcaseItemWrapper {
  flex-shrink: 0;
  width: var(--showcase-card-width);
  max-width: var(--showcase-card-max-width);
  margin-right: var(--showcase-card-gap);
}
.showcaseItemWrapper:first-child {
  margin-left: var(--showcase-card-gap);
}

.showcaseCardContainer {
  width: 100%;
  perspective: 1000px;
  flex-shrink: 0;
  padding: 0 1.5rem;
}

.showcaseCardLink {
  display: block;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 16 / 9;
  box-shadow: 0 20px 40px -15px color-mix(in srgb, var(--text-primary) 20%, transparent);
  background-color: var(--bg-secondary);
  border: 1px solid color-mix(in srgb, var(--border-color) 50%, transparent);
}

.showcaseCardImageWrapper {
  position: absolute;
  inset: 0;
}
.showcaseCardImage {
  transition: transform 0.4s ease;
}
.showcaseCardLink:hover .showcaseCardImage {
  transform: scale(1.05);
}

.showcaseCardContent {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 2.5rem;
  color: #fff;
  background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
  text-align: right;
}
.showcaseCardTitle {
  font-family: var(--font-main);
  font-size: 2.8rem;
  line-height: 1.2;
}
.showcaseCardGame {
  font-family: var(--font-main);
  color: var(--text-secondary);
  font-weight: 500;
  margin-top: 0.75rem;
}
[data-theme="dark"] .showcaseCardGame {
  color: color-mix(in srgb, var(--text-secondary) 80%, #fff);
}

.showcaseArrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 10;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(8px);
}
.showcaseArrow.left {
  left: 3rem;
  right: auto;
}
.showcaseArrow.right {
  right: 3rem;
  left: auto;
}

/* --- Mobile Vertical Showcase --- */
.mobileShowcaseContainer {
    position: relative;
    width: 70%; /* MODIFIED: Reduced from 80% */
    max-width: 400px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mobileShowcaseCardWrapper {
    width: 100%;
}

/* --- MOBILE RESPONSIVENESS --- */
@media (max-width: 768px) {
  .horizontalShowcaseWrapper {
    display: none;
  }

  .articlesPageContainer .page-title {
    margin-bottom: 2rem;
  }

  .showcaseSection {
    margin-bottom: 4rem;
  }

  .showcaseArrow {
    width: 40px;
    height: 40px;
  }

  .showcaseArrow.left {
    left: -5rem; /* MODIFIED: Increased distance further */
  }

  .showcaseArrow.right {
    right: -5rem; /* MODIFIED: Increased distance further */
  }

  .showcaseCardTitle {
    font-size: 2.2rem;
  }
}

--- END OF FILE components/HorizontalShowcase.module.css ---

================================================================================

--- START OF FILE components/HorizontalShowcase.tsx ---

// components/HorizontalShowcase.tsx

'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { CardProps } from '@/types';
import styles from './HorizontalShowcase.module.css';

const ArrowIcon = ({ direction = 'right' }: { direction?: 'left' | 'right' }) => (
  <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
    <polyline points={direction === 'right' ? "9 18 15 12 9 6" : "15 18 9 12 15 6"} />
  </svg>
);

const ShowcaseCard = ({ article, isActive }: { article: CardProps, isActive: boolean }) => {
  const router = useRouter();
  const setPrefix = useLayoutIdStore((state) => state.setPrefix);
  const layoutIdPrefix = "articles-showcase";
  
  const handleClick = (e: React.MouseEvent) => {
    e.preventDefault();
    setPrefix(layoutIdPrefix);
    router.push(`/articles/${article.slug}`, { scroll: false });
  };

  const imageSource = article.imageUrl;
  if (!imageSource) return null;

  return (
    <motion.div
      className={styles.showcaseCardContainer}
      animate={{ scale: isActive ? 1 : 0.85, opacity: isActive ? 1 : 0.7 }}
      transition={{ type: 'spring', stiffness: 300, damping: 30 }}
    >
      <motion.div
        layoutId={`${layoutIdPrefix}-card-container-${article.legacyId}`}
        onClick={handleClick}
        className={`no-underline ${styles.showcaseCardLink}`}
        draggable="false"
        style={{ cursor: 'pointer' }}
      >
        <motion.div layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`} className={styles.showcaseCardImageWrapper}>
          <Image 
            src={imageSource} alt={article.title} fill sizes="60vw"
            style={{ objectFit: 'cover' }} className={styles.showcaseCardImage}
            draggable="false"
          />
        </motion.div>
        <div className={styles.showcaseCardContent}>
          <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`} className={styles.showcaseCardTitle}>{article.title}</motion.h3>
          <p className={styles.showcaseCardGame}>{article.game}</p>
        </div>
      </motion.div>
    </motion.div>
  );
};

export default function HorizontalShowcase({ articles, onActiveIndexChange }: { articles: CardProps[], onActiveIndexChange: (index: number) => void }) {
  const [activeIndex, setActiveIndex] = useState(0);
  const [xOffset, setXOffset] = useState(0);
  const [isCalculated, setIsCalculated] = useState(false);
  
  const wrapperRef = useRef<HTMLDivElement>(null);
  const cardRefs = useRef<(HTMLDivElement | null)[]>([]);

  const calculateAndGoToIndex = useCallback((index: number) => {
    if (!wrapperRef.current || !cardRefs.current[index]) return;
    const wrapperWidth = wrapperRef.current.offsetWidth;
    const targetCard = cardRefs.current[index]!;
    const targetOffsetLeft = targetCard.offsetLeft;
    const targetWidth = targetCard.offsetWidth;
    const newXOffset = (wrapperWidth / 2) - targetOffsetLeft - (targetWidth / 2);
    setXOffset(newXOffset);
    setActiveIndex(index);
    onActiveIndexChange(index);
    setIsCalculated(true);
  }, [onActiveIndexChange]);

  useEffect(() => {
    const handleResize = () => calculateAndGoToIndex(activeIndex);
    window.addEventListener('resize', handleResize);
    const timeoutId = setTimeout(() => handleResize(), 100); 
    return () => { window.removeEventListener('resize', handleResize); clearTimeout(timeoutId); };
  }, [activeIndex, calculateAndGoToIndex]);
  
  const handleNext = useCallback(() => { const nextIndex = Math.min(activeIndex + 1, articles.length - 1); calculateAndGoToIndex(nextIndex); }, [activeIndex, articles.length, calculateAndGoToIndex]);
  const handlePrev = useCallback(() => { const prevIndex = Math.max(activeIndex - 1, 0); calculateAndGoToIndex(prevIndex); }, [activeIndex, calculateAndGoToIndex]);
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => { if (event.key === 'ArrowRight') handleNext(); if (event.key === 'ArrowLeft') handlePrev(); };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleNext, handlePrev]);

  const onDragEnd = (event: any, { offset, velocity }: any) => {
    const swipeConfidenceThreshold = 10000;
    const swipePower = Math.abs(offset.x) * velocity.x;
    if (swipePower < -swipeConfidenceThreshold) { handleNext(); } 
    else if (swipePower > swipeConfidenceThreshold) { handlePrev(); } 
    else { calculateAndGoToIndex(activeIndex); }
  };

  return (
    <div ref={wrapperRef} className={styles.horizontalShowcaseWrapper} dir="ltr">
      <AnimatePresence>
        {isCalculated && activeIndex > 0 && (
          <motion.button className={`${styles.showcaseArrow} ${styles.left}`} onClick={handlePrev} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
            <ArrowIcon direction="left" />
          </motion.button>
        )}
      </AnimatePresence>
      <AnimatePresence>
        {isCalculated && activeIndex < articles.length - 1 && (
          <motion.button className={`${styles.showcaseArrow} ${styles.right}`} onClick={handleNext} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
            <ArrowIcon direction="right" />
          </motion.button>
        )}
      </AnimatePresence>

      <motion.div
        className={styles.horizontalShowcaseList}
        drag="x" dragConstraints={{ left: 0, right: 0 }} dragElastic={0.1} onDragEnd={onDragEnd}
        initial={{ opacity: 0 }}
        animate={{ x: xOffset, opacity: isCalculated ? 1 : 0 }}
        transition={{ x: { type: 'spring', stiffness: 300, damping: 50 }, opacity: { duration: 0.5 } }}
      >
        {articles.map((article, index) => (
          <div key={article.id} ref={(el) => { cardRefs.current[index] = el; }} className={styles.showcaseItemWrapper}>
            <ShowcaseCard article={article} isActive={activeIndex === index} />
          </div>
        ))}
      </motion.div>
    </div>
  );
}

--- END OF FILE components/HorizontalShowcase.tsx ---

================================================================================

--- START OF FILE components/HubFilters.tsx ---

// components/HubFilters.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './filters/Filters.module.css';

export type HubTypeFilter = 'all' | 'review' | 'article' | 'news';
export type HubSortOrder = 'latest' | 'viral';

const typeFilters: { label: string, value: HubTypeFilter }[] = [
    { label: 'الكل', value: 'all' },
    { label: 'مراجعات', value: 'review' },
    { label: 'مقالات', value: 'article' },
    { label: 'أخبار', value: 'news' },
];

const sortOrders: { label: string, value: HubSortOrder }[] = [
    { label: 'الأحدث', value: 'latest' },
    { label: 'الأكثر رواجًا', value: 'viral' },
];

interface HubFiltersProps {
    activeTypeFilter: HubTypeFilter;
    onTypeFilterChange: (filter: HubTypeFilter) => void;
    activeSort: HubSortOrder;
    onSortChange: (sort: HubSortOrder) => void;
}

export default function HubFilters({
    activeTypeFilter,
    onTypeFilterChange,
    activeSort,
    onSortChange
}: HubFiltersProps) {
    return (
        <div className={styles.filtersContainer} style={{ marginBottom: '3rem' }}>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>نوع المحتوى:</span>
                <div className={styles.filterButtonsGroup}>
                    {typeFilters.map(filter => (
                        <motion.button
                            key={filter.value}
                            onClick={() => onTypeFilterChange(filter.value)}
                            className={`${styles.filterButton} ${activeTypeFilter === filter.value ? styles.active : ''}`}
                        >
                            {filter.label}
                            {activeTypeFilter === filter.value && <motion.div layoutId="hub-type-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>الفرز حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    {sortOrders.map(sort => (
                        <motion.button
                            key={sort.value}
                            onClick={() => onSortChange(sort.value)}
                            className={`${styles.filterButton} ${activeSort === sort.value ? styles.active : ''}`}
                        >
                            {sort.label}
                            {activeSort === sort.value && <motion.div layoutId="hub-sort-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
        </div>
    );
}







--- END OF FILE components/HubFilters.tsx ---

================================================================================

--- START OF FILE components/HubPage.module.css ---

/* components/HubPage.module.css */
.hubPageContainer {
  /* padding-top: var(--nav-height-scrolled); <-- REMOVED */
}

.hubHero {
  height: 40vh; /* <-- REDUCED HEIGHT */
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  margin-bottom: -8rem; /* <-- PULLS CONTENT UP */
}

.heroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
}

.heroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 100%); /* Adjusted gradient */
  z-index: -1;
}

.heroTitle {
  font-size: 6.4rem;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
}

@media (max-width: 768px) {
  .hubHero {
    height: 35vh;
  }
  .heroTitle {
    font-size: 4.8rem;
  }
}




--- END OF FILE components/HubPage.module.css ---

================================================================================

--- START OF FILE components/HubPageClient.tsx ---

// components/HubPageClient.tsx
'use client';

import { useState, useMemo, useRef, useEffect } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import HubFilters, { HubTypeFilter, HubSortOrder } from './HubFilters';
import ArticleCard from './ArticleCard';
import Image from 'next/image';
import { adaptToCardProps } from '@/lib/adapters';
import { urlFor } from '@/sanity/lib/image';
import styles from './HubPage.module.css';
import { CardProps, EngagementScore } from '@/types';

interface HubPageClientProps {
    initialItems: any[];
    hubTitle: string;
    hubType: 'اللعبة' | 'وسم' | 'أعمال';
    headerAction?: React.ReactNode;
}

export default function HubPageClient({ initialItems, hubTitle, hubType, headerAction }: HubPageClientProps) {
    if (!initialItems || initialItems.length === 0) {
        return (
            <div className="container page-container">
                <h1 className="page-title">{hubType}: &quot;{hubTitle}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)', fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto'}}>
                    لم يُنشر أي محتوى يطابق هذا المحور بعد. الأرشيف يترقب المستجدات.
                </p>
            </div>
        );
    }
    
    const [activeTypeFilter, setActiveTypeFilter] = useState<HubTypeFilter>('all');
    const [activeSort, setActiveSort] = useState<HubSortOrder>('latest');
    const [engagementScores, setEngagementScores] = useState<Map<number, number>>(new Map());
    const contentRef = useRef(null);
    const isInView = useInView(contentRef, { once: true, amount: 0.1 });

    useEffect(() => {
        const fetchScores = async () => {
            try {
                const res = await fetch('/api/engagement-scores');
                const data: EngagementScore[] = await res.json();
                const scoresMap = new Map(data.map(score => [score.id, score.engagementScore]));
                setEngagementScores(scoresMap);
            } catch (error) {
                console.error("Failed to fetch engagement scores for Hub Page:", error);
            }
        };
        if (activeSort === 'viral') {
            fetchScores();
        }
    }, [activeSort]);

    // THE FIX: Wrap in arrow function and apply width optimization
    const adaptedInitialItems = useMemo(() => 
        (initialItems || [])
            .map(item => adaptToCardProps(item, { width: 600 }))
            .filter(Boolean) as CardProps[],
        [initialItems]
    );

    const filteredAndSortedItems = useMemo(() => {
        let items = [...adaptedInitialItems];

        if (activeTypeFilter !== 'all') {
            items = items.filter(item => item.type === activeTypeFilter);
        }

        if (activeSort === 'viral') {
            items.sort((a, b) => {
                const scoreA = engagementScores.get(a.legacyId) || 0;
                const scoreB = engagementScores.get(b.legacyId) || 0;
                return scoreB - scoreA;
            });
        }
        
        return items;
    }, [adaptedInitialItems, activeTypeFilter, activeSort, engagementScores]);

    const latestItem = useMemo(() => {
        if (initialItems && initialItems.length > 0) {
            return initialItems[0];
        }
        return null;
    }, [initialItems]);

    const heroImageUrl = latestItem?.mainImageRef 
        ? urlFor(latestItem.mainImageRef).width(1920).auto('format').url() 
        : null;
    const heroBlurDataURL = latestItem?.mainImageRef 
        ? urlFor(latestItem.mainImageRef).width(20).blur(10).auto('format').url()
        : null;
    
    const heroContent = (
        <div className={styles.hubHero} style={{ height: heroImageUrl ? '40vh' : 'auto', marginBottom: heroImageUrl ? '-8rem' : '0', paddingTop: heroImageUrl ? '0' : `calc(var(--nav-height-scrolled) + 4rem)`}}>
            {heroImageUrl && (
                <>
                    <Image 
                        src={heroImageUrl} 
                        alt={`Background for ${hubTitle}`} 
                        fill 
                        className={styles.heroBg}
                        style={{ objectFit: 'cover' }} 
                        priority 
                        placeholder={heroBlurDataURL ? 'blur' : 'empty'}
                        blurDataURL={heroBlurDataURL || ''}
                    />
                    <div className={styles.heroOverlay} />
                </>
            )}
            <motion.div 
                className="container"
                style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1.5rem', zIndex: 5 }}
                initial={{opacity: 0, y: 20}} animate={{opacity: 1, y: 0}} transition={{duration: 0.5, delay: 0.2}}
            >
                {headerAction}
                <h1 className={`${styles.heroTitle} page-title`} style={{margin: 0}}>
                    {hubType}<span>: &quot;{hubTitle}&quot;</span>
                </h1>
            </motion.div>
        </div>
    );

    const layoutIdPrefix = `hub-${hubType}-${hubTitle.replace(/\s+/g, '-')}`;

    return (
        <div className={styles.hubPageContainer}>
            {heroContent}
            <div ref={contentRef} className="container" style={{paddingTop: '4rem'}}>
                 <motion.div
                    initial={{ opacity: 0, y: 50 }}
                    animate={isInView ? { opacity: 1, y: 0 } : {}}
                    transition={{ duration: 0.7, ease: "easeOut" as const }}
                >
                    <HubFilters
                        activeTypeFilter={activeTypeFilter}
                        onTypeFilterChange={setActiveTypeFilter}
                        activeSort={activeSort}
                        onSortChange={setActiveSort}
                    />
                </motion.div>
                
                <motion.div 
                    layout 
                    className="content-grid" 
                    style={{ paddingBottom: '6rem' }}
                >
                    <AnimatePresence>
                        {filteredAndSortedItems.length > 0 ? (
                            filteredAndSortedItems.map(item => (
                                <motion.div
                                    key={item.id}
                                    layout
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    exit={{ opacity: 0 }}
                                    transition={{ type: 'spring' as const, stiffness: 250, damping: 25 }}
                                    style={{ height: '100%' }}
                                >
                                    <ArticleCard
                                        article={item}
                                        layoutIdPrefix={layoutIdPrefix}
                                    />
                                </motion.div>
                            ))
                        ) : (
                                <motion.div 
                                initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                                style={{gridColumn: '1 / -1', textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}}
                            >
                                لا يوجد محتوى يطابق بحثك.
                            </motion.div>
                        )}
                    </AnimatePresence>
                </motion.div>
            </div>
        </div>
    );
}

--- END OF FILE components/HubPageClient.tsx ---

================================================================================

--- START OF FILE components/ImageCompare.module.css ---

/* components/ImageCompare.module.css */
.compareWrapper {
  margin: 2rem 0;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  box-shadow: 0 10px 30px -10px rgba(0,0,0,0.2);
  line-height: 0; 
}

.placeholder {
  width: 100%;
  aspect-ratio: 16/9;
  background-color: var(--bg-primary);
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  padding: 1rem;
}

.dropzone {
  aspect-ratio: 16 / 9;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  font-family: var(--font-main);
  font-size: 1.4rem;
  transition: border-color 0.2s, background-color 0.2s;
  position: relative; /* For image positioning */
  overflow: hidden; /* To contain the image */
  cursor: pointer; /* For click-to-upload */
}

.dropzone.active {
  border-color: var(--accent);
  background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.uploadIcon {
  width: 2.4rem;
  height: 2.4rem;
  margin-bottom: 0.5rem;
  opacity: 0.6;
}

.imagePreview {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
}

.dropzoneContent {
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(0,0,0,0.5);
  color: white;
  padding: 1rem;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.2s ease-out;
}
.dropzone:hover .dropzoneContent {
  opacity: 1;
}

.imageCompareContainer {
  margin: 2rem 0;
}

.imageCompareContainer[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="large"] { max-width: 100%; }

.twoImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

.fourImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}




--- END OF FILE components/ImageCompare.module.css ---

================================================================================

--- START OF FILE components/ImageCompare.tsx ---

// components/ImageCompare.tsx
'use client';

import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { urlFor } from '@/sanity/lib/image'; // Import urlFor
import styles from './ImageCompare.module.css';

export default function ImageCompare({ value }: { value: any }) {
    const { image1, image2, size } = value;

    if (!image1?.asset || !image2?.asset) {
        return <div className={styles.placeholder}>Could not load image comparison.</div>;
    }

    // --- THE DEFINITIVE FIX ---
    const imageUrl1 = urlFor(image1).auto('format').url();
    const imageUrl2 = urlFor(image2).auto('format').url();

    return (
        <div className={styles.imageCompareContainer} data-size={size || 'large'}>
            <div className={styles.compareWrapper}>
                <ReactCompareSlider
                    itemOne={<ReactCompareSliderImage src={imageUrl1} alt={image1.alt || 'Before'} />}
                    itemTwo={<ReactCompareSliderImage src={imageUrl2} alt={image2.alt || 'After'} />}
                />
            </div>
        </div>
    );
}




--- END OF FILE components/ImageCompare.tsx ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.module.css ---

/* components/KineticReleaseTimeline.module.css */
.timelineContainer {
  position: relative;
  max-width: 760px;
  margin: 0 auto;
  padding: 4rem 2rem;
}

.timelineSpine {
  position: absolute;
  top: 0;
  right: 50%;
  transform: translateX(50%);
  width: 2px;
  height: 100%;
  z-index: 1;
  /* CRITICAL FIX: Force GPU acceleration and ensure rendering */
  will-change: transform;
  backface-visibility: visible;
}

.timelineSpineTrack {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
  border-radius: 2px;
}

.timelineSpineProgress {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  transform-origin: top;
  box-shadow: 0 0 10px 0 var(--accent);
  /* CRITICAL FIX: Ensure progress bar renders */
  will-change: transform;
}

.timelineItemsWrapper {
  display: flex;
  flex-direction: column;
  /* CRITICAL FIX: Create new stacking context */
  position: relative;
  z-index: 2;
}

/* --- REVISED LAYOUT LOGIC --- */
.timelineItemWrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  position: relative;
  margin-bottom: 4rem;
  gap: 80px;
  /* CRITICAL FIX: Remove z-index that was conflicting */
  /* z-index: 2; REMOVED */
}

.timelineItemWrapper.left {
  flex-direction: row-reverse;
}

.timelineItemWrapper.right {
  flex-direction: row;
}

/* This targets the motion.div wrapping the card */
.timelineItemWrapper > div:last-child {
    width: calc(50% - 40px);
}

.synopsisContainer {
  width: calc(50% - 40px);
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  color: var(--text-primary);
  line-height: 1.7;
  pointer-events: none;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 2.5rem;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
}

.synopsisContainer.left {
  text-align: right;
}

.synopsisContainer.right {
  text-align: left;
}

.synopsisFirstWord {
  font-weight: 700;
  color: var(--accent);
}

.dotsContainer {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  /* CRITICAL FIX: Force rendering */
  pointer-events: none;
}

.dot {
  position: absolute;
  left: 50%;
  width: 12px;
  height: 12px;
  background-color: var(--border-color);
  border-radius: 50%;
  transform: translateX(-50%) translateY(-50%);
  transition: background-color 0.2s ease-in-out, box-shadow 0.3s ease-in-out;
  /* CRITICAL FIX: Ensure dots render */
  will-change: background-color, box-shadow;
  backface-visibility: visible;
}

.releasedIndicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background-color: color-mix(in srgb,var(--accent) 90%,transparent);
  backdrop-filter: blur(4px);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-size: 1.3rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  border: 1px solid rgba(255,255,255,0.2);
}

.checkIcon {
  width: 16px;
  height: 16px;
}

.terminusContainer {
  position: relative;
  text-align: center;
  margin-top: 2rem;
  height: 60px;
  z-index: 3;
}

.timelineTerminusButton {
  display: inline-flex;
  align-items: center;
  gap: 1rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  padding: 1rem 2.5rem;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-secondary);
  transition: all 0.15s ease-out;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
}

.timelineTerminusButton:hover {
  color: var(--accent);
  border-color: var(--accent);
  transform: translateY(-3px);
  box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent);
}

.terminusIcon {
  width: 20px;
  height: 20px;
}

/* --- MOBILE OVERRIDES --- */
@media (max-width: 768px) {
  .timelineContainer {
    padding: 4rem 1rem;
  }
  .timelineItemWrapper {
      gap: 40px;
  }
  .timelineItemWrapper > div:last-child,
  .synopsisContainer {
      width: calc(50% - 20px);
  }
  .synopsisContainer {
      padding: 1.5rem;
      font-size: 1.3rem;
  }
}

--- END OF FILE components/KineticReleaseTimeline.module.css ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.tsx ---

// components/KineticReleaseTimeline.tsx
'use client';

import React, { useMemo, useRef, useState, useLayoutEffect } from 'react';
import { motion, useScroll, useInView, useTransform, MotionValue, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import TimelineCard from './TimelineCard';
import styles from './KineticReleaseTimeline.module.css';

const ViewAllIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" {...props}>
        <rect x="3" y="3" width="7" height="7"></rect>
        <rect x="14" y="3" width="7" height="7"></rect>
        <rect x="14" y="14" width="7" height="7"></rect>
        <rect x="3" y="14" width="7" height="7"></rect>
    </svg>
);

const SynopsisDisplay = ({ synopsis, isLeft, isInView }: { synopsis: string; isLeft: boolean; isInView: boolean; }) => {
    const [firstWord, ...rest] = synopsis.split(' ');
    const restOfText = rest.join(' ');

    return (
        <AnimatePresence>
            {isInView && (
                <motion.div
                    className={`${styles.synopsisContainer} ${isLeft ? styles.left : styles.right}`}
                    initial={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    transition={{ duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                >
                    <p>
                        <span className={styles.synopsisFirstWord}>{firstWord}</span>
                        {' '}{restOfText}
                    </p>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

const TimelineItem = ({ release, index }: { release: any, index: number }) => {
    const itemRef = useRef(null);
    const cardIsInView = useInView(itemRef, { once: true, amount: 0.5 });
    const isLeft = index % 2 === 0;
    const variants = {
        hidden: { opacity: 0, x: isLeft ? -50 : 50, scale: 0.9 },
        visible: { opacity: 1, x: 0, scale: 1, transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] as const } }
    };

    return (
        <div ref={itemRef} className={`${styles.timelineItemWrapper} ${isLeft ? styles.left : styles.right}`}>
            <SynopsisDisplay synopsis={release.synopsis} isLeft={isLeft} isInView={cardIsInView} />
            <motion.div variants={variants} initial="hidden" animate={cardIsInView ? "visible" : "hidden"}>
                <TimelineCard release={release} />
            </motion.div>
        </div>
    );
};

const TimelineDot = ({ position, scrollYProgress }: { position: number, scrollYProgress: MotionValue<number> }) => {
    const backgroundColor = useTransform( scrollYProgress, [position - 0.01, position], ['var(--border-color)', 'var(--accent)'] );
    const boxShadow = useTransform( scrollYProgress, [position - 0.01, position], ['0 0 0px 0 rgba(0,0,0,0)', '0 0 8px 0 var(--accent)'] );
    
    return ( 
        <motion.div 
            className={styles.dot} 
            style={{ 
                top: `${position * 100}%`, 
                backgroundColor: backgroundColor, 
                boxShadow: boxShadow,
            }} 
        /> 
    );
};

export default function KineticReleaseTimeline({ releases: allReleases }: { releases: any[] }) {
    const timelineRef = useRef<HTMLDivElement>(null);
    const terminusRef = useRef(null);
    const isTerminusInView = useInView(terminusRef, { once: true, amount: 0.8 });
    const [dotPositions, setDotPositions] = useState<number[]>([]);
    const { scrollYProgress } = useScroll({ target: timelineRef, offset: ["start 50%", "end 50%"], });
    
    const releasesForThisMonth = useMemo(() => {
        if (!allReleases) return [];
        const now = new Date();
        const currentMonth = now.getUTCMonth();
        const currentYear = now.getUTCFullYear();
        
        return allReleases
            .filter(release => {
                const releaseDate = new Date(release.releaseDate + 'T00:00:00Z');
                return releaseDate.getUTCMonth() === currentMonth && releaseDate.getUTCFullYear() === currentYear; 
            })
            .sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    }, [allReleases]);

    useLayoutEffect(() => {
        if (timelineRef.current && releasesForThisMonth.length > 0) {
            const timeoutId = setTimeout(() => {
                const containerEl = timelineRef.current; 
                if (!containerEl) return;
                const containerHeight = containerEl.scrollHeight;
                const itemElements = Array.from(containerEl.querySelectorAll(`.${styles.timelineItemWrapper}`));
                const positions = itemElements.map(el => { 
                    const item = el as HTMLElement; 
                    const top = item.offsetTop + (item.offsetHeight / 2); 
                    return top / containerHeight; 
                });
                setDotPositions(positions);
            }, 100);
            return () => clearTimeout(timeoutId);
        }
    }, [releasesForThisMonth]);

    return (
        <div ref={timelineRef} className={styles.timelineContainer}>
            <div className={styles.timelineSpine}>
                <div className={styles.timelineSpineTrack} />
                <motion.div 
                    className={styles.timelineSpineProgress} 
                    style={{ scaleY: scrollYProgress }}
                />
                <div className={styles.dotsContainer}>
                    {dotPositions.map((pos, index) => ( 
                        <TimelineDot key={index} position={pos} scrollYProgress={scrollYProgress} /> 
                    ))}
                </div>
            </div>
            <div className={styles.timelineItemsWrapper}>
                {releasesForThisMonth.length > 0 ? (
                    releasesForThisMonth.map((release, index) => ( 
                        <TimelineItem key={release._id} release={release} index={index} /> 
                    ))
                ) : (
                    <motion.div 
                        style={{ paddingTop: '20vh', textAlign: 'center', color: 'var(--text-secondary)', width: '100%' }} 
                        initial={{ opacity: 0 }} 
                        animate={{ opacity: 1 }} 
                        transition={{ duration: 0.8, delay: 0.8, ease: 'easeOut' as const }}
                    >
                        لا إصدارات مجدولة لهذا الشهر.
                    </motion.div>
                )}
            </div>

            {releasesForThisMonth.length > 0 && (
                <motion.div
                    ref={terminusRef}
                    className={styles.terminusContainer}
                    initial={{ opacity: 0, y: 30 }}
                    animate={isTerminusInView ? { opacity: 1, y: 0 } : {}}
                    transition={{ duration: 0.6, ease: 'easeOut', delay: 0.3 }}
                >
                    <motion.div 
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                        style={{ display: 'inline-block' }}
                    >
                        <Link href="/releases" className={`${styles.timelineTerminusButton} no-underline`}>
                            <ViewAllIcon className={styles.terminusIcon} />
                            <span>عرض كل الإصدارات</span>
                        </Link>
                    </motion.div>
                </motion.div>
            )}
        </div>
    );
}

--- END OF FILE components/KineticReleaseTimeline.tsx ---

================================================================================

--- START OF FILE components/Lightbox.module.css ---

/* components/Lightbox.module.css */
.lightboxOverlay {
    position: fixed;
    inset: 0;
    background-color: color-mix(in srgb, var(--bg-primary) 70%, transparent);
    backdrop-filter: blur(10px) saturate(120%);
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 15vh 20vw;
    cursor: zoom-out;
}

@media (max-width: 1024px) {
    .lightboxOverlay {
        padding: 10vh 5vw;
    }
}

.imageContainer {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0,0,0,0.6);
    background-color: var(--border-color); /* Fallback for loading */
}

.lightboxImage {
    max-width: none;
    max-height: none;
    width: 100%;
    height: 100%;
    object-fit: contain; /* THE FIX: Ensures the whole image is visible */
    cursor: grab;
    will-change: transform;
}
.lightboxImage:active {
    cursor: grabbing;
}

.controls {
    position: absolute;
    top: 2rem;
    left: 2rem; /* RTL */
    right: auto;
    z-index: 9999;
    display: flex;
    gap: 0.75rem;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    padding: 0.5rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.controlButton {
    width: 44px;
    height: 44px;
    border-radius: 6px;
    background-color: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
}
.controlButton:hover {
    background-color: var(--bg-primary);
    color: var(--accent);
}
.controlButton svg {
    width: 22px;
    height: 22px;
}

/* --- THE DEFINITIVE FIX: Navigation Button Styles --- */
.navButton {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(4px);
    z-index: 9999;
    transition: all 0.2s ease-out;
}
.navButton:hover {
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-50%) scale(1.1);
}
.navButton.prev {
    left: 2rem; /* RTL */
    right: auto;
}
.navButton.next {
    right: 2rem; /* RTL */
    left: auto;
}




--- END OF FILE components/Lightbox.module.css ---

================================================================================

--- START OF FILE components/Lightbox.tsx ---

// components/Lightbox.tsx
'use client';

import { createPortal } from 'react-dom';
import { AnimatePresence, motion, useMotionValue, useSpring } from 'framer-motion';
import { useLightboxStore } from '@/lib/lightboxStore';
import { useBodyClass } from '@/hooks/useBodyClass'; // <-- IMPORT HOOK
import { useEffect, useState, useRef, useCallback } from 'react';
import styles from './Lightbox.module.css';

const ZoomInIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ZoomOutIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ResetIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>;
const DownloadIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const CloseIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const ArrowIcon = ({ dir }: { dir: 'left' | 'right' }) => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points={dir === 'left' ? "15 18 9 12 15 6" : "9 18 15 12 9 6"} /></svg>;

const clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max);
const springConfig = { type: 'spring', damping: 30, stiffness: 400 };

export default function Lightbox() {
    const { isOpen, imageUrls, currentIndex, closeLightbox, goToNext, goToPrevious } = useLightboxStore();
    const [isMounted, setIsMounted] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const imageRef = useRef<HTMLImageElement>(null);
    const imageUrl = imageUrls[currentIndex];

    useBodyClass('lightbox-active', isOpen); // <-- REFACTORED

    const scale = useMotionValue(1);
    const x = useMotionValue(0);
    const y = useMotionValue(0);

    const animatedScale = useSpring(scale, springConfig);
    const animatedX = useSpring(x, springConfig);
    const animatedY = useSpring(y, springConfig);
    
    const [dragConstraints, setDragConstraints] = useState({ left: 0, right: 0, top: 0, bottom: 0 });

    useEffect(() => {
        setIsMounted(true);
        const handleKeyDown = (e: KeyboardEvent) => { 
            if (e.key === 'Escape') closeLightbox();
            if (isOpen && imageUrls.length > 1) {
                if (e.key === 'ArrowRight') goToPrevious();
                if (e.key === 'ArrowLeft') goToNext();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [closeLightbox, isOpen, imageUrls, goToNext, goToPrevious]);

    const resetTransform = useCallback(() => {
        scale.set(1);
        x.set(0);
        y.set(0);
    }, [scale, x, y]);

    useEffect(() => { if (isOpen) resetTransform(); }, [isOpen, resetTransform, currentIndex]);
    
    const updateConstraints = useCallback((currentScale: number) => {
        const currentX = x.get();
        const currentY = y.get();

        if (currentScale <= 1) {
            setDragConstraints({ left: 0, right: 0, top: 0, bottom: 0 });
            resetTransform();
            return;
        }

        if (containerRef.current && imageRef.current && imageRef.current.naturalWidth > 0) {
            const container = containerRef.current.getBoundingClientRect();
            const imageAspectRatio = imageRef.current.naturalWidth / imageRef.current.naturalHeight;
            const containerAspectRatio = container.width / container.height;
            
            let renderedWidth, renderedHeight;
            if (imageAspectRatio > containerAspectRatio) {
                renderedWidth = container.width;
                renderedHeight = container.width / imageAspectRatio;
            } else {
                renderedHeight = container.height;
                renderedWidth = container.height * imageAspectRatio;
            }

            const overhangX = Math.max(0, (renderedWidth * currentScale - container.width) / 2);
            const overhangY = Math.max(0, (renderedHeight * currentScale - container.height) / 2);

            setDragConstraints({ left: -overhangX, right: overhangX, top: -overhangY, bottom: overhangY });
            
            x.set(clamp(currentX, -overhangX, overhangX));
            y.set(clamp(currentY, -overhangY, overhangY));
        }
    }, [x, y, resetTransform, scale]);

    useEffect(() => {
        const unsubscribe = scale.onChange(updateConstraints);
        return () => unsubscribe();
    }, [scale, updateConstraints]);
    
    const handleZoom = useCallback((delta: number, clientX?: number, clientY?: number) => {
        const currentScale = scale.get();
        const newScale = clamp(currentScale + delta, 1, 8);
        const scaleRatio = newScale / currentScale;

        const currentX = x.get();
        const currentY = y.get();
        
        if (containerRef.current && clientX && clientY) {
            const rect = containerRef.current.getBoundingClientRect();
            const pointerX = clientX - rect.left - rect.width / 2;
            const pointerY = clientY - rect.top - rect.height / 2;
            
            const newX = pointerX + (currentX - pointerX) * scaleRatio;
            const newY = pointerY + (currentY - pointerY) * scaleRatio;
            
            x.set(newX);
            y.set(newY);
        }
        scale.set(newScale);
    }, [scale, x, y]);

    const handleWheel = useCallback((e: React.WheelEvent) => {
        e.preventDefault();
        e.stopPropagation();
        handleZoom(e.deltaY * -0.01, e.clientX, e.clientY);
    }, [handleZoom]);

    const isZoomed = scale.get() > 1.001;
    
    const downloadUrl = imageUrl ? `${imageUrl.split('?')[0]}?dl` : '';

    const lightboxContent = (
        <AnimatePresence>
            {isOpen && imageUrl && (
                <motion.div className={styles.lightboxOverlay} onWheel={handleWheel} onClick={closeLightbox} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div ref={containerRef} className={styles.imageContainer} onClick={(e) => e.stopPropagation()} initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} transition={{type: 'spring', damping: 25, stiffness: 250}}>
                        <AnimatePresence mode="wait">
                            <motion.img
                                key={currentIndex}
                                ref={imageRef}
                                drag={isZoomed}
                                dragConstraints={dragConstraints}
                                dragElastic={0}
                                dragMomentum={false}
                                src={imageUrl}
                                alt="Full resolution view"
                                className={styles.lightboxImage}
                                style={{ 
                                    scale: animatedScale, 
                                    x: animatedX, 
                                    y: animatedY 
                                }}
                                initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}
                            />
                        </AnimatePresence>
                    </motion.div>
                    
                    <div className={styles.controls} onClick={(e) => e.stopPropagation()}>
                        <button className={styles.controlButton} onClick={() => handleZoom(0.5)} title="Zoom In"><ZoomInIcon /></button>
                        <button className={styles.controlButton} onClick={() => handleZoom(-0.5)} title="Zoom Out"><ZoomOutIcon /></button>
                        <button className={styles.controlButton} onClick={resetTransform} title="Reset Zoom"><ResetIcon /></button>
                        <a href={downloadUrl} download className={styles.controlButton} title="Download Image"><DownloadIcon /></a>
                        <button className={styles.controlButton} onClick={closeLightbox} title="Close"><CloseIcon /></button>
                    </div>

                    {imageUrls.length > 1 && (
                        <>
                            <button className={`${styles.navButton} ${styles.prev}`} onClick={(e) => { e.stopPropagation(); goToPrevious(); }}><ArrowIcon dir="left" /></button>
                            <button className={`${styles.navButton} ${styles.next}`} onClick={(e) => { e.stopPropagation(); goToNext(); }}><ArrowIcon dir="right" /></button>
                        </>
                    )}
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) return null;
    return createPortal(lightboxContent, document.body);
}




--- END OF FILE components/Lightbox.tsx ---

================================================================================

--- START OF FILE components/Navbar.module.css ---

/* components/Navbar.module.css */

.navbar {
  position: fixed;
  top: 0;
  right: 0;
  width: 100%;
  z-index: 1070;
  height: var(--nav-height);
  display: flex;
  align-items: center;
  transition: height 0.3s ease, background-color 0.3s ease, backdrop-filter 0.3s ease, border-bottom 0.3s ease;
  border-bottom: 1px solid transparent;
}

.navbar.scrolled {
  height: var(--nav-height-scrolled);
  background-color: color-mix(in srgb,var(--bg-primary) 80%,transparent);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border-color);
}

.navContainer {
  width: 100%;
}

/* --- DESKTOP LAYOUT --- */
.desktopView {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  width: 100%;
}

.navLogo {
  font-family: var(--font-heading), sans-serif;
  font-size: 3rem;
  font-weight: 800;
  color: var(--text-primary);
}

.desktopView > .navLogo { justify-self: start; }
.desktopView > nav { justify-self: center; }

.navLinks {
  display: flex;
  gap: 3rem;
  list-style: none;
}

.navLinks a {
  font-family: var(--font-ui), sans-serif;
  font-weight: 500;
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: color 0.3s ease, transform 0.3s ease, text-shadow 0.3s ease;
}

.navLinks a:hover {
  color: var(--accent);
  transform: translateY(-2px);
  text-shadow: 0 4px 8px color-mix(in srgb,var(--accent) 40%,transparent);
}

.navControls {
  justify-self: end;
  display: flex;
  align-items: center;
  gap: 2rem;
}

.navSearch {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  position: relative;
  width: 2.4rem;
  height: 2.4rem;
  color: var(--text-primary);
}

.navSearch svg {
  width: 2.4rem;
  height: 2.4rem;
  stroke: currentColor;
  transition: stroke 0.3s ease, transform 0.3s ease, color 0.3s ease;
}

.navSearch:hover svg {
  color: var(--accent);
  transform: rotate(-15deg) scale(1.1);
}

/* --- MOBILE LAYOUT & UTILITIES --- */
.mobileView { display: none; }
.hamburgerButton { display: none; }
.mobileNavOverlay { display: none; }

/* === NEW SUB-ORBITAL STYLES === */

.orbitalCenter {
  font-family: var(--font-heading), sans-serif;
  font-weight: 800;
  font-size: 8rem;
  color: var(--text-secondary);
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  width: 120px;
  height: 120px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1; /* Better vertical centering for the icon */
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  transition: all 0.2s ease-out;
}

.orbitalCenter:hover {
  transform: scale(1.05);
  border-color: var(--accent);
  color: var(--accent);
  box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent);
}

.orbitalCenter.active {
  border-color: var(--accent);
  color: var(--accent);
  box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent);
}

.orbitalItemWrapper {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem; /* Space between orb and title */
}

.orbitalOrb {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  font-size: 2rem;
  font-weight: 800;
}

.orbitalOrb.active {
  border-color: var(--accent);
  color: var(--accent);
  box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent);
}

.orbitalOrb svg {
  width: 28px;
  height: 28px;
}

.orbitalTitle {
  font-family: var(--font-main);
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--text-primary);
  pointer-events: none;
  text-align: center;
  text-shadow: 0 2px 5px var(--bg-primary);
}


@media (max-width: 1024px) {
  .desktopView { display: none; }

  .mobileView {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
  }

  .mobileNavGroupLeft, .mobileNavGroupRight {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex: 1;
  }
  .mobileNavGroupLeft { justify-content: flex-start; }
  .mobileNavGroupRight { justify-content: flex-end; }
  
  .hamburgerButton {
    display: flex;
    align-items: center;
    justify-content: center;
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    z-index: 1201;
    color: var(--text-primary);
    width: 2.4rem;
    height: 2.4rem;
  }
  
  .mobileNavOverlay {
    display: flex; /* Changed from block */
    align-items: center;
    justify-content: center;
    position: fixed;
    inset: 0;
    background-color: color-mix(in srgb, var(--bg-primary) 85%, transparent);
    backdrop-filter: blur(10px);
    z-index: 1200;
  }

  .mobileNavContent {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .mobileNavLinks {
    /* This class is no longer used by the new design, but kept to avoid breaking other potential dependencies */
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3rem;
  }

  .mobileNavLinks a {
    font-family: var(--font-main);
    font-weight: 700;
    font-size: 2.8rem;
    color: var(--text-primary);
  }
}

/* === EDITOR-SPECIFIC OVERRIDES === */

/* On desktop, hide the center navigation links when editor is active */
body.editor-active .desktopView > nav {
  display: none;
}
/* This simplifies the grid for the editor view */
body.editor-active .desktopView {
  grid-template-columns: auto 1fr;
}

/* On mobile, hide the entire main mobile nav view, as the editor has its own */
@media (max-width: 1024px) {
  body.editor-active .mobileView {
    display: none;
  }
}

--- END OF FILE components/Navbar.module.css ---

================================================================================

--- START OF FILE components/Navbar.tsx ---

// components/Navbar.tsx
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { ThemeToggle } from './ThemeToggle';
import UserProfile from './UserProfile';
import NotificationBell from '@/components/notifications/NotificationBell'; // <-- ADDED IMPORT
import { motion, AnimatePresence, Variants, Transition } from 'framer-motion';
import { useScrolled } from '@/hooks/useScrolled';
import { useBodyClass } from '@/hooks/useBodyClass';
import { useUIStore } from '@/lib/uiStore';
import { ReviewIcon, NewsIcon, ArticleIcon, ReleaseIcon, StudioIcon, PreviewIcon } from '@/components/icons/index';
import { EternalGamesIcon } from '@/components/icons/AuthIcons';
import { useEditorStore } from '@/lib/editorStore';
import { QualityToggle } from '@/app/studio/[contentType]/[id]/editor-components/QualityToggle';
import Search from './Search';
import styles from './Navbar.module.css';
import editorStyles from '@/app/studio/[contentType]/[id]/Editor.module.css';

const SearchIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
);

export const HamburgerIcon = ({ isOpen }: { isOpen: boolean }) => (
    <div style={{ width: '24px', height: '24px', position: 'relative' }}>
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '6px', borderRadius: '2px' }} animate={{ rotate: isOpen ? 45 : 0, y: isOpen ? 5 : 0 }} transition={{ type: 'spring', stiffness: 300, damping: 20 }} />
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '11px', borderRadius: '2px' }} animate={{ opacity: isOpen ? 0 : 1 }} transition={{ duration: 0.1 }} />
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '16px', borderRadius: '2px' }} animate={{ rotate: isOpen ? -45 : 0, y: isOpen ? -5 : 0 }} transition={{ type: 'spring', stiffness: 300, damping: 20 }} />
    </div>
);

const ConstellationIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" role="img" color="currentColor" {...props} style={{ transform: 'translate(1px, 2px)' }}>
        <path d="M12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M20 18C21.1046 18 22 17.1046 22 16C22 14.8954 21.1046 14 20 14C18.8954 14 18 14.8954 18 16C18 17.1046 18.8954 18 20 18Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M11 22C12.1046 22 13 21.1046 13 20C13 18.8954 12.1046 18 11 18C9.89543 18 9 18.8954 9 20C9 21.1046 9.89543 22 11 22Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M15 6C16.1046 6 17 5.10457 17 4C17 2.89543 16.1046 2 15 2C13.8954 2 13 2.89543 13 4C13 5.10457 13.8954 6 15 6Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M14.5 6L12.5 10M13 4.5L6 7.5M12 14L11 18M14 13L18 15M18 17L13 19.5" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
    </svg>
);

const CelestialAlmanacIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" color="currentColor" {...props}>
      <path fillRule="evenodd" clipRule="evenodd" d="M18 1.25C19.5188 1.25 20.75 2.48122 20.75 4V4.23047C20.75 5.5687 20.1855 6.84489 19.1953 7.74512L15.7441 10.8818C15.4292 11.1681 15.25 11.5744 15.25 12C15.25 12.4256 15.4292 12.8319 15.7441 13.1182L19.1953 16.2549C20.1855 17.1551 20.75 18.4313 20.75 19.7695V20C20.75 21.5188 19.5188 22.75 18 22.75H6C4.48122 22.75 3.25 21.5188 3.25 20V19.7695C3.25 18.4313 3.81451 17.1551 4.80469 16.2549L8.25586 13.1182C8.57077 12.8319 8.75 12.4256 8.75 12C8.75 11.5744 8.57077 11.1681 8.25586 10.8818L4.80469 7.74512C3.81451 6.84489 3.25 5.5687 3.25 4.23047V4C3.25 2.48122 4.48122 1.25 6 1.25H18Z" fill="currentColor"/>
      <path d="M16.5 19.5001V17.0001H14C13.4477 17.0001 13 16.5523 13 16.0001C13 15.4478 13.4477 15.0001 14 15.0001H16.5V12.5001C16.5 11.9478 16.9477 11.5001 17.5 11.5001C18.0523 11.5001 18.5 11.9478 18.5 12.5001V15.0001H21C21.5523 15.0001 22 15.4478 22 16.0001C22 16.5523 21.5523 17.0001 21 17.0001H18.5V19.5001C18.5 20.0523 18.0523 20.5001 17.5 20.5001C16.9477 20.5001 16.5 20.0523 16.5 19.5001Z" fill="none" stroke="var(--bg-primary)" strokeWidth="2.5"/>
      <path d="M16.5 19.5001V17.0001H14C13.4477 17.0001 13 16.5523 13 16.0001C13 15.4478 13.4477 15.0001 14 15.0001H16.5V12.5001C16.5 11.9478 16.9477 11.5001 17.5 11.5001C18.0523 11.5001 18.5 11.9478 18.5 12.5001V15.0001H21C21.5523 15.0001 22 15.4478 22 16.0001C22 16.5523 21.5523 17.0001 21 17.0001H18.5V19.5001C18.5 20.0523 18.0523 20.5001 17.5 20.5001C16.9477 20.5001 16.5 20.0523 16.5 19.5001Z" fill="currentColor"/>
    </svg>
);

const navItems = [
    { href: '/reviews', label: 'المراجعات', Icon: ReviewIcon },
    { href: '/news', label: 'الأخبار', Icon: NewsIcon },
    { href: '/articles', label: 'المقالات', Icon: ArticleIcon },
    { href: '/releases', label: 'الإصدارات', Icon: ReleaseIcon },
    { href: '/celestial-almanac', label: 'التقويم', Icon: CelestialAlmanacIcon },
    { href: '/constellation', label: 'الكوكبة', Icon: ConstellationIcon }
];

const orbitalContainerVariants: Variants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.08, delayChildren: 0.2 } }
};

const itemTransition: Transition = { type: 'spring', stiffness: 400, damping: 20 };

const OrbitalNavItem = ({ item, angle, radius, isActive, onClick }: { item: typeof navItems[0], angle: number, radius: string, isActive: boolean, onClick: () => void }) => {
    const cosAngle = Math.round(Math.cos(angle) * 1e10) / 1e10;
    const sinAngle = Math.round(Math.sin(angle) * 1e10) / 1e10;

    const x = `calc(${radius} * ${cosAngle})`;
    const y = `calc(${radius} * ${sinAngle})`;

    const itemVariants: Variants = {
        hidden: { scale: 0, x: 0, y: 0, opacity: 0 },
        visible: { scale: 1, x, y, opacity: 1 },
        exit: { scale: 0, x: 0, y: 0, opacity: 0, transition: { duration: 0.2, ease: 'easeIn' } },
    };
    
    return (
        <motion.div
            variants={itemVariants}
            transition={itemTransition}
            className={styles.orbitalItemWrapper}
        >
            <Link href={item.href} onClick={onClick} className="no-underline">
                <motion.div className={`${styles.orbitalOrb} ${isActive ? styles.active : ''}`} whileHover={{ scale: 1.15 }} whileTap={{ scale: 0.9 }}>
                    <item.Icon />
                </motion.div>
            </Link>
            <motion.div
                className={styles.orbitalTitle}
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0, transition: { delay: 0.15, duration: 0.3 } }}
                exit={{ opacity: 0, y: 5, transition: { duration: 0.1 } }}
            >
                {item.label}
            </motion.div>
        </motion.div>
    );
};

const AnimatedPreviewIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <motion.circle 
            cx="12" cy="12" r="3"
            variants={{
                hover: { scaleY: 0.1, transition: { duration: 0.1, ease: "easeOut" } },
                rest: { scaleY: 1, transition: { duration: 0.2, delay: 0.1, ease: "easeIn" } }
            }}
        />
    </svg>
);

const EditorPreviewButton = () => {
    const { liveUrl } = useEditorStore();
    const MotionLink = motion(Link);

    const linkVariants = {
        rest: { color: 'var(--text-primary)', scale: 1 },
        hover: { color: 'var(--accent)', scale: 1.15 }
    };

    return liveUrl ? (
        <MotionLink
            href={liveUrl}
            target="_blank"
            className={`${editorStyles.iconButton} no-underline`}
            title="معاينة الصفحة الحية"
            initial="rest"
            whileHover="hover"
            whileTap="hover"
            animate="rest"
            variants={linkVariants}
            transition={{ type: 'spring', stiffness: 400, damping: 15 }}
        >
            <AnimatedPreviewIcon />
        </MotionLink>
    ) : (
        <motion.button
            className={editorStyles.iconButton}
            disabled
            title="المستند غير منشور"
        >
            <PreviewIcon />
        </motion.button>
    );
};

const Navbar = () => {
    const scrolled = useScrolled(50);
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const { isMobileMenuOpen, toggleMobileMenu, setMobileMenuOpen } = useUIStore();
    const { isEditorActive, blockUploadQuality, setBlockUploadQuality, liveUrl } = useEditorStore();
    const pathname = usePathname();

    useBodyClass('mobile-menu-open', isMobileMenuOpen);

    const openSearch = () => {
        setIsSearchOpen(true);
        setMobileMenuOpen(false);
    };

    const closeAll = () => {
        setMobileMenuOpen(false);
        setIsSearchOpen(false);
    }
    
    return (
        <>
            <header className={`${styles.navbar} ${scrolled ? styles.scrolled : ''}`}>
                <div className={`container ${styles.navContainer}`}>
                    <div className={styles.desktopView}>
                        <Link href="/" className={`${styles.navLogo} no-underline`} onClick={closeAll}>
                            <EternalGamesIcon style={{ width: '30px', height: '30px' }} />
                        </Link>
                        <nav>
                            <ul className={styles.navLinks}>
                                {navItems.map(item => (
                                    <li key={item.href}><Link href={item.href}>{item.label}</Link></li>
                                ))}
                            </ul>
                        </nav>
                        <div className={styles.navControls}>
                            {isEditorActive && <EditorPreviewButton />}
                            {/* ADDED: Notification Bell */}
                            <NotificationBell />
                            <ThemeToggle />
                            <UserProfile />
                            <button className={styles.navSearch} onClick={openSearch} aria-label="فتح البحث">
                                <SearchIcon />
                            </button>
                        </div>
                    </div>

                    <div className={styles.mobileView}>
                        <div className={styles.mobileNavGroupLeft}>
                            <button className={styles.hamburgerButton} onClick={toggleMobileMenu} aria-label="تبديل القائمة">
                                <HamburgerIcon isOpen={isMobileMenuOpen} />
                            </button>
                            {isEditorActive && (
                                <QualityToggle
                                    currentQuality={blockUploadQuality}
                                    onQualityChange={setBlockUploadQuality}
                                    isMobile={true}
                                />
                            )}
                             <button className={styles.navSearch} onClick={openSearch} aria-label="فتح البحث">
                                <SearchIcon />
                            </button>
                        </div>
                        <Link href="/" className={`${styles.navLogo} no-underline`} onClick={closeAll}>
                            <EternalGamesIcon style={{ width: '28px', height: '28px' }} />
                        </Link>
                        <div className={styles.mobileNavGroupRight}>
                            {isEditorActive && <EditorPreviewButton />}
                            {/* ADDED: Notification Bell */}
                            <NotificationBell />
                            <ThemeToggle />
                            <UserProfile />
                        </div>
                    </div>
                </div>
            </header>
            
            <AnimatePresence>
                {isMobileMenuOpen && (
                    <motion.div
                        className={styles.mobileNavOverlay}
                        onClick={closeAll}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <motion.div
                            className={styles.mobileNavContent}
                            variants={orbitalContainerVariants}
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                        >
                            <Link href="/" onClick={closeAll} className={`${styles.orbitalCenter} no-underline ${pathname === '/' ? styles.active : ''}`}>
                                <EternalGamesIcon style={{ width: '48px', height: '48px' }} />
                            </Link>
                            {navItems.map((item, i) => {
                                const angle = -Math.PI / 2 + (i / navItems.length) * (Math.PI * 2);
                                return (
                                    <OrbitalNavItem
                                        key={item.href}
                                        item={item}
                                        angle={angle}
                                        radius="min(38vh, 38vw)"
                                        isActive={pathname.startsWith(item.href)}
                                        onClick={closeAll}
                                    />
                                );
                            })}
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
            
            <Search isOpen={isSearchOpen} onClose={() => setIsSearchOpen(false)} />
        </>
    );
};

export default Navbar;

--- END OF FILE components/Navbar.tsx ---

================================================================================

--- START OF FILE components/PageTransitionWrapper.tsx ---

// components/PageTransitionWrapper.tsx
'use client';

import { m, AnimatePresence, LazyMotion, domAnimation } from 'framer-motion';
import { usePathname } from 'next/navigation';
import React from 'react';

export default function PageTransitionWrapper({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();

  return (
    <LazyMotion features={domAnimation}>
      <AnimatePresence mode="wait">
        <m.div
          key={pathname}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
          transition={{ duration: 0.3, ease: 'easeInOut' }}
        >
          {children}
        </m.div>
      </AnimatePresence>
    </LazyMotion>
  );
}

--- END OF FILE components/PageTransitionWrapper.tsx ---

================================================================================

--- START OF FILE components/PaginatedCarousel.module.css ---

/* components/PaginatedCarousel.module.css */

.paginatedContainer {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.paginatedContent {
    /* flex-grow: 1; <-- This property was pushing the controls to the bottom, it has been removed. */
    position: relative;
    min-height: 380px; /* Adjust based on item height to prevent layout shift */
}

.itemList {
    display: flex;
    flex-direction: column;
}

.paginationControls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    padding-top: 1rem; /* Reduced top padding to bring controls closer to content */
    padding-bottom: 1.5rem; /* Added bottom padding for spacing from elements below */
}

.paginationDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: var(--border-color);
    border: none;
    cursor: pointer;
    padding: 0;
    transition: all 0.3s ease;
}

.paginationDot:hover {
    background-color: var(--text-secondary);
}

.paginationDot.active {
    background-color: var(--accent);
    transform: scale(1.2);
    box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 50%, transparent);
}

--- END OF FILE components/PaginatedCarousel.module.css ---

================================================================================

--- START OF FILE components/PaginatedCarousel.tsx ---

// components/PaginatedCarousel.tsx
'use client';

import React, { useState, useEffect, useRef, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { CardProps } from '@/types';
import CreatorCredit from '@/components/CreatorCredit';
import { Calendar03Icon } from '@/components/icons/index';
import styles from './PaginatedCarousel.module.css';
import feedStyles from './homepage/feed/Feed.module.css';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

const LatestArticleListItem = memo(({ article }: { article: CardProps }) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "homepage-latest-articles";
    const linkPath = `/articles/${article.slug}`;

    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (e.ctrlKey || e.metaKey) return;
        if ((e.target as HTMLElement).closest('a[href^="/creators"]')) return;
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    return (
        <motion.a
            href={linkPath}
            onClick={handleClick}
            layoutId={`${layoutIdPrefix}-card-container-${article.legacyId}`} 
            className={`${feedStyles.latestArticleItem} no-underline`}
        >
            <motion.div layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`} className={feedStyles.latestArticleThumbnail}>
                <Image 
                    src={article.imageUrl} 
                    alt={article.title} 
                    fill 
                    sizes="120px" 
                    placeholder="blur" 
                    blurDataURL={article.blurDataURL} 
                    style={{ objectFit: 'cover' }} 
                />
            </motion.div>
            <div className={feedStyles.latestArticleInfo}>
                <motion.h4 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`} className={feedStyles.latestArticleTitle}>{article.title}</motion.h4>
                <div className={feedStyles.latestArticleMeta}>
                    <CreatorCredit label="بقلم" creators={article.authors} />
                    {article.date && (
                        <div className={feedStyles.latestArticleDate}>
                            <Calendar03Icon style={{ width: '16px', height: '16px', color: 'var(--accent)' }} />
                            <span>{article.date}</span>
                        </div>
                    )}
                </div>
            </div>
        </motion.a>
    );
});
LatestArticleListItem.displayName = "LatestArticleListItem";

type PaginatedCarouselProps = {
    items: CardProps[];
    itemsPerPage?: number;
};

export default function PaginatedCarousel({ items, itemsPerPage = 3 }: PaginatedCarouselProps) {
    const [currentPage, setCurrentPage] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const [isMobile, setIsMobile] = useState(false);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    const totalPages = Math.ceil(items.length / itemsPerPage);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const resetTimeout = () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } };

    useEffect(() => {
        resetTimeout();
        if (!isHovered && totalPages > 1) {
            timeoutRef.current = setTimeout(
                () => setCurrentPage((prevPage) => (prevPage + 1) % totalPages),
                3500
            );
        }
        return () => resetTimeout();
    }, [currentPage, isHovered, totalPages]);

    const startIndex = currentPage * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = items.slice(startIndex, endIndex);
    
    const hoverHandlers = isMobile ? {} : {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
    };

    return (
        <div 
            className={styles.paginatedContainer}
            {...hoverHandlers}
        >
            <div className={styles.paginatedContent}>
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentPage}
                        initial={{ opacity: 0, x: 30 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: -30 }}
                        transition={{ duration: 0.4, ease: 'easeInOut' }}
                        className={styles.itemList}
                    >
                        {currentItems.map((item, index) => (
                            <React.Fragment key={item.id}>
                                <LatestArticleListItem article={item} />
                                {index < currentItems.length - 1 && <div className={feedStyles.listDivider} />}
                            </React.Fragment>
                        ))}
                    </motion.div>
                </AnimatePresence>
            </div>
            {totalPages > 1 && (
                <div className={styles.paginationControls}>
                    {Array.from({ length: totalPages }).map((_, index) => (
                        <button
                            key={index}
                            className={`${styles.paginationDot} ${currentPage === index ? styles.active : ''}`}
                            onClick={() => setCurrentPage(index)}
                            aria-label={`Go to page ${index + 1}`}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}

--- END OF FILE components/PaginatedCarousel.tsx ---

================================================================================

--- START OF FILE components/PasswordChangeForm.tsx ---

// components/PasswordChangeForm.tsx
'use client';

import { useState, useTransition } from 'react';
import { changePasswordAction } from '@/app/actions/userActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from './ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function PasswordChangeForm() {
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    
    // --- DEFINITIVE FIX: Comment is now correctly formatted ---
    // State to manage form fields for floating labels
    const [currentPassword, setCurrentPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');

    const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const formData = new FormData(event.currentTarget);
        const form = event.currentTarget;

        startTransition(async () => {
            const result = await changePasswordAction(formData);
            if (result.success) {
                toast.success(result.message || 'تم تغيير كلمة السر بنجاح!');
                // Clear state on success
                setCurrentPassword('');
                setNewPassword('');
                setConfirmPassword('');
                form.reset();
            } else {
                toast.error(result.message || 'Failed to change password.');
            }
        });
    };

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <form onSubmit={handleSubmit} style={{ maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
            <div className={`profile-form-group ${hasContent(currentPassword)}`}>
                <input 
                    id="currentPassword" 
                    name="currentPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={currentPassword}
                    onChange={(e) => setCurrentPassword(e.target.value)}
                    placeholder=" "
                />
                 <label className="profile-form-label" htmlFor="currentPassword">كلمة السر الحالية</label>
            </div>
            <div className={`profile-form-group ${hasContent(newPassword)}`}>
                <input 
                    id="newPassword" 
                    name="newPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={newPassword}
                    onChange={(e) => setNewPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="newPassword">كلمة السر الجديدة</label>
            </div>
            <div className={`profile-form-group ${hasContent(confirmPassword)}`}>
                <input 
                    id="confirmPassword" 
                    name="confirmPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="confirmPassword">تأكيد الجديدة</label>
            </div>
            <motion.button 
                type="submit" 
                className="primary-button" 
                disabled={isPending}
                animate={{
                    width: isPending ? '48px' : 'auto',
                    height: '48px',
                    borderRadius: isPending ? '50%' : '5px',
                }}
                transition={{ type: 'spring', stiffness: 400, damping: 25 }}
            >
                <AnimatePresence mode="wait">
                    {isPending ? (
                        <ButtonLoader key="loader" />
                    ) : (
                        <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>تحديث كلمة السر</motion.span>
                    )}
                </AnimatePresence>
            </motion.button>
        </form>
    );
}










--- END OF FILE components/PasswordChangeForm.tsx ---

================================================================================

--- START OF FILE components/PortableTextComponent.tsx ---

// components/PortableTextComponent.tsx
'use client'

import React, {useEffect, useState, useMemo} from 'react'
import {
  PortableText,
  PortableTextComponents,
  PortableTextComponentProps,
  PortableTextMarkComponentProps,
} from '@portabletext/react'
import {urlFor} from '@/sanity/lib/image'
import dynamic from 'next/dynamic'
import {slugify} from 'transliteration'
import NextImage from 'next/image'
import {useLightboxStore} from '@/lib/lightboxStore'
import type {PortableTextBlock} from '@portabletext/types'
import {useTheme} from 'next-themes'

// --- LAZY-LOADED COMPONENTS ---
const LoadingSpinner = () => (
  <div style={{display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '200px'}}>
    <div className="spinner" />
  </div>
)

const ImageCompare = dynamic(() => import('./ImageCompare'), {
  loading: () => <LoadingSpinner />,
  ssr: false,
})
const TwoImageGrid = dynamic(() => import('./custom/TwoImageGrid'), {
  loading: () => <LoadingSpinner />,
})
const FourImageGrid = dynamic(() => import('./custom/FourImageGrid'), {
  loading: () => <LoadingSpinner />,
})
const SanityTable = dynamic(() => import('./custom/SanityTable'), {
  loading: () => <LoadingSpinner />,
})
const GameDetails = dynamic(() => import('./content/GameDetails'), {
  loading: () => <LoadingSpinner />,
})
const YoutubeEmbed = dynamic(() => import('./content/YoutubeEmbed'), {
  loading: () => <LoadingSpinner />,
  ssr: false,
})
// --- END LAZY-LOADED COMPONENTS ---

const COLOR_PALETTE = [
  {
    title: 'Grays',
    colors: [
      '#FFFFFF',
      '#F9FAFB',
      '#F3F4F6',
      '#E5E7EB',
      '#D1D5DB',
      '#9CA3AF',
      '#6B7280',
      '#4B5563',
      '#374151',
      '#1F2937',
    ],
  },
  {
    title: 'Reds',
    colors: [
      '#FEF2F2',
      '#FEE2E2',
      '#FECACA',
      '#F87171',
      '#EF4444',
      '#DC2626',
      '#B91C1C',
      '#991B1B',
      '#7F1D1D',
      '#450A0A',
    ],
  },
  {
    title: 'Oranges',
    colors: [
      '#FFF7ED',
      '#FFEDD5',
      '#FED7AA',
      '#FB923C',
      '#F97316',
      '#EA580C',
      '#C2410C',
      '#9A3412',
      '#7C2D12',
      '#431407',
    ],
  },
  {
    title: 'Yellows',
    colors: [
      '#FEFCE8',
      '#FEF9C3',
      '#FEF08A',
      '#FACC15',
      '#EAB308',
      '#CA8A04',
      '#A16207',
      '#854D0E',
      '#713F12',
      '#422006',
    ],
  },
  {
    title: 'Greens',
    colors: [
      '#F0FDF4',
      '#DCFCE7',
      '#BBF7D0',
      '#4ADE80',
      '#22C55E',
      '#16A34A',
      '#15803D',
      '#166534',
      '#14532D',
      '#052e16',
    ],
  },
  {
    title: 'Cyans',
    colors: [
      '#ECFEFF',
      '#CFFAFE',
      '#A5F3FC',
      '#22D3EE',
      '#06B6D4',
      '#0891B2',
      '#0E7490',
      '#155E75',
      '#164E63',
      '#083344',
    ],
  },
  {
    title: 'Blues',
    colors: [
      '#EFF6FF',
      '#DBEAFE',
      '#BFDBFE',
      '#60A5FA',
      '#3B82F6',
      '#2563EB',
      '#1D4ED8',
      '#1E40AF',
      '#1E3A8A',
      '#172554',
    ],
  },
  {
    title: 'Purples',
    colors: [
      '#F5F3FF',
      '#EDE9FE',
      '#DDD6FE',
      '#A78BFA',
      '#8B5CF6',
      '#7C3AED',
      '#6D28D9',
      '#5B21B6',
      '#4C1D95',
      '#2E1065',
    ],
  },
]

type ColorMapping = {
  word: string
  color: string
}

const ColorMark = ({
  value,
  children,
}: PortableTextMarkComponentProps<{_type: 'color'; hex: string}>) => {
  const {resolvedTheme} = useTheme()
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  const originalColor = value?.hex

  if (!mounted || !originalColor) {
    return <span style={{color: originalColor}}>{children}</span>
  }

  let colorInfo: {palette: (typeof COLOR_PALETTE)[0]; grade: number} | null = null
  for (const palette of COLOR_PALETTE) {
    const gradeIndex = palette.colors.findIndex(
      (c) => c.toLowerCase() === originalColor.toLowerCase(),
    )
    if (gradeIndex !== -1) {
      colorInfo = {palette, grade: gradeIndex + 1}
      break
    }
  }

  if (colorInfo && colorInfo.palette.title === 'Grays') {
    return <span>{children}</span>
  }

  let finalColor = originalColor

  if (colorInfo) {
    const {palette, grade} = colorInfo
    if (resolvedTheme === 'light' && grade >= 1 && grade <= 4) {
      finalColor = palette.colors[4]
    } else if (resolvedTheme === 'dark' && grade >= 7 && grade <= 10) {
      finalColor = palette.colors[5]
    }
  }

  const getLuminance = (hex: string): number => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    if (!result) return 0
    const r = parseInt(result[1], 16)
    const g = parseInt(result[2], 16)
    const b = parseInt(result[3], 16)
    return 0.2126 * r + 0.7152 * g + 0.0722 * b
  }

  const luminance = getLuminance(finalColor)

  if (resolvedTheme === 'dark' && luminance < 60) {
    finalColor = `color-mix(in srgb, ${finalColor} 20%, white 80%)`
  } else if (resolvedTheme === 'light' && luminance > 200) {
    finalColor = `color-mix(in srgb, ${finalColor} 70%, black 30%)`
  }

  return <span style={{color: finalColor}}>{children}</span>
}

const SanityImageComponent = ({value}: {value: any}) => {
  const {asset, alt} = value
  const openLightbox = useLightboxStore((state) => state.openLightbox)
  if (!asset?._id || !asset?.url) return null

  const {width, height} = asset.metadata?.dimensions || {width: 1920, height: 1080}
  const blurDataURL = asset.metadata?.lqip

  const optimizedSrc = urlFor(asset).width(1920).auto('format').url()

  const fullResSrc = urlFor(asset).auto('format').url()

  return (
    <div style={{margin: '4rem 0'}}>
      <div onClick={() => openLightbox([fullResSrc], 0)} className="image-lightbox-trigger">
        <NextImage
          src={optimizedSrc}
          alt={alt || 'Content Image'}
          width={width}
          height={height}
          sizes="(max-width: 960px) 90vw, 850px"
          placeholder={blurDataURL ? 'blur' : 'empty'}
          blurDataURL={blurDataURL}
          loading="lazy"
          draggable={false}
          style={{
            width: '100%',
            height: 'auto',
          }}
        />
      </div>
    </div>
  )
}

const HeadingComponent = ({level, children}: {level: number; children?: React.ReactNode}) => {
  const textContent = Array.isArray(children) ? children.join('') : (children as string) || ''
  const id = slugify(textContent)

  const styles: Record<number, React.CSSProperties> = {
    1: {
      fontSize: '3.6rem',
      margin: '5rem 0 2rem 0',
      paddingBottom: '1rem',
      borderBottom: '1px solid var(--border-color)',
    },
    2: {
      fontSize: '2.8rem',
      margin: '5rem 0 2rem 0',
      paddingBottom: '1rem',
      borderBottom: '1px solid var(--border-color)',
    },
    3: {fontSize: '2.2rem', margin: '4rem 0 1.5rem 0'},
  }

  return React.createElement(`h${level}`, {id, style: styles[level] || styles[2]}, children)
}

const BlockquoteComponent = (props: PortableTextComponentProps<PortableTextBlock>) => {
  return (
    <blockquote
      style={{
        margin: '4rem 0',
        paddingRight: '2rem',
        borderRight: '4px solid var(--accent)',
        fontSize: '2.4rem',
        fontStyle: 'italic',
        color: 'var(--text-primary)',
      }}
    >
      {props.children}
    </blockquote>
  )
}

// THE DEFINITIVE FIX: Encapsulate the entire logic within the `useMemo` hook that defines the `components`.
// This avoids complex type inference issues by constructing the final object in one go.

export default function PortableTextComponent({
  content,
  colorDictionary = [],
}: {
  content: any[]
  colorDictionary?: ColorMapping[]
}) {
  if (!content) return null

  const components: PortableTextComponents = useMemo(() => {
    const colorMap = new Map(colorDictionary.map((item) => [item.word.toLowerCase(), item.color]))
    const regex =
      colorDictionary.length > 0
        ? new RegExp(
            `\\b(${colorDictionary
              .map((item) => item.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))
              .join('|')})\\b`,
            'gi',
          )
        : null

    const NormalBlockRenderer = (props: PortableTextComponentProps<PortableTextBlock>) => {
      // If there's no regex, just render a plain paragraph.
      if (!regex) {
        return <p>{props.children}</p>
      }

      return (
        <p>
          {React.Children.map(props.children, (child: any) => {
            // If the child is not a plain string, render it as is. This handles marks (bold, links, etc.)
            if (typeof child !== 'string') {
              return child
            }

            const parts = child.split(regex)

            return parts.map((part, i) => {
              const lowerPart = part.toLowerCase()
              if (colorMap.has(lowerPart)) {
                return (
                  <span key={i} style={{color: colorMap.get(lowerPart), fontWeight: '600'}}>
                    {part}
                  </span>
                )
              }
              return <React.Fragment key={i}>{part}</React.Fragment>
            })
          })}
        </p>
      )
    }

    return {
      types: {
        image: SanityImageComponent,
        imageCompare: ({value}) => <ImageCompare value={value} />,
        twoImageGrid: ({value}) => <TwoImageGrid value={value} />,
        fourImageGrid: ({value}) => <FourImageGrid value={value} />,
        table: ({value}) => <SanityTable value={value} />,
        gameDetails: ({value}) => <GameDetails details={value.details} />,
        youtube: ({value}) => <YoutubeEmbed value={value} />,
      },
      block: {
        h1: ({children}) => <HeadingComponent level={1}>{children}</HeadingComponent>,
        h2: ({children}) => <HeadingComponent level={2}>{children}</HeadingComponent>,
        h3: ({children}) => <HeadingComponent level={3}>{children}</HeadingComponent>,
        blockquote: BlockquoteComponent,
        normal: NormalBlockRenderer, // Use the correctly typed renderer.
      },
      marks: {
        color: ColorMark,
        link: ({value, children}) => {
          const rel = !value.href.startsWith('/') ? 'noreferrer noopener' : undefined
          const isExternal = rel === 'noreferrer noopener'
          return (
            <a href={value.href} rel={rel} target={isExternal ? '_blank' : '_self'}>
              {children}
            </a>
          )
        },
      },
    }
  }, [colorDictionary])

  return (
    <div className="portable-text-content" style={{fontSize: '1.8rem', lineHeight: 1.8}}>
      <PortableText value={content} components={components} />
    </div>
  )
}

--- END OF FILE components/PortableTextComponent.tsx ---

================================================================================

--- START OF FILE components/ProfileEditForm.module.css ---

/* components/ProfileEditForm.module.css */
.avatarFormGroup{margin-bottom:2rem}
.avatarInputContainer{display:flex;align-items:center;gap:1.5rem}
.avatarPreviewButton{position:relative;border-radius:50%;overflow:hidden;padding:0;border:none;background:none;cursor:pointer;width:80px;height:80px;flex-shrink:0}
.profileAvatarPreview{border-radius:50%;transition:all .3s ease-out}
.avatarUploadPrompt{position:absolute;inset:0;background-color:color-mix(in srgb,var(--bg-primary) 70%,transparent);color:var(--text-primary);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem;font-size:1.2rem;font-weight:500;font-family:var(--font-ui);opacity:0;transition:opacity .3s ease-out;z-index:2}
.avatarPreviewButton:hover .avatarUploadPrompt{opacity:1}
.avatarPreviewButton:hover .profileAvatarPreview{transform:scale(1.1);filter:blur(2px) brightness(.8)}
.formDescription{font-size:1.4rem;color:var(--text-secondary);margin:0}










--- END OF FILE components/ProfileEditForm.module.css ---

================================================================================

--- START OF FILE components/ProfileEditForm.tsx ---

// components/ProfileEditForm.tsx
'use client';

import { updateUserAvatar, updateUserProfile, checkUsernameAvailability } from '@/app/actions/userActions';
// THE FIX: Import User but define a looser type for the prop to handle partial selects and schema mismatches
import { User } from '@/lib/generated/client';
import { useRef, useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import { useSession } from 'next-auth/react';
import AvatarCropperModal from './AvatarCropperModal';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useDebounce } from '@/hooks/useDebounce';
import { useToast } from '@/lib/toastStore';
import avatarStyles from './ProfileEditForm.module.css';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const ToggleSwitch = ({ checked, onChange, name }: { checked: boolean, onChange: (checked: boolean) => void, name: string }) => (
    <button
        type="button"
        role="switch"
        aria-checked={checked}
        onClick={() => onChange(!checked)}
        className={`toggle ${checked ? 'active' : ''}`}
    >
        <motion.div className="toggle-handle" layout transition={{ type: 'spring', stiffness: 700, damping: 30 }} />
        <input type="checkbox" name={name} checked={checked} readOnly style={{ display: 'none' }} />
    </button>
);

// THE FIX: Define a specific type for the user prop that matches what we actually use and fetch.
// This avoids issues where the Prisma User type requires fields (like 'lastRoleChange') that we don't select.
type ProfileUser = {
    id: string;
    name?: string | null;
    username?: string | null;
    image?: string | null;
    bio?: string | null;
    twitterHandle?: string | null;
    instagramHandle?: string | null;
    age?: number | null;
    country?: string | null;
    agePublic: boolean;
    countryPublic: boolean;
}

export default function ProfileEditForm({ user }: { user: ProfileUser }) {
    const inputFileRef = useRef<HTMLInputElement>(null);
    const { update: updateSession } = useSession();
    const toast = useToast();
    const [isSaving, startSaveTransition] = useTransition();
    const [isCheckingUsername, startUsernameCheckTransition] = useTransition();
    
    const [avatarPreview, setAvatarPreview] = useState(user.image ?? '/default-avatar.svg');
    const [avatarFile, setAvatarFile] = useState<File | null>(null);
    const [name, setName] = useState(user.name ?? '');
    const [username, setUsername] = useState(user.username ?? '');
    const [bio, setBio] = useState(user.bio ?? '');
    const [twitterHandle, setTwitterHandle] = useState(user.twitterHandle ?? '');
    const [instagramHandle, setInstagramHandle] = useState(user.instagramHandle ?? '');
    const [agePublic, setAgePublic] = useState(user.agePublic);
    const [countryPublic, setCountryPublic] = useState(user.countryPublic);

    const [usernameStatus, setUsernameStatus] = useState<{ type: 'idle' | 'checking' | 'valid' | 'invalid', message: string }>({ type: 'idle', message: '' });
    const debouncedUsername = useDebounce(username, 500);
    const [isCropperOpen, setIsCropperOpen] = useState(false);
    const [cropperImageSrc, setCropperImageSrc] = useState<string | null>(null);
    
    const hasTextChanged = 
        name !== (user.name ?? '') ||
        username !== (user.username ?? '') ||
        bio !== (user.bio ?? '') ||
        twitterHandle !== (user.twitterHandle ?? '') ||
        instagramHandle !== (user.instagramHandle ?? '') ||
        agePublic !== user.agePublic ||
        countryPublic !== user.countryPublic;

    const hasChanges = !!avatarFile || hasTextChanged;
    const isSaveDisabled = isSaving || !hasChanges || usernameStatus.type === 'invalid' || usernameStatus.type === 'checking';

    useEffect(() => {
        if (debouncedUsername && debouncedUsername !== user.username) {
            setUsernameStatus({ type: 'checking', message: 'Checking...' });
            startUsernameCheckTransition(async () => {
                const result = await checkUsernameAvailability(debouncedUsername);
                setUsernameStatus({ type: result.available ? 'valid' : 'invalid', message: result.message });
            });
        } else {
            setUsernameStatus({ type: 'idle', message: '' });
        }
    }, [debouncedUsername, user.username]);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => { setCropperImageSrc(reader.result as string); setIsCropperOpen(true); };
        reader.readAsDataURL(file);
        if(inputFileRef.current) inputFileRef.current.value = "";
    };
    const handleCropComplete = (croppedFile: File) => {
        setAvatarFile(croppedFile);
        setAvatarPreview(URL.createObjectURL(croppedFile));
        setIsCropperOpen(false);
    };
    async function handleProfileSave(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault();
        if (isSaveDisabled) return;
        startSaveTransition(async () => {
            try {
                if (avatarFile) {
                    const avatarFormData = new FormData();
                    avatarFormData.append('avatar', avatarFile);
                    const avatarResult = await updateUserAvatar(avatarFormData);
                    if (!avatarResult.success) throw new Error(avatarResult.message);
                }
                if (hasTextChanged) {
                    const profileFormData = new FormData(event.currentTarget);
                    const profileResult = await updateUserProfile(profileFormData);
                    if (!profileResult.success) throw new Error(profileResult.message);
                }
                await updateSession();
                toast.success('حُدِّثَ الملف بنجاح!');
                setAvatarFile(null);
            } catch (error: any) {
                toast.error(error.message || 'أخفق تحديث الملف.');
            }
        });
    }

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <>
            <AvatarCropperModal isOpen={isCropperOpen} onClose={() => setIsCropperOpen(false)} imageSrc={cropperImageSrc || ''} onCropComplete={handleCropComplete} />
            <form onSubmit={handleProfileSave} style={{ maxWidth: '600px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                <div className={avatarStyles.avatarFormGroup}>
                    <label className="profile-form-label" style={{position: 'static', transform: 'none', marginBottom: '0.5rem', fontSize: '1.4rem', color: 'var(--text-primary)', fontWeight: '600'}}>صورتك الرمزية</label>
                    <div className={avatarStyles.avatarInputContainer}>
                        <button type="button" className={avatarStyles.avatarPreviewButton} onClick={() => inputFileRef.current?.click()}>
                            <div className={avatarStyles.avatarUploadPrompt}><UploadIcon /><span>تغيير</span></div>
                            <Image src={avatarPreview} alt="Avatar preview" width={80} height={80} className={avatarStyles.profileAvatarPreview} />
                        </button>
                        <p className={avatarStyles.formDescription}>انقر لرفع صورة جديدة (أقصاه 4.5 ميجابايت).</p>
                        <input ref={inputFileRef} type="file" name="avatar_source" onChange={handleFileChange} accept="image/png, image/jpeg, image/webp" style={{ display: 'none' }} disabled={isSaving} />
                    </div>
                </div>
                <div className={`profile-form-group ${hasContent(name)}`}>
                    <input id="name" name="name" value={name} onChange={(e) => setName(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="name" className="profile-form-label">الاسم المعروض</label>
                </div>
                <div className={`profile-form-group ${hasContent(username)}`}>
                    <input id="username" name="username" value={username} onChange={(e) => setUsername(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="username" className="profile-form-label">اسم المستخدم</label>
                    <AnimatePresence>
                        {usernameStatus.message && ( <motion.p initial={{opacity: 0, height: 0}} animate={{opacity: 1, height: 'auto'}} exit={{opacity: 0, height: 0}} style={{ fontSize: '1.3rem', margin: '0.5rem 0 0 0', color: usernameStatus.type === 'invalid' ? '#DC2626' : (usernameStatus.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameStatus.message}</motion.p> )}
                    </AnimatePresence>
                </div>
                <div className={`profile-form-group ${hasContent(bio)}`}>
                    <textarea id="bio" name="bio" value={bio} onChange={(e) => setBio(e.target.value)} rows={4} className="profile-input" maxLength={500} placeholder=" " />
                    <label htmlFor="bio" className="profile-form-label">النبذة التعريفية</label>
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                    <div className={`profile-form-group ${hasContent(twitterHandle)}`}>
                        <input id="twitterHandle" name="twitterHandle" value={twitterHandle} onChange={(e) => setTwitterHandle(e.target.value)} className="profile-input" placeholder=" " />
                         <label htmlFor="twitterHandle" className="profile-form-label">حساب تويتر</label>
                    </div>
                    <div className={`profile-form-group ${hasContent(instagramHandle)}`}>
                        <input id="instagramHandle" name="instagramHandle" value={instagramHandle} onChange={(e) => setInstagramHandle(e.target.value)} className="profile-input" placeholder=" "/>
                        <label htmlFor="instagramHandle" className="profile-form-label">حساب إنستغرام</label>
                    </div>
                </div>

                <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem', background: 'var(--bg-primary)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border-color)'}}>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="agePublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار العمر علنًا</label>
                        <ToggleSwitch name="agePublic" checked={agePublic} onChange={setAgePublic} />
                    </div>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="countryPublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار البلد علنًا</label>
                        <ToggleSwitch name="countryPublic" checked={countryPublic} onChange={setCountryPublic} />
                    </div>
                </div>

                <motion.button
                    type="submit"
                    className="primary-button"
                    disabled={isSaveDisabled}
                    style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        overflow: 'hidden'
                    }}
                    animate={{
                        width: isSaving ? '48px' : '100%',
                        height: '48px',
                        borderRadius: isSaving ? '50%' : '5px',
                        paddingLeft: isSaving ? '0rem' : '2.4rem',
                        paddingRight: isSaving ? '0rem' : '2.4rem',
                    }}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                >
                    <AnimatePresence mode="wait">
                        {isSaving ? (
                            <ButtonLoader key="loader" />
                        ) : (
                            <motion.span
                                key="text"
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                style={{ whiteSpace: 'nowrap' }}
                            >
                                حفظ التغييرات
                            </motion.span>
                        )}
                    </AnimatePresence>
                </motion.button>
            </form>
        </>
    );
}

--- END OF FILE components/ProfileEditForm.tsx ---

================================================================================

--- START OF FILE components/ReadingHud.module.css ---

/* components/ReadingHud.module.css */

.readingHud {
  position: fixed;
  bottom: 15vh; /* THE FIX: Anchor to the bottom */
  top: auto; /* THE FIX: Unset top anchor */
  left: 2rem;
  transform: none; /* THE FIX: Remove vertical centering transform */
  display: flex;
  align-items: center;
  height: 70vh; /* THE FIX: Set height relative to viewport height */
  max-height: 700px; /* THE FIX: Add a max-height */
  z-index: 100;
}

@media (max-width: 1024px) {
  .readingHud {
    display: none;
  }
}

.track {
  width: 2px;
  height: 100%;
  background-color: var(--border-color);
  position: relative;
  border-radius: 2px;
  overflow: hidden; /* THE FIX: This container now acts as a mask */
}

.progress {
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  box-shadow: 0 0 8px 0 color-mix(in srgb, var(--accent) 70%, transparent);
  /* THE FIX: We now animate translateY instead of scaleY */
  transform-origin: top; 
  will-change: transform;
}

.markers {
  position: absolute;
  top: 0;
  right: 50%;
  width: 1px;
  height: 100%;
  margin-right: -5px; 
}

.marker {
  position: absolute;
  right: 50%;
  width: 10px; 
  height: 10px; 
  border: 2px solid var(--bg-primary);
  border-radius: 50%;
  cursor: pointer;
  padding: 0;
}

.markerDot {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: var(--border-color);
    transition: transform 0.15s ease-out, background-color 0.15s ease-out, box-shadow 0.15s ease-out;
    will-change: transform, background-color, box-shadow;
    transform: scale(1);
}

.marker.active .markerDot {
    background-color: var(--accent);
    box-shadow: 0 0 12px 2px color-mix(in srgb, var(--accent) 70%, transparent);
    transform: scale(1.8);
}

.marker:hover .markerDot {
    background-color: var(--accent);
    transform: scale(2.2);
    z-index: 2; 
}

.marker::after {
  content: attr(data-title);
  position: absolute;
  top: 50%;
  left: 18px;
  transform: translateY(-50%) scale(0.9);
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  font-family: var(--font-ui);
  font-size: 1.4rem;
  font-weight: 500;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s ease-out, transform 0.15s ease-out, left 0.15s ease-out;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  border: 1px solid var(--border-color);
}
.marker:hover::after {
  opacity: 1;
  transform: translateY(-50%) scale(1);
  left: 25px;
}

.readingHudMobile {
  position: fixed;
  top: var(--nav-height-scrolled);
  left: 0;
  right: 0;
  height: 3px;
  z-index: 100;
  pointer-events: none;
}

.mobileTrack {
  width: 100%;
  height: 100%;
  background-color: color-mix(in srgb, var(--border-color) 50%, transparent);
  position: relative;
}

.mobileProgress {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0; 
  width: 100%;
  background-color: var(--accent);
  transform-origin: right; 
  box-shadow: 0 0 10px 0 var(--accent);
}

@media (min-width: 1025px) {
  .readingHudMobile {
    display: none;
  }
}

--- END OF FILE components/ReadingHud.module.css ---

================================================================================

--- START OF FILE components/ReadingHud.tsx ---

// components/ReadingHud.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, useScroll, useSpring, AnimatePresence, MotionValue, useTransform } from 'framer-motion';
import styles from './ReadingHud.module.css';

type Heading = {
    id: string;
    title: string;
    top: number;
    level: number; // MODIFIED: Added level
};

// We don't need a custom hook; useScroll with a null target handles window scroll.
export default function ReadingHud({ 
    contentContainerRef, 
    headings,
    isMobile 
}: { 
    contentContainerRef: React.RefObject<HTMLDivElement | null>, 
    headings: Heading[],
    isMobile: boolean
}) {
    const [activeHeadings, setActiveHeadings] = useState<Set<string>>(new Set());
    const [showHud, setShowHud] = useState(false);
    
    const { scrollYProgress } = useScroll({ offset: ['start start', 'end end'] });
    
    const springyProgress = useSpring(scrollYProgress, { stiffness: 200, damping: 40, restDelta: 0.001 });
    const progressValue = useTransform(scrollYProgress, (p) => p); // Raw progress MotionValue

    // THE FIX: Create a new MotionValue for translateY animation.
    const translateY = useTransform(springyProgress, [0, 1], ['-100%', '0%']);

    useEffect(() => {
        const unsubscribe = progressValue.on('change', (latestProgress) => {
            
            const documentScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            const documentScrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            
            setShowHud(documentScrollTop > 100 && latestProgress < 0.99);

            if (headings.length === 0 || documentScrollHeight <= 0) return;
            
            const currentlyActive = new Set<string>();

            for (let i = 0; i < headings.length; i++) {
                const heading = headings[i];
                const headingProgressPosition = heading.top / documentScrollHeight;
                if (latestProgress >= headingProgressPosition) {
                    currentlyActive.add(heading.id);
                }
            }
            
            setActiveHeadings(currentlyActive);
        });

        return () => unsubscribe();
    }, [headings, progressValue, contentContainerRef]); 

    const handleMarkerClick = (headingId: string) => {
        const targetScrollPosition = headings.find(h => h.id === headingId)?.top;

        if (targetScrollPosition !== undefined) {
             window.scrollTo({ top: targetScrollPosition, behavior: 'smooth' });
        }
    };

    if (isMobile) {
        return (
            <AnimatePresence>
                {showHud && (
                    <motion.aside
                        className={styles.readingHudMobile}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <div className={styles.mobileTrack}>
                            <motion.div className={styles.mobileProgress} style={{ scaleX: springyProgress }} /> 
                        </div>
                    </motion.aside>
                )}
            </AnimatePresence>
        );
    }

    return (
        <AnimatePresence>
            {showHud && headings.length > 0 && (
                <motion.aside
                    className={styles.readingHud}
                    initial={{ opacity: 0, x: 20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: 20 }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                >
                    <div className={styles.track}>
                        {/* THE FIX: Apply the new translateY style instead of scaleY */}
                        <motion.div className={styles.progress} style={{ translateY }} />
                    </div>
                    <div className={styles.markers}>
                        {headings.map((h) => {
                            const isActive = activeHeadings.has(h.id);
                            
                            const documentScrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
                            if (documentScrollHeight <= 0) return null;
                            
                            const topPercentage = (h.top / documentScrollHeight) * 100;
                            
                            // MODIFIED: Conditionally add a class for h2 markers
                            const markerClass = h.level === 2 ? styles.markerH2 : '';

                            return (
                                <button
                                    key={h.id}
                                    className={`${styles.marker} ${markerClass} ${isActive ? styles.active : ''}`}
                                    style={{ 
                                        top: `${topPercentage}%`,
                                    }}
                                    onClick={() => handleMarkerClick(h.id)}
                                    data-title={h.title}
                                    aria-label={`Scroll to ${h.title}`}
                                >
                                    <div className={styles.markerDot} />
                                </button>
                            )
                        })}
                    </div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
};

--- END OF FILE components/ReadingHud.tsx ---

================================================================================

--- START OF FILE components/ScoreBox.module.css ---

/* components/ScoreBox.module.css */

.scoreBox {
  background-color: transparent;
  border: 1px solid var(--border-color);
  box-shadow: 0 8px 30px rgba(0,0,0,0.08);
  border-radius: 12px;
  padding: 4rem;
  margin-top: 5rem;
  text-align: center;
  position: relative;
  overflow: hidden;
  transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}
[data-theme="dark"] .scoreBox {
  border: 1px solid var(--border-color);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 15%, transparent);
}

.scoreBoxBorder {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}
[data-theme="dark"] .scoreBoxBorder {
  filter: drop-shadow(0 0 10px color-mix(in srgb, var(--accent) 70%, transparent));
}

.scoreBoxScore {
  font-family: var(--font-main), sans-serif;
  font-size: 9rem;
  font-weight: 800;
  color: var(--accent);
  line-height: 1;
  text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.scoreBoxVerdictLabel {
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-top: 0.5rem;
}

.scoreBoxVerdictText {
  font-size: 1.8rem;
  font-style: italic;
  max-width: 600px;
  margin: 1.5rem auto 3rem auto;
  color: var(--text-primary);
}

.scoreBoxDivider {
  width: 100%;
  height: 1px;
  background-color: var(--border-color);
  margin-bottom: 3rem;
}

.scoreBoxProsCons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3rem;
  text-align: right;
}

.scoreBoxProsCons h4 {
  font-family: var(--font-main), sans-serif;
  font-weight: 700;
  font-size: 1.8rem;
  margin-bottom: 1rem;
}

.scoreBoxProsCons ul {
  list-style: none;
  padding-right: 0;
}

.scoreBoxProsCons li {
  display: flex;
  flex-direction: row-reverse;
  justify-content: flex-end;
  align-items: flex-start;
  margin-bottom: 1rem;
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  gap: 1rem;
}

/* --- THE DEFINITIVE FIX FOR MOBILE --- */
@media (max-width: 640px) {
  .scoreBox {
    padding: 2rem;
  }
  .scoreBoxProsCons {
    grid-template-columns: 1fr; /* Stack to a single column */
    gap: 4rem; /* Increase gap between pros and cons sections */
  }
}

--- END OF FILE components/ScoreBox.module.css ---

================================================================================

--- START OF FILE components/ScoreBox.tsx ---

// components/ScoreBox.tsx
'use client';

import React, { useRef, memo } from 'react';
import { motion, useInView } from 'framer-motion';
import { AnimatedNumber } from './AnimatedNumber';
import { CheckIcon, CancelIcon } from '@/components/icons/index';
import styles from './ScoreBox.module.css';

const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.25, delayChildren: 0.2 }, }, };
const itemVariants = { hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: 'easeOut' as const } }, };

const ScoreBoxComponent = ({ review, className }: { review: any, className?: string }) => {
    const ref = useRef(null);
    // THE DEFINITIVE FIX: Changed `amount` from `0.5` to `'some'`.
    // This makes the trigger more sensitive and reliable on fast-scrolling mobile devices,
    // ensuring the animation fires as soon as any part of the component enters the viewport.
    const isInView = useInView(ref, { once: true, amount: 'some' });

    return (
        <motion.div ref={ref} className={`${styles.scoreBox} ${className || ''}`} initial="hidden" animate={isInView ? "visible" : "hidden"} variants={containerVariants}>
            <svg className={styles.scoreBoxBorder} width="100%" height="100%">
                <motion.rect x="1" y="1" width="calc(100% - 2px)" height="calc(100% - 2px)" rx="12" stroke="var(--accent)" strokeWidth="2" fill="transparent" initial={{ pathLength: 0 }} animate={{ pathLength: isInView ? 1 : 0 }} transition={{ duration: 1, ease: 'easeInOut' }} />
            </svg>
            <AnimatedNumber value={review.score} isInView={isInView} className={styles.scoreBoxScore} />
            <motion.div variants={itemVariants} className={styles.scoreBoxVerdictLabel}>الخلاصة</motion.div>
            <motion.p variants={itemVariants} className={styles.scoreBoxVerdictText}>{review.verdict}</motion.p>
            <motion.div variants={itemVariants} className={styles.scoreBoxDivider} />
            <div className={styles.scoreBoxProsCons}>
                <motion.div variants={itemVariants}>
                    <h4>المحاسن</h4>
                    <ul>{review.pros.map((pro: string, index: number) => (<li key={`pro-${index}`}>{pro} <CheckIcon style={{flexShrink:0,width:'3.5rem',height:'3.5rem',marginTop:'-0.3rem',color:'#16A34A'}} /></li>))}</ul>
                </motion.div>
                <motion.div variants={itemVariants}>
                    <h4>المساوئ</h4>
                    <ul>{review.cons.map((con: string, index: number) => (<li key={`con-${index}`}>{con} <CancelIcon style={{flexShrink:0,width:'1.8rem',height:'1.8rem',marginTop:'0.6rem',color:'#DC2626'}} /></li>))}</ul>
                </motion.div>
            </div>
        </motion.div>
    );
};

export default memo(ScoreBoxComponent);

--- END OF FILE components/ScoreBox.tsx ---

================================================================================

--- START OF FILE components/Search.module.css ---

/* components/Search.module.css */

.searchOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: color-mix(in srgb, var(--bg-primary) 85%, transparent);
  backdrop-filter: blur(10px);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding-top: 15vh;
  z-index: 2000;
}

.searchContainer {
  position: relative;
  width: 100%;
  max-width: 700px;
  padding: 0 2rem;
}

.searchCloseButton {
  position: absolute;
  top: -60px;
  left: 2rem; /* RTL */
  right: auto;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  padding: 1rem;
  width: 40px;
  height: 40px;
  transition: color 0.3s ease, transform 0.3s ease;
}

.searchCloseButton:hover {
  transform: scale(1.1) rotate(90deg);
  color: var(--accent);
}

.searchInput {
  width: 100%;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  color: var(--text-primary);
  font-family: var(--font-main), sans-serif;
  font-size: 2.2rem;
  padding: 1.5rem 2rem;
  outline: none;
  text-align: right; /* RTL */
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
  box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

.searchInput:focus {
  border-color: var(--accent);
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.searchResultsList {
  margin-top: 2rem;
  max-height: 65vh;
  overflow-y: auto;
  list-style: none;
  padding: 1rem 1rem 0 1rem;
}

.searchResultLink {
  display: flex;
  align-items: center;
  gap: 2.5rem;
  padding: 1.5rem;
  margin: 0 0 1.5rem 0;
  border-radius: 10px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease-out;
  box-shadow: none;
  position: relative;
  overflow: hidden;
  text-align: right; /* RTL */
}

.searchResultLink:hover {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  transform: translateY(-3px) scale(1.005);
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent), 0 5px 20px rgba(0,0,0,0.2);
}

.searchResultThumbnail {
  flex-shrink: 0;
  width: 100px;
  height: 60px;
  border-radius: 6px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}

.searchResultImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.searchResultDetails h4 {
  font-family: var(--font-main), sans-serif;
  font-size: 2rem;
  font-weight: 700;
  line-height: 1.3;
  margin: 0;
  color: var(--text-primary);
  transition: color 0.2s ease;
}

.searchResultLink:hover h4 {
  color: var(--accent);
}

.searchResultDetails p {
  font-family: var(--font-main), sans-serif;
  font-size: 1.4rem;
  color: var(--text-secondary);
  margin: 0.5rem 0 0 0;
}

.searchInitialPrompt {
  font-family: var(--font-main), sans-serif;
  font-size: 2.8rem;
  text-align: center;
  color: var(--text-secondary);
  margin-top: 5rem;
}

.searchResultImageFallback {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
}


@media (max-width: 768px) {
    .searchOverlay {
        padding-top: 10vh;
    }
    .searchContainer {
        padding: 0 1rem;
    }
    .searchInput {
        font-size: 1.8rem;
        padding: 1.2rem 1.5rem;
    }
    .searchResultLink {
        gap: 1.5rem;
        padding: 1rem;
    }
    .searchResultThumbnail {
        width: 80px;
        height: 48px;
    }
    .searchResultDetails h4 {
        font-size: 1.6rem;
    }
    .searchResultDetails p {
        font-size: 1.2rem;
    }
}




--- END OF FILE components/Search.module.css ---

================================================================================

--- START OF FILE components/Search.tsx ---

// components/Search.tsx

'use client';

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import type { SanitySearchResult } from '@/types/sanity';
import { useDebounce } from '@/hooks/useDebounce';
import styles from './Search.module.css';

const CrossIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

const overlayVariants = { hidden: { opacity: 0, backdropFilter: 'blur(0px)' }, visible: { opacity: 1, backdropFilter: 'blur(12px)' } };
const containerVariants = { hidden: { y: '-10vh', opacity: 0, scale: 0.98, transition: { type: 'spring' as const, stiffness: 200, damping: 25 } }, visible: { y: 0, opacity: 1, scale: 1, transition: { type: 'spring' as const, stiffness: 200, damping: 25 } } };
const listVariants = { visible: { transition: { staggerChildren: 0.03, delayChildren: 0.05 } } };
const resultItemVariants = { hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0 } };

export default function Search({ isOpen, onClose }: { isOpen: boolean, onClose: () => void }) {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState<SanitySearchResult[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    const debouncedQuery = useDebounce(query, 250);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (isOpen) {
            inputRef.current?.focus();
            const handleKeyDown = (event: KeyboardEvent) => { if (event.key === 'Escape') onClose(); };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
        } else {
            setQuery('');
            setResults([]);
        }
    }, [isOpen, onClose]);

    const performSearch = useCallback(async (searchQuery: string) => {
        if (searchQuery.length < 3) { setResults([]); return; }
        setIsSearching(true);
        try {
            const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) throw new Error('Search failed');
            const data: SanitySearchResult[] = await response.json();
            setResults(data);
        } catch (error) {
            console.error('Search error:', error);
            setResults([]);
        } finally {
            setIsSearching(false);
        }
    }, []);

    useEffect(() => { performSearch(debouncedQuery); }, [debouncedQuery, performSearch]);

    const getLinkPath = (item: SanitySearchResult) => {
        switch (item._type) {
            case 'review': return `/reviews/${item.slug}`;
            case 'article': return `/articles/${item.slug}`;
            case 'news': return `/news/${item.slug}`;
            default: return '/';
        }
    };

    const hasContent = useMemo(() => query.length >= 3 && results.length > 0, [query, results]);
    const isInitialPrompt = query.length < 3;
    const formatDate = (dateString?: string) => {
        if (!dateString) return '';
        return new Date(dateString).toLocaleDateString('ar-EG', { year: 'numeric', month: 'short', day: 'numeric' });
    };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div className={styles.searchOverlay} onClick={onClose} variants={overlayVariants} initial="hidden" animate="visible" exit="hidden" style={{ zIndex: 2000 }} >
                    <motion.div className={styles.searchContainer} onClick={(e) => e.stopPropagation()} variants={containerVariants} initial="hidden" animate="visible" exit="hidden" >
                        <button className={styles.searchCloseButton} onClick={onClose} aria-label="إغلاق البحث"><CrossIcon /></button>
                        <input ref={inputRef} type="search" className={styles.searchInput} placeholder="استنطاق الأرشيف" value={query} onChange={(e) => setQuery(e.target.value)} />
                        <div className={styles.searchResultsList}>
                            <AnimatePresence mode="wait">
                                {isInitialPrompt && (<motion.p key="prompt" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className={styles.searchInitialPrompt}>خُطَّ ما في نفسِكَ تُجِبْكَ السجلات.</motion.p> )}
                                {isSearching && (<motion.div key="loading" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ display: 'flex', justifyContent: 'center', padding: '4rem' }}><div className="spinner" style={{ width: '50px', height: '50px', borderTopColor: 'var(--accent)' }} /></motion.div> )}
                                {hasContent && (
                                    <motion.ul key="results" variants={listVariants} initial="hidden" animate="visible" exit="hidden" >
                                        {results.map(result => (
                                            <motion.li key={result._id} variants={resultItemVariants}>
                                                <Link href={getLinkPath(result)} onClick={onClose} className={`${styles.searchResultLink} no-underline`}>
                                                    <motion.div className={styles.searchResultThumbnail}>
                                                        {result.imageUrl ? (<Image src={result.imageUrl} alt={result.title} width={100} height={60} className={styles.searchResultImage} sizes="100px" />) : (<div className={styles.searchResultImageFallback} />)}
                                                    </motion.div>
                                                    <div className={styles.searchResultDetails}>
                                                        <h4>{result.title}</h4>
                                                        <p style={{ textTransform: 'capitalize' }}>
                                                            {result._type === 'review' && `مراجعة • ${formatDate(result.publishedAt)}`}
                                                            {result._type === 'article' && `مقالة • ${formatDate(result.publishedAt)}`}
                                                            {result._type === 'news' && `خبر • ${formatDate(result.publishedAt)}`}
                                                        </p>
                                                    </div>
                                                </Link>
                                            </motion.li>
                                        ))}
                                    </motion.ul>
                                )}
                                {!isSearching && query.length >= 3 && results.length === 0 && (<motion.div key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ color: 'var(--text-secondary)', marginTop: '3rem', textAlign: 'center', fontSize: '2.4rem' }}><p>لا أثرَ في السجلاتِ لـ &quot;{query}&quot;.</p></motion.div>)}
                            </AnimatePresence>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}




--- END OF FILE components/Search.tsx ---

================================================================================

--- START OF FILE components/SessionProvider.tsx ---

// components/SessionProvider.tsx
'use client';
import { SessionProvider } from 'next-auth/react';
import type { Session } from 'next-auth';
import React from 'react';

type Props = {
  children: React.ReactNode;
  session?: Session | null;
};

export default function NextAuthProvider({ children, session }: Props) {
  // THE FIX: Cast session to any to definitively resolve the TS2322 error
  // caused by module augmentation mismatches.
  return <SessionProvider session={session as any}>{children}</SessionProvider>;
}

--- END OF FILE components/SessionProvider.tsx ---

================================================================================

--- START OF FILE components/SignInModal.module.css ---

.authModalPanelContainer {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 420px;
  min-height: 450px;
}
.authSatelliteContainer {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
}
.authOrbRowTop {
  display: flex;
  justify-content: center;
  gap: 3rem;
  width: 100%;
}
.authFooterText {
  font-family: var(--font-ui);
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-align: center;
}
.authMorphWrapper {
  position: relative;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}
.authCredentialsPanel {
  width: 420px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  box-shadow: 0 25px 50px -12px rgba(0,0,0,0.35);
  padding: 3rem;
  overflow: hidden;
}
.authCredentialsContent {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.authBackButton {
  position: absolute;
  top: 1.5rem;
  right: 1.5rem;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  width: 24px;
  height: 24px;
  z-index: 20;
  transition: color 0.2s ease-out, transform 0.2s ease-out;
}
.authBackButton:hover {
  color: var(--text-primary);
  transform: translateX(2px);
}
.formHeader {
  text-align: center;
  margin-bottom: 2rem;
}
.formTitle {
  font-size: 2.4rem;
  margin: 0;
  font-family: var(--font-heading);
}
.credentialsForm {
  display: flex;
  flex-direction: column;
  gap: 2.5rem; /* Increased gap to accommodate labels */
  width: 100%;
}

/* --- THE DEFINITIVE FIX: FLOATING LABEL STYLES --- */
.authFormGroup {
  position: relative;
}
.authFormLabel {
  position: absolute;
  right: 1.5rem;
  left: auto;
  top: 1.2rem;
  font-family: var(--font-main);
  font-size: 1.4rem;
  color: var(--text-secondary);
  pointer-events: none;
  transition: all 0.2s ease-out;
}
.authInput:focus ~ .authFormLabel,
.authInput:not(:placeholder-shown) ~ .authFormLabel {
  top: -2.4rem; /* Move label up */
  right: 0;
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--accent);
}
.authInput {
  width: 100%;
  height: 4.8rem;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
  text-align: right;
}
.authInput:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
}
/* --- END FLOATING LABEL STYLES --- */

.authSubmitButton {
  background-color: var(--accent);
  color: #fff;
  border: none;
  padding: 1.2rem 2.4rem;
  border-radius: 8px;
  font-weight: 700;
  font-size: 1.6rem;
  cursor: pointer;
  margin-top: 1rem;
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
  transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
}
.authSubmitButton:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 50%, transparent);
}
[data-theme="dark"] .authSubmitButton {
  color: var(--bg-primary);
}
.authViewSwitcher {
  margin-top: 2rem;
  text-align: center;
  font-size: 1.4rem;
  color: var(--text-secondary);
}
.linkButton {
  position: relative;
  background: none;
  border: none;
  padding: 0;
  margin: 0 0.5rem;
  font: inherit;
  color: var(--accent);
  font-weight: 600;
  cursor: pointer;
  text-decoration: none;
}

.linkButton::after {
  content: '';
  position: absolute;
  width: 100%;
  transform: scaleX(0);
  height: 2px;
  bottom: -2px;
  right: 0;
  background-color: var(--accent);
  transform-origin: bottom right;
  transition: transform 0.3s ease-out;
}

.linkButton:hover::after {
  transform: scaleX(1);
}

.authMessage {
  margin-top: 1rem;
  font-size: 1.4rem;
  text-align: center;
}
.authMessage.error {
  color: #DC2626;
}
.authMessage.success {
  color: #16A34A;
}

/* ADDED: Mobile responsiveness */
@media (max-width: 480px) {
  .authModalPanelContainer {
    max-width: 90vw;
    min-height: 400px;
  }
  .authCredentialsPanel {
    width: 75vw;
    padding: 2rem;
  }
  .formTitle {
    font-size: 2rem;
  }
  .authInput {
    height: 4.4rem;
    font-size: 1.5rem;
  }
  .authFormLabel {
    top: 1rem;
  }
  .authSubmitButton {
    font-size: 1.5rem;
  }
  .authOrbRowTop {
    gap: 1.5rem;
  }
}

--- END OF FILE components/SignInModal.module.css ---

================================================================================

--- START OF FILE components/SignInModal.tsx ---

// components/SignInModal.tsx
'use client';

import React, { useState, useEffect, useTransition } from 'react';
import { createPortal } from 'react-dom';
import { signIn } from 'next-auth/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { useRouter, usePathname } from 'next/navigation';
import { AuthOrb } from './AuthOrb';
import { requestPasswordReset } from '@/app/actions/authActions';
import ButtonLoader from './ui/ButtonLoader';
// MODIFIED: Replaced dynamic imports with a single static import
import { GitHubIcon, GoogleIcon, XIcon, EternalGamesIcon } from '@/components/icons/AuthIcons';
import styles from './SignInModal.module.css';
import modalStyles from './modals/Modals.module.css';

const formContentVariants = {
    hidden: { opacity: 0, transition: { duration: 0.15, ease: 'easeOut' as const } },
    visible: { opacity: 1, transition: { delay: 0.25, duration: 0.3, ease: 'easeIn' as const } },
    exit: { opacity: 0, transition: { duration: 0.15, ease: 'easeOut' as const } }
};

const satelliteVariants = {
    hidden: (direction: number) => ({
        y: 80, x: direction * 20, scale: 0, opacity: 0, rotate: 360,
        transition: { duration: 0.4, ease: 'easeIn' as const }
    }),
    visible: {
        y: 0, x: 0, scale: 1, opacity: 1, rotate: 0,
        // MODIFIED: Slightly adjusted spring for a snappier feel
        transition: { type: 'spring' as const, stiffness: 350, damping: 25, delay: 0.1 }
    }
};

// --- START: Refactored Form Components (No changes within these) ---

const SignInForm = ({ onSwitchToSignUp, onForgotPassword, onAuthSuccess, onBack, callbackUrl }: { onSwitchToSignUp: () => void, onForgotPassword: () => void, onAuthSuccess: () => void, onBack: () => void, callbackUrl: string }) => {
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);
    const router = useRouter();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSignIn = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        const formData = new FormData(event.currentTarget);
        
        startTransition(async () => {
            const result = await signIn('credentials', { redirect: false, ...Object.fromEntries(formData) });
            if (result?.error) setMessage({ type: 'error', text: result.error });
            else if (result?.url) { router.push(result.url); onAuthSuccess(); } 
            else setMessage({ type: 'error', text: 'طرأ خطبٌ ما.' });
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>الدخول بالبريد الإلكتروني</h2></div>
            <form onSubmit={handleSignIn} className={styles.credentialsForm}>
                <input type="hidden" name="returnTo" value={callbackUrl} />
                <div className={styles.authFormGroup}>
                    <input id="signin-email" type="email" name="email" required className={styles.authInput} value={email} onChange={e => setEmail(e.target.value)} placeholder=" " />
                    <label htmlFor="signin-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <div className={styles.authFormGroup}>
                    <input id="signin-password" type="password" name="password" required className={styles.authInput} value={password} onChange={e => setPassword(e.target.value)} placeholder=" " />
                    <label htmlFor="signin-password" className={styles.authFormLabel}>كلمة السر</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>تسجيل الدخول</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${styles.error}`}>{message.text}</p>}
            <p className={styles.authViewSwitcher}>جديدٌ في رحابنا؟ <button type="button" onClick={() => {onSwitchToSignUp(); setMessage(null);}} className={styles.linkButton}>أنشئ حسابًا</button></p>
            <button type="button" onClick={onForgotPassword} className={styles.linkButton} style={{textAlign: 'center', fontSize: '1.4rem', color: 'var(--text-secondary)', display: 'block', margin: '1rem auto 0'}}>أنسيت كلمة السر؟</button>
        </motion.div>
    );
};

const SignUpForm = ({ onSwitchToSignIn, onAuthSuccess, onBack, callbackUrl }: { onSwitchToSignIn: () => void, onAuthSuccess: () => void, onBack: () => void, callbackUrl: string }) => {
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);
    const router = useRouter();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSignUp = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        const formData = new FormData(event.currentTarget);
        startTransition(async () => {
            const result = await signIn('signup', { redirect: false, ...Object.fromEntries(formData) });
            if (result?.error) setMessage({ type: 'error', text: result.error });
            else if (result?.url) { router.push(result.url); onAuthSuccess(); } 
            else setMessage({ type: 'error', text: 'طرأ خطبٌ ما.' });
        });
    };
    
    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>إنشاء حساب</h2></div>
             <form onSubmit={handleSignUp} className={styles.credentialsForm}>
                <input type="hidden" name="returnTo" value={callbackUrl} />
                <div className={styles.authFormGroup}>
                    <input id="signup-email" type="email" name="email" required value={email} onChange={e => setEmail(e.target.value)} className={styles.authInput} placeholder=" " />
                    <label htmlFor="signup-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <div className={styles.authFormGroup}>
                    <input id="signup-password" type="password" name="password" required value={password} onChange={e => setPassword(e.target.value)} className={styles.authInput} placeholder=" " />
                    <label htmlFor="signup-password" className={styles.authFormLabel}>كلمة السر (8 حروف على الأقل)</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>أنشئ حسابًا</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${styles.error}`}>{message.text}</p>}
            <p className={styles.authViewSwitcher}>لديك حساب؟ <button type="button" onClick={() => {onSwitchToSignIn(); setMessage(null);}} className={styles.linkButton}>تسجيل الدخول</button></p>
        </motion.div>
    );
};

const ForgotPasswordForm = ({ onBack }: { onBack: () => void }) => {
    const [email, setEmail] = useState('');
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);
        startTransition(async () => {
            const result = await requestPasswordReset(email);
            setMessage({type: result.success ? 'success' : 'error', text: result.message});
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>إعادة تعيين كلمة السر</h2><p style={{color: 'var(--text-secondary)', fontSize: '1.5rem'}}>أدخل بريدك ليصلك رابط التعيين.</p></div>
            <form onSubmit={handleSubmit} className={styles.credentialsForm}>
                <div className={styles.authFormGroup}>
                    <input id="reset-email" type="email" name="email" required className={styles.authInput} value={email} onChange={(e) => setEmail(e.target.value)} placeholder=" " />
                    <label htmlFor="reset-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', height: '48px', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إرسال الرابط</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${message.type === 'error' ? styles.error : styles.success}`}>{message.text}</p>}
        </motion.div>
    );
};

// --- END: Refactored Form Components ---

const authProviders = [
    { id: 'github', Icon: GitHubIcon, label: 'GitHub' },
    { id: 'google', Icon: GoogleIcon, label: 'Google' },
    { id: 'twitter', Icon: XIcon, label: 'X/Twitter' },
];

export default function SignInModal() {
    const { isSignInModalOpen, setSignInModalOpen } = useUserStore();
    const [view, setView] = useState<'orbs' | 'signin' | 'signup' | 'forgotPassword'>('orbs');
    const [isMounted, setIsMounted] = useState(false);
    const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
    const pathname = usePathname();

    useEffect(() => { setIsMounted(true); }, []);

    const handleClose = () => {
        if (loadingProvider) return;
        setSignInModalOpen(false);
        setTimeout(() => { setView('orbs'); setLoadingProvider(null); }, 350);
    };

    const handleProviderSignIn = (provider: string) => {
        setLoadingProvider(provider);
        signIn(provider, { callbackUrl: pathname });
    };

    const modalContent = (
        <AnimatePresence>
            {isSignInModalOpen && (
                <motion.div className={modalStyles.modalOverlay} onClick={handleClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={styles.authModalPanelContainer} onClick={(e) => e.stopPropagation()} initial="hidden" animate="visible" >
                        <div className={styles.authSatelliteContainer}>
                            <div className={styles.authOrbRowTop}>
                                <AnimatePresence>
                                    {view === 'orbs' && authProviders.map((provider, i) => {
                                        const direction = i - 1;
                                        return (
                                            <motion.div key={provider.id} custom={direction} variants={satelliteVariants} initial="hidden" animate="visible" exit="hidden">
                                                <AuthOrb Icon={provider.Icon} onClick={() => handleProviderSignIn(provider.id)} ariaLabel={`الدخول عبر ${provider.label}`} isLoading={loadingProvider === provider.id} isDisabled={!!loadingProvider} />
                                            </motion.div>
                                        );
                                    })}
                                </AnimatePresence>
                            </div>
                            <AnimatePresence>
                                {view === 'orbs' && (
                                    <motion.p className={styles.authFooterText} initial={{ opacity: 0 }} animate={{ opacity: 1, transition: { delay: 0.2 } }} exit={{ opacity: 0, transition: { duration: 0.2 } }}>
                                        انضم إلى EternalGames عبر مزود خدمة أو تابع بالبريد.
                                    </motion.p>
                                )}
                            </AnimatePresence>
                        </div>
                        
                        <div className={styles.authMorphWrapper} style={{ zIndex: 10 }}>
                            <AnimatePresence mode="popLayout" initial={false}>
                                {view === 'orbs' && (
                                    <motion.div key="orbs" layoutId="auth-panel" style={{ zIndex: loadingProvider ? 0 : 'auto' }}>
                                        <AuthOrb Icon={EternalGamesIcon} onClick={() => setView('signin')} ariaLabel="الدخول بالبريد" isLarge isDisabled={!!loadingProvider} />
                                    </motion.div>
                                )}
                                {view === 'signin' && (
                                    <motion.div key="signin" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <SignInForm onSwitchToSignUp={() => setView('signup')} onForgotPassword={() => setView('forgotPassword')} onAuthSuccess={handleClose} onBack={() => setView('orbs')} callbackUrl={pathname} />
                                    </motion.div>
                                )}
                                {view === 'signup' && (
                                    <motion.div key="signup" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <SignUpForm onSwitchToSignIn={() => setView('signin')} onAuthSuccess={handleClose} onBack={() => setView('orbs')} callbackUrl={pathname} />
                                    </motion.div>
                                )}
                                {view === 'forgotPassword' && (
                                    <motion.div key="forgot-password" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <ForgotPasswordForm onBack={() => setView('signin')} />
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) return null;
    return createPortal(modalContent, document.body);
}

--- END OF FILE components/SignInModal.tsx ---

================================================================================

--- START OF FILE components/StudioBar.module.css ---

/* components/StudioBar.module.css */

.studioBar {
  position: fixed;
  bottom: 2rem;
  right: 0;
  left: 0;
  width: max-content;
  margin-right: auto;
  margin-left: auto;
  z-index: 1080;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 20%, transparent);
  backdrop-filter: blur(10px);
  padding: 0.5rem;
}

.studioBarContent {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.studioBarButton {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1.25rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.5rem;
  color: var(--text-primary);
  background-color: transparent;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s ease-out, color 0.2s ease-out;
}

.studioBarButton:hover {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}

.brand {
  color: var(--accent);
}

.brand:hover {
  color: var(--accent); /* Ensure hover doesn't change color from accent */
}










--- END OF FILE components/StudioBar.module.css ---

================================================================================

--- START OF FILE components/StudioBar.tsx ---

// components/StudioBar.tsx
'use client';

import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { StudioIcon } from '@/components/icons/index';
import { useEffect } from 'react';
import styles from './StudioBar.module.css';

const EditIcon = () => ( <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /> </svg> );

export default function StudioBar({ serverRoles = [] }: { serverRoles?: string[] }) {
    const { data: session, update } = useSession();
    const pathname = usePathname();
    
    // Prioritize server roles for immediate rendering feedback
    const effectiveRoles = serverRoles.length > 0 ? serverRoles : (session?.user as any)?.roles || [];
    
    const isCreatorOrAdmin = effectiveRoles.some((role: string) => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
    
    // THE DEFINITIVE FIX:
    // 1. Only attempt to sync if the server actually provided roles (length > 0).
    //    If serverRoles is empty, it means RootLayout didn't find a user, so we shouldn't force a sync loop.
    // 2. Use safe sorting for comparison to avoid false positives.
    useEffect(() => {
        if (serverRoles.length > 0 && session?.user) {
            const sessionRoles = (session.user as any).roles || [];
            
            // Create copies before sorting to avoid mutating props/state
            const sortedServerRoles = [...serverRoles].sort();
            const sortedSessionRoles = [...sessionRoles].sort();

            if (JSON.stringify(sortedServerRoles) !== JSON.stringify(sortedSessionRoles)) {
                console.log("StudioBar: Detected role change from server. Syncing session...");
                update();
            }
        }
    }, [serverRoles, session, update]);

    let editPath = null;
    const pathSegments = pathname.split('/').filter(Boolean);
    
    // Logic to determine edit path could go here in the future

    if (!isCreatorOrAdmin || pathname.startsWith('/studio')) {
        return null;
    }

    return (
        <AnimatePresence>
            <motion.div
                className={styles.studioBar}
                initial={{ y: '100%', opacity: 0 }}
                animate={{ y: '0%', opacity: 1 }}
                exit={{ y: '100%', opacity: 0 }}
                transition={{ type: 'spring' as const, stiffness: 300, damping: 30 }}
            >
                <div className={styles.studioBarContent}>
                    <Link href="/studio" className={`${styles.studioBarButton} ${styles.brand}`}>
                        <StudioIcon height={20} width={20} />
                        <span>الديوان</span>
                    </Link>

                    {editPath && (
                        <Link href={editPath} className={styles.studioBarButton}>
                            <EditIcon />
                            <span>تعديل الصفحة</span>
                        </Link>
                    )}
                </div>
            </motion.div>
        </AnimatePresence>
    );
}

--- END OF FILE components/StudioBar.tsx ---

================================================================================

--- START OF FILE components/TagLinks.module.css ---

/* components/TagLinks.module.css */

.tagLinksContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

.tagLinksContainer.small {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}
  
.tagLink {
    display: inline-block; /* motion.div wrapper handles block display */
    background-color: color-mix(in srgb,var(--accent) 15%,transparent);
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 500;
    transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    cursor: pointer;
}
  
.tagLink:hover {
    background-color: var(--accent);
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px -3px color-mix(in srgb, var(--accent) 40%, transparent), 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}
  
[data-theme="dark"] .tagLink:hover {
    color: var(--bg-primary);
}










--- END OF FILE components/TagLinks.module.css ---

================================================================================

--- START OF FILE components/TagLinks.tsx ---

// components/TagLinks.tsx
'use client';

import { useRouter } from 'next/navigation';
import { translateTag } from '@/lib/translations';
import styles from './TagLinks.module.css';

export default function TagLinks({ tags, small = false }: { tags: string[], small?: boolean }) {
  const router = useRouter();

  if (!tags || tags.length === 0) return null;

  const handleTagClick = (e: React.MouseEvent | React.TouchEvent, tag: string) => {
    e.preventDefault();
    e.stopPropagation(); // Stop the event from bubbling up to the card's main link/handlers
    const slug = tag.toLowerCase().replace(/ /g, '-');
    router.push(`/tags/${slug}`);
  };

  return (
    <div className={`${styles.tagLinksContainer} ${small ? styles.small : ''}`}>
      {tags.map((tag) => (
        <span 
          key={tag} 
          className={styles.tagLink}
          onClick={(e) => handleTagClick(e, tag)}
          onTouchStart={(e) => handleTagClick(e, tag)} // ADDED: Handle touch for immediate response
        >
          {translateTag(tag)}
        </span>
      ))}
    </div>
  );
}

--- END OF FILE components/TagLinks.tsx ---

================================================================================

--- START OF FILE components/TerminalTicker.tsx ---

// components/TerminalTicker.tsx
'use client';

import { useState, useEffect } from 'react';
import type { SanityNews } from '@/types/sanity';
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../app/news/NewsPage.module.css'; // <-- IMPORTED

const ScrambledText = ({ text }: { text: string }) => {
  const [displayText, setDisplayText] = useState('');
  const chars = '!<>-_\\/[]{}—=+*^?#________';

  useEffect(() => {
    let frame = 0;
    const frameRate = 2;
    const scrambleDuration = 30;

    const intervalId = setInterval(() => {
      let newText = '';
      let isComplete = true;

      for (let i = 0; i < text.length; i++) {
        const progress = (frame - i * frameRate) / scrambleDuration;
        if (progress < 1 && progress > 0) {
          const randomChar = chars[Math.floor(Math.random() * chars.length)];
          newText += randomChar;
          isComplete = false;
        } else {
          newText += text[i];
        }
      }

      setDisplayText(newText);
      frame++;

      if (isComplete) {
        clearInterval(intervalId);
      }
    }, 40);

    return () => clearInterval(intervalId);
  }, [text]);

  return <>{displayText}</>;
};

export default function TerminalTicker({ headlines }: { headlines: SanityNews[] }) {
  const [index, setIndex] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setIndex((prevIndex) => (prevIndex + 1) % headlines.length);
    }, 6000);
    return () => clearInterval(timer);
  }, [headlines.length]);

  return (
    <div className={styles.terminalTickerContainer}>
      <h3 className={styles.terminalTickerTitle}>
        <motion.span
          animate={{ opacity: [0.5, 1, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity }}
          style={{ display: 'inline-block', width: '8px', height: '8px', borderRadius: '50%', backgroundColor: '#ff4d4d', marginRight: '1rem' }}
        />
        LIVE FEED
      </h3>
      <div className={styles.terminalTickerContent}>
        <AnimatePresence mode="wait">
          <motion.div
            key={index}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Link href={`/news/${headlines[index].slug}`} className="no-underline">
              <p className={styles.terminalTickerCategory}>{headlines[index].category}</p>
              <h4 className={styles.terminalTickerHeadline}>
                <ScrambledText text={headlines[index].title} />
              </h4>
            </Link>
          </motion.div>
        </AnimatePresence>
      </div>
    </div>
  );
}










--- END OF FILE components/TerminalTicker.tsx ---

================================================================================

--- START OF FILE components/ThemeProvider.tsx ---

'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
// CORRECTED: The 'ThemeProviderProps' type is now imported directly from the main package.
// The old '/dist/types' path no longer exists in the newer version of the library.
import { type ThemeProviderProps } from 'next-themes';

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
































--- END OF FILE components/ThemeProvider.tsx ---

================================================================================

--- START OF FILE components/ThemeToggle.module.css ---

/* components/ThemeToggle.module.css */

.themeToggleButton {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    transition: color 0.3s ease;
}
  
.themeToggleButton:hover {
    color: var(--accent);
}










--- END OF FILE components/ThemeToggle.module.css ---

================================================================================

--- START OF FILE components/ThemeToggle.tsx ---

// components/ThemeToggle.tsx
'use client';

import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './ThemeToggle.module.css'; // <-- IMPORTED MODULE

const SunIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
const MoonIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;

export const ThemeToggle = () => {
    const [mounted, setMounted] = useState(false);
    const { theme, setTheme } = useTheme();
    useEffect(() => { setMounted(true); }, []);

    if (!mounted) { return <div style={{ width: '24px', height: '24px' }} />; }

    const isDark = theme === 'dark';

    return (
        <motion.button
            className={styles.themeToggleButton} // <-- UPDATED CLASS
            onClick={() => setTheme(isDark ? 'light' : 'dark')}
            aria-label={isDark ? 'تفعيل الوضع النهاري' : 'تفعيل الوضع الليلي'}
            title={isDark ? 'تفعيل الوضع النهاري' : 'تفعيل الوضع الليلي'}
            whileHover={{ scale: 1.2, rotate: 90 }}
            whileTap={{ scale: 0.9, rotate: -90 }}
            transition={{ type: "spring", stiffness: 400, damping: 15 }}
        >
            <AnimatePresence mode="wait" initial={false}>
                <motion.div
                    key={isDark ? "moon" : "sun"}
                    initial={{ y: -20, opacity: 0, rotate: -90 }}
                    animate={{ y: 0, opacity: 1, rotate: 0 }}
                    exit={{ y: 20, opacity: 0, rotate: 90 }}
                    transition={{ duration: 0.3, ease: 'easeInOut' }}
                >
                    {isDark ? <SunIcon /> : <MoonIcon />}
                </motion.div>
            </AnimatePresence>
        </motion.button>
    );
};










--- END OF FILE components/ThemeToggle.tsx ---

================================================================================

--- START OF FILE components/TimelineCard.module.css ---

/* components/TimelineCard.module.css */
.livingCardWrapper {
    transform-style: preserve-d;
    height: 100%;
}

.timelineCard {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    will-change: transform;
    transform-style: preserve-d;
    position: relative; /* For glare positioning */
}

/* --- NEW GLARE EFFECT STYLE --- */
.livingCardGlare {
    position: absolute;
    inset: 0;
    background: radial-gradient(
        circle at var(--mouse-x) var(--mouse-y),
        rgba(255, 255, 255, 0.2),
        transparent 40%
    );
    opacity: 0;
    transition: opacity 0.4s ease-out;
    z-index: 1;
    pointer-events: none;
}

.livingCardWrapper:hover .livingCardGlare {
    opacity: 1;
}
/* --- END NEW STYLE --- */

.imageContainer {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    overflow: hidden;
    flex-shrink: 0;
}

.image {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.4s ease-out;
}

.livingCardWrapper:hover .image {
    transform: scale(1.05);
}

@keyframes pulse-glow {
    0%, 100% {
        box-shadow: 0 0 10px 0px color-mix(in srgb, var(--accent) 50%, transparent);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 16px 2px color-mix(in srgb, var(--accent) 70%, transparent);
        transform: scale(1.03);
    }
}

.releasedBadge {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    background-color: color-mix(in srgb, var(--accent) 95%, black 20%);
    backdrop-filter: blur(5px);
    color: #fff;
    padding: 0.4rem 1rem;
    border-radius: 999px;
    font-family: var(--font-ui);
    font-size: 1.2rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border: 1px solid color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 2;
    animation: pulse-glow 3s infinite ease-in-out;
}

.checkIcon {
    width: 14px;
    height: 14px;
    filter: drop-shadow(0 0 5px #fff);
}

.cardContent {
    padding: 1.5rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    background-color: var(--bg-secondary);
}

.cardHeader h4 {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    line-height: 1.3;
    color: var(--text-primary);
    margin: 0 0 0.4rem 0;
}

.cardHeader p {
    font-family: var(--font-ui);
    font-size: 1.4rem;
    color: var(--text-secondary);
    margin: 0;
}

.platformIcons {
    display: flex;
    gap: 1.2rem;
    align-items: center;
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.platformIcon {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
}

@media (max-width: 768px) {
    .cardContent {
        padding: 1rem;
    }
    .cardHeader h4 {
        font-size: 1.6rem;
    }
    .cardHeader p {
        font-size: 1.2rem;
    }
    .platformIcons {
        gap: 0.8rem;
        padding-top: 0.8rem;
        margin-top: 0.8rem;
    }
    .platformIcon {
        width: 16px;
        height: 16px;
    }
}




--- END OF FILE components/TimelineCard.module.css ---

================================================================================

--- START OF FILE components/TimelineCard.tsx ---

// components/TimelineCard.tsx
'use client';

import Link from 'next/link';
import Image from 'next/image';
import type { SanityGameRelease } from '@/types/sanity';
import { motion, useMotionValue, useTransform, useSpring } from 'framer-motion';
import { memo } from 'react';
import { useLivingCard } from '@/hooks/useLivingCard';
import { urlFor } from '@/sanity/lib/image';
import styles from './TimelineCard.module.css';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

// THE DEFINITIVE FIX: The icon map now handles both legacy and current values.
const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    'PC': PCIcon,
    'PlayStation': PS5Icon,
    'PlayStation 5': PS5Icon, // Legacy value support
    'Xbox': XboxIcon,
    'Switch': SwitchIcon,
};

const CheckIcon = (props: React.SVGProps<SVGSVGElement>) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props}><path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.052-.143z" clipRule="evenodd" /></svg> );

const TimelineCardComponent = ({ release }: { release: SanityGameRelease & { game?: { slug?: string } } }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();
    
    // Glare effect logic
    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);
    const smoothMouseX = useSpring(mouseX, { damping: 20, stiffness: 150, mass: 0.7 });
    const smoothMouseY = useSpring(mouseY, { damping: 20, stiffness: 150, mass: 0.7 });
    const glareX = useTransform(smoothMouseX, [0, 1], ['0%', '100%']);
    const glareY = useTransform(smoothMouseY, [0, 1], ['0%', '100%']);
    const glareOpacity = useTransform(smoothMouseX, [0, 0.5, 1], [0.3, 0.6, 0.3]);
    
    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        livingCardAnimation.onMouseMove(e);
        if (!livingCardRef.current) return;
        const { left, top, width, height } = livingCardRef.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const handleMouseLeave = () => {
        livingCardAnimation.onMouseLeave();
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const date = new Date(release.releaseDate);
    const day = date.getUTCDate();
    const monthIndex = date.getUTCMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;

    const linkPath = release.game?.slug ? `/games/${release.game.slug}` : '/';

    return (
        <motion.div 
            ref={livingCardRef} 
            onMouseMove={handleMouseMove} 
            onMouseEnter={livingCardAnimation.onMouseEnter} 
            onMouseLeave={handleMouseLeave}
            className={styles.livingCardWrapper} 
            style={livingCardAnimation.style}
        >
            <Link href={linkPath} className={`${styles.timelineCard} no-underline`}>
                <motion.div
                    className={styles.livingCardGlare}
                    style={{ opacity: glareOpacity, '--mouse-x': glareX, '--mouse-y': glareY } as any}
                />
                
                <div className={styles.imageContainer}>
                    <Image
                        src={urlFor(release.mainImage).width(800).height(450).fit('crop').auto('format').url()}
                        alt={release.title}
                        fill
                        sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 320px"
                        className={styles.image}
                        placeholder="blur"
                        blurDataURL={release.mainImage.blurDataURL}
                    />
                    {new Date(release.releaseDate) < new Date() && <div className={styles.releasedBadge}><CheckIcon className={styles.checkIcon} /> صدرت</div>}
                </div>
                <div className={styles.cardContent}>
                    <div className={styles.cardHeader}>
                        <h4>{release.title}</h4>
                        <p>{formattedDate}</p>
                    </div>
                    <div className={styles.platformIcons}>
                        {(release.platforms || []).map(p => { const Icon = PlatformIcons[p]; return Icon ? <Icon key={p} className={styles.platformIcon} /> : null; })}
                    </div>
                </div>
            </Link>
        </motion.div>
    );
}

export default memo(TimelineCardComponent);

--- END OF FILE components/TimelineCard.tsx ---

================================================================================

--- START OF FILE components/ToastProvider.tsx ---

// components/ToastProvider.tsx

'use client';

import { useState, useEffect, useMemo } from 'react';
import { AnimatePresence } from 'framer-motion';
import { createPortal } from 'react-dom';
import useToastStore from '@/lib/toastStore';
import { Toast } from './ui/Toast';

const ToastContainer = ({ toasts, dismissToast, position }: { toasts: any[], dismissToast: (id: string) => void, position: 'left' | 'right' }) => (
<div
className="toast-container-global"
style={{
position: 'fixed',
bottom: '2rem',
[position]: '2rem',
zIndex: 9999,
display: 'flex',
flexDirection: 'column',
gap: '1rem',
[position === 'right' ? 'left' : 'right']: 'auto',
}}
>
<AnimatePresence>
{toasts.map((toast) => (
<Toast
key={toast.id}
id={toast.id}
message={toast.message}
type={toast.type}
onDismiss={dismissToast}
/>
))}
</AnimatePresence>
</div>
);

export default function ToastProvider() {
const { toasts, dismissToast } = useToastStore();
const [isMounted, setIsMounted] = useState(false); // Must be top-level hook

//  DEFINITIVE FIX FOR HOOKS ORDER
// Hooks must be executed unconditionally at the top level.
const { leftToasts, rightToasts } = useMemo(() => {
return {
leftToasts: toasts.filter(t => t.position === 'left'),
rightToasts: toasts.filter(t => t.position === 'right'),
};
}, [toasts]); // Unconditional hook execution

// Effect to set mount status runs only on client
useEffect(() => {
setIsMounted(true);
}, []);

//  Conditionally return null only if mounting fails or on server
if (!isMounted) {
// We return null here. The internal useToastStore hooks (and useMemo above)
// are still executed, preserving the hooks order between renders.
return null;
}

// After mounting, create the portal into document.body.
return createPortal(
<>
<ToastContainer toasts={rightToasts} dismissToast={dismissToast} position="right" />
<ToastContainer toasts={leftToasts} dismissToast={dismissToast} position="left" />
</>,
document.body
);
}
































--- END OF FILE components/ToastProvider.tsx ---

================================================================================

--- START OF FILE components/UserProfile.module.css ---

/* components/UserProfile.module.css */

.userProfileContainer {
  position: relative;
}

.userAvatarButton {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  border-radius: 50%;
}

.userAvatar {
  border-radius: 50%;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}

.userAvatarButton:hover .userAvatar {
  border-color: var(--accent);
}

.userAvatarFallback {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-main);
  font-weight: 700;
  font-size: 1.6rem;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}

.userAvatarButton:hover .userAvatarFallback {
  border-color: var(--accent);
}

.userAvatarSkeleton {
  width: 99px; /* Matches Sign In button */
  height: 39px; /* Matches Sign In button */
  background-color: var(--border-color);
  border-radius: 5px;
  animation: pulse 1.5s infinite ease-in-out;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.userDropdown {
  position: absolute;
  top: calc(100% + 15px);
  left: 0; /* RTL */
  right: auto;
  width: 240px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 15%, transparent);
  z-index: 1100;
  overflow: hidden;
  padding: 0.5rem 0;
  transform-origin: top left; /* RTL */
}

.dropdownUserInfo {
  padding: 0.75rem 1.25rem;
  text-align: right; /* RTL */
}

.dropdownUserName {
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dropdownUserEmail {
  font-family: var(--font-main);
  font-size: 1.4rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.userDropdownDivider {
  height: 1px;
  background-color: var(--border-color);
  margin: 0.5rem 0;
}

.userDropdownItem {
  display: flex;
  align-items: center;
  gap: 1rem;
  width: 100%;
  text-align: right; /* RTL */
  padding: 0.75rem 1.25rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: background-color 0.2s ease, color 0.2s ease;
  background: none;
  border: none;
  cursor: pointer;
}

.dropdownItemIcon {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
    transition: color 0.2s ease;
}

.userDropdownItem:hover {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}

.userDropdownItem:hover .dropdownItemIcon {
    color: var(--accent);
}

.userDropdownItem.signout {
  color: #DC2626;
}

.userDropdownItem.signout:hover {
  background-color: color-mix(in srgb, #DC2626 15%, transparent);
  color: #DC2626;
}

.userDropdownItem.signout:hover .dropdownItemIcon {
    color: #DC2626;
}

.signInButton {
  background: var(--accent);
  color: #fff;
  border: none;
  /* MODIFIED: Reduced padding and font-size for desktop */
  padding: 0.8rem 1.8rem;
  font-size: 1.2rem;
  border-radius: 5px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s ease, transform 0.2s ease-out;
}

[data-theme="dark"] .signInButton {
  color: var(--bg-primary);
}

.signInButton:hover {
  opacity: 0.85;
  transform: scale(1.05);
}

/* ADDED: Media query for mobile-specific button size */
@media (max-width: 768px) {
  .signInButton {
    padding: 0.6rem 0.9rem;
    font-size: 1.3rem;
  }
}

--- END OF FILE components/UserProfile.module.css ---

================================================================================

--- START OF FILE components/UserProfile.tsx ---

// components/UserProfile.tsx
'use client';

import { useSession, signOut } from 'next-auth/react';
import Image from 'next/image';
import Link from 'next/link';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { UserCircleIcon, UserSettings01Icon, AllBookmarkIcon, Logout03Icon } from '@/components/icons/index';
import SignInModal from './SignInModal';
import styles from './UserProfile.module.css';

const UserProfile = () => {
    const { data: session, status } = useSession();
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const dropdownRef = useRef<HTMLDivElement>(null);
    const { setSignInModalOpen } = useUserStore();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsDropdownOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    if (status === 'loading') {
        return <div className={styles.userAvatarSkeleton} />;
    }

    if (session && session.user) {
        const userInitial = session.user.name ? session.user.name.charAt(0).toUpperCase() : '?';

        return (
            <div className={styles.userProfileContainer} ref={dropdownRef}>
                <motion.button
                    className={styles.userAvatarButton}
                    onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                    aria-label="فتح قائمة المستخدم"
                    animate={{ scale: isDropdownOpen ? 1.1 : 1, rotate: isDropdownOpen ? -15 : 0 }}
                    transition={{ type: 'spring', stiffness: 400, damping: 15 }}
                >
                    {session.user.image ? (
                        <Image
                            src={session.user.image}
                            alt={session.user.name || 'User Avatar'}
                            width={36}
                            height={36}
                            className={styles.userAvatar}
                        />
                    ) : (
                        <div className={styles.userAvatarFallback}><span>{userInitial}</span></div>
                    )}
                </motion.button>

                <AnimatePresence>
                    {isDropdownOpen && (
                        <motion.div
                            className={styles.userDropdown}
                            initial={{ opacity: 0, scale: 0.95, y: -10 }}
                            animate={{ opacity: 1, scale: 1, y: 0 }}
                            exit={{ opacity: 0, scale: 0.95, y: -10 }}
                            transition={{ duration: 0.2, ease: 'easeOut' }}
                        >
                            <div className={styles.dropdownUserInfo}>
                                <p className={styles.dropdownUserName}>{session.user.name}</p>
                                <p className={styles.dropdownUserEmail}>{session.user.email}</p>
                            </div>
                            <div className={styles.userDropdownDivider} />
                            
                            {(session.user as any).username && (
                                <Link href={`/profile/${(session.user as any).username}`} className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>
                                    <UserCircleIcon className={styles.dropdownItemIcon} />
                                    <span>ملفك الشخصي</span>
                                </Link>
                            )}

                            <Link href="/profile" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>
                                <UserSettings01Icon className={styles.dropdownItemIcon} />
                                <span>الإعدادات</span>
                            </Link>
                            <Link href="/profile/bookmarks" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>
                                <AllBookmarkIcon className={styles.dropdownItemIcon} />
                                <span>المحفوظات</span>
                            </Link>
                            
                            <div className={styles.userDropdownDivider} />
                            <button onClick={() => signOut()} className={`${styles.userDropdownItem} ${styles.signout}`}>
                                <Logout03Icon className={styles.dropdownItemIcon} />
                                <span>تسجيل الخروج</span>
                            </button>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        );
    }

    return (
        <>
            <button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton}
            >
                تسجيل الدخول
            </button>
            <SignInModal />
        </>
    );
};

export default UserProfile;

--- END OF FILE components/UserProfile.tsx ---

================================================================================

--- START OF FILE components/UserStoreHydration.tsx ---

// components/UserStoreHydration.tsx
'use client';

import { useEffect, useRef } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import { getUserState } from '@/app/actions/userActions';
import { useRouter, usePathname } from 'next/navigation';

// Define the type for the passed state
type InitialUserState = {
    engagements: { contentId: number; contentType: string; type: 'LIKE' | 'BOOKMARK' }[];
    shares: { contentId: number; contentType: string }[];
} | null;

function UserStoreHydration({ initialUserState }: { initialUserState?: InitialUserState }) {
    const { data: session, status } = useSession();
    const router = useRouter();
    const pathname = usePathname();
    const { syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb } = useUserStore();
    
    const lastSyncedUserId = useRef<string | null>(null);

    useEffect(() => {
        if (status === 'authenticated' && (session as any)?.needsOnboarding && pathname !== '/welcome') {
            const callbackUrl = pathname !== '/' ? `?callbackUrl=${encodeURIComponent(pathname)}` : '';
            router.push(`/welcome${callbackUrl}`);
            return; 
        }

        if (status === 'loading') {
            return;
        }

        if (status === 'authenticated') {
            const currentUserId = (session?.user as any)?.id;
            
            // THE FIX: If we have initial server data, use it immediately
            if (initialUserState && (!isSyncedWithDb || lastSyncedUserId.current !== currentUserId)) {
                syncWithDb(initialUserState);
                setIsSyncedWithDb(true);
                lastSyncedUserId.current = currentUserId;
                return; // Skip the fetch logic below
            }

            const needsSync = !isSyncedWithDb || (currentUserId && lastSyncedUserId.current !== currentUserId);

            if (needsSync && currentUserId) {
                getUserState().then(result => {
                    if (result.success && result.data) {
                        syncWithDb(result.data);
                        setIsSyncedWithDb(true);
                        lastSyncedUserId.current = currentUserId;
                    }
                });
            }
        } 
        else if (status === 'unauthenticated') {
            if (_hasHydrated) {
                reset();
                lastSyncedUserId.current = null;
            }
        }

    }, [status, session, pathname, router, syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb, initialUserState]);

    return null;
}

export default UserStoreHydration;

--- END OF FILE components/UserStoreHydration.tsx ---

================================================================================

--- START OF FILE components/comments/CommentForm.tsx ---

// components/comments/CommentForm.tsx
'use client';
import { useState, useTransition, FormEvent } from 'react';
import { Session } from 'next-auth';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from './Comments.module.css';

export default function CommentForm({
    slug,
    session,
    parentId,
    onPostComment,
    onReplySuccess,
}: {
    slug: string;
    session: Session | null;
    parentId?: string;
    onPostComment: (content: string, parentId?: string) => Promise<void>;
    onReplySuccess?: () => void;
}) {
    const [commentText, setCommentText] = useState('');
    const [isPending, startTransition] = useTransition();
    const isButtonDisabled = isPending || commentText.trim().length === 0;

    const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const content = commentText;
        if (content.trim().length === 0) return;

        startTransition(async () => {
            await onPostComment(content, parentId);
            setCommentText('');
            if (parentId && onReplySuccess) {
                onReplySuccess();
            }
        });
    };

    return (
        <div className={styles.commentFormWrapper}>
            <div className={styles.commentFormAvatar}>
                <Image src={session!.user.image || '/default-avatar.svg'} alt={session!.user.name || 'User Avatar'} width={40} height={40} className="user-avatar" />
            </div>
            <div className={styles.commentFormMain}>
                <form onSubmit={handleSubmit}>
                    <textarea
                        name="comment"
                        placeholder="أدلِ برأيك..."
                        required
                        className="profile-input" // This global class is okay here
                        disabled={isPending}
                        value={commentText}
                        onChange={(e) => setCommentText(e.target.value)}
                    />
                    <div className={styles.commentEditActions}>
                        <motion.button type="submit" className={`${isButtonDisabled ? 'outline-button' : 'primary-button'}`} disabled={isButtonDisabled} animate={{ width: isPending ? '44px' : 'auto', height: '44px', borderRadius: isPending ? '50%' : '5px' }}>
                            <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{parentId ? 'أضف ردًا' : 'انشر التعليق'}</motion.span>}</AnimatePresence>
                        </motion.button>
                        {parentId && (<button type="button" onClick={onReplySuccess} className="outline-button">إلغاء</button>)}
                    </div>
                </form>
            </div>
        </div>
    );
}




--- END OF FILE components/comments/CommentForm.tsx ---

================================================================================

--- START OF FILE components/comments/CommentItem.tsx ---

// components/comments/CommentItem.tsx
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import { Session } from 'next-auth';
import { useState, useTransition, useMemo } from 'react';
import { deleteComment, updateComment, getReplies } from '@/app/actions/commentActions';
import ConfirmationModal from '../ConfirmationModal';
import CommentVoteButtons from './CommentVoteButtons';
import CommentForm from './CommentForm';
import Link from 'next/link';
import Image from 'next/image';
import TimeStamp from './TimeStamp';
import ActionButton from '../ActionButton';
import styles from './Comments.module.css';

const ReplyIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path> </svg> );
const EditIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>;
const DeleteIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;
const animationVariants = { initial: { opacity: 0, y: -10 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 10 } };

export default function CommentItem({ comment, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comment: any;
    session: Session | null;
    slug: string;
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
    onPostReply: (content: string, parentId?: string) => Promise<void>;
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    const [isPending, startTransition] = useTransition();
    const [isEditing, setIsEditing] = useState(false);
    const [editText, setEditText] = useState(comment.content);
    const [showDeleteModal, setShowDeleteModal] = useState(false);
    const [isReplying, setIsReplying] = useState(false);
    const [replies, setReplies] = useState<any[]>(comment.replies || []);
    const [areRepliesVisible, setAreRepliesVisible] = useState(true);
    const [isLoadingReplies, setIsLoadingReplies] = useState(false);
    const replyCount = comment._count?.replies || 0;
    
    const userRoles = (session?.user as any)?.roles || [];
    const isAuthor = session?.user?.id === comment.author.id;
    const isModerator = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const canDelete = isAuthor || isModerator;

    const handleToggleReplies = async () => { if (areRepliesVisible) { setAreRepliesVisible(false); return; } setIsLoadingReplies(true); setAreRepliesVisible(true); if (replies.length < replyCount) { const result = await getReplies(comment.id); if (result.success) { setReplies(result.replies as any[]); } } setIsLoadingReplies(false); };
    
    const handleDeleteConfirm = () => {
        startTransition(async () => {
            const result = await deleteComment(comment.id);
            if (result.success) {
                onDeleteSuccess(result.deletedId || comment.id, result.wasDeleted ?? false, result.updatedComment);
            }
            setShowDeleteModal(false);
        });
    };

    const handleUpdate = () => {
        startTransition(async () => {
            const result = await updateComment(comment.id, editText);
            if(result.success && result.updatedComment) {
                onUpdateSuccess(result.updatedComment);
            }
            setIsEditing(false);
        });
    };
    
    const DeletedState = () => ( <div className={`${styles.commentItem} ${styles.deleted}`}> <div className={styles.commentAuthorInfo}> <div className={styles.deletedAvatar} /> <div> <p className={`${styles.commentAuthorLink} ${styles.deleted}`}>طُمِسَ التعليق</p> <TimeStamp date={comment.createdAt} /> </div> </div> </div> );

    if (comment.isDeleted) { return ( <> <DeletedState /> {replyCount > 0 && ( <div className={styles.commentRepliesList}> {(replies || []).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </> ); }

    return ( <> <motion.div className={styles.commentItem} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}> <div className={styles.commentHeader}> <div className={styles.commentAuthorInfo}>
        <Link href={`/profile/${comment.author.username}`}><Image src={comment.author.image || '/default-avatar.svg'} alt={comment.author.name || 'User Avatar'} width={40} height={40} className="user-avatar" /></Link>
        <div className={styles.authorAndTimestamp}>
            <Link 
                href={`/profile/${comment.author.username}`} 
                className={`${styles.commentAuthorLink} no-underline ${comment.isOptimistic ? styles.pulsingText : ''}`}
            >
                {comment.author.name}
            </Link>
            {!comment.isOptimistic && <TimeStamp date={comment.createdAt} />}
        </div>
    </div> 
    {session?.user && !comment.isOptimistic && ( <ActionButton onClick={() => setIsReplying(!isReplying)} aria-label="Reply" disabled={isPending}> <ReplyIcon /> </ActionButton> )} 
    </div> <AnimatePresence mode="wait"> {!isEditing ? ( <motion.div key="display" variants={animationVariants} initial="initial" animate="animate" exit="exit"> 
    <div className={styles.commentBody}>
        <p className={comment.isOptimistic ? styles.pulsingText : ''}>{comment.content}</p>
    </div> 
    <div className={styles.commentFooter}> 
    {!comment.isOptimistic && (
        <>
            <CommentVoteButtons commentId={comment.id} initialVotes={comment.votes} onVoteUpdate={onVoteUpdate} /> 
            {replyCount > 0 && (<button onClick={handleToggleReplies} className={`outline-button ${styles.viewRepliesButton}`} disabled={isLoadingReplies}>{isLoadingReplies ? 'جارٍ التحميل...' : areRepliesVisible ? 'إخفاء الردود' : `عرض ${replyCount} ${replyCount > 1 ? 'ردود' : 'رد'}`}</button>)} 
            {(isAuthor || canDelete) && ( <div className={styles.commentAuthorActions}>
                {isAuthor && <ActionButton onClick={() => setIsEditing(true)} aria-label="Edit" disabled={isPending}><EditIcon /></ActionButton>}
                {canDelete && <ActionButton onClick={() => setShowDeleteModal(true)} aria-label="Delete" disabled={isPending}><DeleteIcon /></ActionButton>}
            </div> )}
        </>
    )}
    </div> </motion.div> ) : ( <motion.div key="edit" variants={animationVariants} initial="initial" animate="animate" exit="exit" className={styles.commentEditForm}> <textarea defaultValue={comment.content} onChange={(e) => setEditText(e.target.value)} className="profile-input" disabled={isPending} autoFocus /> <div className={styles.commentEditActions}> <button onClick={handleUpdate} className="primary-button" disabled={isPending || editText.trim() === ''}>حفظ</button> <button onClick={() => setIsEditing(false)} className="outline-button" disabled={isPending}>إلغاء</button> </div> </motion.div> )} </AnimatePresence> <AnimatePresence> {isReplying && ( <motion.div className={styles.commentReplyFormContainer} variants={animationVariants} initial="initial" animate="animate" exit="exit"> <CommentForm slug={slug} session={session} parentId={comment.id} onPostComment={onPostReply} onReplySuccess={() => setIsReplying(false)} /> </motion.div> )} </AnimatePresence> {areRepliesVisible && ( <div className={styles.commentRepliesList}> {isLoadingReplies && <div className="spinner" />} {!isLoadingReplies && (replies).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </motion.div> <ConfirmationModal isOpen={showDeleteModal} onClose={() => setShowDeleteModal(false)} onConfirm={handleDeleteConfirm} title="حذف التعليق" message="أمتأكدٌ من الحذف؟" /> </> );
}

--- END OF FILE components/comments/CommentItem.tsx ---

================================================================================

--- START OF FILE components/comments/CommentList.tsx ---

// components/comments/CommentList.tsx
'use client';
import CommentItem from './CommentItem';
import type { Session } from 'next-auth';
import styles from './Comments.module.css';

export default function CommentList({ comments, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comments: any[],
    session: Session | null,
    slug: string,
    onVoteUpdate: (commentId: string, newVotes: any[]) => void,
    onPostReply: (content: string, parentId?: string) => Promise<void>,
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    if (comments.length === 0) {
        return <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginTop: '4rem' }}>كن أول من يخط حرفًا هنا.</p>
    }
    return (
        <div className={styles.commentList}>
            {comments.map(comment => (
                <CommentItem
                    key={comment.id}
                    comment={comment}
                    session={session}
                    slug={slug}
                    onVoteUpdate={onVoteUpdate}
                    onPostReply={onPostReply}
                    onDeleteSuccess={onDeleteSuccess} // Pass down callback
                    onUpdateSuccess={onUpdateSuccess} // Pass down callback
                />
            ))}
        </div>
    )
}

--- END OF FILE components/comments/CommentList.tsx ---

================================================================================

--- START OF FILE components/comments/CommentSection.tsx ---

// components/comments/CommentSection.tsx
'use client';

import { useState, useOptimistic } from 'react';
import { useSession } from 'next-auth/react';
import type { Session } from 'next-auth';
import { postReplyOrComment } from '@/app/actions/commentActions';
import CommentForm from './CommentForm';
import SignInPrompt from './SignInPrompt';
import CommentList from './CommentList';
import styles from './Comments.module.css';

const addReplyToState = (comments: any[], parentId: string, reply: any): any[] => {
    return comments.map(comment => {
        if (comment.id === parentId) {
            const updatedReplies = comment.replies ? [...comment.replies, reply] : [reply];
            return { ...comment, replies: updatedReplies, _count: { replies: (comment._count?.replies || 0) + 1 } };
        }
        if (comment.replies && comment.replies.length > 0) {
            return { ...comment, replies: addReplyToState(comment.replies, parentId, reply) };
        }
        return comment;
    });
};

// THE FIX: Accept initialComments prop and remove useEffect fetching
export default function CommentSection({ slug, contentType, initialComments }: { slug: string; contentType: string; initialComments: any[] }) {
    const { data: session } = useSession();
    const typedSession = session as unknown as Session | null;

    const [comments, setComments] = useState<any[]>(initialComments);
    
    const currentPath = `/${contentType}/${slug}`;

    // Removed useEffect fetching logic completely. Data is now provided by the server.

    const [optimisticComments, addOptimisticComment] = useOptimistic(
        comments,
        (state, { newComment, parentId }) => {
            if (parentId) {
                return addReplyToState(state, parentId, newComment);
            }
            return [newComment, ...state];
        }
    );

    const handlePostComment = async (content: string, parentId?: string) => {
        if (!typedSession?.user?.id) return;

        const optimisticComment = {
            id: crypto.randomUUID(),
            content,
            parentId,
            createdAt: new Date().toISOString(),
            author: typedSession.user,
            authorId: typedSession.user.id,
            votes: [],
            replies: [],
            _count: { replies: 0 },
            isOptimistic: true,
        };

        addOptimisticComment({ newComment: optimisticComment, parentId });

        const result = await postReplyOrComment(slug, content, currentPath, parentId);

        if (result.success && result.comment) {
            setComments(currentComments => {
                const updateWithNewComment = (commentsList: any[]): any[] => {
                    return commentsList.map(c => {
                        if (c.id === optimisticComment.id) return result.comment;
                        if (c.replies) return { ...c, replies: updateWithNewComment(c.replies) };
                        return c;
                    });
                };

                if (parentId) {
                     return addReplyToState(currentComments, parentId, result.comment)
                        .filter(c => c.id !== optimisticComment.id);
                }
                
                return [result.comment, ...currentComments.filter(c => c.id !== optimisticComment.id)];
            });
        }
    };
    
    const handleVoteUpdate = (commentId: string, newVotes: any[]) => {
        const updateVotesRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(comment => {
                if (comment.id === commentId) return { ...comment, votes: newVotes };
                if (comment.replies) return { ...comment, replies: updateVotesRecursive(comment.replies) };
                return comment;
            });
        };
        setComments(prevComments => updateVotesRecursive(prevComments));
    };

    const handleDeleteSuccess = (deletedId: string, wasDeleted: boolean, updatedComment?: any) => {
        const removeOrUpdateRecursive = (commentsList: any[]): any[] => {
            if (wasDeleted) {
                return commentsList.filter(c => {
                    if (c.replies) c.replies = removeOrUpdateRecursive(c.replies);
                    return c.id !== deletedId;
                });
            } else {
                return commentsList.map(c => {
                    if (c.id === deletedId) return updatedComment;
                    if (c.replies) return { ...c, replies: removeOrUpdateRecursive(c.replies) };
                    return c;
                });
            }
        };
        setComments(prevComments => removeOrUpdateRecursive(prevComments));
    };

    const handleUpdateSuccess = (updatedComment: any) => {
        const updateRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(c => {
                if (c.id === updatedComment.id) return updatedComment;
                if (c.replies) return { ...c, replies: updateRecursive(c.replies) };
                return c;
            });
        };
        setComments(prevComments => updateRecursive(prevComments));
    };

    return (
        <div className={styles.commentsSection}>
            {typedSession?.user ? (
                <CommentForm slug={slug} session={typedSession} onPostComment={handlePostComment} />
            ) : (
                <SignInPrompt />
            )}
            
            <div>
                <CommentList
                    comments={optimisticComments}
                    session={typedSession}
                    slug={slug}
                    onVoteUpdate={handleVoteUpdate}
                    onPostReply={handlePostComment}
                    onDeleteSuccess={handleDeleteSuccess}
                    onUpdateSuccess={handleUpdateSuccess}
                />
            </div>
        </div>
    );
}

--- END OF FILE components/comments/CommentSection.tsx ---

================================================================================

--- START OF FILE components/comments/CommentVoteButtons.tsx ---

// components/comments/CommentVoteButtons.tsx
'use client';
import { useTransition, useOptimistic, useRef } from 'react';
import { voteOnComment } from '@/app/actions/commentActions';
import { VoteType } from '@/lib/generated/client';
import { useUserStore } from '@/lib/store';
import { useSession } from 'next-auth/react';
import { motion, useAnimationControls } from 'framer-motion';
import styles from './Comments.module.css';

const ThumbsUpIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" as const }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
const ThumbsDownIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ transform: 'scaleY(-1)' }}> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" as const }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
type Vote = { userId: string; type: VoteType; };
const buttonVariants = { inactive: { scale: 1 }, active: { scale: [1, 1.3, 1.1], transition: { duration: 0.4, ease: "easeOut" as const } } }
const countVariants = { initial: { y: 10, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: -10, opacity: 0 }, transition: { type: 'spring' as const, stiffness: 400, damping: 20 } };


export default function CommentVoteButtons({ commentId, initialVotes, onVoteUpdate }: { 
    commentId: string; 
    initialVotes: Vote[];
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
}) {
    const { data: session } = useSession();
    const setSignInModalOpen = useUserStore((s) => s.setSignInModalOpen);
    const [_, startTransition] = useTransition(); 
    const latestRequestRef = useRef(0);
    const likeControls = useAnimationControls();
    const dislikeControls = useAnimationControls();

    const [optimisticVotes, setOptimisticVotes] = useOptimistic(initialVotes, (state, newVote: { voteType: VoteType; userId: string }) => {
        const existingVoteIndex = state.findIndex(v => v.userId === newVote.userId);
        if (existingVoteIndex > -1) {
            const existingVote = state[existingVoteIndex];
            if (existingVote.type === newVote.voteType) { return state.filter(v => v.userId !== newVote.userId); } 
            else { return state.map(v => v.userId === newVote.userId ? { ...v, type: newVote.voteType } : v); }
        } else { return [...state, { userId: newVote.userId, type: newVote.voteType }]; }
    });

    const likes = optimisticVotes.filter(v => v.type === 'LIKE').length;
    const dislikes = optimisticVotes.filter(v => v.type === 'DISLIKE').length;
    const currentUserVote = optimisticVotes.find(v => v.userId === (session?.user as any)?.id)?.type;

    const handleVote = (voteType: VoteType) => {
        const userId = (session?.user as any)?.id;
        if (!userId) { setSignInModalOpen(true); return; }

        const requestId = ++latestRequestRef.current;
        
        if (voteType === 'LIKE') {
            likeControls.start("active");
        } else {
            dislikeControls.start("active");
        }
        
        startTransition(() => {
            setOptimisticVotes({ voteType, userId });
        });

        voteOnComment(commentId, voteType).then(result => {
            if (requestId === latestRequestRef.current && result.success && result.updatedVotes) {
                onVoteUpdate(commentId, result.updatedVotes);
            }
        });
    };

    return (
        <div className={styles.commentVoteActions}>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'LIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.LIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants} 
                initial={currentUserVote === 'LIKE' ? 'active' : 'inactive'}
                animate={likeControls}
            >
                <ThumbsUpIcon isActive={currentUserVote === 'LIKE'} />
                <motion.span key={likes} variants={countVariants} initial="initial" animate="animate" exit="exit">{likes}</motion.span>
            </motion.button>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'DISLIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.DISLIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants}
                initial={currentUserVote === 'DISLIKE' ? 'active' : 'inactive'}
                animate={dislikeControls}
            >
                <ThumbsDownIcon isActive={currentUserVote === 'DISLIKE'} />
                <motion.span key={dislikes} variants={countVariants} initial="initial" animate="animate" exit="exit">{dislikes}</motion.span>
            </motion.button>
        </div>
    );
}




--- END OF FILE components/comments/CommentVoteButtons.tsx ---

================================================================================

--- START OF FILE components/comments/Comments.module.css ---

/* components/comments/Comments.module.css */
@keyframes pulse-text {
    0%, 100% {
        color: var(--text-primary);
    }
    50% {
        color: var(--text-secondary);
    }
}

.pulsingText {
    animation: pulse-text 2s ease-in-out infinite;
}

.commentsSection { margin-top: 8rem; padding-top: 4rem; border-top: 1px solid var(--border-color); }
.commentsBlock .commentsSection { margin-top: 0; padding-top: 0; border-top: none; }
.commentsBlock { margin-top: 8rem; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 3rem; }
.commentSigninPrompt { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 4rem; text-align: center; margin-top: 2rem; }
.commentFormWrapper { display: flex; align-items: flex-start; gap: 1.5rem; margin-bottom: 5rem; max-width: 700px; }
.commentFormAvatar { flex-shrink: 0; margin-top: 0.5rem; }
.commentFormMain { flex-grow: 1; }
.commentFormMain .profileInput { min-height: 120px; margin-bottom: 1rem; }
.commentList { position: relative; max-width: 700px; display: flex; flex-direction: column; gap: 4rem; border-right: 2px solid var(--border-color); padding-right: 3rem; border-left: none; padding-left: 0; }
.commentItem { position: relative; }
.commentItem::before { content: ''; position: absolute; right: -3.9rem; left: auto; top: 10px; width: 14px; height: 14px; border-radius: 50%; background-color: var(--bg-secondary); border: 3px solid var(--accent); }
.commentHeader { display: flex; align-items: flex-start; justify-content: space-between; gap: 1.2rem; margin-bottom: 1rem; }
.commentAuthorInfo { display: flex; align-items: center; gap: 1.2rem; flex-grow: 1; }
.commentAuthorLink { font-family: var(--font-main), sans-serif; font-weight: 700; font-size: 1.8rem; color: var(--text-primary); transition: color 0.2s ease; }
.commentAuthorLink:hover { color: var(--accent); }

.authorAndTimestamp {
    display: flex;
    align-items: baseline; 
    gap: 0.8rem;
    flex-wrap: wrap;
}
.commentTimestamp {
    font-size: 1.3rem;
    color: var(--text-secondary);
    font-family: var(--font-main), sans-serif;
    margin: 0;
}

.commentBody { padding-right: 52px; padding-left: 0; }
.commentFooter { display: flex; justify-content: space-between; align-items: center; margin-top: 1.5rem; padding-right: 52px; padding-left: 0; flex-wrap: wrap; gap: 1rem; }
.commentVoteActions { display: flex; align-items: center; gap: 1.5rem; }
.commentAuthorActions { display: flex; align-items: center; gap: 0.5rem; }

.viewRepliesButton { margin-left: auto; margin-right: 1.5rem; padding: 0.6rem 1.2rem !important; font-size: 1.3rem !important; }

.voteButton { display: flex; align-items: center; gap: 0.6rem; background: none; border: none; cursor: pointer; color: var(--text-secondary); padding: 0.4rem 0.8rem; margin: 0 -0.8rem; border-radius: 999px; transition: color 0.2s ease, background-color 0.2s ease; }
.voteButton:hover:not(:disabled) { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }
.voteButton.active { color: var(--accent); font-weight: 700; }
.commentEditForm { margin-top: 1rem; padding-right: 52px; padding-left: 0; }
.commentEditActions { display: flex; gap: 1rem; }
.commentReplyFormContainer { padding-right: 52px; padding-left: 0; margin-top: 1.5rem; }
.commentReplyFormContainer .commentFormWrapper { margin: 0; padding: 0; }
.commentRepliesList { position: relative; display: flex; flex-direction: column; gap: 3rem; margin-top: 3rem; padding-right: 52px; padding-left: 0; }
.commentRepliesList::before { content: ''; position: absolute; top: 0; right: 20px; left: auto; bottom: 0; width: 2px; background-color: var(--border-color); }
.commentRepliesList .commentItem { padding-right: 0; border-right: none; }
.commentRepliesList .commentItem::before { display: none; }
.commentItem.deleted .commentAuthorInfo { opacity: 0.7; }
.deletedAvatar { width: 40px; height: 40px; border-radius: 50%; background-color: var(--border-color); }
.commentAuthorLink.deleted { color: var(--text-secondary); font-style: italic; }

@media (max-width: 768px) {
    .commentsBlock {
        padding: 1.5rem;
    }
    .commentList {
        padding-right: 1.5rem;
        border-right-width: 1px;
    }
    .commentItem::before {
        right: -2.3rem;
    }
    .commentBody, .commentFooter, .commentEditForm, .commentReplyFormContainer, .commentRepliesList {
        padding-right: 0;
    }
    .commentRepliesList {
        padding-right: 2rem;
    }
    .commentRepliesList::before {
        right: 0;
    }
    .commentHeader {
        gap: 0.5rem;
    }
    .authorAndTimestamp {
        align-items: flex-start;
        flex-direction: column;
        gap: 0.2rem;
    }
}




--- END OF FILE components/comments/Comments.module.css ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.module.css ---

/* components/comments/SignInPrompt.module.css */

.signInPrompt {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 4rem;
    text-align: center;
    margin-top: 2rem;
}

.signInButton {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 1rem 2.4rem;
    border-radius: 5px;
    font-family: var(--font-ui), sans-serif;
    font-weight: 500;
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

[data-theme="dark"] .signInButton {
    color: var(--bg-primary);
}

.signInButton:hover {
    opacity: 0.85;
}










--- END OF FILE components/comments/SignInPrompt.module.css ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.tsx ---

// components/comments/SignInPrompt.tsx
'use client';

import { useUserStore } from "@/lib/store";
import { motion } from "framer-motion";
import styles from './SignInPrompt.module.css'; // <-- IMPORTED MODULE

export default function SignInPrompt() {
    const { setSignInModalOpen } = useUserStore();

    return (
        <div className={styles.signInPrompt}>
            <h3>شارك في النقاش</h3>
            <p>لتترك تعليقًا، سجِّل دخولك.</p>
            <motion.button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton} // <-- UPDATED CLASS
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 400, damping: 15 }}
            >تسجيل الدخول</motion.button>
        </div>
    );
}










--- END OF FILE components/comments/SignInPrompt.tsx ---

================================================================================

--- START OF FILE components/comments/TimeStamp.tsx ---

'use client';
import { useState, useEffect } from 'react';
export default function TimeStamp({ date }: { date: Date }) {
const [displayTime, setDisplayTime] = useState('');
useEffect(() => {
const updateDisplayTime = () => {
const seconds = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
if (seconds < 5) { setDisplayTime("للتو"); return; }
if (seconds < 60) { setDisplayTime(`منذ ${Math.floor(seconds)} ثوانٍ`); return; }
const minutes = seconds / 60;
if (minutes < 60) { setDisplayTime(`منذ ${Math.floor(minutes)} دقائق`); return; }
const hours = minutes / 60;
if (hours < 24) { setDisplayTime(`منذ ${Math.floor(hours)} ساعات`); return; }
setDisplayTime(new Date(date).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
};
updateDisplayTime();
const interval = setInterval(updateDisplayTime, 30000); // update every 30 seconds
return () => clearInterval(interval);
}, [date]);
return <p className="comment-timestamp">{displayTime}</p>;
}




--- END OF FILE components/comments/TimeStamp.tsx ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.module.css ---

/* components/constellation/ConstellationControlPanel.module.css */

.settingsButton {
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  left: auto;
  z-index: 2001;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background-color: color-mix(in srgb,var(--bg-secondary) 80%,transparent);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(4px);
  transition: all 0.3s ease;
}

.settingsButton:hover {
  border-color: var(--accent);
  color: var(--accent);
  box-shadow: 0 0 15px 0 color-mix(in srgb,var(--accent) 70%,transparent);
}

.panelOverlay {
  position: absolute;
  inset: 0;
  z-index: 2000;
  background-color: rgba(0,0,0,0.3);
}

.panel {
  position: absolute;
  top: 0;
  right: 0;
  left: auto;
  bottom: 0;
  width: 100%;
  max-width: 320px;
  background-color: color-mix(in srgb,var(--bg-secondary) 90%,transparent);
  backdrop-filter: blur(10px);
  border-left: 1px solid var(--border-color);
  border-right: none;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  font-family: var(--font-main);
}

.panelHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.panelHeader h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: 600;
}

.closeButton {
  background: none;
  border: none;
  padding: 0.5rem;
  color: var(--text-secondary);
  cursor: pointer;
  transition: color 0.2s;
}
.closeButton:hover {
  color: var(--text-primary);
}

.divider {
  height: 1px;
  background-color: var(--border-color);
  margin: -0.5rem 0;
}

.section {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.label {
  font-size: 1.4rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.presetButtons {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 1rem;
}

.presetButton {
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);padding: 0.8rem;border-radius: 6px;
  font-size: 1.3rem;font-weight: 500;text-transform: capitalize;
  cursor: pointer;transition: all 0.2s ease;
}

.presetButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.presetButton.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .presetButton.active {
  color: var(--bg-primary);
}

.rangeInput {
  -webkit-appearance: none;appearance: none;
  width: 100%;height: 4px;background: var(--border-color);
  border-radius: 2px;outline: none;transition: background-color 0.2s;
}
.rangeInput:disabled {
  background-color: color-mix(in srgb,var(--border-color) 50%,transparent);
}
.rangeInput::-webkit-slider-thumb {
  -webkit-appearance: none;appearance: none;
  width: 16px;height: 16px;background: var(--accent);
  border-radius: 50%;cursor: pointer;
  transition: filter 0.2s ease-out;
}
.rangeInput::-webkit-slider-thumb:hover {
  filter: drop-shadow(0 0 6px var(--accent));
}
.rangeInput:disabled::-webkit-slider-thumb {
  background: var(--text-secondary);cursor: not-allowed;filter: none;
}

.section > .label {
  display: block;
  width: 100%;
}

.toggle {
  width: 44px;height: 24px;background-color: var(--border-color);
  border-radius: 999px;padding: 2px;
  display: flex;cursor: pointer;justify-content: flex-start;
  border: none;
}
.toggle.active {
  background-color: var(--accent);justify-content: flex-end;
}
.toggleHandle {
  width: 20px;
  height: 20px;
  background-color: white;
  border-radius: 50%;
}

.note {
  font-size: 1.2rem;
  color: var(--text-secondary);
  margin: -0.5rem 0 0 0;
  font-style: italic;
}

@media (max-width: 1024px) {
  .panelOverlay {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }
  .panel {
    position: relative;
    top: auto;
    right: auto;
    bottom: auto;
    left: auto;
    width: 100%;
    max-width: 380px;
    border-radius: 12px;
    border: 1px solid var(--border-color);
  }
}




--- END OF FILE components/constellation/ConstellationControlPanel.module.css ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.tsx ---

// components/constellation/ConstellationControlPanel.tsx
'use client';

import { motion } from 'framer-motion';
import { useTheme } from 'next-themes';
import styles from './ConstellationControlPanel.module.css';

export type Preset = 'أداء' | 'مُتَّزِن' | 'فائق';
export type ConstellationSettings = {
    activePreset: Preset | 'custom';
    starCountMultiplier: number;
    bloomIntensity: number;
    alwaysShowOrbits: boolean;
    flawlessPathThickness: number;
};

const CloseIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

const panelVariants = {
    hidden: { x: '-100%', opacity: 0 },
    visible: { x: 0, opacity: 1, transition: { type: 'spring' as const, damping: 25, stiffness: 150, staggerChildren: 0.05, delayChildren: 0.1 } },
    exit: { x: '-100%', opacity: 0, transition: { duration: 0.2 } }
};
const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: -20, transition: { duration: 0.15 } }
};

interface ControlPanelProps {
    settings: ConstellationSettings;
    setSettings: (settings: ConstellationSettings) => void;
    onClose: () => void;
    onPresetChange: (preset: Preset) => void;
    isFullscreen: boolean;
    onToggleFullscreen: () => void;
}

export default function ConstellationControlPanel({ settings, setSettings, onClose, onPresetChange, isFullscreen, onToggleFullscreen }: ControlPanelProps) {
    const { resolvedTheme } = useTheme();
    const isLightMode = resolvedTheme === 'light';

    const handleValueChange = (key: keyof ConstellationSettings, value: number | boolean) => {
        setSettings({ ...settings, activePreset: 'custom', [key]: value });
    };

    return (
        <motion.div className={styles.panelOverlay} onClick={onClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
            <motion.div className={styles.panel} variants={panelVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
                <motion.div className={styles.panelHeader} variants={itemVariants}>
                    <h3>إعدادات الكوكبة</h3>
                    <motion.button onClick={onClose} className={styles.closeButton} whileHover={{ scale: 1.1, rotate: 90 }}><CloseIcon /></motion.button>
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>إعدادات الجودة</label>
                    <div className={styles.presetButtons}>
                        {(['أداء', 'مُتَّزِن', 'فائق'] as Preset[]).map(p => (
                            <motion.button key={p} className={`${styles.presetButton} ${settings.activePreset === p ? styles.active : ''}`} onClick={() => onPresetChange(p)} whileTap={{ scale: 0.95 }}>
                                {p}
                            </motion.button>
                        ))}
                    </div>
                </motion.div>

                <motion.div className={styles.divider} variants={itemVariants} />

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label} htmlFor="galaxy-density">كثافة المجرة</label>
                    <input id="galaxy-density" type="range" min="0.1" max="1.5" step="0.1" value={settings.starCountMultiplier} onChange={(e) => handleValueChange('starCountMultiplier', parseFloat(e.target.value))} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants} style={{ opacity: isLightMode ? 0.5 : 1 }}>
                    <label className={styles.label} htmlFor="bloom-intensity">كثافة التوهج {isLightMode && "(معطل)"}</label>
                    <input id="bloom-intensity" type="range" min="0" max="2.5" step="0.1" value={settings.bloomIntensity} onChange={(e) => handleValueChange('bloomIntensity', parseFloat(e.target.value))} disabled={isLightMode} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.divider} variants={itemVariants} />

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label} htmlFor="path-thickness">سماكة المسار</label>
                    <input id="path-thickness" type="range" min="1" max="3" step="0.1" value={settings.flawlessPathThickness} onChange={(e) => handleValueChange('flawlessPathThickness', parseFloat(e.target.value))} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>إظهار المدارات دومًا</label>
                    <button className={`${styles.toggle} ${settings.alwaysShowOrbits ? styles.active : ''}`} onClick={() => handleValueChange('alwaysShowOrbits', !settings.alwaysShowOrbits)}>
                        <motion.div className={styles.toggleHandle} layout transition={{ type: 'spring', stiffness: 500, damping: 25 }} />
                    </button>
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>وضع ملء الشاشة</label>
                    <button className={`${styles.toggle} ${isFullscreen ? styles.active : ''}`} onClick={onToggleFullscreen}>
                        <motion.div className={styles.toggleHandle} layout transition={{ type: 'spring', stiffness: 500, damping: 25 }} />
                    </button>
                </motion.div>
            </motion.div>
        </motion.div>
    );
}




--- END OF FILE components/constellation/ConstellationControlPanel.tsx ---

================================================================================

--- START OF FILE components/constellation/Scene.tsx ---

// components/constellation/Scene.tsx
import React, { useRef, useMemo, Suspense, useCallback, useState } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Tube, Line, Html } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, SIZES, StarData, ScreenPosition, Placement, getStarSize, StarActionType } from './config';
import { ConstellationSettings } from './ConstellationControlPanel';
import { motion, AnimatePresence } from 'framer-motion';

const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
    const positions = useMemo(() => {
        const pos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
            pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
        }
        return pos;
    }, [count, radius]);
    return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const InteractiveStar = ({ star, color, isHovered, onHover, onClick }: {
    star: StarData, color: string, isHovered: boolean,
    onHover: (star: StarData | null) => void,
    onClick: (star: StarData) => void
}) => {
    const ref = useRef<THREE.Mesh>(null!);
    const size = useMemo(() => getStarSize(star), [star]);
    useFrame(() => { ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.5 : 1), 0.2); });
    const handlePointerOver = (e: ThreeEvent<PointerEvent>) => { e.stopPropagation(); document.body.style.cursor = 'pointer'; onHover(star); };
    const handlePointerOut = () => { onHover(null); document.body.style.cursor = 'auto'; };
    return (
        <mesh ref={ref} onClick={(e) => { e.stopPropagation(); onClick(star); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
            <sphereGeometry args={[size, 16, 16]} />
            <meshBasicMaterial color={color} toneMapped={false} />
        </mesh>
    );
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
    const ref = useRef<THREE.Group>(null!);
    useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 45; });
    return (
        <group ref={ref}>
            <StarLayer count={Math.floor(1500 * countMultiplier)} radius={4} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(1000 * countMultiplier)} radius={6} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(500 * countMultiplier)} radius={8} size={0.008} opacity={0.3} color={themeColors.bgStarColor} />
        </group>
    );
};

const createUIShareIconGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const createCenteredShapeFromPoints = (points: {x: number, y: number}[]) => {
        const shape = new THREE.Shape();
        const vecs = points.map(p => new THREE.Vector2(p.x, p.y).sub(center).multiplyScalar(scale));
        shape.moveTo(vecs[0].x, -vecs[0].y);
        for (let i = 1; i < vecs.length; i++) shape.lineTo(vecs[i].x, -vecs[i].y);
        shape.closePath();
        return shape;
    };
    const createCircleShape = ({x, y, r}: {x: number, y: number, r: number}) => {
        const shape = new THREE.Shape();
        const centerVec = new THREE.Vector2(x, y).sub(center).multiplyScalar(scale);
        shape.absarc(centerVec.x, -centerVec.y, r * scale, 0, Math.PI * 2, false);
        return shape;
    };
    const circle1Shape = createCircleShape({ x: 18, y: 5, r: 3 });
    const circle2Shape = createCircleShape({ x: 6, y: 12, r: 3 });
    const circle3Shape = createCircleShape({ x: 18, y: 19, r: 3 });
    const line1Points = [{ x: 8.59, y: 13.51 }, { x: 15.42, y: 17.44 }, { x: 14.42, y: 19.18 }, { x: 7.59, y: 15.25 }];
    const line2Points = [{ x: 8.59, y: 10.49 }, { x: 9.59, y: 12.23 }, { x: 16.42, y: 8.30 }, { x: 15.42, y: 6.56 }];
    const line1Shape = createCenteredShapeFromPoints(line1Points);
    const line2Shape = createCenteredShapeFromPoints(line2Points);
    return new THREE.ShapeGeometry([circle1Shape, circle2Shape, circle3Shape, line1Shape, line2Shape]);
};

const createUIHeartGeometry = () => {
    const shape = new THREE.Shape();
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const transform = (x: number, y: number) => {
        const v = new THREE.Vector2(x, y).sub(center);
        return { x: v.x * scale, y: -v.y * scale };
    };
    let p0 = transform(12, 21); shape.moveTo(p0.x, p0.y);
    let p1 = transform(12, 21), p2 = transform(5.8, 16.4), p3 = transform(2.8, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(0.9, 9.7); p2 = transform(2.5, 5); p3 = transform(6.7, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(8.6, 4.3); p2 = transform(10.5, 5.2); p3 = transform(12, 6.7); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(13.5, 5.2); p2 = transform(15.4, 4.3); p3 = transform(17.3, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(21.5, 5); p2 = transform(23.1, 9.7); p3 = transform(21.2, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(18.2, 16.4); p2 = transform(12, 21); p3 = transform(12, 21); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    return new THREE.ShapeGeometry(shape);
};

const createUIBookmarkGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const points = [
        new THREE.Vector2(6, 2), new THREE.Vector2(4, 4), new THREE.Vector2(4, 22),
        new THREE.Vector2(12, 17), new THREE.Vector2(20, 22), new THREE.Vector2(20, 4),
        new THREE.Vector2(18, 2),
    ];
    const transformedPoints = points.map(p => {
        const v = p.clone().sub(center);
        return new THREE.Vector2(v.x * scale, -v.y * scale);
    });
    return new THREE.ShapeGeometry(new THREE.Shape().setFromPoints(transformedPoints));
};

const ICON_GEOMETRIES = {
    heart: createUIHeartGeometry(),
    bookmark: createUIBookmarkGeometry(),
    share: createUIShareIconGeometry(),
    comment: new THREE.ShapeGeometry(new THREE.Shape().setFromPoints([
        new THREE.Vector2(-0.6, 0.4), new THREE.Vector2(0.6, 0.4), new THREE.Vector2(0.6, -0.2),
        new THREE.Vector2(0.1, -0.2), new THREE.Vector2(0, -0.4), new THREE.Vector2(-0.1, -0.2),
        new THREE.Vector2(-0.6, -0.2),
    ]))
};

const ActionOrbit3D = ({ actions }: { actions: StarActionType[] }) => {
    const { camera } = useThree();
    const groupRef = useRef<THREE.Group>(null!);
    useFrame(() => { if (groupRef.current) groupRef.current.quaternion.copy(camera.quaternion); });
    const radius = 0.3;
    const iconScale = 0.085;

    return (
        <group ref={groupRef}>
            {actions.map((action, index) => {
                const angle = (index / actions.length) * Math.PI * 2;
                const iconPosition = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                const geometryKey = action === 'like' ? 'heart' : action;
                const geometry = ICON_GEOMETRIES[geometryKey];
                return (
                    <group key={action}>
                        <Tube renderOrder={0} args={[new THREE.LineCurve3(new THREE.Vector3(0,0,0), iconPosition), 16, 0.002, 8, false]}>
                            <meshBasicMaterial color="white" toneMapped={false} />
                        </Tube>
                        <mesh renderOrder={1} position={iconPosition} geometry={geometry} scale={iconScale}>
                            <meshBasicMaterial color={THEME_CONFIG.dark.reviewColor} toneMapped={false} />
                        </mesh>
                    </group>
                );
            })}
        </group>
    );
};

const UserStarPoints = ({ stars, themeColors, hoveredStar, setHoveredStar, setActiveStar, alwaysShowOrbits }: {
    stars: StarData[], themeColors: typeof THEME_CONFIG.dark, hoveredStar: StarData | null,
    setHoveredStar: (star: StarData | null) => void,
    setActiveStar: (star: StarData, position: ScreenPosition) => void,
    alwaysShowOrbits: boolean
}) => {
    const { camera, gl } = useThree();
    const handleStarClick = useCallback((star: StarData) => {
        const canvasRect = gl.domElement.getBoundingClientRect();
        const vec = new THREE.Vector3().copy(star.position);
        vec.project(camera);
        const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
        const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
        const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
        let finalX = x;
        const cardWidth = 300;
        const padding = 20;
        if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
        if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
        setActiveStar(star, { top: y, left: finalX, placement });
    }, [camera, gl.domElement, setActiveStar]);
    return (
        <group>
            {stars.map(star => {
                const colorKey = `${star.content._type}Color` as keyof typeof themeColors;
                const isHovered = hoveredStar?.id === star.id;
                return (
                    <group key={star.id || star.content._id} position={star.position}>
                        <InteractiveStar star={star} color={themeColors[colorKey]} isHovered={isHovered} onHover={setHoveredStar} onClick={handleStarClick} />
                        {(alwaysShowOrbits || isHovered) && star.actions.length > 0 && (
                            <ActionOrbit3D actions={star.actions} />
                        )}
                    </group>
                );
            })}
        </group>
    );
};

const ConstellationPath = ({ pathPoints, color, thickness }: { pathPoints: THREE.Vector3[], color: string, thickness: number }) => {
    return <Line points={pathPoints} color={color} lineWidth={thickness} />;
};

const HoverContext = ({ hoveredStar, alwaysShowOrbits }: { hoveredStar: StarData, alwaysShowOrbits: boolean }) => {
    return (
        <Html position={hoveredStar.position}>
            <div style={{ position: 'relative', pointerEvents: 'none', transform: 'translate(-50%, -50%)' }}>
                {!alwaysShowOrbits && (
                    <motion.div
                        initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }}
                        transition={{ duration: 0.2, ease: 'easeOut' as const }}
                        style={{
                            position: 'absolute', bottom: '80px', left: '50%', transform: 'translateX(-50%)',
                            background: 'var(--bg-secondary)', color: 'var(--text-primary)', padding: '0.5rem 1rem',
                            borderRadius: '6px', border: '1px solid var(--border-color)', fontSize: '1.4rem',
                            fontFamily: 'var(--font-ui)', whiteSpace: 'nowrap', zIndex: 10000,
                            boxShadow: '0 4px 15px rgba(0,0,0,0.2)'
                        }}
                    >
                        <p style={{ margin: 0, fontWeight: 600 }}>{hoveredStar.content.title}</p>
                        <p style={{ margin: 0, textTransform: 'capitalize', color: 'var(--text-secondary)' }}>{hoveredStar.content._type}</p>
                    </motion.div>
                )}
            </div>
        </Html>
    );
};

function InteractiveLayer({ chronologicalStars, themeColors, setActiveStar, settings, isMobile }: any) {
    const [hoveredStar, setHoveredStar] = useState<StarData | null>(null);
    const { bloomIntensity, alwaysShowOrbits, flawlessPathThickness } = settings;
    const isBloomEnabled = bloomIntensity > 0;

    const controlsRef = useRef<any>(null);
    useFrame(() => {
        if (controlsRef.current) {
            controlsRef.current.autoRotate = !hoveredStar;
            controlsRef.current.update();
        }
    });

    return (
        <>
            <AnimatePresence>{hoveredStar && <HoverContext hoveredStar={hoveredStar} alwaysShowOrbits={alwaysShowOrbits} />}</AnimatePresence>
            {isBloomEnabled ? (
                <Selection>
                    <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={0}>
                        <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
                    </EffectComposer>
                    {chronologicalStars.length > 0 && (
                        <Select enabled>
                            <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                            <ConstellationPath pathPoints={chronologicalStars.map((s: StarData) => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                        </Select>
                    )}
                </Selection>
            ) : (
                chronologicalStars.length > 0 && (
                    <>
                        <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                        <ConstellationPath pathPoints={chronologicalStars.map((s: StarData) => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                    </>
                )
            )}
            <OrbitControls
                ref={controlsRef}
                enableZoom
                autoRotate={true}
                autoRotateSpeed={0.15}
                minDistance={2.5}
                maxDistance={isMobile ? 20 : 15} // MODIFIED: Increased maxDistance for both views
                zoomSpeed={0.5}
            />
        </>
    );
}

interface SceneProps {
    chronologicalStars: StarData[];
    themeColors: typeof THEME_CONFIG.dark;
    setActiveStar: (star: StarData, position: ScreenPosition) => void;
    settings: ConstellationSettings;
    isMobile: boolean;
}

export const Scene = ({ chronologicalStars, themeColors, setActiveStar, settings, isMobile }: SceneProps) => {
    return (
        <Suspense fallback={null}>
            <color attach="background" args={[themeColors.bgColor]} />
            <ambientLight intensity={0.5} />
            <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
            <InteractiveLayer
                chronologicalStars={chronologicalStars}
                themeColors={themeColors}
                setActiveStar={setActiveStar}
                settings={settings}
                isMobile={isMobile}
            />
        </Suspense>
    );
};

--- END OF FILE components/constellation/Scene.tsx ---

================================================================================

--- START OF FILE components/constellation/StarPreviewCard.tsx ---

// components/constellation/StarPreviewCard.tsx

import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { urlFor } from '@/sanity/lib/image';
import { SanityContentObject, StarData, ScreenPosition } from './config';

interface StarPreviewCardProps {
    starData: StarData;
    position: ScreenPosition;
    onClose: () => void;
}

const typeMap: Record<'review' | 'article' | 'news', string> = {
    review: 'مراجعة',
    article: 'مقالة',
    news: 'خبر'
}

export const StarPreviewCard = ({ starData, position, onClose }: StarPreviewCardProps) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "constellation-preview";
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);
    
    const { content } = starData;
    const getLinkPath = (item: SanityContentObject) => {
        switch (item._type) {
            case 'review': return `/reviews/${item.slug}`;
            case 'article': return `/articles/${item.slug}`;
            case 'news': return `/news/${item.slug}`;
            default: return '/';
        }
    };
    
    const imageUrl = content.mainImage?.asset ? urlFor(content.mainImage).width(600).height(338).fit('crop').auto('format').url() : null;
    const blurDataURL = content.mainImage?.blurDataURL;
    const contentType = typeMap[content._type] || 'محتوى';
    const linkPath = getLinkPath(content);
    const formattedDate = content.publishedAt 
        ? new Date(content.publishedAt).toLocaleDateString('ar-EG', { year: 'numeric', month: 'short', day: 'numeric' })
        : '';

    const handleClick = (e: React.MouseEvent) => {
        e.stopPropagation();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
        onClose();
    };

    return (
        <motion.div
            layoutId={`${layoutIdPrefix}-card-container-${content.legacyId}`}
            onClick={handleClick}
            initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }}
            transition={{ type: 'spring', damping: 25, stiffness: 300 }}
            style={{
                position: 'fixed', top: position.top, left: position.left,
                width: isMobile ? '260px' : '300px',
                background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px',
                boxShadow: '0 10px 30px rgba(0,0,0,0.3)', overflow: 'hidden', zIndex: 10001,
                transform: position.placement === 'below'
                ? 'translate(-50%, 0)'
                : 'translate(-50%, calc(-100% - 20px))',
                transformOrigin: position.placement === 'below' ? 'top center' : 'bottom center',
                cursor: 'pointer',
            }}
        >
            <motion.button
                onClick={(e) => { e.stopPropagation(); onClose(); }} 
                whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
                style={{
                    position: 'absolute', top: '10px', right: '10px', zIndex: 2, width: '32px', height: '32px',
                    borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.3)', color: 'white',
                    display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
                }} aria-label="إغلاق"
            >
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </motion.button>

            <motion.div layoutId={`${layoutIdPrefix}-card-image-${content.legacyId}`} style={{ position: 'relative', width: '100%', height: isMobile ? '130px' : '150px' }}>
                {imageUrl ? ( 
                    <Image 
                        src={imageUrl} alt={content.title} fill sizes="300px"
                        style={{ objectFit: 'cover' }} 
                        placeholder={blurDataURL ? 'blur' : 'empty'}
                        blurDataURL={blurDataURL || ''}
                    /> 
                ) : ( <div style={{ width: '100%', height: '100%', backgroundColor: 'var(--border-color)' }} /> )}
            </motion.div>

            <div style={{ padding: isMobile ? '1rem' : '1.5rem', textAlign: 'right' }}>
                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', marginBottom: '0.5rem'}}>
                    <p style={{ textTransform: 'capitalize', color: 'var(--accent)', fontFamily: 'var(--font-main)', fontSize: isMobile ? '1.2rem' : '1.3rem', margin: 0 }}>{contentType}</p>
                    {formattedDate && <p style={{color: 'var(--text-secondary)', fontSize: isMobile ? '1.1rem' : '1.2rem', margin: 0}}>{formattedDate}</p>}
                </div>
                <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${content.legacyId}`} style={{ margin: '0 0 1.2rem 0', fontSize: isMobile ? '1.5rem' : '1.7rem' }}>{content.title}</motion.h3>
                <div className="primary-button no-underline" style={{ display: 'block', textAlign: 'center', pointerEvents: 'none', fontSize: isMobile ? '1.3rem' : 'inherit', padding: isMobile ? '0.6rem 1rem' : '1rem 2.4rem' }}>
                    عرض كامل الـ{contentType}
                </div>
            </div>
        </motion.div>
    );
};

--- END OF FILE components/constellation/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE components/constellation/config.ts ---

import * as THREE from 'three';
// Import the new Sanity types instead of the old mock data types
import type { SanityReview, SanityArticle, SanityNews } from '@/types/sanity';

//  Type Definitions
// Create a new union type for any content object from Sanity
export type SanityContentObject = SanityReview | SanityArticle | SanityNews;

export type StarActionType = 'bookmark' | 'like' | 'comment' | 'share';
export type StarType = 'history' | 'like' | 'comment' | 'share';

export type StarData = {
id: number;
position: THREE.Vector3;
content: SanityContentObject;
// This determines the star's base size based on the most significant action
type: StarType;
// This contains ALL actions taken on the content, used to draw the orbit
actions: StarActionType[];
};

export type Placement = 'above' | 'below';
export type ScreenPosition = {
top: number;
left: number;
placement: Placement;
};

//  Theme-aware Color & Size Mapping
export const THEME_CONFIG = {
dark: {
reviewColor: '#00E5FF', articleColor: '#E1E1E6', newsColor: '#7D808C',
pathColor: '#FFFFFF', bgStarColor: '#FFFFFF', bgColor: '#0A0B0F',
},
light: {
reviewColor: '#0891B2', articleColor: '#1F2937', newsColor: '#6B7280',
pathColor: '#1F2937', bgStarColor: '#1F2937', bgColor: '#F0F2F5',
},
};

const BASE_SIZE = 0.035;
const BOOKMARK_MULTIPLIER = 1.6;

export const SIZES: Record<StarType, number> = {
history: BASE_SIZE,
like: BASE_SIZE * 1.3,
comment: BASE_SIZE * 1.6,
share: BASE_SIZE * 2.0,
};

// A bookmarked star is ALWAYS the largest version of its type
export const getStarSize = (star: StarData) => {
// legacyId is the correct property for the numeric ID
return star.actions.includes('bookmark') ? SIZES['share'] * BOOKMARK_MULTIPLIER : SIZES[star.type];
};
































--- END OF FILE components/constellation/config.ts ---

================================================================================

--- START OF FILE components/constellation/index.tsx ---

// components/constellation/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { useBodyClass } from '@/hooks/useBodyClass';
import * as THREE from 'three';
import { THEME_CONFIG, StarData, SanityContentObject, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from './ConstellationControlPanel';
import { getCommentedContentIds } from '@/app/actions/userActions';
import styles from './ConstellationControlPanel.module.css';

const CelestialGearIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="8"></circle>
        <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
    </svg>
);

type InitialData = {
    userContent: SanityContentObject[];
    commentedSlugs: string[];
    isGuest: boolean;
} | null;

export default function Constellation({ initialData }: { initialData?: InitialData }) {
    const [isHydrated, setIsHydrated] = useState(false);
    useEffect(() => { setIsHydrated(true); }, []);

    const [isFullscreen, setIsFullscreen] = useState(false);
    const [isMobile, setIsMobile] = useState(false);

    useBodyClass('constellation-active'); 
    useBodyClass('fullscreen-active', isFullscreen); 
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);
    
    const { resolvedTheme } = useTheme();
    // Still hook into store, but we might ignore it if initialData is present
    const { bookmarks, likes, shares } = useUserStore();
    
    const [userContent, setUserContent] = useState<SanityContentObject[]>(initialData?.userContent || []);
    const [activeStar, setActiveStar] = useState<StarData | null>(null);
    const [activeStarPosition, setActiveStarPosition] = useState<ScreenPosition | null>(null);
    const [isPanelOpen, setIsPanelOpen] = useState(false);
    const [commentedContentSlugs, setCommentedContentSlugs] = useState<string[]>(initialData?.commentedSlugs || []);

    useBodyClass('editor-active', isPanelOpen);

    // THE FIX: Only fetch client-side if NO initial server data is provided (Guest Mode)
    useEffect(() => {
        if (!isHydrated) return;
        
        // If we have server data, we don't need to fetch anything.
        if (initialData && !initialData.isGuest) {
            return;
        }

        // --- Guest / Fallback Logic ---
        getCommentedContentIds().then(slugs => { setCommentedContentSlugs(slugs); });

        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));
        
        const allIds = [...new Set([...safeBookmarks, ...safeLikes, ...safeShares])];
        
        if (allIds.length === 0) { 
            setUserContent([]); 
            return; 
        }

        const fetchContent = async () => {
            const response = await fetch('/api/content-by-ids', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ ids: allIds }), 
            });
            if (response.ok) { 
                const data = await response.json(); 
                setUserContent(data); 
            } else {
                console.error("Failed to fetch content for Constellation:", response.statusText);
            }
        };
        fetchContent();
    }, [isHydrated, bookmarks, likes, shares, initialData]);

    const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
        'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
        'مُتَّزِن': { activePreset: 'مُتَّزِن', starCountMultiplier: 1.0, bloomIntensity: 0.9, alwaysShowOrbits: false, flawlessPathThickness: 2 },
        'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.5, alwaysShowOrbits: false, flawlessPathThickness: 2.5 },
    }), []);

    const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['مُتَّزِن']);
    const userIntentBloom = useRef(PRESETS['مُتَّزِن'].bloomIntensity);

    useEffect(() => {
        if (resolvedTheme === 'light') {
            if (settings.bloomIntensity > 0) {
                setSettings(s => ({ ...s, bloomIntensity: 0 }));
            }
        } else {
            if (settings.bloomIntensity !== userIntentBloom.current) {
                setSettings(s => ({ ...s, bloomIntensity: userIntentBloom.current }));
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [resolvedTheme]);

    useEffect(() => {
        if (resolvedTheme === 'dark' && settings.activePreset === 'custom') {
            userIntentBloom.current = settings.bloomIntensity;
        }
    }, [settings.bloomIntensity, settings.activePreset, resolvedTheme]);

    const handlePresetChange = (preset: Preset) => {
        let newSettings = { ...PRESETS[preset] };
        userIntentBloom.current = newSettings.bloomIntensity;
        if (resolvedTheme === 'light') {
            newSettings.bloomIntensity = 0;
        }
        setSettings(newSettings);
    };

    const isDark = resolvedTheme === 'dark';
    const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;

    const chronologicalStars = useMemo(() => {
        if (!isHydrated || userContent.length === 0) return [];
        
        // If we have server data, use the IDs from the content itself.
        // Otherwise, fallback to store (though store should match content).
        
        // We need to reconstruct the 'actions' for the stars.
        // If server data is present, we can infer actions if we passed them, 
        // BUT for simplicity, we can still use the client store 'bookmarks/likes' arrays 
        // to determine the *type* of the star, since hydration syncs those quickly.
        // OR we can rely on the fact that if it's in `userContent`, the user engaged with it.
        
        // Let's rely on the Store for the *Action Types* (bookmarks/likes) as that's the source of truth for UI state.
        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));

        const starMap = new Map<number, { type: "history" | "like" | "comment" | "share", actions: ("bookmark" | "like" | "comment" | "share")[], content: SanityContentObject }>();
        
        userContent.filter(content => content.legacyId != null).forEach(content => {
            const id = content.legacyId; 
            let type: "history" | "like" | "comment" | "share" = 'history'; 
            const actions: ("bookmark" | "like" | "comment" | "share")[] = [];

            // Check Store + Server Comment Data
            if (safeLikes.includes(id)) { actions.push('like'); }
            if (safeShares.includes(id)) { actions.push('share'); }
            if (commentedContentSlugs.includes(content.slug)) { actions.push('comment'); }
            if (safeBookmarks.includes(id)) { actions.push('bookmark'); }

            // Fallback: If store hasn't hydrated yet but we have content (server mode), assume simple 'like' or 'history'
            // to ensure stars appear immediately.
            if (initialData && !initialData.isGuest && actions.length === 0) {
                // If it's in userContent but not in store yet, it's likely a like or bookmark.
                // We can default to 'like' visually until store hydrates fully.
                actions.push('like');
            }

            if (actions.includes('like')) type = 'like';
            if (actions.includes('comment')) type = 'comment'; 
            if (actions.includes('share')) type = 'share';
            
            starMap.set(id, { type, actions: actions.sort(), content });
        });
        
        const allUserStars: StarData[] = [];
        starMap.forEach((data, id) => {
            const u=Math.random(), v=Math.random(), theta=2*Math.PI*u, phi=Math.acos(2*v-1);
            const r = 1.8 + Math.random() * 0.6;
            const position = new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            allUserStars.push({ id, position, content: data.content, type: data.type, actions: data.actions });
        });
        
        const sortedStars = allUserStars.sort((a, b) => 
            new Date(a.content.publishedAt).getTime() - new Date(b.content.publishedAt).getTime()
        );

        if (sortedStars.length > 1) {
            const curve = new THREE.CatmullRomCurve3( sortedStars.map(s => s.position) );
            const points = curve.getPoints(sortedStars.length - 1);
            return sortedStars.map((star, i) => ({ ...star, position: points[i] }));
        }
        return sortedStars;
    }, [isHydrated, userContent, bookmarks, likes, shares, commentedContentSlugs, initialData]);

    const handleSetActiveStar = useCallback((star: StarData, position: ScreenPosition) => {
        if (isMobile) {
            setActiveStar(star);
            setActiveStarPosition({ top: 110, left: window.innerWidth / 2, placement: 'below' });
        } else {
            setActiveStar(star);
            setActiveStarPosition(position);
        }
    }, [isMobile]);
    const handleClosePreview = useCallback(() => { setActiveStar(null); setActiveStarPosition(null); }, []);

    if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

    return (
        <>
            <AnimatePresence>
                {activeStar && activeStarPosition && ( <motion.div style={{ position: 'fixed', inset: 0, zIndex: 10000 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}> <StarPreviewCard starData={activeStar} position={activeStarPosition} onClose={handleClosePreview} /> </motion.div> )}
                {isPanelOpen && <ConstellationControlPanel settings={settings} setSettings={setSettings} onClose={() => setIsPanelOpen(false)} onPresetChange={handlePresetChange} isFullscreen={isFullscreen} onToggleFullscreen={() => setIsFullscreen(!isFullscreen)} />}
            </AnimatePresence>
            <div style={{ position: 'relative', width: '100%', height: 'calc(100vh - var(--nav-height-scrolled))' }}>
                <motion.button className={styles.settingsButton} onClick={() => setIsPanelOpen(true)} title="فتح إعدادات الكوكبة" whileHover={{ scale: 1.1, rotate: 90 }} transition={{ type: 'spring', stiffness: 500, damping: 20 }} whileTap={{ scale: 0.9 }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.5 } }}>
                    <CelestialGearIcon />
                </motion.button>
                <Canvas camera={{ position: [0, 0, isMobile ? 10 : 7], fov: 60 }}>
                    <Scene 
                        settings={settings} 
                        chronologicalStars={chronologicalStars} 
                        themeColors={themeColors} 
                        setActiveStar={handleSetActiveStar} 
                        isMobile={isMobile}
                    />
                </Canvas>
                {chronologicalStars.length === 0 && ( <div style={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', textAlign: 'center', pointerEvents: 'none', padding: '2rem' }}> <motion.h1 className="page-title" style={{ fontSize: '6rem' }} initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.2, ease: 'easeOut' }}> كوكبتك في انتظارك </motion.h1> <motion.p style={{ maxWidth: '600px', fontSize: '2rem', color: 'var(--text-secondary)' }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.4, ease: 'easeOut' }}> بينما تستكشف وتعجب وتشارك، ستبدأ خريطتك النجمية الشخصية في التكون هنا. </motion.p> </div> )}
            </div>
        </>
    );
}

--- END OF FILE components/constellation/index.tsx ---

================================================================================

--- START OF FILE components/content/ContentPage.module.css ---

/* components/content/ContentPage.module.css */

.contentLayout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
}
@media (min-width: 1024px) {
  .contentLayout {
    grid-template-columns: 2fr 1fr;
  }
  .contentLayout > main {
    min-width: 0;
  }
}

.heroImage {
    position: relative;
    width: 100%;
    aspect-ratio: 5 / 1;
    height: auto;
    margin-bottom: 3rem;
    border-radius: 12px;
    overflow: hidden;
}

.sidebar {
    margin-top: 3rem;
}

.relatedGrid {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

/* --- Header Layout --- */
.titleWrapper {
    margin-bottom: 1.5rem;
    min-width: 0;
}

.metaContainer {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    margin-bottom: 3rem;
    gap: 1.5rem;
    flex-direction: row-reverse; /* This places metaBlockLeft on the left and metaBlockRight on the right in RTL */
}

.metaBlockLeft {
    display: flex;
    flex-direction: column;
    align-items: center; /* MODIFIED: Aligns items to the left */
    gap: 1rem;
}

.metaBlockRight {
    display: flex;
    flex-direction: column;
    align-items: right; /* MODIFIED: Aligns items to the right */
    gap: 1rem;
    font-size: 1.5rem;
    text-align: right;
}

.dateContainer {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    justify-content: flex-end;
}

.metadataIcon {
    width: 16px;
    height: 16px;
    color: var(--accent);
    flex-shrink: 0;
}

.dateText {
    font-size: 1.4rem;
    color: var(--text-secondary);
    margin: 0;
}


@media (max-width: 768px) {
    .heroImage {
        aspect-ratio: 3 / 1;
        margin-bottom: 2rem;
    }
    .titleWrapper {
        margin-bottom: 2rem;
    }

    /* THE DEFINITIVE FIX FOR MOBILE LAYOUT */
    .metaContainer {
        flex-direction: row-reverse; /* Maintain two-column layout */
        align-items: flex-end;      /* Align columns at the bottom */
        gap: 1rem;                  /* Reduce gap for smaller screens */
    }

    .metaBlockLeft {
      align-items: center; /* Keep items left-aligned */
    }

    .metaBlockRight {
      align-items: right;   /* Keep items right-aligned */
    }
}

--- END OF FILE components/content/ContentPage.module.css ---

================================================================================

--- START OF FILE components/content/ContentPageClient.tsx ---

// components/content/ContentPageClient.tsx
'use client';

import { useEffect, useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { adaptToCardProps } from '@/lib/adapters';
import { sanityLoader } from '@/lib/sanity.loader';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';

import type { SanityReview, SanityArticle, SanityNews } from '@/types/sanity';
import PortableTextComponent from '@/components/PortableTextComponent';
import ScoreBox from '@/components/ScoreBox';
import ArticleCard from '@/components/ArticleCard';
import GameLink from '@/components/GameLink';
import ContentActionBar from '@/components/ContentActionBar';
import TagLinks from '@/components/TagLinks';
import ReadingHud from '@/components/ReadingHud';
import { ContentBlock } from '@/components/ContentBlock';
import { SparklesIcon, Calendar03Icon } from '@/components/icons/index';
import CreatorCredit from '@/components/CreatorCredit';
import styles from './ContentPage.module.css';
import { CardProps } from '@/types';
import { translateTag } from '@/lib/translations';

type Slug = { current: string } | string;

type ContentItem = Omit<SanityReview | SanityArticle | SanityNews, 'slug'> & { 
    slug: Slug; 
    relatedContent?: any[] 
};

type ContentType = 'reviews' | 'articles' | 'news';

export type Heading = { id: string; title: string; top: number; level: number }; 

type ColorMapping = {
  word: string;
  color: string;
}

const contentVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { delay: 0.4, duration: 0.5 } } };
const adaptReviewForScoreBox = (review: any) => ({ score: review.score, verdict: review.verdict, pros: review.pros, cons: review.cons });

export default function ContentPageClient({ item, type, children, colorDictionary }: {
    item: ContentItem;
    type: ContentType;
    children: React.ReactNode;
    colorDictionary: ColorMapping[];
}) {
    const { prefix: layoutIdPrefix, setPrefix } = useLayoutIdStore();
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const [headings, setHeadings] = useState<Heading[]>([]);
    const [isMobile, setIsMobile] = useState(false);
    
    const articleBodyRef = useRef<HTMLDivElement>(null); 
    const scrollTrackerRef = useRef<HTMLDivElement>(null); 
    const [isLayoutStable, setIsLayoutStable] = useState(false); 
    
    const isReview = type === 'reviews';
    const isNews = type === 'news';
    
    const slugString = typeof item.slug === 'string' ? item.slug : item.slug?.current || '';
    
    const measureHeadings = useCallback(() => {
        const contentElement = articleBodyRef.current;
        const trackerElement = scrollTrackerRef.current;
        if (!contentElement || !trackerElement) return;

        const navbarOffset = 90;
        const documentScrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        const seenIds = new Set<string>();
        
        let newHeadings: Heading[] = [];

        const headingElements = Array.from(contentElement.querySelectorAll('h1'));
        headingElements.forEach((h, index) => {
            let id = h.id;
            if (!id || seenIds.has(id)) { 
                id = `${h.textContent?.trim().slice(0, 20).replace(/\s+/g, '-') || 'heading'}-${index}`;
            }
            seenIds.add(id);
            h.id = id;
            
            const topPosition = h.getBoundingClientRect().top + documentScrollTop;
            const scrollToPosition = topPosition - navbarOffset;
            
            newHeadings.push({ id: id, title: h.textContent || '', top: Math.max(0, scrollToPosition), level: 1 });
        });

        if (isReview) {
             const scoreBoxElement = contentElement.querySelector('.score-box-container');
             if (scoreBoxElement) {
                 const topPosition = scoreBoxElement.getBoundingClientRect().top + documentScrollTop;
                 const scoreBoxScrollPosition = topPosition - navbarOffset;
                 
                 newHeadings.push({ 
                     id: 'verdict-summary', 
                     title: 'الخلاصة', 
                     top: Math.max(0, scoreBoxScrollPosition),
                     level: 1 
                 });
             }
        }
        
        if (newHeadings.length > 0) {
            setHeadings(newHeadings);
        }

    }, [isReview]);

    useEffect(() => {
        return () => {
            setPrefix('default');
        };
    }, [setPrefix]);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        const handleResize = () => {
            checkMobile();
            if (isLayoutStable) measureHeadings();
        }
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [isLayoutStable, measureHeadings]); 

    useEffect(() => { window.scrollTo(0, 0); }, []);

    useEffect(() => {
        const timeout = setTimeout(() => setIsLayoutStable(true), 1500); 
        return () => clearTimeout(timeout);
    }, [item]);

    useEffect(() => {
        if (isLayoutStable) {
            requestAnimationFrame(() => {
                measureHeadings();
            });
        }
    }, [isLayoutStable, measureHeadings]); 

    if (!item) return null;

    const relatedContent = (item as any).relatedReviews || (item as any).relatedArticles || (item as any).relatedNews || [];
    const uniqueRelatedContent = relatedContent ? Array.from(new Map(relatedContent.map((related: any) => [related._id, related])).values()) : [];
    
    // THE FIX: Wrap in arrow function and apply width optimization
    const adaptedRelatedContent = (uniqueRelatedContent || [])
        .map((related: any) => adaptToCardProps(related, { width: 600 }))
        .filter(Boolean) as CardProps[];

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const publishedDate = new Date(item.publishedAt as string);
    const day = publishedDate.getDate();
    const year = publishedDate.getFullYear();
    const monthIndex = publishedDate.getMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

    const primaryCreators = (item as any).authors || (item as any).reporters || [];
    const contentTypeForActionBar = type.slice(0, -1) as 'review' | 'article' | 'news';
    
    const heroImageUrl = urlFor(item.mainImage).width(2000).height(400).fit('crop').auto('format').url();
    const fullResImageUrl = urlFor(item.mainImage).auto('format').url();
    
    const springTransition = { type: 'spring' as const, stiffness: 200, damping: 35 };

    return (
        <>
            <ReadingHud 
                contentContainerRef={scrollTrackerRef}
                headings={headings} 
                isMobile={isMobile} 
            />

            <motion.div
                layoutId={`${layoutIdPrefix}-card-container-${item.legacyId}`}
                transition={springTransition}
                style={{ backgroundColor: 'var(--bg-primary)' }}
            >
                <motion.div 
                    layoutId={`${layoutIdPrefix}-card-image-${item.legacyId}`} 
                    className={`${styles.heroImage} image-lightbox-trigger`}
                    transition={springTransition}
                    onClick={() => openLightbox([fullResImageUrl], 0)}
                >
                    <Image 
                        loader={sanityLoader} 
                        src={heroImageUrl} 
                        alt={item.title} 
                        fill 
                        sizes="100vw"
                        style={{ objectFit: 'cover' }} 
                        priority
                        placeholder="blur" 
                        blurDataURL={(item.mainImage as any).blurDataURL} 
                    />
                </motion.div>

                <div className="container page-container" style={{ paddingTop: '0' }}>
                    <motion.div initial="hidden" animate="visible" variants={contentVariants} >
                        <div className={styles.contentLayout}>
                            <main ref={scrollTrackerRef}>
                                <div className={styles.titleWrapper}>
                                    {isNews && <p className="news-card-category" style={{ textAlign: 'right', margin: '0 0 1rem 0' }}>{translateTag((item as any).category?.title)}</p>}
                                    <motion.h1 layoutId={`${layoutIdPrefix}-card-title-${item.legacyId}`} className="page-title" style={{ textAlign: 'right', margin: 0 }} transition={springTransition}>{item.title}</motion.h1>
                                </div>
                                
                                <div className={styles.metaContainer}>
                                    <div className={styles.metaBlockLeft}>
                                        {(item as any).game?.title && <GameLink gameName={(item as any).game.title} gameSlug={(item as any).game.slug} />}
                                        <ContentActionBar contentId={item.legacyId} contentType={contentTypeForActionBar} contentSlug={slugString} />
                                    </div>
                                    <div className={styles.metaBlockRight}>
                                        <CreatorCredit label="بقلم" creators={primaryCreators} />
                                        <CreatorCredit label="تصميم" creators={item.designers} />
                                        <div className={styles.dateContainer}>
                                            <Calendar03Icon className={styles.metadataIcon} />
                                            <p className={styles.dateText}>نُشر في {formattedDate}</p>
                                        </div>
                                    </div>
                                </div>

                                <div ref={articleBodyRef} className="article-body">
                                    <PortableTextComponent content={item.content || []} colorDictionary={colorDictionary} />
                                    {isReview && <ScoreBox review={adaptReviewForScoreBox(item)} className="score-box-container" />}
                                </div>
                                <div style={{ marginTop: '4rem', paddingTop: '2rem', borderTop: '1px solid var(--border-color)' }}>
                                    <TagLinks tags={(item.tags || []).map((t: any) => t.title)} />
                                </div>
                            </main>
                            <aside className={styles.sidebar}>
                                <ContentBlock title="قد يروق لك" Icon={SparklesIcon}>
                                    <motion.div 
                                        className={styles.relatedGrid}
                                        variants={{ visible: { transition: { staggerChildren: 0.1 } } }}
                                        initial="hidden"
                                        animate="visible"
                                        exit="hidden"
                                    >
                                        {adaptedRelatedContent.map(related => (
                                            <motion.div key={related.id} variants={{ hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0 } }}>
                                                <ArticleCard article={related} layoutIdPrefix={`related-${type}`} />
                                            </motion.div>
                                        ))}
                                    </motion.div>
                                </ContentBlock>
                            </aside>
                        </div>
                    </motion.div>
                </div>
            </motion.div>
            
            <motion.div initial="hidden" animate="visible" variants={contentVariants} className="container" style={{ paddingBottom: '6rem' }}>
                <ContentBlock title="حديث المجتمع">{children}</ContentBlock>
            </motion.div>
        </>
    );
}

--- END OF FILE components/content/ContentPageClient.tsx ---

================================================================================

--- START OF FILE components/content/GameDetails.module.css ---

/* components/content/GameDetails.module.css */
.detailsContainer {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
  margin: 4rem 0;
}

[data-theme='dark'] .detailsContainer {
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 10%, transparent);
}

.detailRow {
  display: grid;
  grid-template-columns: 2fr 1fr;
  align-items: center;
  position: relative;
}

/* THE DEFINITIVE FIX: Central Divider Line */
.detailRow::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  /* Position the line at the end of the first grid column (2fr / 3fr total = 66.66%) */
  right: calc(100% / 3);
  left: auto;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

.detailRow:not(:last-child) {
  border-bottom: 1px solid var(--border-color);
}

.detailLabel {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-weight: 700;
  font-size: 1.6rem;
  color: var(--accent);
  text-align: right;
  position: relative;
}

/* This is the new rule for the TableComponent header cell's divider */
.detailLabel_before_override::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  left: 0;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

.detailValue {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  text-align: right; /* Default to RTL alignment */
}

/* Enforce LTR text alignment when dir="ltr" is set */
.detailValue[dir='ltr'] {
  text-align: left;
}

@media (max-width: 768px) {
  .detailRow {
    grid-template-columns: 1.5fr 1fr;
  }
  /* THE DEFINITIVE FIX: Adjust divider for mobile grid */
  .detailRow::before {
    right: calc(100% / 2.5); /* 1fr / 2.5fr total */
  }
  .detailLabel,
  .detailValue {
    padding: 1.2rem 1.5rem;
    font-size: 1.5rem;
  }
}

--- END OF FILE components/content/GameDetails.module.css ---

================================================================================

--- START OF FILE components/content/GameDetails.tsx ---

// components/content/GameDetails.tsx
'use client';

import React, { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import styles from './GameDetails.module.css';

type Detail = {
  label: string;
  value: string;
};

interface GameDetailsProps {
  details: Detail[];
}

const isRTL = (s: string) => {
  const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
  return rtlChars.test(s);
};

// Animation Variants for Game Details
const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.12, // Stagger each row
            delayChildren: 0.2,
        },
    },
};

const rowVariants = {
    hidden: { opacity: 0, x: -30 }, // Slide in from the left
    visible: {
        opacity: 1,
        x: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX: Explicitly cast the type
            stiffness: 200,
            damping: 25,
        },
    },
};

export default function GameDetails({ details }: GameDetailsProps) {
    const containerRef = useRef(null);
    const isInView = useInView(containerRef, { once: true, amount: 0.4 });

    if (!details || details.length === 0) {
        return null;
    }

    return (
        <motion.div
            ref={containerRef}
            className={styles.detailsContainer}
            variants={containerVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            {details.map((detail, index) => (
                <motion.div key={index} className={styles.detailRow} variants={rowVariants}>
                    <span className={styles.detailLabel}>{detail.label}</span>
                    <span
                        className={styles.detailValue}
                        dir={isRTL(detail.value) ? 'rtl' : 'ltr'}
                    >
                        {detail.value}
                    </span>
                </motion.div>
            ))}
        </motion.div>
    );
}

--- END OF FILE components/content/GameDetails.tsx ---

================================================================================

--- START OF FILE components/content/YoutubeEmbed.tsx ---

// components/content/YoutubeEmbed.tsx
'use client'

import React from 'react'

const getYouTubeId = (url: string): string | null => {
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
  const match = url.match(regExp)
  return match && match[2].length === 11 ? match[2] : null
}

export default function YoutubeEmbed({value}: {value: {url: string}}) {
  const {url} = value
  if (!url) {
    return null
  }
  const id = getYouTubeId(url)
  if (!id) {
    return (
      <div style={{margin: '2rem 0', color: '#DC2626'}}>
        Invalid YouTube URL provided.
      </div>
    )
  }

  return (
    <div
      style={{
        position: 'relative',
        paddingBottom: '56.25%', // 16:9 aspect ratio
        height: 0,
        overflow: 'hidden',
        maxWidth: '100%',
        background: '#000',
        margin: '4rem 0',
        borderRadius: '12px',
        border: '1px solid var(--border-color)',
      }}
    >
      <iframe
        src={`https://www.youtube.com/embed/${id}`}
        title="YouTube video player"
        frameBorder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowFullScreen
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          borderRadius: '12px',
        }}
      />
    </div>
  )
}

--- END OF FILE components/content/YoutubeEmbed.tsx ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.module.css ---

/* components/custom/FourImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}




--- END OF FILE components/custom/FourImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.tsx ---

// components/custom/FourImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import styles from './FourImageGrid.module.css';

export default function FourImageGrid({ value }: { value: any }) {
    const { image1, image2, image3, image4 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2, image3, image4].filter(img => img?.asset);
    if (images.length === 0) return null;
    
    const imageUrls = images.map(img => urlFor(img.asset).auto('format').url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={() => openLightbox(imageUrls, index)}
                >
                    <Image
                        src={urlFor(image.asset).width(800).auto('format').url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}




--- END OF FILE components/custom/FourImageGrid.tsx ---

================================================================================

--- START OF FILE components/custom/SanityTable.module.css ---

/* components/custom/SanityTable.module.css */

.tableContainer {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
  margin: 4rem 0;
}

[data-theme='dark'] .tableContainer {
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 10%, transparent);
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th,
.table td {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  text-align: right;
  vertical-align: middle;
  position: relative;
}

.table th {
  font-weight: 700;
  color: var(--accent);
}

.table thead { 
  position: relative;
}

.table thead tr {
  border-bottom: 1px solid var(--border-color);
}

/* THE DEFINITIVE FIX: Full-width horizontal separator */
.table thead::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* Changed from 5% */
  right: 0; /* Changed from 5% */
  height: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
  opacity: 0.8;
}


.table tbody tr:not(:last-child) {
  border-bottom: 1px solid var(--border-color);
}

/* Glowing dividers ONLY for header cells */
.table th:not(:first-child)::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  right: -1px;
  left: auto;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

/* Non-glowing dividers for body cells */
.table td:not(:first-child)::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  right: -1px;
  left: auto;
  width: 1px; /* Thinner line */
  background-color: var(--border-color); /* Standard border color */
  box-shadow: none; /* No glow */
}

@media (max-width: 768px) {
    .tableContainer {
        overflow-x: auto;
    }
    .table {
        min-width: 600px;
    }
    .table th,
    .table td {
        padding: 1.2rem 1.5rem;
        font-size: 1.5rem;
    }
}

--- END OF FILE components/custom/SanityTable.module.css ---

================================================================================

--- START OF FILE components/custom/SanityTable.tsx ---

// components/custom/SanityTable.tsx
'use client';

import { PortableText } from '@portabletext/react';
import { motion, useInView } from 'framer-motion';
import { useRef } from 'react';
import styles from './SanityTable.module.css';

const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.15,
        },
    },
};

const headerVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 150,
            damping: 25,
            staggerChildren: 0.1,
        },
    },
};

const bodyVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.12,
        },
    },
};

const rowVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 200,
            damping: 30,
            staggerChildren: 0.07,
        },
    },
};

const cellVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
        opacity: 1,
        scale: 1,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 250,
            damping: 20,
        },
    },
};

const CellContent = ({ content }: { content: any[] }) => {
    return (
        <motion.div variants={cellVariants}>
            <PortableText value={content} />
        </motion.div>
    );
};

export default function SanityTable({ value }: { value: any }) {
    const tableRef = useRef(null);
    const isInView = useInView(tableRef, { once: true, amount: 0.3 });

    if (!value || !value.rows || value.rows.length === 0) {
        return null;
    }

    const hasHeaderRow = value.rows[0]?.cells.every((cell: any) => cell.isHeader);
    const bodyRows = hasHeaderRow ? value.rows.slice(1) : value.rows;

    return (
        <motion.div
            ref={tableRef}
            className={styles.tableContainer}
            variants={containerVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            <table className={styles.table}>
                {hasHeaderRow && (
                    <motion.thead variants={headerVariants}>
                        <tr>
                            {value.rows[0].cells.map((cell: any) => (
                                <th key={cell._key}>
                                    <CellContent content={cell.content} />
                                </th>
                            ))}
                        </tr>
                    </motion.thead>
                )}
                <motion.tbody variants={bodyVariants}>
                    {bodyRows.map((row: any) => (
                        <motion.tr key={row._key} variants={rowVariants}>
                            {row.cells.map((cell: any) => (
                                <td key={cell._key}>
                                    <CellContent content={cell.content} />
                                </td>
                            ))}
                        </motion.tr>
                    ))}
                </motion.tbody>
            </table>
        </motion.div>
    );
}

--- END OF FILE components/custom/SanityTable.tsx ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.module.css ---

/* components/custom/TwoImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}




--- END OF FILE components/custom/TwoImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.tsx ---

// components/custom/TwoImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import styles from './TwoImageGrid.module.css';

export default function TwoImageGrid({ value }: { value: any }) {
    const { image1, image2 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2].filter(img => img?.asset);
    if (images.length === 0) return null;

    const imageUrls = images.map(img => urlFor(img.asset).auto('format').url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div 
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={() => openLightbox(imageUrls, index)}
                >
                    <Image
                        src={urlFor(image.asset).width(800).auto('format').url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}




--- END OF FILE components/custom/TwoImageGrid.tsx ---

================================================================================

--- START OF FILE components/effects/KineticGlyphs.module.css ---

/* components/effects/KineticGlyphs.module.css */
.glyphContainer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
}

.glyphSvg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    overflow: visible;
}

.glyphPath {
    stroke: var(--accent);
    stroke-width: 1;
    fill: none;
}




--- END OF FILE components/effects/KineticGlyphs.module.css ---

================================================================================

--- START OF FILE components/effects/KineticGlyphs.tsx ---

// components/effects/KineticGlyphs.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './KineticGlyphs.module.css';

const pathVariants = {
    hidden: { pathLength: 0, pathOffset: 1 },
    visible: { 
        pathLength: 1, 
        pathOffset: 0,
        transition: { duration: 0.6, ease: 'easeInOut' as const }
    },
    exit: { 
        pathLength: 0, 
        pathOffset: -1,
        transition: { duration: 0.3, ease: 'easeInOut' as const }
    }
};

export default function KineticGlyphs() {
    return (
        <div className={styles.glyphContainer}>
            <motion.svg className={styles.glyphSvg} viewBox="0 0 100 100" preserveAspectRatio="none">
                <motion.path
                    className={styles.glyphPath}
                    // --- THE DEFINITIVE FIX ---
                    // The radius of the arc commands has been reduced from 4 to 3.
                    // This ensures the path's corners are smaller than the container's
                    // CSS border-radius, preventing them from being clipped by overflow:hidden.
                    d="M 3.5,0.5 H 96.5 A 3,3 0 0 1 99.5,3.5 V 96.5 A 3,3 0 0 1 96.5,99.5 H 3.5 A 3,3 0 0 1 0.5,96.5 V 3.5 A 3,3 0 0 1 3.5,0.5 Z"
                    variants={pathVariants}
                    initial="hidden"
                    animate="visible"
                    exit="exit"
                />
            </motion.svg>
        </div>
    );
}




--- END OF FILE components/effects/KineticGlyphs.tsx ---

================================================================================

--- START OF FILE components/effects/KineticGrid.module.css ---



--- END OF FILE components/effects/KineticGrid.module.css ---

================================================================================

--- START OF FILE components/effects/KineticGrid.tsx ---

// components/effects/KineticGrid.tsx
'use client';

import React, { useRef, createContext, useContext } from 'react';
import { motion, useMotionValue, useSpring, useTransform } from 'framer-motion';
import styles from './KineticGrid.module.css';

// Create a context to pass motion values down to child cards
const KineticGridContext = createContext<{
    mouseX: any;
    mouseY: any;
} | null>(null);

export const useKineticGrid = () => {
    const context = useContext(KineticGridContext);
    if (!context) {
        throw new Error('useKineticGrid must be used within a KineticGrid provider');
    }
    return context;
};

const gridContainerVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.08,
    },
  },
};

export const KineticGrid = ({ children }: { children: React.ReactNode }) => {
    const gridRef = useRef<HTMLDivElement>(null);

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);

    const springConfig = { stiffness: 150, damping: 20, mass: 0.5 };
    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);

    const rotateX = useTransform(smoothMouseY, [0, 1], ['12deg', '-12deg']);
    const rotateY = useTransform(smoothMouseX, [0, 1], ['-12deg', '12deg']);
    const scale = useSpring(1, springConfig);

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        if (!gridRef.current) return;
        const { left, top, width, height } = gridRef.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const handleMouseEnter = () => {
        scale.set(1.02);
    };

    const handleMouseLeave = () => {
        mouseX.set(0.5);
        mouseY.set(0.5);
        scale.set(1);
    };

    return (
        <KineticGridContext.Provider value={{ mouseX, mouseY }}>
            <motion.div
                ref={gridRef}
                className={styles.perspectiveContainer}
                onMouseMove={handleMouseMove}
                onMouseEnter={handleMouseEnter}
                onMouseLeave={handleMouseLeave}
                style={{
                    rotateX,
                    rotateY,
                    scale
                }}
                variants={gridContainerVariants}
                initial="hidden"
                animate="visible"
            >
                <div className="content-grid">
                    {children}
                </div>
            </motion.div>
        </KineticGridContext.Provider>
    );
};

--- END OF FILE components/effects/KineticGrid.tsx ---

================================================================================

--- START OF FILE components/effects/KineticUnveilCard.module.css ---



--- END OF FILE components/effects/KineticUnveilCard.module.css ---

================================================================================

--- START OF FILE components/effects/KineticUnveilCard.tsx ---



--- END OF FILE components/effects/KineticUnveilCard.tsx ---

================================================================================

--- START OF FILE components/filters/ArticleFilters.tsx ---

// components/filters/ArticleFilters.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import { translateTag } from '@/lib/translations';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';

export default function ArticleFilters({ 
    sortOrder, onSortChange, searchTerm, onSearchChange, 
    allGames, selectedGame, onGameSelect, 
    allGameTags, selectedGameTags, onGameTagToggle,
    allArticleTypeTags, selectedArticleType, onArticleTypeSelect,
    onClearAllFilters 
}: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const hasActiveFilters = !!selectedGame || selectedGameTags.length > 0 || !!selectedArticleType || searchTerm;

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في المقالات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
            <FilterGroup label="الفرز حسب:">
                {[{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر رواجًا', value: 'viral' }].map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${sortOrder === option.value ? styles.active : ''}`}>
                        {option.label}
                        {sortOrder === option.value && <motion.div layoutId="article-sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="نوع المقال:">
                <motion.button onClick={() => onArticleTypeSelect(null)} className={`${styles.filterButton} ${!selectedArticleType ? styles.active : ''}`}>
                    الكل
                    {!selectedArticleType && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                </motion.button>
                {allArticleTypeTags.map((tag: any) => (
                    <motion.button key={tag._id} onClick={() => onArticleTypeSelect(tag)} className={`${styles.filterButton} ${selectedArticleType?._id === tag._id ? styles.active : ''}`}>
                        {translateTag(tag.title)}
                        {selectedArticleType?._id === tag._id && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="التصفية بـ:">
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedGameTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allGameTags} selectedTags={selectedGameTags} onTagToggle={(tag) => { onGameTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAllFilters} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
             <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {[{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر رواجًا', value: 'viral' }].map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${sortOrder === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {sortOrder === option.value && <motion.div layoutId="article-sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="النوع:">
                             <motion.button onClick={() => onArticleTypeSelect(null)} className={`${styles.filterButton} ${!selectedArticleType ? styles.active : ''}`}>
                                الكل
                                {!selectedArticleType && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                            </motion.button>
                            {allArticleTypeTags.map((tag: any) => (
                                <motion.button key={tag._id} onClick={() => onArticleTypeSelect(tag)} className={`${styles.filterButton} ${selectedArticleType?._id === tag._id ? styles.active : ''}`}>
                                    {translateTag(tag.title)}
                                    {selectedArticleType?._id === tag._id && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="تصفية:">
                             <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedGameTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allGameTags} selectedTags={selectedGameTags} onTagToggle={(tag) => { onGameTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAllFilters}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}

--- END OF FILE components/filters/ArticleFilters.tsx ---

================================================================================

--- START OF FILE components/filters/Filters.module.css ---

/* components/filters/Filters.module.css */

/* --- Main Filter Container --- */
.filtersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  position: relative;
  z-index: 2;
}

.desktopFilters {
  display: flex;
  flex-direction: column;
  gap: 1.8rem; /* Reduced vertical gap between filter groups on desktop */
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-main);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
  margin-left: 1.5rem; /* RTL spacing */
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

/* --- THE DEFINITIVE, CENTRALIZED FILTER BUTTON STYLES --- */
.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative;
  overflow: hidden;
}
.filterButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.filterButton.active {
  color: var(--bg-secondary);
  background-color: var(--accent);
  border-color: var(--accent);
}

.filterButton.clear {
  color: var(--text-secondary);
  border-color: var(--border-color);
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.filterButton.clear:hover {
  background-color: var(--border-color);
  color: var(--text-primary);
}

.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

/* --- Search Input (used in both filter bars) --- */
.searchInput {
  flex-grow: 1;
  min-width: 250px;
  padding: 1rem 1.5rem;
  font-size: 1.6rem;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  text-align: right; /* RTL */
}
.searchInput:focus {
  outline: none;
  border-color: var(--accent);
}

/* --- Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0; /* RTL */
  left: auto;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverBackdrop {
    position: fixed;
    inset: 0;
    z-index: 5;
    background: transparent;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
  text-align: right; /* RTL */
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
  text-align: right; /* RTL */
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: right; /* RTL */
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-main);
  transition: background-color 0.1s ease-out;
}
.popoverItemButton:hover {
  background-color: var(--bg-primary);
}
.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

/* --- Selected Game Button --- */
.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem; /* RTL */
  margin-left: 0;
  flex-shrink: 0;
  cursor: pointer;
  color: currentColor; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
  z-index: 2;
}
.gameClearButton:hover {
  opacity: 1;
}
.gameSelectedButton.active {
  background-color: transparent;
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}

.mobileTriggerBar {
    display: none;
}

.collapsibleFilterContent {
    transform-origin: top;
    display: flex;
    flex-direction: column;
    gap: 2rem;
    padding-top: 2rem;
}

@media (max-width: 768px) {
  .desktopFilters {
    display: none;
  }
  .filtersContainer {
    padding: 1.5rem;
    gap: 1.5rem;
  }
  .mobileTriggerBar {
    display: flex;
    gap: 1rem;
    align-items: center;
  }
  .filterGroup {
    flex-direction: row;
    align-items: center;
    gap: 1rem;
  }
  .filterLabel {
    margin-left: 0;
    margin-right: 1rem; /* RTL */
  }
  .filterPopover {
    right: auto;
    left: 0;
  }
}

--- END OF FILE components/filters/Filters.module.css ---

================================================================================

--- START OF FILE components/filters/GameFilterPopover.tsx ---

// components/filters/GameFilterPopover.tsx
'use client';
import { useState, useMemo } from 'react';
import { motion } from 'framer-motion';
import type { SanityGame } from '@/types/sanity';
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: 10 }, visible: { opacity: 1, x: 0 } };

export default function GameFilterPopover({ allGames, selectedGame, onGameSelect, onClose }: { allGames: SanityGame[], selectedGame: SanityGame | null, onGameSelect: (game: SanityGame | null) => void, onClose: () => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  
  const results = useMemo(() => {
    if (searchTerm.trim() === '') {
        return allGames;
    }
    return allGames.filter(game => 
        game.title.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, allGames]);


  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="ابحث عن لعبة..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {results.map((game, index) => (
          <motion.button 
            key={game._id} 
            variants={itemVariants}
            initial={index < 10 ? "hidden" : "visible"} // <-- THE FIX IS HERE
            animate="visible" // Ensure all items are driven to the 'visible' state
            className={`${styles.popoverItemButton} ${selectedGame?._id === game._id ? styles.selected : ''}`} 
            onClick={() => { onGameSelect(game); onClose(); }}
          >
            {game.title}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}

--- END OF FILE components/filters/GameFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/NewsFilters.tsx ---

// components/filters/NewsFilters.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';
import type { SanityGame, SanityTag } from '@/types/sanity';

interface NewsFiltersProps {
    activeSort: 'latest' | 'viral';
    onSortChange: (sort: 'latest' | 'viral') => void;
    searchTerm: string;
    onSearchChange: (term: string) => void;
    allGames: SanityGame[];
    selectedGame: SanityGame | null;
    onGameSelect: (game: SanityGame | null) => void;
    allTags: SanityTag[];
    selectedTags: SanityTag[];
    onTagToggle: (tag: SanityTag) => void;
    onClearAll: () => void;
}

export default function NewsFilters({
    activeSort, onSortChange,
    searchTerm, onSearchChange, allGames, selectedGame, onGameSelect,
    allTags, selectedTags, onTagToggle, onClearAll
}: NewsFiltersProps) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const hasActiveFilters = !!searchTerm || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest';

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في الأخبار بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
            
            <FilterGroup label="الفرز حسب:">
                {[{ label: 'الأحدث', value: 'latest' as 'latest' | 'viral' }, { label: 'الأكثر رواجًا', value: 'viral' as 'latest' | 'viral' }].map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                        {option.label}
                        {activeSort === option.value && <motion.div layoutId="news-sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            
            <FilterGroup label="التصفية بـ:">
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game as SanityGame | null); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
             <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {[{ label: 'الأحدث', value: 'latest' as 'latest' | 'viral' }, { label: 'الأكثر رواجًا', value: 'viral' as 'latest' | 'viral' }].map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {activeSort === option.value && <motion.div layoutId="news-sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="تصفية:">
                             <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game as SanityGame | null); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}

--- END OF FILE components/filters/NewsFilters.tsx ---

================================================================================

--- START OF FILE components/filters/ReviewFilters.tsx ---

// components/filters/ReviewFilters.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import ScoreFilterPopover from './ScoreFilterPopover';
import PopoverTriggerButton from './ui/PopoverTriggerButton';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';

export type SortOption = 'latest' | 'score';
export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';

const sortOptions: { label: string; value: SortOption }[] = [ { label: 'الأحدث', value: 'latest' }, { label: 'الأعلى تقييمًا', value: 'score' }, ];
const scoreRangeMap: Record<ScoreFilter, string> = { 'All': 'الكل', '9-10': '9-10', '8-8.9': '8-8.9', '7-7.9': '7-7.9', '<7': '<7' };

export default function ReviewFilters({ activeSort, onSortChange, selectedScoreRange, onScoreSelect, allGames, selectedGame, onGameSelect, allTags, selectedTags, onTagToggle, onClearAll, searchTerm, onSearchChange }: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const scoreButtonLabel = selectedScoreRange === 'All' ? 'التقييم' : `التقييم: ${scoreRangeMap[selectedScoreRange as ScoreFilter]}`;
    const hasActiveFilters = selectedScoreRange !== 'All' || !!selectedGame || selectedTags.length > 0 || searchTerm;

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في المراجعات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} style={{ width: '100%', marginBottom: '1.5rem', marginTop: '0.5rem' }} />
            <FilterGroup label="الفرز حسب:">
                {sortOptions.map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                        {option.label}
                        {activeSort === option.value && <motion.div layoutId="sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="التصفية حسب:">
                <div style={{ position: 'relative' }}>
                    <PopoverTriggerButton label={scoreButtonLabel} isActive={selectedScoreRange !== 'All'} onClick={() => togglePopover('score')} layoutId="review-score-highlight" />
                    <AnimatePresence>{openPopover === 'score' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><ScoreFilterPopover selectedScoreRange={selectedScoreRange} onScoreSelect={(score) => { onScoreSelect(score); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </div>
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح الكل</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
            <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {sortOptions.map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {activeSort === option.value && <motion.div layoutId="sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="التصفية حسب:">
                           <div style={{ position: 'relative' }}>
                                <PopoverTriggerButton label={scoreButtonLabel} isActive={selectedScoreRange !== 'All'} onClick={() => togglePopover('score')} layoutId="review-score-highlight" />
                                <AnimatePresence>{openPopover === 'score' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><ScoreFilterPopover selectedScoreRange={selectedScoreRange} onScoreSelect={(score) => { onScoreSelect(score); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </div>
                            <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll}><span>مسح الكل</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}

--- END OF FILE components/filters/ReviewFilters.tsx ---

================================================================================

--- START OF FILE components/filters/ScoreFilterPopover.tsx ---

// components/filters/ScoreFilterPopover.tsx
'use client';
import { motion } from 'framer-motion';
import styles from './Filters.module.css';

export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';
const scoreFilters: { label: string; value: ScoreFilter }[] = [
    { label: 'كل التقييمات', value: 'All' },
    { label: 'تحفة فنية (9-10)', value: '9-10' },
    { label: 'رائعة (8-8.9)', value: '8-8.9' },
    { label: 'جيدة (7-7.9)', value: '7-7.9' },
    { label: 'متفاوتة (<7)', value: '<7' },
];
const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: 10 }, visible: { opacity: 1, x: 0 } }; // RTL: from right

export default function ScoreFilterPopover({ selectedScoreRange, onScoreSelect, onClose }: { selectedScoreRange: ScoreFilter, onScoreSelect: (score: ScoreFilter) => void, onClose: () => void }) {
  return (
    <motion.div className={styles.filterPopover} style={{ width: '220px' }} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <div className={styles.popoverResultsList}>
        {scoreFilters.map(filter => (
          <motion.button key={filter.value} variants={itemVariants} className={`${styles.popoverItemButton} ${selectedScoreRange === filter.value ? styles.selected : ''}`} onClick={() => { onScoreSelect(filter.value); onClose(); }}>
            {filter.label}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}







--- END OF FILE components/filters/ScoreFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/TagFilterPopover.tsx ---

// components/filters/TagFilterPopover.tsx
'use client';
import { useState } from 'react';
import { motion } from 'framer-motion';
import type { SanityTag } from '@/types/sanity';
import { translateTag } from '@/lib/translations'; // Import the translator
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: -10, scale: 0.95 }, };

export default function TagFilterPopover({ allTags, selectedTags, onTagToggle }: { allTags: SanityTag[], selectedTags: SanityTag[], onTagToggle: (tag: SanityTag) => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  const selectedTagIds = new Set(selectedTags.map(t => t._id));

  // DEFINITIVE FIX: Search both the original English title and the translated Arabic title.
  const filteredTags = allTags.filter(tag => 
    tag.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
    translateTag(tag.title).toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="ابحث عن وسم..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {filteredTags.map(tag => (
          <motion.button key={tag._id} className={`${styles.popoverItemButton} ${selectedTagIds.has(tag._id) ? styles.selected : ''}`} onClick={() => onTagToggle(tag)}>
            {translateTag(tag.title)}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}







--- END OF FILE components/filters/TagFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterContainer.tsx ---

// components/filters/ui/FilterContainer.tsx
import React from 'react';
import styles from '../Filters.module.css';

interface FilterContainerProps {
    children: React.ReactNode;
}

const FilterContainer = React.forwardRef<HTMLDivElement, FilterContainerProps>(({ children }, ref) => {
    return (
        <div className={styles.filtersContainer} ref={ref}>
            {children}
        </div>
    );
});

FilterContainer.displayName = 'FilterContainer';
export default FilterContainer;




--- END OF FILE components/filters/ui/FilterContainer.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterGroup.tsx ---

// components/filters/ui/FilterGroup.tsx
import React from 'react';
import styles from '../Filters.module.css';

interface FilterGroupProps {
    label?: string;
    children: React.ReactNode;
}

export default function FilterGroup({ label, children }: FilterGroupProps) {
    return (
        <div className={styles.filterGroup}>
            {label && <span className={styles.filterLabel}>{label}</span>}
            <div className={styles.filterButtonsGroup}>
                {children}
            </div>
        </div>
    );
}




--- END OF FILE components/filters/ui/FilterGroup.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterToggleButton.tsx ---

// components/filters/ui/FilterToggleButton.tsx
'use client';

import { motion } from 'framer-motion';
import { FilterHorizontalIcon } from '@/components/icons';
import styles from '../Filters.module.css';

export default function FilterToggleButton({ onClick, hasActiveFilters }: { onClick: () => void, hasActiveFilters: boolean }) {
    return (
        <motion.button
            onClick={onClick}
            className={`${styles.filterButton} ${hasActiveFilters ? styles.active : ''}`}
            style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', flexShrink: 0, zIndex: 1 }}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
        >
            <span style={{ zIndex: 1, position: 'relative' }}>الفلاتر</span>
            <FilterHorizontalIcon height={20} width={20} />
        </motion.button>
    );
}




--- END OF FILE components/filters/ui/FilterToggleButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

// components/filters/ui/PopoverTriggerButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';

interface PopoverTriggerButtonProps {
    label: string;
    isActive: boolean;
    onClick: () => void;
    className?: string;
    layoutId?: string; // Prop is now used to pass a UNIQUE ID
}

export default function PopoverTriggerButton({ label, isActive, onClick, className = '', layoutId }: PopoverTriggerButtonProps) {
    return (
        <motion.button
            onClick={onClick}
            className={`${styles.filterButton} ${isActive ? styles.active : ''} ${className}`}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
        >
            {/* The highlight is only rendered if a layoutId is provided */}
            {isActive && layoutId && <motion.div layoutId={layoutId} className={styles.filterHighlight} />}
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.button>
    );
}










--- END OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedGameButton.tsx ---

// components/filters/ui/SelectedGameButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityGame } from '@/types/sanity';

interface SelectedGameButtonProps {
    selectedGame: SanityGame | null;
    onClearGame: (game: null) => void;
    onOpenPopover: () => void;
}

export default function SelectedGameButton({ selectedGame, onClearGame, onOpenPopover }: SelectedGameButtonProps) {
    if (!selectedGame) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>اللعبة</button>
        );
    }

    // The root element is now a simple motion.div with the layout prop to prevent flickering.
    return (
        <motion.div layout className={`${styles.filterButton} ${styles.gameSelectedButton} ${styles.active}`} onClick={onOpenPopover}>
            {/* The animated highlight is now self-contained for consistency */}
            <motion.div layoutId="game-highlight" className={styles.filterHighlight} />
            <span style={{ marginRight: '0.75rem', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', zIndex: 1, position: 'relative' }}>
                {selectedGame.title}
            </span>
            <motion.button
                className={styles.gameClearButton}
                onClick={(e) => {
                    e.stopPropagation();
                    onClearGame(null);
                }}
                whileTap={{ scale: 0.9 }}
            >
                {/* The SVG is now correctly styled to be visible against the cyan background */}
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </motion.button>
        </motion.div>
    );
}










--- END OF FILE components/filters/ui/SelectedGameButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedTagsButton.tsx ---

// components/filters/ui/SelectedTagsButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityTag } from '@/types/sanity';

interface SelectedTagsButtonProps {
    selectedTags: SanityTag[];
    onOpenPopover: () => void;
}

export default function SelectedTagsButton({ selectedTags, onOpenPopover }: SelectedTagsButtonProps) {
    const isActive = selectedTags.length > 0;
    const label = isActive ? `الوسوم (${selectedTags.length})` : "الوسوم";

    if (!isActive) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>
                {label}
            </button>
        );
    }
    
    return (
        <motion.button
            layout
            className={`${styles.filterButton} ${styles.active}`}
            onClick={onOpenPopover}
            whileHover={{ scale: 1.05 }}
        >
            <motion.div layoutId="tags-highlight" className={styles.filterHighlight} />
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.button>
    );
}







--- END OF FILE components/filters/ui/SelectedTagsButton.tsx ---

================================================================================

--- START OF FILE components/homepage/HomepageFeeds.module.css ---

/* components/homepage/HomepageFeeds.module.css */
.feedsGrid {
    display: grid;
    grid-template-columns: 2fr 1.2fr;
    gap: 4rem;
    margin-top: 6rem;
}

@media (max-width: 1024px) {
    .feedsGrid {
        grid-template-columns: 1fr;
        gap: 6rem;
        margin-top: 4rem;
    }
}




--- END OF FILE components/homepage/HomepageFeeds.module.css ---

================================================================================

--- START OF FILE components/homepage/HomepageFeeds.tsx ---

// components/homepage/HomepageFeeds.tsx
'use client';

import React, { useRef, useState, memo } from "react";
import { motion, useScroll, useTransform, AnimatePresence } from "framer-motion";
import { useRouter } from "next/navigation";
import Image from "next/image";
import Link from "next/link";
import Feed from "./feed/Feed";
import CreatorCredit from "@/components/CreatorCredit";
import KineticGlyphs from "@/components/effects/KineticGlyphs";
import { useLivingCard } from "@/hooks/useLivingCard";
import { CardProps } from "@/types";
import { ContentBlock } from "../ContentBlock";
import { ArticleIcon, NewsIcon } from "@/components/icons/index";
import PaginatedCarousel from "../PaginatedCarousel";
import KineticSpotlightNews from "./kinetic-news/KineticSpotlightNews";
import NewsfeedStream from "./kinetic-news/NewsfeedStream";
import gridStyles from './HomepageFeeds.module.css';
import feedStyles from './feed/Feed.module.css';
import { useLayoutIdStore } from "@/lib/layoutIdStore";

// --- Specific Card Renderers ---

const TopArticleCard = memo(({ article }: { article: CardProps }) => {
    // THE FIX: Explicitly typed for HTMLAnchorElement
    const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLAnchorElement>();
    const [isHovered, setIsHovered] = useState(false);
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "homepage-top-articles";
    const linkPath = `/articles/${article.slug}`;

    const handleClick = (e: React.MouseEvent) => {
        if ((e.target as HTMLElement).closest('a[href^="/creators"]')) return;
        if (e.ctrlKey || e.metaKey) return; // Allow new tab
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    return (
        <motion.a
            href={linkPath}
            layout
            layoutId={`${layoutIdPrefix}-card-container-${article.legacyId}`}
            ref={livingCardRef} 
            style={{...livingCardAnimation.style, height: '100%', cursor: 'pointer', display: 'block' }} 
            className="no-underline"
            onMouseMove={livingCardAnimation.onMouseMove} 
            onMouseEnter={() => { livingCardAnimation.onMouseEnter(); setIsHovered(true); }} 
            onMouseLeave={() => { livingCardAnimation.onMouseLeave(); setIsHovered(false); }}
            onTouchStart={livingCardAnimation.onTouchStart}
            onTouchEnd={livingCardAnimation.onTouchEnd}
            onTouchCancel={livingCardAnimation.onTouchCancel}
            onClick={handleClick}
        >
            <div
                className={feedStyles.topArticleCard}
            >
                <AnimatePresence>{isHovered && <KineticGlyphs />}</AnimatePresence>
                
                <div
                    className={feedStyles.topArticleCardInner}
                >
                    <motion.div layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`} className={feedStyles.topArticleImage}>
                        <Image src={article.imageUrl} alt={article.title} fill sizes="(max-width: 768px) 45vw, 30vw" placeholder="blur" blurDataURL={article.blurDataURL} style={{ objectFit: 'cover' }} />
                    </motion.div>
                    <div className={feedStyles.topArticleContent}>
                        <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`} className={feedStyles.topArticleTitle}>{article.title}</motion.h3>
                        <div className={feedStyles.topArticleMeta}><CreatorCredit label="بقلم" creators={article.authors} small /></div>
                    </div>
                </div>
            </div>
        </motion.a>
    );
});
TopArticleCard.displayName = "TopArticleCard";

// --- Main Component ---

interface HomepageFeedsProps {
    topArticles: CardProps[]; latestArticles: CardProps[];
    pinnedNews: CardProps[]; newsList: CardProps[];
}

export default function HomepageFeeds({ topArticles, latestArticles, pinnedNews, newsList }: HomepageFeedsProps) {
    const containerRef = useRef<HTMLDivElement>(null);
    const { scrollYProgress } = useScroll({ target: containerRef, offset: ['start end', 'end start'] });
    const articlesY = useTransform(scrollYProgress, [0, 1], [0, -80]);
    const newsY = useTransform(scrollYProgress, [0, 1], [0, -50]);

    return (
        <div className={gridStyles.feedsGrid} ref={containerRef}>
            <motion.div style={{ y: articlesY }}>
                <ContentBlock title="أحدث المقالات" Icon={ArticleIcon}>
                    <Feed
                        topSectionLabel="الأكثر رواجًا"
                        latestSectionLabel="الأحدث"
                        topItems={topArticles}
                        viewAllLink="/articles"
                        viewAllText="عرض كل المقالات"
                        topItemsContainerClassName={feedStyles.topArticlesGrid}
                        renderTopItem={(item) => <TopArticleCard key={item.id} article={item} />}
                        enableTopSectionHoverEffect={false}
                        latestSectionContent={<PaginatedCarousel items={latestArticles} />}
                    />
                </ContentBlock>
            </motion.div>
            <motion.div style={{ y: newsY }}>
                <ContentBlock title="موجز الأنباء" Icon={NewsIcon}>
                    <Feed
                        topSectionLabel="الأكثر رواجًا"
                        latestSectionLabel="الأحدث"
                        topItems={pinnedNews}
                        viewAllLink="/news"
                        viewAllText="عرض كل الأخبار"
                        topItemsContainerClassName={feedStyles.pinnedNewsList}
                        renderTopItem={() => null}
                        topSectionContent={<KineticSpotlightNews items={pinnedNews} />}
                        latestSectionContent={<NewsfeedStream items={newsList} />}
                        enableTopSectionHoverEffect={true}
                    />
                </ContentBlock>
            </motion.div>
        </div>
    );
}

--- END OF FILE components/homepage/HomepageFeeds.tsx ---

================================================================================

--- START OF FILE components/homepage/PaginatedLatestArticles.module.css ---

/* components/homepage/PaginatedLatestArticles.module.css */

.paginatedContainer {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.paginatedContent {
    /* flex-grow: 1; <-- This property was pushing the controls to the bottom, it has been removed. */
    position: relative;
    min-height: 380px; /* Adjust based on item height to prevent layout shift */
}

.itemList {
    display: flex;
    flex-direction: column;
}

.paginationControls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    padding-top: 1rem; /* Reduced top padding to bring controls closer to content */
    padding-bottom: 1.5rem; /* Added bottom padding for spacing from elements below */
}

.paginationDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: var(--border-color);
    border: none;
    cursor: pointer;
    padding: 0;
    transition: all 0.3s ease;
}

.paginationDot:hover {
    background-color: var(--text-secondary);
}

.paginationDot.active {
    background-color: var(--accent);
    transform: scale(1.2);
    box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 50%, transparent);
}

--- END OF FILE components/homepage/PaginatedLatestArticles.module.css ---

================================================================================

--- START OF FILE components/homepage/PaginatedLatestArticles.tsx ---

// components/homepage/PaginatedLatestArticles.tsx
'use client';

import React, { useState, useEffect, useRef, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { CardProps } from '@/types';
import CreatorCredit from '@/components/CreatorCredit';
import { Calendar03Icon } from '@/components/icons/index';
import styles from './PaginatedLatestArticles.module.css';
import feedStyles from './feed/Feed.module.css';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

const LatestArticleListItem = memo(({ article }: { article: CardProps }) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "homepage-latest-articles";
    const linkPath = `/articles/${article.slug}`;

    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (e.ctrlKey || e.metaKey) return;
        if ((e.target as HTMLElement).closest('a[href^="/creators"]')) return;
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    return (
        <motion.a
            href={linkPath}
            onClick={handleClick}
            layoutId={`${layoutIdPrefix}-card-container-${article.legacyId}`} 
            className={`${feedStyles.latestArticleItem} no-underline`}
        >
            <motion.div layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`} className={feedStyles.latestArticleThumbnail}>
                <Image 
                    src={article.imageUrl} 
                    alt={article.title} 
                    fill 
                    sizes="120px" 
                    placeholder="blur" 
                    blurDataURL={article.blurDataURL} 
                    style={{ objectFit: 'cover' }} 
                />
            </motion.div>
            <div className={feedStyles.latestArticleInfo}>
                <motion.h4 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`} className={feedStyles.latestArticleTitle}>{article.title}</motion.h4>
                <div className={feedStyles.latestArticleMeta}>
                    <CreatorCredit label="بقلم" creators={article.authors} />
                    {article.date && (
                        <div className={feedStyles.latestArticleDate}>
                            <Calendar03Icon style={{ width: '16px', height: '16px', color: 'var(--accent)' }} />
                            <span>{article.date}</span>
                        </div>
                    )}
                </div>
            </div>
        </motion.a>
    );
});
LatestArticleListItem.displayName = "LatestArticleListItem";

type PaginatedLatestArticlesProps = {
    items: CardProps[];
    itemsPerPage?: number;
};

export default function PaginatedLatestArticles({ items, itemsPerPage = 3 }: PaginatedLatestArticlesProps) {
    const [currentPage, setCurrentPage] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    const totalPages = Math.ceil(items.length / itemsPerPage);

    const resetTimeout = () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } };

    useEffect(() => {
        resetTimeout();
        if (!isHovered && totalPages > 1) {
            timeoutRef.current = setTimeout(
                () => setCurrentPage((prevPage) => (prevPage + 1) % totalPages),
                3500
            );
        }
        return () => resetTimeout();
    }, [currentPage, isHovered, totalPages]);

    const startIndex = currentPage * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = items.slice(startIndex, endIndex);

    return (
        <div 
            className={styles.paginatedContainer}
            onMouseEnter={() => setIsHovered(true)} 
            onMouseLeave={() => setIsHovered(false)}
        >
            <div className={styles.paginatedContent}>
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentPage}
                        initial={{ opacity: 0, x: 30 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: -30 }}
                        transition={{ duration: 0.4, ease: 'easeInOut' }}
                        className={styles.itemList}
                    >
                        {currentItems.map((item, index) => (
                            <React.Fragment key={item.id}>
                                <LatestArticleListItem article={item} />
                                {index < currentItems.length - 1 && <div className={feedStyles.listDivider} />}
                            </React.Fragment>
                        ))}
                    </motion.div>
                </AnimatePresence>
            </div>
            {totalPages > 1 && (
                <div className={styles.paginationControls}>
                    {Array.from({ length: totalPages }).map((_, index) => (
                        <button
                            key={index}
                            className={`${styles.paginationDot} ${currentPage === index ? styles.active : ''}`}
                            onClick={() => setCurrentPage(index)}
                            aria-label={`Go to page ${index + 1}`}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}

--- END OF FILE components/homepage/PaginatedLatestArticles.tsx ---

================================================================================

--- START OF FILE components/homepage/feed/Feed.module.css ---

/* components/homepage/feed/Feed.module.css */
@keyframes pulse-live {
    0%, 100% { box-shadow: 0 0 5px 1px color-mix(in srgb, var(--accent) 60%, transparent); }
    50% { box-shadow: 0 0 10px 2px color-mix(in srgb, var(--accent) 80%, transparent); }
}

/* --- Generic Feed Container --- */
.feedContainer {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    height: 100%;
    display: flex;
    flex-direction: column;
}

.topSection {
    padding: 2rem 2.5rem;
    position: relative;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: flex-start; /* Aligns label to the right in RTL */
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.sectionLabel {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    font-family: var(--font-ui);
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border: 1px solid var(--accent);
    border-radius: 999px;
    position: relative;
    z-index: 2;
}

.liveIndicator {
    width: 8px;
    height: 8px;
    background-color: var(--accent);
    border-radius: 50%;
    animation: pulse-live 1.5s infinite ease-in-out;
}

.topItemsContainer {
    position: relative;
    z-index: 2;
    width: 100%;
    order: 2; /* Ensure it's below the label */
    margin-top: 1.5rem;
}

.latestSection {
    padding: 1.5rem 2.5rem 0 2.5rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.latestItemsList {
    flex-grow: 1;
}

.listDivider {
    height: 1px;
    background: linear-gradient(to left, transparent, var(--border-color) 20%, var(--border-color) 80%, transparent);
}

.viewAllLink {
    display: flex;
    /* THE FIX: Set direction to RTL to ensure text is on the right */
    direction: rtl; 
    /* THE FIX: Reverse the display order of icon/text so the icon is on the left */
    flex-direction: row-reverse;
    /* THE FIX: Adjust gap for better spacing */
    gap: 0.5rem; 
    
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 1.25rem;
    margin-top: auto;
    border-top: 1px solid var(--border-color);
    font-family: var(--font-ui);
    font-weight: 600;
    color: var(--text-secondary);
    transition: background-color 0.2s ease, color 0.2s ease;
    position: relative;
    z-index: 2;
    
    /* THE FIX: Apply text style to the span */
}

.viewAllLink span {
    font-size: 1.8rem; /* Set a specific size for the text to be prominent */
}

.viewAllLink svg {
    /* Set icon size */
    width: 2.2rem;
    height: 2.2rem;
    color: var(--accent); /* Ensure color from the start */
    
    /* The main arrow is now the correct way. We apply the transform only on hover/specific state */
    transform: scaleX(-1); /* To make it point to the left/outside */
    transition: transform 0.2s ease, color 0.2s ease;
}

.viewAllLink:hover {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}

.viewAllLink:hover svg {
    /* On hover, move the arrow */
    transform: translateX(4px) scaleX(-1); 
    color: var(--accent);
}

.topItemsContainer {
    display: block;
    width: 100%;
    order: 2; 
    margin-top: 1.5rem;
}

/* --- Article Feed Specifics --- */
.topArticlesGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2.5rem;
    grid-auto-rows: 1fr; /* THE FIX: Ensure equal height */
}

.topArticleCard {
    display: block;
    text-decoration: none;
    position: relative;
    border-radius: 12px;
    overflow: hidden;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    transform-style: preserve-3d;
    will-change: transform;
    cursor: pointer;
    transform: translateZ(0px);
    height: 100%; /* THE FIX: Ensure card fills its row's height */
}

.topArticleImage {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 10;
}

.topArticleImage img {
    transition: transform 0.4s ease-out;
}

.topArticleCard:hover .topArticleImage img {
    transform: scale(1.03);
}

.topArticleContent {
    padding: 1.5rem;
    text-align: right;
    border-top: 1px solid var(--border-color);
    transform: translateZ(20px);
}

.topArticleTitle {
    font-family: var(--font-heading);
    font-size: 1.9rem;
    color: var(--text-primary);
    line-height: 1.3;
    margin: 0 0 0.75rem 0;
    transition: color 0.2s ease;
}

.topArticleCard:hover .topArticleTitle {
    color: var(--accent);
}

.topArticleMeta {
    font-size: 1.3rem;
    color: var(--text-secondary);
}

/* New inner container for clipping to have height 100% for the effect */
.topArticleCardInner {
    height: 100%; /* THE FIX: Ensure inner motion.div fills all space */
    display: flex;
    flex-direction: column;
}

/* --- List Item Fix: Ensure list item is a block element for proper layout */
.latestArticleItem {
    display: grid;
    grid-template-columns: 120px 1fr;
    gap: 2rem;
    align-items: center;
    position: relative;
    padding: 1.5rem 0;
    border-radius: 8px; /* Added for hover effect */
    cursor: pointer;
    /* NEW: Use flex-grow for vertical space distribution */
    flex-grow: 1; 
}


.latestArticleThumbnail {
    width: 120px;
    height: 75px;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
    transition: border-color 0.3s ease;
}

.latestArticleItem:hover .latestArticleThumbnail {
    border-color: var(--accent);
}

.latestArticleThumbnail img {
    transition: transform 0.3s ease-out;
}

.latestArticleItem:hover .latestArticleThumbnail img {
    transform: scale(1.05);
}

.latestArticleInfo {
    text-align: right;
}

.latestArticleTitle {
    font-size: 1.7rem;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
    transition: color 0.2s ease;
    position: relative;
    display: inline-block; /* Required for the underline effect */
}

.latestArticleItem:hover .latestArticleTitle {
    color: var(--accent);
}

.latestArticleTitle::after {
    content: '';
    position: absolute;
    bottom: -6px;
    right: 0;
    width: 100%;
    height: 1px;
    background: var(--accent);
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    filter: drop-shadow(0 0 4px var(--accent));
}

.latestArticleItem:hover .latestArticleTitle::after {
    transform: scaleX(1);
}

.latestArticleMeta {
    font-size: 1.3rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
}

.latestArticleDate {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* --- News Feed Specifics --- */
.pinnedNewsList {
    display: flex;
    flex-direction: column;
}

.pinnedNewsDivider {
    height: 1px;
    background-color: color-mix(in srgb, var(--accent) 30%, transparent);
    margin: 0.75rem 0;
}

.pinnedNewsItem {
    display: grid;
    grid-template-columns: 80px 1fr;
    gap: 1.5rem;
    align-items: center;
    text-decoration: none;
    cursor: pointer;
    padding: 0.5rem;
    margin: -0.5rem;
    border-radius: 8px;
    transition: background-color 0.2s ease;
    min-height: 80px; /* NEW: Enforce consistent height */
}

.pinnedNewsItem:hover {
    background-color: var(--bg-primary);
}

.pinnedNewsThumbnail {
    width: 80px;
    height: 50px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: 1px solid transparent;
}

.pinnedNewsThumbnail img {
    transition: transform 0.3s ease-out;
}

.pinnedNewsItem:hover .pinnedNewsThumbnail img {
    transform: scale(1.05);
}

.pinnedNewsInfo {
    text-align: right;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.25rem;
}

.pinnedNewsTitle {
    font-size: 1.7rem;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.2s ease;
    /* NEW: Handle text overflow for consistency */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;  
    overflow: hidden;
    text-overflow: ellipsis;
}

.pinnedNewsItem:hover .pinnedNewsTitle {
    color: var(--accent);
}

.pinnedNewsDate {
    font-size: 1.3rem;
    color: var(--text-secondary);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.pinnedNewsCategory {
    font-size: 1.3rem;
    font-weight: 500;
    color: var(--accent);
    margin: 0;
}

.newsListDivider {
    height: 1px;
    background: var(--border-color);
}

.newsListItem {
    display: grid;
    grid-template-columns: 60px 1fr;
    gap: 1.5rem;
    align-items: center;
    text-decoration: none;
    padding: 1.25rem 1rem;
    border-radius: 8px;
    margin: 0 -1rem;
    transition: background-color 0.2s ease;
    cursor: pointer;
}

.newsListItem:hover {
    background-color: var(--bg-primary);
}

.newsListItem:hover .newsListTitle {
    color: var(--accent);
}

.newsListItem:hover .newsListThumbnail {
    border-color: var(--accent);
}

.newsListThumbnail {
    width: 60px;
    height: 40px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
    transition: border-color 0.3s ease;
}
.newsListThumbnail img {
    transition: transform 0.3s ease-out;
}
.newsListItem:hover .newsListThumbnail img {
    transform: scale(1.05);
}

.newsListInfo {
    text-align: right;
}

.newsListCategory {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0 0 0.25rem 0;
}

.newsListTitle {
    font-size: 1.4rem;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.2s ease;
}

/* --- Mobile Overrides --- */
@media (max-width: 768px) {
    .topArticlesGrid {
        grid-template-columns: 1fr 1fr; /* THE FIX: Force two columns */
        gap: 1.5rem; /* THE FIX: Reduce gap to give cards more space */
    }
    .topSection, .latestSection {
        padding-left: 1.5rem; /* THE FIX: Reduce horizontal padding */
        padding-right: 1.5rem; /* THE FIX: Reduce horizontal padding */
    }
}

--- END OF FILE components/homepage/feed/Feed.module.css ---

================================================================================

--- START OF FILE components/homepage/feed/Feed.tsx ---

'use client';

import { motion, AnimatePresence } from 'framer-motion';
import React, { useState } from 'react';
import Link from 'next/link';
import { CardProps } from '@/types';
import KineticGlyphs from '@/components/effects/KineticGlyphs';
import styles from './Feed.module.css';

// THE FIX: Simplified ArrowIcon - it now points right (in LTR terms)
const ArrowIcon = () => <svg width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>;

interface FeedProps {
    topSectionLabel: string;
    latestSectionLabel: string;
    topItems: CardProps[];
    latestItems?: CardProps[];
    viewAllLink: string;
    viewAllText: string;
    topItemsContainerClassName?: string;
    renderTopItem: (item: CardProps, index: number) => React.ReactNode;
    renderListItem?: (item: CardProps, index: number) => React.ReactNode;
    listDividerClassName?: string;
    enableTopSectionHoverEffect?: boolean;
    latestSectionContent?: React.ReactNode;
    topSectionContent?: React.ReactNode;
}

const kineticCardVariant = {
    hidden: { 
        opacity: 0, 
        y: 50, 
        rotateX: -20,
        clipPath: "inset(100% 0% 0% 0%)"
    },
    visible: { 
        opacity: 1, 
        y: 0, 
        rotateX: 0,
        clipPath: "inset(0% 0% 0% 0%)",
        transition: { 
            duration: 0.8, 
            ease: [0.22, 1, 0.36, 1] as const 
        }
    }
};

export default function Feed({
    topSectionLabel, latestSectionLabel, topItems, latestItems = [],
    viewAllLink, viewAllText, topItemsContainerClassName = '',
    renderTopItem, renderListItem, listDividerClassName = styles.listDivider,
    enableTopSectionHoverEffect = false, latestSectionContent, topSectionContent
}: FeedProps) {
    const [isTopSectionHovered, setIsTopSectionHovered] = useState(false);

    return (
        <div className={styles.feedContainer}>
            {topItems.length > 0 && (
                <div
                    className={styles.topSection}
                    onMouseEnter={() => { if (enableTopSectionHoverEffect) setIsTopSectionHovered(true); }}
                    onMouseLeave={() => { if (enableTopSectionHoverEffect) setIsTopSectionHovered(false); }}
                >
                    <AnimatePresence>{isTopSectionHovered && enableTopSectionHoverEffect && <KineticGlyphs />}</AnimatePresence>
                    <span className={styles.sectionLabel}>{topSectionLabel}</span>
                    <motion.div 
                        layout /* THE FIX: Added layout prop here */
                        className={`${styles.topItemsContainer} ${topItemsContainerClassName}`} 
                        style={{ perspective: '800px' }}
                    >
                        {topSectionContent ? (
                            <motion.div variants={kineticCardVariant}>{topSectionContent}</motion.div>
                        ) : (
                            topItems.map((item, index) => (
                                <motion.div key={item.id} variants={kineticCardVariant} style={{ height: '100%' }}>
                                    {renderTopItem(item, index)}
                                </motion.div>
                            ))
                        )}
                    </motion.div>
                </div>
            )}

            <div className={styles.latestSection}>
                <span className={styles.sectionLabel} style={{ alignSelf: 'flex-start' }}>
                    <div className={styles.liveIndicator}></div>
                    <span>{latestSectionLabel}</span>
                </span>
                <motion.div className={styles.latestItemsList} variants={kineticCardVariant}>
                    {latestSectionContent ? (
                        latestSectionContent
                    ) : (
                        latestItems.map((item, index) => (
                            renderListItem && (
                                <React.Fragment key={item.id}>
                                    {renderListItem(item, index)}
                                    {index < latestItems.length - 1 && <div className={listDividerClassName} />}
                                </React.Fragment>
                            )
                        ))
                    )}
                </motion.div>
            </div>
            
            <motion.div variants={kineticCardVariant}>
                <Link href={viewAllLink} className={`${styles.viewAllLink} no-underline`}>
                    {/* THE FIX: Reordered the elements to put the icon first in LTR order (which translates to the left in RTL) */}
                    <ArrowIcon />
                    <span>{viewAllText}</span>
                </Link>
            </motion.div>
        </div>
    );
}

--- END OF FILE components/homepage/feed/Feed.tsx ---

================================================================================

--- START OF FILE components/homepage/feed/FeedSkeleton.module.css ---

/* components/homepage/feed/FeedSkeleton.module.css */
@keyframes pulse-skeleton {
    0%, 100% {
        background-color: var(--border-color);
    }
    50% {
        background-color: color-mix(in srgb, var(--border-color) 60%, var(--bg-secondary));
    }
}

.skeletonBlock {
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    border-radius: 6px;
}

.feedsGridSkeleton {
    display: grid;
    grid-template-columns: 2fr 1.2fr;
    gap: 4rem;
    margin-top: 6rem;
}

.feedColumnSkeleton {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.topSectionSkeleton {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2.5rem;
}

.articleCardSkeleton {
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    background-color: var(--bg-secondary);
}

.imageSkeleton {
    aspect-ratio: 16 / 10;
    border-bottom: 1px solid var(--border-color);
}

.contentSkeleton {
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.latestSectionSkeleton {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
}

.newsItemSkeleton {
    display: flex;
    gap: 1.5rem;
    align-items: center;
}

.newsContentSkeleton {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

@media (max-width: 1024px) {
    .feedsGridSkeleton {
        grid-template-columns: 1fr;
        gap: 6rem;
        margin-top: 4rem;
    }
}




--- END OF FILE components/homepage/feed/FeedSkeleton.module.css ---

================================================================================

--- START OF FILE components/homepage/feed/FeedSkeleton.tsx ---

// components/homepage/feed/FeedSkeleton.tsx
import React from 'react';
import styles from './FeedSkeleton.module.css';

const SkeletonBlock = ({ className, style }: { className?: string, style?: React.CSSProperties }) => (
    <div className={`${styles.skeletonBlock} ${className || ''}`} style={style}></div>
);

const ArticleCardSkeleton = () => (
    <div className={styles.articleCardSkeleton}>
        <SkeletonBlock className={styles.imageSkeleton} />
        <div className={styles.contentSkeleton}>
            <SkeletonBlock style={{ width: '80%', height: '24px' }} />
            <SkeletonBlock style={{ width: '50%', height: '16px' }} />
        </div>
    </div>
);

const NewsItemSkeleton = () => (
    <div className={styles.newsItemSkeleton}>
        <SkeletonBlock style={{ width: '80px', height: '50px', borderRadius: '6px' }} />
        <div className={styles.newsContentSkeleton}>
            <SkeletonBlock style={{ width: '40%', height: '12px' }} />
            <SkeletonBlock style={{ width: '90%', height: '16px' }} />
        </div>
    </div>
);

const FeedSkeleton = () => {
    return (
        <div className={styles.feedsGridSkeleton}>
            {/* Left Column (Articles) */}
            <div className={styles.feedColumnSkeleton}>
                <SkeletonBlock style={{ height: '40px', width: '200px', marginBottom: '2rem' }} />
                <div className={styles.topSectionSkeleton}>
                    <ArticleCardSkeleton />
                    <ArticleCardSkeleton />
                </div>
                <div className={styles.latestSectionSkeleton}>
                    <SkeletonBlock style={{ height: '20px', width: '150px', marginBottom: '1.5rem' }} />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
            </div>
            {/* Right Column (News) */}
            <div className={styles.feedColumnSkeleton}>
                <SkeletonBlock style={{ height: '40px', width: '200px', marginBottom: '2rem' }} />
                <div className={styles.topSectionSkeleton}>
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
                <div className={styles.latestSectionSkeleton}>
                    <SkeletonBlock style={{ height: '20px', width: '150px', marginBottom: '1.5rem' }} />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
            </div>
        </div>
    );
};

export default FeedSkeleton;




--- END OF FILE components/homepage/feed/FeedSkeleton.tsx ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/KineticSpotlightNews.module.css ---

/* components/homepage/kinetic-news/KineticSpotlightNews.module.css */

.spotlightContainer {
    display: flex;
    flex-direction: column;
}

.spotlightItem {
    position: relative;
    /* overflow: hidden; <-- This was preventing the highlight from showing, removed. */
}

.kineticHighlightBar {
    position: absolute;
    top: 8;
    bottom: 8;
    right: 0; /* Aligned to the right for RTL */
    left: auto;
    width: 4px; /* INCREASED */
    background: 
        linear-gradient(
            var(--accent), 
            color-mix(in srgb, var(--accent) 60%, #00ffff)
        ); /* ADDED GRADIENT */
    box-shadow: 0 0 12px 8px var(--accent); /* INCREASED */
    border-radius: 4px;
}

--- END OF FILE components/homepage/kinetic-news/KineticSpotlightNews.module.css ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/KineticSpotlightNews.tsx ---

// components/homepage/kinetic-news/KineticSpotlightNews.tsx
'use client';

import React, { useState, useEffect, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { CardProps } from '@/types';
import { Calendar03Icon } from '@/components/icons/index';
import { translateTag } from '@/lib/translations';
import styles from './KineticSpotlightNews.module.css';
import feedStyles from '../feed/Feed.module.css';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

const PinnedNewsCard = memo(({ item, isActive }: { item: CardProps, isActive: boolean }) => {
    const primaryTag = item.tags && item.tags.length > 0 ? translateTag(item.tags[0].title) : 'أخبار';
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "homepage-pinned-news";
    const linkPath = `/news/${item.slug}`;

    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (e.ctrlKey || e.metaKey) return; // Allow new tab
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    return (
        <motion.a
            href={linkPath}
            onClick={handleClick}
            layoutId={`${layoutIdPrefix}-card-container-${item.legacyId}`}
            className={`${feedStyles.pinnedNewsItem} ${styles.spotlightItem} no-underline`}
        >
            {isActive && (
                <motion.div
                    className={styles.kineticHighlightBar}
                    layoutId="kinetic-spotlight-highlight-bar"
                    transition={{ type: 'spring', stiffness: 400, damping: 35 }}
                />
            )}
            <motion.div layoutId={`${layoutIdPrefix}-card-image-${item.legacyId}`} className={feedStyles.pinnedNewsThumbnail}>
                <Image 
                    src={item.imageUrl} 
                    alt={item.title} 
                    fill 
                    sizes="80px" 
                    placeholder="blur" 
                    blurDataURL={item.blurDataURL} 
                    style={{ objectFit: 'cover' }} 
                />
            </motion.div>
            <div className={feedStyles.pinnedNewsInfo}>
                <motion.h4 layoutId={`${layoutIdPrefix}-card-title-${item.legacyId}`} className={feedStyles.pinnedNewsTitle}>{item.title}</motion.h4>
                {item.date && (
                    <div className={feedStyles.pinnedNewsDate}>
                        <Calendar03Icon style={{width: '14px', height: '14px', color: 'var(--accent)'}} />
                        <span>{item.date.split(' - ')[0]}</span>
                    </div>
                )}
                <p className={feedStyles.pinnedNewsCategory}>{primaryTag}</p>
            </div>
        </motion.a>
    );
});
PinnedNewsCard.displayName = 'PinnedNewsCard';

export default function KineticSpotlightNews({ items }: { items: CardProps[] }) {
    const [activeIndex, setActiveIndex] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (isHovered || items.length <= 1) return;

        const interval = setInterval(() => {
            setActiveIndex((prevIndex) => (prevIndex + 1) % items.length);
        }, 4000);

        return () => clearInterval(interval);
    }, [isHovered, items.length]);

    const hoverHandlers = isMobile ? {} : {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
    };

    return (
        <div 
            className={styles.spotlightContainer}
            {...hoverHandlers}
        >
            {items.map((item, index) => (
                <React.Fragment key={item.id}>
                    <PinnedNewsCard item={item} isActive={activeIndex === index} />
                    {index < items.length - 1 && <div className={feedStyles.pinnedNewsDivider} />}
                </React.Fragment>
            ))}
        </div>
    );
}

--- END OF FILE components/homepage/kinetic-news/KineticSpotlightNews.tsx ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/NewsfeedStream.module.css ---




--- END OF FILE components/homepage/kinetic-news/NewsfeedStream.module.css ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/NewsfeedStream.tsx ---

// components/homepage/kinetic-news/NewsfeedStream.tsx
'use client';

import React, { useState, useEffect, useRef, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { CardProps } from '@/types';
import { Calendar03Icon } from '@/components/icons/index';
import { translateTag } from '@/lib/translations';
import styles from './NewsfeedStream.module.css';
import feedStyles from '../feed/Feed.module.css';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import Image from 'next/image';

const LatestNewsListItem = memo(({ item }: { item: CardProps }) => {
    const primaryTag = item.tags && item.tags.length > 0 ? translateTag(item.tags[0].title) : 'أخبار';
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "homepage-news-stream";
    const linkPath = `/news/${item.slug}`;
    
    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (e.ctrlKey || e.metaKey) return; // Allow new tab
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    return (
        <motion.a
            href={linkPath}
            onClick={handleClick}
            layoutId={`${layoutIdPrefix}-card-container-${item.legacyId}`}
            className={`${feedStyles.newsListItem} no-underline`}
        >
            <motion.div layoutId={`${layoutIdPrefix}-card-image-${item.legacyId}`} className={feedStyles.newsListThumbnail}>
                <Image 
                    src={item.imageUrl} 
                    alt={item.title} 
                    fill 
                    sizes="60px" 
                    placeholder="blur" 
                    blurDataURL={item.blurDataURL} 
                    style={{ objectFit: 'cover' }} 
                />
            </motion.div>
            <div className={feedStyles.newsListInfo}>
                <p className={feedStyles.newsListCategory}>{primaryTag}</p>
                <motion.h5 layoutId={`${layoutIdPrefix}-card-title-${item.legacyId}`} className={feedStyles.newsListTitle}>{item.title}</motion.h5>
                {item.date && (
                    <div style={{ margin: '0.25rem 0 0', fontSize: '1.2rem', color: 'var(--text-secondary)', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                        <Calendar03Icon style={{width: '14px', height: '14px', color: 'var(--accent)'}} />
                        <span>{item.date.split(' - ')[0]}</span>
                    </div>
                )}
            </div>
        </motion.a>
    );
});
LatestNewsListItem.displayName = "LatestNewsListItem";

export default function NewsfeedStream({ items }: { items: CardProps[] }) {
    const [listItems, setListItems] = useState(items);
    const [isHovered, setIsHovered] = useState(false);
    const [isMobile, setIsMobile] = useState(false);
    const intervalRef = useRef<NodeJS.Timeout | null>(null);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (!isHovered && items.length > 5 && !isMobile) {
            intervalRef.current = setInterval(() => {
                setListItems(prevItems => {
                    const newItems = [...prevItems];
                    const firstItem = newItems.shift();
                    if (firstItem) {
                        newItems.push(firstItem);
                    }
                    return newItems;
                });
            }, 3000);
        }

        return () => {
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
            }
        };
    }, [isHovered, items.length, isMobile]);

    const hoverHandlers = isMobile ? {} : {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
    };

    return (
        <div {...hoverHandlers}>
            <AnimatePresence initial={false}>
                {listItems.slice(0, 5).map((item, index) => (
                    <motion.div
                        key={item.id}
                        layout
                        initial={{ opacity: 0, y: 50 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -50 }}
                        transition={{ type: 'spring', stiffness: 350, damping: 35 }}
                    >
                        <LatestNewsListItem item={item} />
                        {index < 4 && <div className={feedStyles.newsListDivider} />}
                    </motion.div>
                ))}
            </AnimatePresence>
        </div>
    );
}

--- END OF FILE components/homepage/kinetic-news/NewsfeedStream.tsx ---

================================================================================

--- START OF FILE components/icons/AuthIcons.tsx ---

// components/icons/AuthIcons.tsx
// This file is the single source of truth for all authentication provider SVG icons.
// By defining them as direct React components in one file, we eliminate multiple
// module lookups and reduce JavaScript bundle overhead, leading to faster rendering.

import React from 'react';

export const GitHubIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
    </svg>
);

export const GoogleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 48 48" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M45.12 24.5c0-1.56-.14-3.06-.4-4.5H24v8.51h11.84c-.51 2.75-2.06 5.08-4.39 6.64v5.52h7.11c4.16-3.83 6.56-9.47 6.56-16.17z" />
        <path d="M24 46c5.94 0 10.92-1.96 14.56-5.3l-7.11-5.52c-1.97 1.32-4.49 2.1-7.45 2.1-5.73 0-10.58-3.87-12.31-9.07H4.34v5.7C7.96 40.5 15.4 46 24 46z" />
        <path d="M11.69 28.18c-.38-1.13-.6-2.33-.6-3.58s.22-2.45.6-3.58v-5.7H4.34C2.96 18.05 2 20.9 2 24.6c0 3.7.96 6.55 2.34 9.28l7.35-5.7z" />
        <path d="M24 10.75c3.23 0 6.13 1.11 8.41 3.29l6.31-6.31C34.91 4.18 29.93 2 24 2 15.4 2 7.96 7.5 4.34 13.37l7.35 5.7c1.73-5.2 6.58-9.02 12.31-9.02z" />
    </svg>
);

export const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 1200 1227" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
    </svg>
);

// MODIFIED: Replaced the old SVG with the new, superior infinity glyph.
export const EternalGamesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="-2 -2 28 28" fill="currentColor" aria-hidden="true" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M6.5 8C4.42522 8 3 9.64616 3 12C3 14.3538 4.42522 16 6.5 16C6.89277 16 7.37581 15.8172 7.9365 15.4098C8.48745 15.0094 9.02767 14.4541 9.51373 13.8641C9.99579 13.279 10.4009 12.6889 10.6866 12.2423C10.7422 12.1554 10.7931 12.0742 10.8389 12C10.7931 11.9258 10.7422 11.8446 10.6866 11.7577C10.4009 11.3111 9.99579 10.721 9.51373 10.1359C9.02767 9.54588 8.48745 8.99058 7.9365 8.59022C7.37581 8.18279 6.89277 8 6.5 8ZM13.1611 12C13.2069 12.0742 13.2578 12.1554 13.3134 12.2423C13.5991 12.6889 14.0042 13.279 14.4863 13.8641C14.9723 14.4541 15.5125 15.0094 16.0635 15.4098C16.6242 15.8172 17.1072 16 17.5 16C19.5748 16 21 14.3538 21 12C21 9.64616 19.5748 8 17.5 8C17.1072 8 16.6242 8.18279 16.0635 8.59022C15.5125 8.99058 14.9723 9.54588 14.4863 10.1359C14.0042 10.721 13.5991 11.3111 13.3134 11.7577C13.2578 11.8446 13.2069 11.9258 13.1611 12ZM12 13.88C11.7349 14.2656 11.4167 14.6996 11.0573 15.1359C10.5136 15.7959 9.85138 16.4906 9.1122 17.0277C8.38275 17.5578 7.48794 18 6.5 18C3.05193 18 1 15.169 1 12C1 8.83099 3.05193 6 6.5 6C7.48794 6 8.38275 6.44221 9.1122 6.97228C9.85138 7.50942 10.5136 8.20412 11.0573 8.86414C11.4167 9.30035 11.7349 9.73442 12 10.12C12.2651 9.73442 12.5833 9.30035 12.9427 8.86414C13.4864 8.20412 14.1486 7.50942 14.8878 6.97228C15.6172 6.44221 16.5121 6 17.5 6C20.9481 6 23 8.83099 23 12C23 15.169 20.9481 18 17.5 18C16.5121 18 15.6172 17.5578 14.8878 17.0277C14.1486 16.4906 13.4864 15.7959 12.9427 15.1359C12.5833 14.6996 12.2651 14.2656 12 13.88Z" />
    </svg>
);

--- END OF FILE components/icons/AuthIcons.tsx ---

================================================================================

--- START OF FILE components/icons/index.tsx ---

// components/icons/index.tsx
'use client';

import React from 'react';

export const ReviewIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
    </svg>
);

export const ArticleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
    </svg>
);

export const NewsIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="2" y1="12" x2="22" y2="12"></line>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
    </svg>
);

export const ReleaseIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M17.2014 2H6.79876C5.341 2 4.06202 2.9847 4.0036 4.40355C3.93009 6.18879 5.18564 7.37422 6.50435 8.4871C8.32861 10.0266 9.24075 10.7964 9.33642 11.7708C9.35139 11.9233 9.35139 12.0767 9.33642 12.2292C9.24075 13.2036 8.32862 13.9734 6.50435 15.5129C5.14932 16.6564 3.9263 17.7195 4.0036 19.5964C4.06202 21.0153 5.341 22 6.79876 22L17.2014 22C18.6591 22 19.9381 21.0153 19.9965 19.5964C20.043 18.4668 19.6244 17.342 18.7352 16.56C18.3298 16.2034 17.9089 15.8615 17.4958 15.5129C15.6715 13.9734 14.7594 13.2036 14.6637 12.2292C14.6487 12.0767 14.6487 11.9233 14.6637 11.7708C14.7594 10.7964 15.6715 10.0266 17.4958 8.4871C18.8366 7.35558 20.0729 6.25809 19.9965 4.40355C19.9381 2.9847 18.6591 2 17.2014 2Z" stroke="currentColor" strokeWidth="2"></path>
    </svg>
);

export const AllBookmarkIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M3 7C3 6.0335 3.7835 5.25 4.75 5.25H15.75C16.7165 5.25 17.5 6.0335 17.5 7V22C17.5 22.2717 17.353 22.5222 17.1159 22.6547C16.8787 22.7873 16.5883 22.7811 16.3569 22.6387L10.25 18.8806L4.14307 22.6387C3.91167 22.7811 3.62134 22.7873 3.38415 22.6547C3.14696 22.5222 3 22.2717 3 22V7Z" fill="currentColor"></path>
        <path fillRule="evenodd" clipRule="evenodd" d="M6.75 3C6.75 2.44772 7.19772 2 7.75 2H17.75C19.4069 2 20.75 3.34315 20.75 5V19C20.75 19.5523 20.3023 20 19.75 20C19.1977 20 18.75 19.5523 18.75 19V5C18.75 4.44772 18.3023 4 17.75 4H7.75C7.19772 4 6.75 3.55228 6.75 3Z" fill="currentColor"></path>
    </svg>
);

export const UserSettings01Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M17.7498 12.25C18.3021 12.25 18.7498 12.6977 18.7498 13.25L18.7498 13.895C19.2875 14.0551 19.7708 14.3409 20.1657 14.7176L20.7537 14.3816C21.2332 14.1076 21.8441 14.2742 22.1181 14.7537C22.3921 15.2332 22.2255 15.8441 21.746 16.1181L21.1586 16.4537C21.2183 16.7099 21.2498 16.9765 21.2498 17.25C21.2498 17.5234 21.2183 17.7899 21.1587 18.046L21.746 18.3816C22.2255 18.6556 22.3921 19.2665 22.1181 19.746C21.8441 20.2255 21.2332 20.3921 20.7537 20.1181L20.1659 19.7822C19.7709 20.1591 19.2876 20.4449 18.7498 20.605L18.7498 21.25C18.7498 21.8023 18.3021 22.25 17.7498 22.25C17.1975 22.25 16.7498 21.8023 16.7498 21.25L16.7498 20.605C16.2121 20.4449 15.7287 20.159 15.3338 19.7822L14.746 20.1181C14.2665 20.3921 13.6556 20.2255 13.3816 19.746C13.1076 19.2665 13.2742 18.6556 13.7537 18.3816L14.341 18.046C14.2814 17.7899 14.2498 17.5234 14.2498 17.25C14.2498 16.9765 14.2814 16.7099 14.341 16.4537L13.7537 16.1181C13.2742 15.8441 13.1076 15.2332 13.3816 14.7537C13.6556 14.2742 14.2665 14.1076 14.746 14.3816L15.334 14.7176C15.7289 14.3409 16.2122 14.0551 16.7498 13.895L16.7498 13.25C16.7498 12.6977 17.1975 12.25 17.7498 12.25ZM17.7498 15.75C17.1936 15.75 16.7067 16.0523 16.4467 16.5063C16.3216 16.7246 16.2498 16.9774 16.2498 17.25C16.2498 17.5225 16.3216 17.7753 16.4466 17.9935C16.7066 18.4477 17.1935 18.75 17.7498 18.75C18.3061 18.75 18.7931 18.4477 19.0531 17.9935C19.1781 17.7753 19.2498 17.5225 19.2498 17.25C19.2498 16.9774 19.178 16.7246 19.053 16.5063C18.793 16.0523 18.3061 15.75 17.7498 15.75Z" fill="currentColor"></path>
        <path d="M12.2343 20.25H2.5C2.08579 20.25 1.75 19.9142 1.75 19.5C1.75 15.8234 4.31022 12.7447 7.7451 11.9495C5.70857 11.2274 4.25 9.28405 4.25 7C4.25 4.10051 6.6005 1.75 9.5 1.75C12.3995 1.75 14.75 4.10051 14.75 7C14.75 9.28405 13.2914 11.2274 11.2549 11.9495C12.1744 12.1624 13.0312 12.5389 13.793 13.0467C13.1837 13.1733 12.6294 13.5507 12.2964 14.1335C11.7057 15.1672 12.025 16.4721 13.0016 17.1219L13.0016 17.3778C12.0612 18.0035 11.7303 19.2365 12.2343 20.25Z" fill="currentColor"></path>
    </svg>
);

export const UserCircleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M6.75 8C6.75 5.1005 9.1005 2.75 12 2.75C14.8995 2.75 17.25 5.1005 17.25 8C17.25 10.8995 14.8995 13.25 12 13.25C9.1005 13.25 6.75 10.8995 6.75 8Z" fill="currentColor"></path>
        <path d="M4.25 20.5C4.25 16.2198 7.71979 12.75 12 12.75C16.2802 12.75 19.75 16.2198 19.75 20.5C19.75 20.9142 19.4142 21.25 19 21.25H5C4.58579 21.25 4.25 20.9142 4.25 20.5Z" fill="currentColor"></path>
    </svg>
);

export const Calendar03Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M7 13.2734C7 12.7212 7.44772 12.2734 8 12.2734H8.00897C8.56126 12.2734 9.00897 12.7212 9.00897 13.2734C9.00897 13.8257 8.56126 14.2734 8.00897 14.2734H8C7.44772 14.2734 7 13.8257 7 13.2734ZM10.9955 13.2734C10.9955 12.7212 11.4432 12.2734 11.9955 12.2734H12.0045C12.5568 12.2734 13.0045 12.7212 13.0045 13.2734C13.0045 13.8257 12.5568 14.2734 12.0045 14.2734H11.9955C11.4432 14.2734 10.9955 13.8257 10.9955 13.2734ZM14.991 13.2734C14.991 12.7212 15.4387 12.2734 15.991 12.2734H16C16.5523 12.2734 17 12.7212 17 13.2734C17 13.8257 16.5523 14.2734 16 14.2734H15.991C15.4387 14.2734 14.991 13.8257 14.991 13.2734ZM7 17.2734C7 16.7212 7.44772 16.2734 8 16.2734H8.00897C8.56126 16.2734 9.00897 16.7212 9.00897 17.2734C9.00897 17.8257 8.56126 18.2734 8.00897 18.2734H8C7.44772 18.2734 7 17.8257 7 17.2734ZM10.9955 17.2734C10.9955 16.7212 11.4432 16.2734 11.9955 16.2734H12.0045C12.5568 16.2734 13.0045 16.7212 13.0045 17.2734C13.0045 17.8257 12.5568 18.2734 12.0045 18.2734H11.9955C11.4432 18.2734 10.9955 17.8257 10.9955 17.2734Z" fill="currentColor"></path>
        <path fillRule="evenodd" clipRule="evenodd" d="M7.6125 1.25C8.15098 1.25 8.5875 1.68754 8.5875 2.22727V3.20455H15.4125V2.22727C15.4125 1.68754 15.849 1.25 16.3875 1.25C16.926 1.25 17.3625 1.68754 17.3625 2.22727V3.20455H18.825C20.4404 3.20455 21.75 4.51717 21.75 6.13636V19.8182C21.75 21.4374 20.4404 22.75 18.825 22.75H5.175C3.55957 22.75 2.25 21.4374 2.25 19.8182V6.13636C2.25 4.51717 3.55957 3.20455 5.175 3.20455H6.6375V2.22727C6.6375 1.68754 7.07403 1.25 7.6125 1.25ZM19.7999 9.75H4.19995V19.8182C4.19995 20.3579 4.63647 20.7955 5.17495 20.7955H18.8249C19.3634 20.7955 19.7999 20.3579 19.7999 19.8182V9.75Z" fill="currentColor"></path>
    </svg>
);

export const FilterHorizontalIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line>
        <line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line>
        <line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line>
        <line x1="17" y1="16" x2="23" y2="16"></line>
    </svg>
);

export const FilterRemoveIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M14.1679 6.56033C14.5584 6.1698 15.1916 6.1698 15.5821 6.56033L17.875 8.85322L20.1679 6.56033C20.5584 6.1698 21.1916 6.1698 21.5821 6.56033C21.9726 6.95085 21.9726 7.58402 21.5821 7.97454L19.2892 10.2674L21.5821 12.5603C21.9726 12.9509 21.9726 13.584 21.5821 13.9745C21.1916 14.3651 20.5584 14.3651 20.1679 13.9745L17.875 11.6816L15.5821 13.9745C15.1916 14.3651 14.5584 14.3651 14.1679 13.9745C13.7774 13.584 13.7774 12.9509 14.1679 12.5603L16.4608 10.2674L14.1679 7.97454C13.7774 7.58402 13.7774 6.95085 14.1679 6.56033Z" fill="currentColor"></path>
        <path d="M3.875 2.51743C2.9085 2.51743 2.125 3.30093 2.125 4.26743V6.79906C2.125 7.31842 2.35569 7.81096 2.75468 8.14345L8.08562 12.5859C8.13522 12.6272 8.16691 12.6862 8.17404 12.7503L8.97114 19.9242C9.10563 21.1347 10.4047 21.841 11.4937 21.2959L13.7296 20.1768C14.2447 19.9189 14.5999 19.4242 14.6795 18.8537L15.0997 15.8419C15.104 15.8112 15.1139 15.7816 15.129 15.7546C14.4074 15.8278 13.6601 15.588 13.1072 15.0352C12.1309 14.0589 12.1309 12.476 13.1072 11.4997L14.3395 10.2674L13.1072 9.0352C12.1309 8.05889 12.1309 6.47598 13.1072 5.49967C14.0835 4.52336 15.6665 4.52336 16.6428 5.49967L17.875 6.7319L19.1072 5.49967C19.7775 4.82938 20.7337 4.61928 21.5833 4.86936C21.6109 4.74515 21.625 4.61776 21.625 4.48939V4.26743C21.625 3.30093 20.8415 2.51743 19.875 2.51743H3.875Z" fill="currentColor"></path>
    </svg>
);

export const PenEdit02Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M18.7116 3.40901C17.833 2.53033 16.4083 2.53033 15.5296 3.40901L13.4997 5.43906L18.5604 10.4997L20.5903 8.46965C21.469 7.59098 21.469 6.16637 20.5903 5.28769L18.7116 3.40901ZM17.4997 11.5604L12.4391 6.49975L3.40899 15.5303C2.98705 15.9523 2.75 16.5246 2.75 17.1213V20.5C2.75 20.9142 3.08579 21.25 3.5 21.25H6.87868C7.47542 21.25 8.04773 21.0129 8.46969 20.591L17.4997 11.5604Z" fill="currentColor"></path>
    </svg>
);

export const ColorPaletteIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M11.75 1C8.02208 1 5 4.02208 5 7.75C5 10.1303 6.23205 12.2228 8.09321 13.4246C9.08931 10.1405 12.1405 7.75 15.75 7.75C16.71 7.75 17.6304 7.91908 18.4833 8.22909C18.4944 8.07084 18.5 7.91108 18.5 7.75C18.5 4.02208 15.4779 1 11.75 1ZM9 15.75C9 12.0221 12.0221 9 15.75 9C19.4779 9 22.5 12.0221 22.5 15.75C22.5 19.4779 19.4779 22.5 15.75 22.5C12.0221 22.5 9 19.4779 9 15.75ZM7.81601 14.7173C6.04546 13.7155 4.69468 12.0583 4.09321 10.0752C2.23204 11.277 1 13.3695 1 15.7498C1 19.4777 4.02208 22.4998 7.75 22.4998C8.76796 22.4998 9.7333 22.2745 10.5988 21.871C8.8568 20.4035 7.75 18.2059 7.75 15.7498C7.75 15.4 7.77246 15.0553 7.81601 14.7173Z" fill="currentColor"></path>
    </svg>
);

export const SparklesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M15 1.25C15.3507 1.25 15.6546 1.49305 15.7317 1.83518L16.2704 4.22676C16.6637 5.97278 18.0272 7.33629 19.7732 7.7296L22.1648 8.26833C22.507 8.3454 22.75 8.64929 22.75 9C22.75 9.35071 22.507 9.6546 22.1648 9.73167L19.7732 10.2704C18.0272 10.6637 16.6637 12.0272 16.2704 13.7732L15.7317 16.1648C15.6546 16.507 15.3507 16.75 15 16.75C14.6493 16.75 14.3454 16.507 14.2683 16.1648L13.7296 13.7732C13.3363 12.0272 11.9728 10.6637 10.2268 10.2704L7.83518 9.73167C7.49305 9.6546 7.25 9.35071 7.25 9C7.25 8.64929 7.49305 8.3454 7.83518 8.26833L10.2268 7.7296C11.9728 7.33629 13.3363 5.97278 13.7296 4.22676L14.2683 1.83518C14.3454 1.49305 14.6493 1.25 15 1.25Z" fill="currentColor"></path>
        <path d="M7 11.25C7.35071 11.25 7.6546 11.493 7.73167 11.8352L8.11647 13.5435C8.37923 14.7099 9.29012 15.6208 10.4565 15.8835L12.1648 16.2683C12.507 16.3454 12.75 16.6493 12.75 17C12.75 17.3507 12.507 17.6546 12.1648 17.7317L10.4565 18.1165C9.29012 18.3792 8.37923 19.2901 8.11647 20.4565L7.73167 22.1648C7.6546 22.507 7.35071 22.75 7 22.75C6.64929 22.75 6.3454 22.507 6.26833 22.1648L5.88353 20.4565C5.62077 19.2901 4.70988 18.3792 3.54345 18.1165L1.83518 17.7317C1.49305 17.6546 1.25 17.3507 1.25 17C1.25 16.6493 1.49305 16.3454 1.83518 16.2683L3.54345 15.8835C4.70988 15.6208 5.62077 14.7099 5.88353 13.5435L6.26833 11.8352C6.3454 11.493 6.64929 11.25 7 11.25Z" fill="currentColor"></path>
    </svg>
);

export const Logout03Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M16.75 5.49986V4.24986C16.75 3.69758 16.3023 3.24986 15.75 3.24986H6.25C5.69772 3.24986 5.25 3.69758 5.25 4.24986V19.7499C5.25 20.3022 5.69772 20.7499 6.25 20.7499H15.75C16.3023 20.7499 16.75 20.3022 16.75 19.7499V18.4999C16.75 17.9476 17.1977 17.4999 17.75 17.4999C18.3023 17.4999 18.75 17.9476 18.75 18.4999V19.7499C18.75 21.4067 17.4069 22.7499 15.75 22.7499H6.25C4.59315 22.7499 3.25 21.4067 3.25 19.7499V4.24986C3.25 2.59301 4.59315 1.24986 6.25 1.24986H15.75C17.4069 1.24986 18.75 2.59301 18.75 4.24986V5.49986C18.75 6.05215 18.3023 6.49986 17.75 6.49986C17.1977 6.49986 16.75 6.05215 16.75 5.49986Z" fill="currentColor"></path>
        <path d="M14.9746 6.91992C14.7503 6.73641 14.4406 6.69817 14.1787 6.82227C13.9169 6.94638 13.75 7.21025 13.75 7.5V9.75H9C8.58579 9.75 8.25 10.0858 8.25 10.5V13.5C8.25 13.6989 8.32907 13.8896 8.46973 14.0303C8.61038 14.1709 8.80109 14.25 9 14.25H13.75V16.5C13.75 16.7898 13.9169 17.0536 14.1787 17.1777C14.4406 17.3018 14.7503 17.2636 14.9746 17.0801L20.4746 12.5801C20.6487 12.4376 20.75 12.2249 20.75 12C20.75 11.7751 20.6487 11.5624 20.4746 11.4199L14.9746 6.91992Z" fill="currentColor"></path>
    </svg>
);

export const CheckIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M15.9571 9.45711C16.3476 9.06658 16.3476 8.43342 15.9571 8.04289C15.5666 7.65237 14.9334 7.65237 14.5429 8.04289L11.25 11.3358L9.95711 10.0429C9.56658 9.65237 8.93342 9.65237 8.54289 10.0429C8.15237 10.4334 8.15237 11.0666 8.54289 11.4571L10.5429 13.4571C10.9334 13.8476 11.5666 13.8476 11.9571 13.4571L15.9571 9.45711Z" fill="currentColor"></path>
    </svg>
);

export const CancelIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M17.4131 4.46973C17.2725 4.32919 17.0815 4.25012 16.8828 4.25C16.7336 4.25 16.5891 4.29444 16.4668 4.37598L16.3525 4.46973L11.997 8.81934L7.65037 4.46973C7.50975 4.32906 7.31899 4.25005 7.1201 4.25C6.97096 4.24998 6.82638 4.29448 6.70408 4.37598L6.58982 4.46973L4.46971 6.58984C4.17696 6.88269 4.17697 7.3575 4.46971 7.65039L8.81639 11.999L4.46971 16.3467C4.17687 16.6395 4.17698 17.1143 4.46971 17.4072L6.58982 19.5273C6.73047 19.668 6.92119 19.7471 7.1201 19.7471C7.31894 19.747 7.50976 19.668 7.65037 19.5273L11.997 15.1797L16.3437 19.5264C16.6365 19.8191 17.1113 19.8199 17.4043 19.5273L19.5254 17.4082C19.666 17.2676 19.745 17.0768 19.7451 16.8779C19.7451 16.679 19.666 16.4883 19.5254 16.3477L15.1777 12L19.5312 7.65234C19.8242 7.35974 19.8246 6.88489 19.5322 6.5918L17.4131 4.46973Z" fill="currentColor"></path>
    </svg>
);

export const StudioIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M22.0002 5.14752V18.8525C22.0002 19.2465 21.7696 19.6037 21.4113 19.7649L16.6643 21.9003C16.6184 21.9275 16.5692 21.9498 16.5175 21.9663C16.4489 21.9882 16.3759 22 16.3001 22C16.1195 22 15.9455 21.9315 15.8131 21.8081L2.31506 9.20638C1.90446 8.81995 1.89411 8.16933 2.29222 7.76997L2.94181 7.11833C3.29478 6.76425 3.85441 6.72665 4.2513 7.03035L17.0159 16.5V7.5L11.723 11.38L8.49192 9.01144L15.8131 2.19186C15.9455 2.06854 16.1195 2 16.3001 2C16.3759 2 16.4489 2.01181 16.5175 2.0337C16.5692 2.05022 16.6184 2.07248 16.6643 2.09974L21.4113 4.23506C21.7696 4.39626 22.0002 4.75353 22.0002 5.14752Z" fill="currentColor"></path>
        <path d="M2.94181 16.8817L2.29222 16.23C1.89411 15.8307 1.90446 15.18 2.31506 14.7936L4.55397 12.6866L6.94156 14.911L4.2513 16.9696C3.85441 17.2733 3.29478 17.2357 2.94181 16.8817Z" fill="currentColor"></path>
    </svg>
);

export const PreviewIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <circle cx="12" cy="12" r="3"></circle>
    </svg>
);

export const NotificationIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M19 18V9.5C19 5.63401 15.866 2.5 12 2.5C8.13401 2.5 5 5.63401 5 9.5V18"></path>
        <path d="M20.5 18H3.5"></path>
        <path d="M13.5 20C13.5 20.8284 12.8284 21.5 12 21.5M10.5 20C10.5 20.8284 11.1716 21.5 12 21.5M12 21.5V20"></path>
    </svg>
);

--- END OF FILE components/icons/index.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PCIcon.tsx ---

// components/icons/platforms/PCIcon.tsx
export default function PCIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 24 24" fill="currentColor" {...props}>
            <path d="M4 2H20C21.1 2 22 2.9 22 4V16C22 17.1 21.1 18 20 18H13V20H15V22H9V20H11V18H4C2.9 18 2 17.1 2 16V4C2 2.9 2.9 2 4 2M4 4V16H20V4H4Z" />
        </svg>
    );
}










--- END OF FILE components/icons/platforms/PCIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PS5Icon.tsx ---

// components/icons/platforms/PS5Icon.tsx
export default function PS5Icon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M3.262 24.248c-2.374-0.681-2.767-2.084-1.69-2.899 0.776-0.51 1.668-0.954 2.612-1.288l0.087-0.027 7.017-2.516v2.89l-5.030 1.839c-0.881 0.339-1.031 0.79-0.299 1.032 0.365 0.093 0.783 0.147 1.214 0.147 0.615 0 1.204-0.109 1.749-0.308l-0.035 0.011 2.422-0.882v2.592c-0.15 0.037-0.32 0.055-0.487 0.091-0.775 0.136-1.667 0.214-2.577 0.214-1.778 0-3.486-0.298-5.078-0.846l0.11 0.033zM18.049 24.544l7.868-2.843c0.893-0.322 1.032-0.781 0.307-1.022-0.363-0.089-0.779-0.14-1.208-0.14-0.622 0-1.22 0.108-1.774 0.305l0.037-0.011-5.255 1.874v-2.983l0.3-0.106c1.050-0.349 2.284-0.62 3.557-0.761l0.083-0.008c0.468-0.050 1.010-0.078 1.559-0.078 1.877 0 3.677 0.331 5.343 0.939l-0.108-0.035c2.309 0.751 2.549 1.839 1.969 2.589-0.559 0.557-1.235 0.998-1.988 1.282l-0.039 0.013-10.677 3.883v-2.869zM12.231 4.248v21.927l4.892 1.576v-18.39c0-0.862 0.38-1.438 0.992-1.238 0.795 0.225 0.95 1.017 0.95 1.881v7.342c3.050 1.491 5.451-0.003 5.451-3.939 0-4.045-1.407-5.842-5.546-7.282-1.785-0.648-4.040-1.294-6.347-1.805l-0.389-0.072z" />
        </svg>
    );
}










--- END OF FILE components/icons/platforms/PS5Icon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/SwitchIcon.tsx ---

// components/icons/platforms/SwitchIcon.tsx
export default function SwitchIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M18.901 32h4.901c4.5 0 8.198-3.698 8.198-8.198v-15.604c0-4.5-3.698-8.198-8.198-8.198h-5c-0.099 0-0.203 0.099-0.203 0.198v31.604c0 0.099 0.099 0.198 0.302 0.198zM25 14.401c1.802 0 3.198 1.5 3.198 3.198 0 1.802-1.5 3.198-3.198 3.198-1.802 0-3.198-1.396-3.198-3.198-0.104-1.797 1.396-3.198 3.198-3.198zM15.198 0h-7c-4.5 0-8.198 3.698-8.198 8.198v15.604c0 4.5 3.698 8.198 8.198 8.198h7c0.099 0 0.203-0.099 0.203-0.198v-31.604c0-0.099-0.099-0.198-0.203-0.198zM12.901 29.401h-4.703c-3.099 0-5.599-2.5-5.599-5.599v-15.604c0-3.099 2.5-5.599 5.599-5.599h4.604zM5 9.599c0 1.698 1.302 3 3 3s3-1.302 3-3c0-1.698-1.302-3-3-3s-3 1.302-3 3z"/>
        </svg>
    );
}










--- END OF FILE components/icons/platforms/SwitchIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/XboxIcon.tsx ---

// components/icons/platforms/XboxIcon.tsx
export default function XboxIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M16 5.425c-1.888-1.125-4.106-1.922-6.473-2.249l-0.092-0.010c-0.070-0.005-0.152-0.008-0.234-0.008-0.613 0-1.188 0.16-1.687 0.441l0.017-0.009c2.357-1.634 5.277-2.61 8.426-2.61 0.008 0 0.016 0 0.024 0h0.019c0.005 0 0.011 0 0.018 0 3.157 0 6.086 0.976 8.501 2.642l-0.050-0.033c-0.478-0.272-1.051-0.433-1.662-0.433-0.085 0-0.169 0.003-0.252 0.009l0.011-0.001c-2.459 0.336-4.677 1.13-6.648 2.297l0.082-0.045zM5.554 5.268c-0.041 0.014-0.077 0.032-0.11 0.054l0.002-0.001c-2.758 2.723-4.466 6.504-4.466 10.684 0 3.584 1.256 6.875 3.353 9.457l-0.022-0.028c-1.754-3.261 4.48-12.455 7.61-16.159-3.53-3.521-5.277-4.062-6.015-4.062-0.010-0-0.021-0.001-0.032-0.001-0.115 0-0.225 0.021-0.326 0.060l0.006-0.002zM20.083 9.275c3.129 3.706 9.367 12.908 7.605 16.161 2.075-2.554 3.332-5.845 3.332-9.43 0-4.181-1.709-7.962-4.467-10.684l-0.002-0.002c-0.029-0.021-0.063-0.039-0.1-0.052l-0.003-0.001c-0.1-0.036-0.216-0.056-0.336-0.056-0.005 0-0.011 0-0.016 0h0.001c-0.741-0-2.485 0.543-6.014 4.063zM6.114 27.306c2.627 2.306 6.093 3.714 9.888 3.714s7.261-1.407 9.905-3.728l-0.017 0.015c2.349-2.393-5.402-10.901-9.89-14.29-4.483 3.39-12.24 11.897-9.886 14.29z" />
        </svg>
    );
}










--- END OF FILE components/icons/platforms/XboxIcon.tsx ---

================================================================================

--- START OF FILE components/modals/Modal.tsx ---

// components/modals/Modal.tsx
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './Modals.module.css';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
    className?: string;
    style?: React.CSSProperties;
}

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring' as const, damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export default function Modal({ isOpen, onClose, children, className, style }: ModalProps) {
    const [isMounted, setIsMounted] = useState(false);

    useEffect(() => {
        setIsMounted(true);
    }, []);

    const modalContent = (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    className={styles.modalOverlay}
                    onClick={onClose}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                >
                    <motion.div
                        className={`${styles.modalContent} ${className || ''}`}
                        style={style}
                        variants={modalVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        onClick={(e) => e.stopPropagation()}
                    >
                        {children}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) {
        return null;
    }

    return createPortal(modalContent, document.body);
}




--- END OF FILE components/modals/Modal.tsx ---

================================================================================

--- START OF FILE components/modals/Modals.module.css ---

/* components/modals/Modals.module.css */

.modalOverlay {
  position: fixed;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5000;
  padding: 2rem;
}

.modalContent {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 3rem;
  max-width: 450px;
  width: 100%;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

.modalActions {
  display: flex;
  justify-content: flex-start;
  gap: 1rem;
}




--- END OF FILE components/modals/Modals.module.css ---

================================================================================

--- START OF FILE components/news/NewsGrid.module.css ---

/* components/news/NewsGrid.module.css */

.newsGrid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 3rem;
    grid-auto-rows: 1fr;
}

@media (max-width: 768px) {
    .newsGrid {
        grid-template-columns: 1fr;
        gap: 2rem;
    }
}

--- END OF FILE components/news/NewsGrid.module.css ---

================================================================================

--- START OF FILE components/news/NewsGrid.tsx ---

// components/news/NewsGrid.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import NewsGridCard from './NewsGridCard';
import { CardProps } from '@/types';
import React from 'react'; 
import styles from './NewsGrid.module.css';

export default function NewsGrid({ news }: { news: CardProps[] }) {
    return (
        <motion.div 
            layout 
            className={styles.newsGrid}
        >
            <AnimatePresence mode="popLayout">
                {news.map((item, index) => (
                    <motion.div
                        key={item.legacyId}
                        layout
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0, scale: 0.8 }}
                        transition={{ 
                            type: 'spring' as const, 
                            stiffness: 400, 
                            damping: 30, 
                        }}
                        style={{ height: '100%', willChange: 'transform, opacity' }}
                    >
                        <NewsGridCard 
                            item={item} 
                            isPriority={index < 4}
                            layoutIdPrefix="news-grid"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </motion.div>
    );
}

--- END OF FILE components/news/NewsGrid.tsx ---

================================================================================

--- START OF FILE components/news/NewsGridCard.module.css ---

/* components/news/NewsGridCard.module.css */

.cardContainer {
    transform-style: preserve-3d;
    height: 100%;
    position: relative;
    cursor: pointer;
}

.newsCard {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    height: 100%;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transform-style: preserve-3d;
    transition: box-shadow 0.4s ease-out, border-color 0.4s ease-out;
}

.cardContainer:hover .newsCard {
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 15%, transparent);
}

.cardLink {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    color: var(--text-primary);
}

.imageContentWrapper {
    display: grid;
    grid-template-columns: 140px 1fr;
    gap: 1.5rem;
    padding: 1.5rem;
    align-items: center;
    flex-grow: 1;
}

.imageContainer {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 10;
    border-radius: 6px;
    overflow: hidden;
    flex-shrink: 0;
}

.cardImage {
    transition: transform 0.4s ease;
}

.cardContainer:hover .cardImage {
    transform: scale(1.05);
}

.cardInfo {
    text-align: right;
    transform: translateZ(20px);
    /* NEW: Prevent child from overflowing */
    overflow: hidden;
}

/* ENHANCEMENT: Styles for Tactile Tag Interaction */
.cardCategory {
    position: relative;
    display: inline-block;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--accent);
    margin-bottom: 0.5rem;
    padding: 0.2rem 0.6rem;
    border-radius: 4px;
    z-index: 1;
    transition: color 0.3s ease;
}
.cardCategory::before {
    content: '';
    position: absolute;
    inset: 0;
    background-color: var(--accent);
    border-radius: 4px;
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
    z-index: -1;
}
.cardContainer:hover .cardCategory {
    color: var(--bg-primary);
}
.cardContainer:hover .cardCategory::before {
    transform: scaleX(1);
}

.cardTitle {
    font-size: 1.8rem;
    line-height: 1.35;
    font-weight: 600;
    margin: 0;
    position: relative;
    /* display: inline-block; <-- REMOVED: This was causing the overflow issue. */
    transition: color 0.2s ease;
    overflow-wrap: break-word; /* ADDED: Ensures long strings without spaces can wrap. */
}

.cardTitle::after {
    content: '';
    position: absolute;
    bottom: -4px;
    right: 0;
    width: 100%;
    height: 1px;
    background: var(--accent);
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
}

.cardContainer:hover .cardTitle {
    color: var(--accent);
}

.cardContainer:hover .cardTitle::after {
    transform: scaleX(1);
}

.cardMetadata {
    border-top: 1px solid var(--border-color);
    padding: 1rem 1.5rem;
    font-size: 1.3rem;
    color: var(--text-secondary);
    display: flex;
    justify-content: space-between;
    align-items: center;
    transform: translateZ(10px);
}

.cardDate {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.metadataIcon {
    width: 14px;
    height: 14px;
    color: var(--accent);
}

@media (max-width: 768px) {
    .imageContentWrapper {
        grid-template-columns: 100px 1fr;
    }
    .cardTitle {
        font-size: 1.6rem;
    }
    .cardMetadata {
        padding: 0.75rem 1rem;
        font-size: 1.2rem;
    }
}

--- END OF FILE components/news/NewsGridCard.module.css ---

================================================================================

--- START OF FILE components/news/NewsGridCard.tsx ---

// components/news/NewsGridCard.tsx
'use client';

import React, { memo } from 'react';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { CardProps } from '@/types';
import { sanityLoader } from '@/lib/sanity.loader';
import { Calendar03Icon } from '@/components/icons';
import styles from './NewsGridCard.module.css';
import CreatorCredit from '../CreatorCredit';
import { translateTag } from '@/lib/translations';

type NewsGridCardProps = {
    item: CardProps;
    isPriority?: boolean;
    layoutIdPrefix: string;
};

const NewsGridCardComponent = ({ item, isPriority = false, layoutIdPrefix }: NewsGridCardProps) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix); 
    const { livingCardRef, livingCardAnimation } = useLivingCard();

    const linkPath = `/news/${item.slug}`;
    
    const handleClick = (e: React.MouseEvent) => {
        if ((e.target as HTMLElement).closest('a, button, [role="button"]')) {
            return;
        }
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    const handleMouseEnter = () => {
        router.prefetch(linkPath);
    };

    const imageSource = item.imageUrl;
    if (!imageSource) return null;

    return (
        <motion.div
            ref={livingCardRef}
            onMouseMove={livingCardAnimation.onMouseMove}
            onMouseEnter={() => { livingCardAnimation.onMouseEnter(); handleMouseEnter(); }}
            onMouseLeave={livingCardAnimation.onMouseLeave}
            onTouchStart={livingCardAnimation.onTouchStart}
            onTouchEnd={livingCardAnimation.onTouchEnd}
            onTouchCancel={livingCardAnimation.onTouchCancel}
            onClick={handleClick}
            className={styles.cardContainer}
            style={livingCardAnimation.style}
        >
            <motion.div
                layoutId={`${layoutIdPrefix}-card-container-${item.legacyId}`}
                className={styles.newsCard}
                initial={{ opacity: 0, y: 50, scale: 0.95 }}
                animate={{ opacity: 1, y: 0, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ type: 'spring', stiffness: 200, damping: 25 }}
            >
                <div className={`${styles.cardLink} no-underline`}>
                    <div className={styles.imageContentWrapper}>
                        <motion.div 
                            className={styles.imageContainer} 
                            layoutId={`${layoutIdPrefix}-card-image-${item.legacyId}`}
                        >
                            <Image 
                                loader={sanityLoader}
                                src={imageSource}
                                alt={item.title}
                                width={300}
                                height={180}
                                sizes="(max-width: 768px) 100px, 140px"
                                className={styles.cardImage}
                                style={{ objectFit: 'cover' }}
                                placeholder="blur" 
                                blurDataURL={item.blurDataURL}
                                priority={isPriority}
                            />
                        </motion.div>
                        <div className={styles.cardInfo}>
                            {item.category && (
                                <p className={styles.cardCategory}>{translateTag(item.category)}</p>
                            )}
                            <motion.h3 
                                className={styles.cardTitle}
                                layoutId={`${layoutIdPrefix}-card-title-${item.legacyId}`}
                            >
                                {item.title}
                            </motion.h3>
                        </div>
                    </div>
                    
                    <div className={styles.cardMetadata}>
                        <CreatorCredit label="بواسطة" creators={item.authors} small />
                        {item.date && (
                            <div className={styles.cardDate}>
                                <Calendar03Icon className={styles.metadataIcon} />
                                <span>{item.date}</span>
                            </div>
                        )}
                    </div>
                </div>
            </motion.div>
        </motion.div>
    );
};

const NewsGridCard = memo(NewsGridCardComponent);
export default NewsGridCard;

--- END OF FILE components/news/NewsGridCard.tsx ---

================================================================================

--- START OF FILE components/news/NewsHero.module.css ---

/* components/news/NewsHero.module.css */

.heroContainer {
    position: relative;
    height: 65vh;
    min-height: 500px;
    width: 100%;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    color: #fff;
    padding-top: var(--nav-height-scrolled);
}

.heroBackground {
    position: absolute;
    inset: 0;
    z-index: -2;
    overflow: hidden;
}

.heroOverlay {
    position: absolute;
    inset: 0;
    z-index: -1;
    background: linear-gradient(to top, rgba(0,0,0,0.95) 10%, rgba(0,0,0,0.6) 35%, transparent 100%);
}

.heroContentWrapper {
    position: relative;
    z-index: 10;
    padding-bottom: 4rem;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

.activeStoryContainer {
    max-width: 650px;
    padding: 0 2rem;
    text-align: right;
    margin-right: auto; /* RTL alignment */
    margin-left: 0;
    position: relative;
}

.textContent {
    position: relative; 
}

.storyCategory {
    font-size: 1.6rem;
    font-weight: 700;
    color: var(--accent);
    letter-spacing: 1.5px;
    margin-bottom: 0.5rem;
}

.storyTitle {
    font-size: clamp(2.8rem, 4.5vw, 4.5rem); /* MODIFIED: Reduced font size */
    line-height: 1.25;
    margin: 0 0 1.5rem 0;
    text-shadow: 0 2px 15px rgba(0,0,0,0.5);
    display: flex;
    flex-wrap: wrap;
}

.storyMeta {
    font-size: 1.5rem;
    color: var(--text-secondary);
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
}

.storyLink {
    display: inline-block;
    color: #fff;
    text-decoration: none;
    transition: color 0.2s ease;
}

.storyLink:hover {
    color: var(--accent);
}

/* --- Controls/Pagination --- */
.controlsContainer {
    position: absolute;
    right: 4rem;
    left: auto;
    bottom: 50%;
    transform: translateY(50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    z-index: 20;
}

.progressDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4);
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease-out;
    border: none;
    padding: 0;
}

.progressDot:hover {
    transform: scale(1.6);
}

.progressDot.active {
    background-color: var(--accent);
    transform: scale(1.4);
    box-shadow: 0 0 10px var(--accent);
}

/* --- Media Queries --- */

@media (max-width: 1024px) {
    .heroContainer {
        height: 60vh;
        min-height: 450px;
    }
    .storyTitle {
        font-size: clamp(2.4rem, 6vw, 3.6rem); /* MODIFIED: Reduced font size */
    }
    .controlsContainer {
        flex-direction: row;
        left: 50%;
        right: auto; /* Reset right positioning for mobile */
        transform: translateX(-50%);
        bottom: 2rem;
        top: auto;
    }
    .activeStoryContainer {
        max-width: 90%;
        text-align: center;
        margin: 0 auto;
    }
    .storyMeta {
        justify-content: center;
    }
}

--- END OF FILE components/news/NewsHero.module.css ---

================================================================================

--- START OF FILE components/news/NewsHero.tsx ---

// components/news/NewsHero.tsx
'use client';

import React, { useState, useEffect, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { CardProps } from '@/types';
import styles from './NewsHero.module.css';
import { Calendar03Icon } from '@/components/icons';
import CreatorCredit from '@/components/CreatorCredit';
import { translateTag } from '@/lib/translations';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useRouter } from 'next/navigation';

const transition = { type: 'spring' as const, stiffness: 400, damping: 50 };

const titleContainerVariants = {
    animate: { transition: { staggerChildren: 0.08 } },
};

const wordVariants = {
    initial: { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0, transition: { ...transition, duration: 0.8 } },
};

const AnimatedStory = memo(({ item, isActive, layoutIdPrefix }: { item: CardProps; isActive: boolean, layoutIdPrefix: string }) => {
    const primaryTag = item.tags && item.tags.length > 0 ? translateTag(item.tags[0].title) : 'أخبار';
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const router = useRouter();

    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(`/news/${item.slug}`, { scroll: false });
    };

    return (
        <AnimatePresence>
            {isActive && (
                <motion.div 
                    key={item.id}
                    className={styles.activeStoryContainer}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.5 }}
                    onClick={handleClick}
                    style={{ cursor: 'pointer' }}
                >
                    <div className={styles.textContent}>
                        <p className={styles.storyCategory}>{primaryTag}</p>
                        <div className={`${styles.storyLink} no-underline`}>
                            <motion.h1 
                                className={styles.storyTitle} 
                                layoutId={`${layoutIdPrefix}-card-title-${item.legacyId}`}
                                variants={titleContainerVariants}
                                initial="initial"
                                animate="animate"
                            >
                                {item.title.split(' ').map((word, index) => (
                                    <motion.span key={index} variants={wordVariants} style={{ display: 'inline-block', marginRight: '0.6rem' }}>
                                        {word}
                                    </motion.span>
                                ))}
                            </motion.h1>
                        </div>
                        <div className={styles.storyMeta}>
                            <CreatorCredit label="بواسطة" creators={item.authors} small disableLink />
                            <span className={styles.storyMetaDate}>
                                 <Calendar03Icon style={{width:'16px', height: '16px', color: 'var(--accent)'}} /> {item.date}
                            </span>
                        </div>
                    </div>
                </motion.div>
            )}
        </AnimatePresence>
    );
});
AnimatedStory.displayName = "AnimatedStory";


const HeroBackground = memo(({ imageUrl, alt, layoutId }: { imageUrl: string; alt: string; layoutId: string }) => {
    return (
        <motion.div 
            key={imageUrl} 
            className={styles.heroBackground} 
            layoutId={layoutId}
            initial={{ opacity: 0, scale: 1.1 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 1.1 }}
            transition={{ duration: 1.5, ease: [0.22, 1, 0.36, 1] }}
        >
             <Image
                src={imageUrl}
                alt={alt}
                fill
                priority
                style={{ objectFit: 'cover', filter: 'grayscale(10%) brightness(0.7)'}}
                sizes="100vw"
            />
        </motion.div>
    );
});
HeroBackground.displayName = "HeroBackground";


export default function NewsHero({ newsItems }: { newsItems: CardProps[] }) {
    const [activeIndex, setActiveIndex] = useState(0);
    const [isPaused, setIsPaused] = useState(false);
    
    useEffect(() => {
        if (isPaused || newsItems.length <= 1) return;
        const interval = setInterval(() => {
            setActiveIndex((prevIndex) => (prevIndex + 1) % newsItems.length);
        }, 4000);
        return () => clearInterval(interval);
    }, [isPaused, newsItems.length]);
    
    if (newsItems.length === 0) return null;

    const activeItem = newsItems[activeIndex];
    const layoutIdPrefix = "news-hero";

    return (
        <motion.div 
            layoutId={`${layoutIdPrefix}-card-container-${activeItem.legacyId}`}
            className={styles.heroContainer}
            onMouseEnter={() => setIsPaused(true)}
            onMouseLeave={() => setIsPaused(false)}
        >
            <AnimatePresence>
                 <HeroBackground key={activeItem.id} imageUrl={activeItem.imageUrl} alt={activeItem.title} layoutId={`${layoutIdPrefix}-card-image-${activeItem.legacyId}`} />
            </AnimatePresence>
            
            <div className={styles.heroOverlay} />

            <div className={`container ${styles.heroContentWrapper}`}>
                <AnimatePresence mode="wait">
                    <AnimatedStory key={activeItem.id} item={activeItem} isActive={true} layoutIdPrefix={layoutIdPrefix} />
                </AnimatePresence>
            </div>

            <div className={styles.controlsContainer}>
                {newsItems.map((item, index) => (
                    <button
                        key={item.id}
                        className={`${styles.progressDot} ${activeIndex === index ? styles.active : ''}`}
                        onClick={() => setActiveIndex(index)}
                    />
                ))}
            </div>
        </motion.div>
    );
}

--- END OF FILE components/news/NewsHero.tsx ---

================================================================================

--- START OF FILE components/notifications/NotificationBell.tsx ---

// components/notifications/NotificationBell.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { NotificationIcon } from '@/components/icons/index';
import { useSession } from 'next-auth/react';
import NotificationPanel from './NotificationPanel';
import { useNotificationStore } from '@/lib/notificationStore';
import styles from './Notifications.module.css';

const bellVariants = {
    rest: { rotate: 0, scale: 1 },
    hover: { 
        rotate: [0, -10, 10, -5, 5, 0],
        scale: 1.1,
        transition: { 
            duration: 0.5, 
            ease: "easeInOut" as const
        }
    },
    tap: { scale: 0.95, rotate: 0 }
};

export default function NotificationBell() {
    const { data: session } = useSession();
    const [isOpen, setIsOpen] = useState(false);
    const panelRef = useRef<HTMLDivElement>(null);

    const { 
        notifications, 
        unreadCount, 
        fetchNotifications, 
        setUnreadCount, 
        setNotifications 
    } = useNotificationStore();

    const userId = (session?.user as any)?.id;

    // 1. Initial Load: Smart Fetch (Cached)
    // This will NOT fetch if data exists in localStorage and is fresh.
    useEffect(() => {
        if (userId) {
            fetchNotifications(false);
        }
    }, [userId, fetchNotifications]);

    // 2. On Click: Force Fetch (Live)
    const handleToggle = () => {
        const nextState = !isOpen;
        setIsOpen(nextState);
        
        if (nextState) {
            // When opening, force a refresh to get the latest updates
            fetchNotifications(true);
        }
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (panelRef.current && !panelRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        if (isOpen) {
            document.addEventListener('mousedown', handleClickOutside);
        }
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isOpen]);

    if (!session?.user) return null;

    return (
        <div className={styles.notificationWrapper} ref={panelRef}>
            <motion.button
                className={styles.bellButton}
                onClick={handleToggle}
                initial="rest"
                whileHover="hover"
                whileTap="tap"
                variants={bellVariants}
                style={{ transformOrigin: 'top center' }}
                title="الإشعارات"
            >
                <NotificationIcon className={styles.bellIcon} />
                <AnimatePresence>
                    {unreadCount > 0 && (
                        <motion.span
                            key="badge"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            className={styles.notificationBadge}
                        >
                            {unreadCount > 9 ? '9+' : unreadCount}
                        </motion.span>
                    )}
                </AnimatePresence>
            </motion.button>

            <AnimatePresence>
                {isOpen && (
                    <NotificationPanel 
                        notifications={notifications} 
                        onClose={() => setIsOpen(false)}
                        setUnreadCount={setUnreadCount}
                        setNotifications={setNotifications}
                    />
                )}
            </AnimatePresence>
        </div>
    );
}

--- END OF FILE components/notifications/NotificationBell.tsx ---

================================================================================

--- START OF FILE components/notifications/NotificationPanel.tsx ---

// components/notifications/NotificationPanel.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { markNotificationAsRead, markAllNotificationsAsRead } from '@/app/actions/notificationActions';
import TimeStamp from '@/components/comments/TimeStamp';
import styles from './Notifications.module.css';
import { useTransition } from 'react';

const panelVariants = {
    hidden: { opacity: 0, y: 10, scale: 0.95, filter: 'blur(10px)' },
    // THE FIX: Added 'as const' to the transition type to satisfy TypeScript/Framer Motion types
    visible: { opacity: 1, y: 0, scale: 1, filter: 'blur(0px)', transition: { type: 'spring' as const, stiffness: 350, damping: 25 } },
    exit: { opacity: 0, y: 10, scale: 0.95, filter: 'blur(10px)', transition: { duration: 0.2 } }
};

const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 }
};

export default function NotificationPanel({ notifications, onClose, setUnreadCount, setNotifications }: any) {
    const [isPending, startTransition] = useTransition();

    const handleMarkRead = (id: string) => {
        // Optimistic update
        setNotifications((prev: any[]) => prev.map(n => n.id === id ? { ...n, read: true } : n));
        setUnreadCount((prev: number) => Math.max(0, prev - 1));
        
        startTransition(async () => {
            await markNotificationAsRead(id);
        });
        onClose();
    };

    const handleMarkAllRead = () => {
        setNotifications((prev: any[]) => prev.map(n => ({ ...n, read: true })));
        setUnreadCount(0);
        startTransition(async () => {
            await markAllNotificationsAsRead();
        });
    };

    return (
        <motion.div
            className={styles.notificationPanel}
            variants={panelVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
        >
            <div className={styles.panelHeader}>
                <h3>الإشعارات</h3>
                {notifications.length > 0 && (
                    <button onClick={handleMarkAllRead} className={styles.markAllReadButton} disabled={isPending}>
                        تحديد الكل كمقروء
                    </button>
                )}
            </div>

            <div className={styles.notificationsList}>
                {notifications.length === 0 ? (
                    <div className={styles.emptyState}>
                        <p>لا توجد إشعارات جديدة.</p>
                    </div>
                ) : (
                    notifications.map((notification: any) => (
                        <motion.div
                            key={notification.id}
                            className={`${styles.notificationItem} ${!notification.read ? styles.unread : ''}`}
                            variants={itemVariants}
                            layout
                        >
                            <div className={styles.avatarWrapper}>
                                <Image 
                                    src={notification.sender.image || '/default-avatar.svg'} 
                                    alt={notification.sender.name} 
                                    width={40} height={40} 
                                    className={styles.notificationAvatar} 
                                />
                            </div>
                            <div className={styles.notificationContent}>
                                {/* MODIFIED: Use the explicit `link` field from DB */}
                                <Link 
                                    href={notification.link || '#'}
                                    onClick={() => handleMarkRead(notification.id)}
                                    className={styles.notificationLink}
                                >
                                    <p>
                                        <span className={styles.senderName}>{notification.sender.name}</span>
                                        {' '}رد على تعليقك.
                                    </p>
                                </Link>
                                <div className={styles.notificationMeta}>
                                    <TimeStamp date={notification.createdAt} />
                                </div>
                            </div>
                            {!notification.read && <div className={styles.unreadDot} />}
                        </motion.div>
                    ))
                )}
            </div>
        </motion.div>
    );
}

--- END OF FILE components/notifications/NotificationPanel.tsx ---

================================================================================

--- START OF FILE components/notifications/Notifications.module.css ---

/* components/notifications/Notifications.module.css */

.notificationWrapper {
    position: relative;
}

.bellButton {
    background: none;
    border: none;
    cursor: pointer;
    position: relative;
    /* THE FIX: Ensures the bell is white/bright (primary text color) instead of gray */
    color: var(--text-primary);
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: color 0.2s ease, background-color 0.2s ease;
}

.bellButton:hover {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.bellIcon {
    width: 24px;
    height: 24px;
}

.notificationBadge {
    position: absolute;
    top: 2px;
    right: 2px;
    background-color: #DC2626;
    color: white;
    font-size: 1rem;
    font-weight: 700;
    min-width: 16px;
    height: 16px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 4px;
    border: 2px solid var(--bg-secondary);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.notificationPanel {
    position: absolute;
    top: calc(100% + 15px);
    left: 0; /* Align left for RTL context in navbar */
    width: 320px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 10px 40px -10px rgba(0,0,0,0.3);
    z-index: 1100;
    overflow: hidden;
    transform-origin: top left;
    display: flex;
    flex-direction: column;
}

.panelHeader {
    padding: 1.2rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
    backdrop-filter: blur(10px);
}

.panelHeader h3 {
    margin: 0;
    font-size: 1.6rem;
    font-family: var(--font-heading);
    color: var(--text-primary);
}

.markAllReadButton {
    background: none;
    border: none;
    color: var(--accent);
    font-size: 1.2rem;
    cursor: pointer;
    font-weight: 600;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.markAllReadButton:hover {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.notificationsList {
    max-height: 350px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.notificationItem {
    padding: 1.2rem 1.5rem;
    display: flex;
    gap: 1.2rem;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s ease;
    position: relative;
}

.notificationItem:last-child {
    border-bottom: none;
}

.notificationItem:hover {
    background-color: var(--bg-primary);
}

.notificationItem.unread {
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}

.notificationAvatar {
    border-radius: 50%;
    border: 1px solid var(--border-color);
}

.notificationContent {
    flex-grow: 1;
    font-size: 1.4rem;
    line-height: 1.4;
}

.notificationLink {
    text-decoration: none;
    color: var(--text-primary);
    display: block;
}

.senderName {
    font-weight: 700;
    color: var(--text-primary);
}

.notificationMeta {
    font-size: 1.2rem;
    color: var(--text-secondary);
    margin-top: 0.4rem;
}

.unreadDot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--accent);
    align-self: center;
    flex-shrink: 0;
}

.emptyState {
    padding: 3rem;
    text-align: center;
    color: var(--text-secondary);
    font-size: 1.4rem;
}

@media (max-width: 768px) {
    .notificationPanel {
        position: fixed;
        top: 70px; /* Below navbar */
        left: 1rem;
        right: 1rem;
        width: auto;
        max-height: 60vh;
    }
}

--- END OF FILE components/notifications/Notifications.module.css ---

================================================================================

--- START OF FILE components/security/BanEnforcer.module.css ---

/* components/security/BanEnforcer.module.css */

.banOverlay {
    position: fixed;
    inset: 0;
    z-index: 99999; /* Highest possible priority */
    background-color: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(20px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    overflow: hidden;
}

.banCard {
    background-color: #0f0f0f;
    border: 1px solid #333;
    border-right: 4px solid #DC2626; /* Red accent for "Danger/Ban" */
    padding: 4rem;
    max-width: 500px;
    width: 100%;
    text-align: center;
    border-radius: 8px;
    box-shadow: 0 0 50px rgba(220, 38, 38, 0.2);
}

.banIcon {
    color: #DC2626;
    width: 64px;
    height: 64px;
    margin-bottom: 2rem;
}

.banTitle {
    font-family: var(--font-heading);
    font-size: 3.2rem;
    color: #fff;
    margin: 0 0 1.5rem 0;
}

.banMessage {
    font-family: var(--font-main);
    font-size: 1.6rem;
    color: #a1a1aa;
    margin-bottom: 3rem;
    line-height: 1.6;
}

.reasonContainer {
    background-color: rgba(220, 38, 38, 0.1);
    border: 1px solid rgba(220, 38, 38, 0.3);
    padding: 1.5rem;
    border-radius: 6px;
    text-align: right;
}

.reasonLabel {
    display: block;
    font-family: var(--font-ui);
    font-weight: 700;
    color: #DC2626;
    margin-bottom: 0.5rem;
    font-size: 1.3rem;
}

.reasonText {
    margin: 0;
    font-family: var(--font-main);
    color: #fff;
    font-size: 1.5rem;
}

--- END OF FILE components/security/BanEnforcer.module.css ---

================================================================================

--- START OF FILE components/security/BanEnforcer.tsx ---

// components/security/BanEnforcer.tsx
'use client';

import { useEffect } from 'react';
import { signOut } from 'next-auth/react';
import styles from './BanEnforcer.module.css';

const LockIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={styles.banIcon}>
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
    </svg>
);

interface BanEnforcerProps {
    isBanned: boolean;
    reason?: string | null;
}

export default function BanEnforcer({ isBanned, reason }: BanEnforcerProps) {
    
    // Simple effect to lock the body scroll if the user is banned upon page load
    useEffect(() => {
        if (isBanned) {
            document.body.style.overflow = 'hidden';
        } else {
            document.body.style.overflow = '';
        }
        
        return () => {
            document.body.style.overflow = '';
        };
    }, [isBanned]);

    if (!isBanned) return null;

    return (
        <div className={styles.banOverlay}>
            <div className={styles.banCard}>
                <LockIcon />
                <h1 className={styles.banTitle}>حساب محظور</h1>
                <p className={styles.banMessage}>
                    تم تعليق وصولك إلى منصة EternalGames. لا يمكنك التفاعل أو تصفح المحتوى الخاص أثناء سريان هذا الحظر.
                </p>
                
                {reason && (
                    <div className={styles.reasonContainer}>
                        <span className={styles.reasonLabel}>سبب الحظر:</span>
                        <p className={styles.reasonText}>{reason}</p>
                    </div>
                )}

                <button 
                    onClick={() => signOut({ callbackUrl: '/' })}
                    className="outline-button"
                    style={{ marginTop: '3rem', width: '100%', borderColor: '#333', color: '#888' }}
                >
                    تسجيل الخروج
                </button>
            </div>
        </div>
    );
}

--- END OF FILE components/security/BanEnforcer.tsx ---

================================================================================

--- START OF FILE components/skeletons/CardSkeleton.module.css ---

/* components/skeletons/CardSkeleton.module.css */
@keyframes pulse-skeleton {
    0%, 100% {
        background-color: var(--border-color);
    }
    50% {
        background-color: color-mix(in srgb, var(--border-color) 60%, var(--bg-secondary));
    }
}

.cardSkeleton {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    height: 100%;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
}

.imageSkeleton {
    width: 100%;
    aspect-ratio: 16 / 9;
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.contentSkeleton {
    padding: 2rem;
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    gap: 1.2rem;
}

.line {
    height: 1.6rem;
    border-radius: 4px;
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.line.title {
    height: 2rem;
    width: 80%;
    margin-bottom: 0.5rem;
}

.line.meta {
    width: 60%;
}

.line.metaShort {
    width: 40%;
}

.tagArea {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    display: flex;
    gap: 0.8rem;
}

.tag {
    height: 2.4rem;
    width: 70px;
    border-radius: 999px;
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

--- END OF FILE components/skeletons/CardSkeleton.module.css ---

================================================================================

--- START OF FILE components/skeletons/CardSkeleton.tsx ---

// components/skeletons/CardSkeleton.tsx
import styles from './CardSkeleton.module.css';

export default function CardSkeleton() {
    return (
        <div className={styles.cardSkeleton}>
            <div className={styles.imageSkeleton}></div>
            <div className={styles.contentSkeleton}>
                <div className={`${styles.line} ${styles.title}`}></div>
                <div className={`${styles.line} ${styles.meta}`}></div>
                <div className={`${styles.line} ${styles.metaShort}`}></div>
                <div className={styles.tagArea}>
                    <div className={styles.tag}></div>
                    <div className={styles.tag}></div>
                </div>
            </div>
        </div>
    );
}

--- END OF FILE components/skeletons/CardSkeleton.tsx ---

================================================================================

--- START OF FILE components/skeletons/CommentListSkeleton.tsx ---

// components/skeletons/CommentListSkeleton.tsx
import React from 'react';
import styles from './CommentSkeleton.module.css';

const CommentSkeletonItem = () => {
    return (
        <div className={styles.wrapper}>
            <div className={styles.avatar} />
            <div className={styles.content}>
                <div className={styles.header}>
                    <div className={styles.name} />
                    <div className={styles.date} />
                </div>
                <div className={styles.body}>
                    <div className={styles.line} style={{ width: '90%' }} />
                    <div className={styles.line} style={{ width: '60%' }} />
                </div>
                <div className={styles.actions}>
                    <div className={styles.action} />
                    <div className={styles.action} />
                </div>
            </div>
        </div>
    );
};

export default function CommentListSkeleton() {
    return (
        <div style={{ marginTop: '2rem', borderRight: '2px solid var(--border-color)' }}>
            {[1, 2, 3].map((i) => (
                <CommentSkeletonItem key={i} />
            ))}
        </div>
    );
}

--- END OF FILE components/skeletons/CommentListSkeleton.tsx ---

================================================================================

--- START OF FILE components/skeletons/CommentSkeleton.module.css ---

/* components/skeletons/CommentSkeleton.module.css */

@keyframes pulse-skeleton {
    0%, 100% {
        background-color: var(--border-color);
        opacity: 0.4;
    }
    50% {
        background-color: color-mix(in srgb, var(--border-color) 60%, var(--bg-secondary));
        opacity: 0.8;
    }
}

.wrapper {
    display: flex;
    gap: 1.2rem;
    margin-bottom: 4rem;
    position: relative;
    padding-right: 3rem; /* Match CommentList padding */
}

/* Connector Line mimicking threaded comments */
.wrapper::before {
    content: '';
    position: absolute;
    right: -0.9rem; /* Align with CommentItem */
    top: 10px;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    border: 2px solid var(--border-color);
}

.avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
    background-color: var(--border-color);
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.header {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.name {
    width: 120px;
    height: 1.8rem;
    border-radius: 4px;
    background-color: var(--border-color);
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.date {
    width: 80px;
    height: 1.3rem;
    border-radius: 4px;
    background-color: var(--border-color);
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.body {
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
}

.line {
    height: 1.6rem;
    border-radius: 4px;
    background-color: var(--border-color);
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.actions {
    display: flex;
    gap: 1.5rem;
    margin-top: 0.5rem;
}

.action {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: var(--border-color);
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

--- END OF FILE components/skeletons/CommentSkeleton.module.css ---

================================================================================

--- START OF FILE components/skeletons/GridPageSkeleton.tsx ---

// components/skeletons/GridPageSkeleton.tsx
import CardSkeleton from "./CardSkeleton";

export default function GridPageSkeleton({ count = 12 }: { count?: number }) {
    return (
        <div className="content-grid" style={{ paddingTop: '4rem', paddingBottom: '6rem' }}>
            {Array.from({ length: count }).map((_, index) => (
                <CardSkeleton key={index} />
            ))}
        </div>
    );
}

--- END OF FILE components/skeletons/GridPageSkeleton.tsx ---

================================================================================

--- START OF FILE components/ui/ButtonLoader.tsx ---

// components/ui/ButtonLoader.tsx
'use client';

import { motion } from 'framer-motion';

// SVG paths for the left and right loops of the infinity symbol
const leftLoopPath = "M 50 50 C 50 25, 25 25, 25 50 C 25 75, 50 75, 50 50";
const rightLoopPath = "M 50 50 C 50 25, 75 25, 75 50 C 75 75, 50 75, 50 50";

// Shared transition for a seamless, continuous loop
const transition = {
  duration: 1.5,
  ease: "easeInOut" as const,
  repeat: Infinity,
  repeatType: "loop" as const,
};

/**
 * The "Glyph Deconstruction" loader.
 * Animates the two halves of an infinity symbol, breaking them apart,
 * orbiting them, and reassembling them in a fluid loop.
 */
export default function ButtonLoader() {
  return (
    <motion.svg
      viewBox="0 0 100 100"
      width="24"
      height="24"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      style={{
        stroke: "currentColor",
        strokeWidth: 8,
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        overflow: "visible", // Prevents clipping during rotation
      }}
    >
      {/* Left loop of the infinity symbol */}
      <motion.path
        d={leftLoopPath}
        style={{ transformOrigin: "25px 50px" }} // Set rotation center to the loop's center
        animate={{
          rotate: [0, -180, -360],
          x: [0, -15, 0],
        }}
        transition={transition}
      />
      {/* Right loop of the infinity symbol */}
      <motion.path
        d={rightLoopPath}
        style={{ transformOrigin: "75px 50px" }} // Set rotation center to the loop's center
        animate={{
          rotate: [0, 180, 360],
          x: [0, 15, 0],
        }}
        transition={transition}
      />
    </motion.svg>
  );
}

--- END OF FILE components/ui/ButtonLoader.tsx ---

================================================================================

--- START OF FILE components/ui/ScrollToTopButton.module.css ---

/* components/ui/ScrollToTopButton.module.css */

.scrollToTopButton {
    position: fixed;
    bottom: 2rem;
    left: 2rem; /* Consistent with toast position */
    right: auto;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: var(--accent);
    color: #fff;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 1000;
}

[data-theme="dark"] .scrollToTopButton {
    color: var(--bg-primary);
}

--- END OF FILE components/ui/ScrollToTopButton.module.css ---

================================================================================

--- START OF FILE components/ui/ScrollToTopButton.tsx ---

// components/ui/ScrollToTopButton.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { useScrolled } from '@/hooks/useScrolled';
import styles from './ScrollToTopButton.module.css';

const ArrowUpIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="19" x2="12" y2="5"></line>
        <polyline points="5 12 12 5 19 12"></polyline>
    </svg>
);

export default function ScrollToTopButton() {
    const isScrolled = useScrolled(400); // Show button after scrolling 400px

    const scrollToTop = () => {
        window.scrollTo({
            top: 0,
            behavior: 'smooth',
        });
    };

    return (
        <AnimatePresence>
            {isScrolled && (
                <motion.button
                    className={styles.scrollToTopButton}
                    onClick={scrollToTop}
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 50 }}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.95 }}
                    aria-label="Scroll to top"
                >
                    <ArrowUpIcon />
                </motion.button>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE components/ui/ScrollToTopButton.tsx ---

================================================================================

--- START OF FILE components/ui/Toast.tsx ---

// components/ui/Toast.tsx

'use client';

import { motion } from 'framer-motion';
import { useEffect } from 'react';
import React from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastProps {
id: string;
message: string;
type: ToastType;
onDismiss: (id: string) => void;
duration?: number;
}

const icons: Record<ToastType, React.JSX.Element> = {
success: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>,
error: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
info: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>,
};

//  DEFINITIVE FIX FOR COLORS
// 'success' now uses the brand's accent color.
const bgColors: Record<ToastType, string> = {
success: 'var(--accent)',
error: '#DC2626',
info: '#6B7280', // Using a neutral secondary text color for info
};

const toastVariants = {
initial: { opacity: 0, y: 50, scale: 0.8 },
animate: { opacity: 1, y: 0, scale: 1, transition: { type: 'spring' as const, damping: 20, stiffness: 200 } },
exit: { opacity: 0, scale: 0.9, transition: { duration: 0.2, ease: 'easeOut' as const } },
};

export const Toast = ({ id, message, type, onDismiss, duration = 5000 }: ToastProps) => {
useEffect(() => {
const timer = setTimeout(() => {
onDismiss(id);
}, duration);

return () => clearTimeout(timer);
}, [id, duration, onDismiss]);

return (
<motion.div
layout
variants={toastVariants}
initial="initial"
animate="animate"
exit="exit"
style={{
display: 'flex',
alignItems: 'center',
gap: '1rem',
padding: '1.25rem 1.5rem',
borderRadius: '8px',
color: '#fff',
backgroundColor: bgColors[type],
boxShadow: '0 10px 25px -5px rgba(0,0,0,0.2)',
width: '100%',
maxWidth: '380px',
}}
>
<div style={{ flexShrink: 0 }}>{icons[type]}</div>
<p style={{ margin: 0, flexGrow: 1, fontWeight: 500 }}>{message}</p>
<button onClick={() => onDismiss(id)} style={{ background: 'none', border: 'none', color: 'inherit', cursor: 'pointer', padding: '0.25rem', marginLeft: 'auto' }}>
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
</button>
</motion.div>
);
};




--- END OF FILE components/ui/Toast.tsx ---

================================================================================

--- START OF FILE components/upscaler/Upscaler.module.css ---

/* components/upscaler/Upscaler.module.css */

.dropzone {
    width: 100%;
    height: 400px;
    border: 2px dashed var(--border-color);
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background-color: color-mix(in srgb, var(--bg-secondary) 50%, transparent);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.dropzone:hover {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}

.dropzone.active {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.dropzoneContent {
    text-align: center;
    color: var(--text-primary);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    z-index: 2;
}

.dropzoneContent h3 {
    font-size: 2.4rem;
    margin: 0;
    font-family: var(--font-heading);
}

.dropzoneContent p {
    color: var(--text-secondary);
    font-size: 1.6rem;
}

.specsLabel {
    font-family: monospace;
    font-size: 1.2rem;
    color: var(--accent);
    background: color-mix(in srgb, var(--accent) 10%, transparent);
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    margin-top: 1rem;
    border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
}

.processingContainer {
    width: 100%;
    max-width: 900px;
    margin: 0 auto;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    background-color: #000;
    position: relative;
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.5);
}

.previewWrapper {
    position: relative;
    width: 100%;
    min-height: 500px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.processingImage {
    max-width: 100%;
    max-height: 80vh;
    object-fit: contain;
    opacity: 0.4;
    filter: blur(8px);
    transition: opacity 0.5s ease;
}

.scanBeam {
    position: absolute;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--accent);
    box-shadow: 0 0 30px 5px var(--accent);
    z-index: 10;
}

.statusOverlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(2px);
}

.statusMessage {
    color: white;
    font-size: 2rem;
    margin-top: 2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0,0,0,0.8);
}

.progressBarContainer {
    width: 300px;
    margin-top: 2rem;
    text-align: center;
}

.progressBarTrack {
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.2);
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progressBarFill {
    height: 100%;
    background: var(--accent);
    border-radius: 3px;
    transition: width 0.2s linear;
    box-shadow: 0 0 10px var(--accent);
}

.progressText {
    color: rgba(255,255,255,0.8);
    font-size: 1.2rem;
    font-family: monospace;
}

.resultContainer {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    animation: fadeIn 0.5s ease-out;
}

.compareContainer {
    height: 600px;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.3);
}

.actionsBar {
    display: flex;
    justify-content: center;
    gap: 2rem;
    padding: 2rem;
    background: var(--bg-secondary);
    border-radius: 12px;
    border: 1px solid var(--border-color);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@media (max-width: 768px) {
    .dropzone { height: 300px; }
    .processingContainer, .compareContainer { min-height: 400px; height: auto; }
    .actionsBar { flex-direction: column; }
}

--- END OF FILE components/upscaler/Upscaler.module.css ---

================================================================================

--- START OF FILE components/upscaler/UpscalerClient.tsx ---

// components/upscaler/UpscalerClient.tsx
'use client';

import { useUpscaler } from '@/hooks/useUpscaler';
import UpscalerDropzone from './UpscalerDropzone';
import UpscalerProcessing from './UpscalerProcessing';
import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import styles from './Upscaler.module.css';
import { motion } from 'framer-motion';

export default function UpscalerClient() {
    const { status, progress, message, resultSrc, originalSrc, upscaleImage, reset } = useUpscaler();

    const handleDownload = () => {
        if (!resultSrc) return;
        const link = document.createElement('a');
        link.href = resultSrc;
        link.download = `eternal-upscale-${Date.now()}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    if (status === 'idle') {
        return <UpscalerDropzone onImageSelect={upscaleImage} />;
    }

    if (status === 'error') {
        return (
            <div className={styles.dropzone} style={{ flexDirection: 'column', gap: '1rem', borderColor: '#DC2626' }}>
                <h3 style={{ color: '#DC2626', margin: 0 }}>فشلت المعالجة</h3>
                <p style={{ color: 'var(--text-secondary)', textAlign: 'center', maxWidth: '80%' }}>{message}</p>
                <p style={{ fontSize: '1.2rem', color: 'var(--text-secondary)' }}>تأكد من دعم المتصفح لـ WebGL وافتح (F12) للتفاصيل.</p>
                <button onClick={reset} className="primary-button" style={{ marginTop: '1rem' }}>
                    حاول مجدداً
                </button>
            </div>
        );
    }

    if (status === 'complete' && resultSrc && originalSrc) {
        return (
            <div className={styles.resultContainer}>
                <div className={styles.compareContainer}>
                    <ReactCompareSlider
                        itemOne={<ReactCompareSliderImage src={originalSrc} alt="Original" />}
                        itemTwo={<ReactCompareSliderImage src={resultSrc} alt="Upscaled" />}
                        style={{ width: '100%', height: '100%' }}
                    />
                </div>
                <div className={styles.actionsBar}>
                    <motion.button 
                        onClick={handleDownload} 
                        className="primary-button"
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                    >
                        تحميل الصورة (PNG)
                    </motion.button>
                    <button onClick={reset} className="outline-button">
                        صورة جديدة
                    </button>
                </div>
            </div>
        );
    }

    return (
        <UpscalerProcessing 
            status={status} 
            progress={progress} 
            message={message} 
            imageSrc={originalSrc || ''} 
        />
    );
}

--- END OF FILE components/upscaler/UpscalerClient.tsx ---

================================================================================

--- START OF FILE components/upscaler/UpscalerDropzone.tsx ---

// components/upscaler/UpscalerDropzone.tsx
'use client';

import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import styles from './Upscaler.module.css';

const ScanIcon = () => (
    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <path d="M3 7V5a2 2 0 0 1 2-2h2" />
        <path d="M17 3h2a2 2 0 0 1 2 2v2" />
        <path d="M21 17v2a2 2 0 0 1-2 2h-2" />
        <path d="M7 21H5a2 2 0 0 1-2-2v-2" />
        <circle cx="12" cy="12" r="3" />
        <path d="M12 16v3" />
        <path d="M12 5v3" />
        <path d="M16 12h3" />
        <path d="M5 12h3" />
    </svg>
);

export default function UpscalerDropzone({ onImageSelect }: { onImageSelect: (file: File) => void }) {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);

    const handleDrag = (e: React.DragEvent, active: boolean) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(active);
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            onImageSelect(e.dataTransfer.files[0]);
        }
    };

    return (
        <motion.div
            className={`${styles.dropzone} ${isDragging ? styles.active : ''}`}
            onDragEnter={(e) => handleDrag(e, true)}
            onDragOver={(e) => handleDrag(e, true)}
            onDragLeave={(e) => handleDrag(e, false)}
            onDrop={handleDrop}
            onClick={() => inputRef.current?.click()}
            whileHover={{ scale: 1.005 }}
            whileTap={{ scale: 0.99 }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
        >
            <input 
                ref={inputRef} 
                type="file" 
                accept="image/*" 
                style={{ display: 'none' }} 
                onChange={(e) => e.target.files && onImageSelect(e.target.files[0])}
            />
            <div className={styles.dropzoneContent}>
                <motion.div 
                    animate={{ rotate: isDragging ? 180 : 0, scale: isDragging ? 1.2 : 1 }} 
                    transition={{ type: 'spring', stiffness: 200, damping: 15 }}
                    style={{ color: 'var(--accent)', marginBottom: '1rem' }}
                >
                    <ScanIcon />
                </motion.div>
                <h3>المسبك البصري (Optical Foundry)</h3>
                <p>أفلت الصورة هنا لرفع دقتها x2 باستخدام الذكاء الاصطناعي.</p>
                <div className={styles.specsLabel}>
                    AI Model: Swin2SR Real-World Super Resolution
                </div>
            </div>
        </motion.div>
    );
}

--- END OF FILE components/upscaler/UpscalerDropzone.tsx ---

================================================================================

--- START OF FILE components/upscaler/UpscalerProcessing.tsx ---

// components/upscaler/UpscalerProcessing.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './Upscaler.module.css';
import { UpscaleStatus } from '@/hooks/useUpscaler';

interface ProcessingProps {
    status: UpscaleStatus;
    progress: number;
    message: string;
    imageSrc: string;
}

export default function UpscalerProcessing({ status, progress, message, imageSrc }: ProcessingProps) {
    return (
        <div className={styles.processingContainer}>
            <div className={styles.previewWrapper}>
                {/* Blurry Background Image */}
                <img src={imageSrc} alt="Processing" className={styles.processingImage} />
                
                {/* Scanning Beam */}
                <motion.div 
                    className={styles.scanBeam}
                    animate={{ top: ['0%', '100%', '0%'] }}
                    transition={{ duration: 4, repeat: Infinity, ease: "easeInOut" }}
                />
                
                <div className={styles.statusOverlay}>
                    <div className="spinner" style={{ width: '50px', height: '50px', borderTopColor: 'var(--accent)' }} />
                    <p className={styles.statusMessage}>{message}</p>
                    
                    {/* Show progress bar for both downloading AND processing tiles */}
                    {(status === 'downloading' || status === 'processing') && progress > 0 && (
                        <div className={styles.progressBarContainer}>
                            <div className={styles.progressBarTrack}>
                                <motion.div 
                                    className={styles.progressBarFill} 
                                    style={{ width: `${progress}%` }}
                                    animate={{ width: `${progress}%` }}
                                />
                            </div>
                            <span className={styles.progressText}>{Math.round(progress)}%</span>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}

--- END OF FILE components/upscaler/UpscalerProcessing.tsx ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.module.css ---

/* components/VanguardReviews/VanguardReviews.module.css */

.vanguardContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 500px;
    position: relative;
    padding: 6rem 0 12rem 0;
    --card-gap: 1.5rem;
    --center-width: 400px;
    --side-width: 280px;
    background-color: var(--bg-secondary);
    width: 100%;
    overflow-x: clip; /* THE DEFINITIVE FIX */
}

.vanguardContainer.manual-hover {
    /* This class is now handled by the parent component for hover state */
}

.spotlightGlow {
    position: absolute;
    width: 800px;
    height: 800px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle at 50% 50%, color-mix(in srgb, var(--accent) 15%, transparent) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
}

.cardSlot {
    position: absolute;
    transition: transform 0.7s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.5s ease-out, left 0.7s cubic-bezier(0.22, 1, 0.36, 1);
    width: var(--center-width);
    height: 500px;
}

.cardWrapper {
    height: 100%;
    will-change: transform;
    transition: filter 0.4s ease-out;
    position: relative;
}

.vanguardContainer.manual-hover .cardWrapper {
    filter: brightness(0.6) saturate(0.8);
}

.vanguardContainer.manual-hover .cardSlot:hover .cardWrapper {
    filter: brightness(1) saturate(1);
}

.vanguardCard {
    background-color: var(--bg-secondary);
    border-radius: 12px;
    overflow: visible;
    height: 100%;
    border: 1px solid var(--border-color);
    box-shadow: 0 15px 30px -10px rgba(0,0,0,0.3);
    color: #fff;
    position: relative;
    transition: border-color 0.3s ease-out, box-shadow 0.3s ease-out;
}

.cardSlot:hover .vanguardCard {
    border-color: var(--accent);
    box-shadow: 0 0 30px -8px color-mix(in srgb, var(--accent) 60%, transparent);
}

.cardImageContainer {
    position: absolute;
    inset: 0;
    border-radius: 12px;
    overflow: hidden;
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
}

.cardSlot:hover .cardImage {
    transform: scale(1.05);
}

.cardContent {
    position: absolute;
    inset: 0;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    text-align: right;
    border-radius: 12px;
    pointer-events: none;
}

.cardContent h3 { font-size: 2rem; line-height: 1.3; margin: 0 0 0.5rem 0; }
.cardDate { font-size: 1.3rem; color: rgba(255,255,255,0.7); }


.vanguardScoreBadge {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    width: 75px;
    height: 75px;
    border-radius: 50%;
    background-color: var(--accent);
    color: var(--bg-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-heading), sans-serif;
    font-weight: 800;
    font-size: 2.2rem;
    border: none;
    box-shadow: 0 0 20px 0px color-mix(in srgb, var(--accent) 80%, transparent);
    z-index: 3;
    transform: translateZ(60px);
    transition: transform 0.4s ease, box-shadow 0.4s ease;
}

.cardSlot:hover .vanguardScoreBadge {
    transform: translateZ(80px) scale(1.05);
    box-shadow: 0 0 25px 3px color-mix(in srgb, var(--accent) 90%, transparent);
}

.creatorBubbleContainer {
    position: absolute;
    top: 30%;
    right: -3.5rem;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.1rem;
    z-index: 5;
    transform: translateZ(50px);
}

.creatorBubble {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    background-color: var(--bg-secondary);
    border: 1.2px solid var(--accent);
    border-radius: 999px;
    padding: 0.3rem 1.2rem;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

.creatorBubble:hover, .creatorBubble.pressed {
    background-color: var(--accent);
    box-shadow: 0 0 15px -0.5px var(--accent);
}

.creatorLabel { color: var(--text-secondary); font-size: 1rem; font-weight: 500; transition: color 0.3s ease; }
.creatorBubble:hover .creatorLabel, .creatorBubble.pressed .creatorLabel { color: color-mix(in srgb, var(--bg-primary) 70%, transparent); }
.creatorName { font-size: 1.2rem; font-weight: 600; transition: color 0.3s ease; }
.creatorBubble:hover .creatorName, .creatorBubble.pressed .creatorName { color: var(--bg-primary); }

/* THE DEFINITIVE FIX */
.creatorArrow { 
    position: absolute; 
    left: -22px; /* Increased initial distance */
    top: 75%; 
    transform: translateY(-50%); 
    color: var(--accent); 
    transition: opacity 0.3s ease, transform 0.3s ease; 
    opacity: 0; 
}
.creatorBubble:hover .creatorArrow, .creatorBubble.pressed .creatorArrow { 
    opacity: 1; 
    transform: translateY(-50%) translateX(-8px); /* Increased travel distance */
}
/* END FIX */

.kineticNavigator {
    position: absolute;
    bottom: 0;
    width: 100%;
    display: flex;
    justify-content: center;
}

.navTrack {
    display: flex;
    flex-direction: row-reverse;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    backdrop-filter: blur(10px);
    z-index: 10;
    max-width: 90vw;
    overflow-x: auto;
    scrollbar-width: none;
}
.navTrack::-webkit-scrollbar { display: none; }

.navItem {
    position: relative;
    border-radius: 8px;
    cursor: pointer;
    overflow: hidden;
    border: 1px solid transparent;
    transition: border-color 0.4s ease;
}

.navImage {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: filter 0.4s ease, transform 0.4s ease;
}

.navItem[data-active="false"] .navImage {
    filter: grayscale(100%) brightness(0.7);
}

.navItem[data-active="true"] {
    border-color: var(--accent);
    box-shadow: 0 0 15px -2px var(--accent);
}

.navTitle {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 8px;
    font-size: 1.2rem;
    font-weight: 600;
    color: #fff;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
    text-align: right;
}

@media (max-width: 1024px) {
    .vanguardContainer {
        --center-width: 60vw;
        --side-width: 40vw;
        padding-bottom: 10rem;
        padding-top: 4rem;
    }
    .cardSlot {
        height: 380px;
    }
}

@media (max-width: 768px) {
    .vanguardContainer {
        --center-width: 65vw;
        --side-width: 45vw;
        min-height: 420px;
        padding-top: 5.5rem;
        padding-bottom: 8rem;
    }
    .cardContent h3 { font-size: 1.8rem; }
    .vanguardScoreBadge {
        width: 55px;
        height: 55px;
        font-size: 2rem;
        top: 1rem;
        right: 1rem;
    }
    .creatorBubbleContainer {
        top: 30%;
        right: -1.5rem;
    }
    .creatorBubble {
        padding: 0.2rem 1rem;
    }
    .creatorName { font-size: 1.1rem; }
}

@media (max-width: 480px) {
    .vanguardContainer {
        --center-width: 70vw;
        --side-width: 50vw;
    }
}

--- END OF FILE components/VanguardReviews/VanguardReviews.module.css ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.tsx ---

// components/VanguardReviews/VanguardReviews.tsx
'use client';

import { useState, useEffect, useRef, memo, useCallback } from 'react';
import { motion, AnimatePresence, useInView, animate, PanInfo } from 'framer-motion';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import Link from 'next/link';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useVanguardCarousel } from '@/hooks/useVanguardCarousel';
import { urlFor } from '@/sanity/lib/image';
import type { SanityAuthor } from '@/types/sanity';
import type { CardProps } from '@/types';
import styles from './VanguardReviews.module.css';

const creatorBubbleContainerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.15, delayChildren: 0.2 } }
};
const creatorBubbleItemVariants = {
    hidden: { opacity: 0, x: 20 },
    visible: { opacity: 1, x: 0, transition: { type: 'spring' as const, stiffness: 300, damping: 20 } }
};
const ArrowIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" role="img" color="currentColor">
        <path d="M12.293 5.29273C12.6591 4.92662 13.2381 4.90402 13.6309 5.22437L13.707 5.29273L19.707 11.2927L19.7754 11.3689C20.0957 11.7617 20.0731 12.3407 19.707 12.7068L13.707 18.7068C13.3165 19.0973 12.6835 19.0973 12.293 18.7068C11.9025 18.3163 11.9025 17.6833 12.293 17.2927L16.5859 12.9998H5C4.44772 12.9998 4 12.552 4 11.9998C4 11.4475 4.44772 10.9998 5 10.9998H16.5859L12.293 6.7068L12.2246 6.63063C11.9043 6.23785 11.9269 5.65885 12.293 5.29273Z" fill="currentColor"></path>
    </svg>
);

const CreatorBubble = ({ label, creator }: { label: string, creator: SanityAuthor }) => {
    const [isPressed, setIsPressed] = useState(false);
    const handleBubbleClick = (e: React.MouseEvent) => { e.stopPropagation(); };
    const profileSlug = creator.username || (creator.slug as any)?.current || creator.name?.toLowerCase().replace(/\s+/g, '-');
    const hasPublicProfile = !!profileSlug;
    
    const bubbleContent = (
        <motion.div 
            className={`${styles.creatorBubble} ${isPressed ? styles.pressed : ''}`}
            whileHover={{ scale: 1.1, x: -10, transition: { type: 'spring', stiffness: 400, damping: 15 } }}
            onTouchStart={() => setIsPressed(true)}
            onTouchEnd={() => setIsPressed(false)}
            onTouchCancel={() => setIsPressed(false)}
        >
            <span className={styles.creatorLabel}>{label}</span>
            <span className={styles.creatorName}>{creator.name}</span>
            <div className={styles.creatorArrow}><ArrowIcon /></div>
        </motion.div>
    );
    
    return (
        <motion.div variants={creatorBubbleItemVariants}>
            {hasPublicProfile ? (
                <Link href={`/creators/${profileSlug}`} onClick={handleBubbleClick} className="no-underline">
                    {bubbleContent}
                </Link>
            ) : (
                <div title={`${creator.name} (no public profile)`}>
                    {bubbleContent}
                </div>
            )}
        </motion.div>
    );
};

const VanguardCard = memo(({ review, isCenter, isInView, isPriority, isMobile, isHovered, isInteractive }: { review: CardProps, isCenter: boolean, isInView: boolean, isPriority: boolean, isMobile: boolean, isHovered: boolean, isInteractive: boolean }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();
    const router = useRouter(); const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = "vanguard-reviews";
    const scoreRef = useRef<HTMLParagraphElement>(null);
    useEffect(() => {
        if (isInView && scoreRef.current && typeof review.score === 'number') {
            const controls = animate(0, review.score, {
                duration: 1.5, ease: [0.22, 1, 0.36, 1],
                onUpdate(value) { if (scoreRef.current) { scoreRef.current.textContent = value.toFixed(1); } }
            });
            return () => controls.stop();
        }
    }, [isInView, review.score]);

    const linkPath = `/reviews/${review.slug}`;
    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (e.ctrlKey || e.metaKey) return; // Allow opening in new tab
        if ((e.target as HTMLElement).closest('a[href^="/creators"]')) {
            e.stopPropagation();
            return;
        }
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };
    
    const imageUrl = review.mainImageRef 
        ? urlFor(review.mainImageRef).width(isCenter ? 800 : 560).height(isCenter ? 1000 : 700).fit('crop').auto('format').url()
        : review.imageUrl;

    const showCredits = isCenter || isHovered;
    
    const livingCardHandlers = isInteractive ? {
        onMouseMove: livingCardAnimation.onMouseMove,
        onTouchMove: livingCardAnimation.onTouchMove, // ADDED: Touch move handler
        onMouseEnter: livingCardAnimation.onMouseEnter,
        onMouseLeave: livingCardAnimation.onMouseLeave,
        onTouchStart: livingCardAnimation.onTouchStart,
        onTouchEnd: livingCardAnimation.onTouchEnd,
        onTouchCancel: livingCardAnimation.onTouchCancel,
    } : {};

    return (
        <div className={styles.cardWrapper}>
            <a 
                href={linkPath}
                onClick={handleClick}
                className="no-underline"
                style={{ display: 'block', height: '100%', cursor: 'pointer' }}
            >
                <motion.div
                    ref={livingCardRef}
                    {...livingCardHandlers}
                    style={{ ...livingCardAnimation.style, transformStyle: 'preserve-3d', height: '100%' }}
                    layoutId={`${layoutIdPrefix}-card-container-${review.legacyId}`} 
                    className={styles.vanguardCard}
                >
                    <AnimatePresence>
                        {showCredits && (
                            <motion.div
                                className={styles.creatorBubbleContainer}
                                variants={creatorBubbleContainerVariants}
                                initial="hidden"
                                animate="visible"
                                exit="hidden"
                                style={{ pointerEvents: 'auto', transform: 'translateZ(50px)' }}
                            >
                                {review.authors.map(author => <CreatorBubble key={author._id} label="بقلم" creator={author} />)}
                                {review.designers?.map(designer => <CreatorBubble key={designer._id} label="تصميم" creator={designer} />)}
                            </motion.div>
                        )}
                    </AnimatePresence>

                    {typeof review.score === 'number' && (<div className={styles.vanguardScoreBadge}><p ref={scoreRef} style={{ margin: 0 }}>0.0</p></div>)}
                    <motion.div layoutId={`${layoutIdPrefix}-card-image-${review.legacyId}`} className={styles.cardImageContainer}>
                        <Image 
                            src={imageUrl} 
                            alt={review.title} 
                            fill 
                            sizes={isCenter ? "(max-width: 768px) 80vw, 400px" : "(max-width: 768px) 60vw, 280px"}
                            className={styles.cardImage} 
                            placeholder="blur" 
                            blurDataURL={review.blurDataURL} 
                            priority={isPriority}
                        />
                    </motion.div>
                    <motion.div className={styles.cardContent} animate={{ background: isCenter ? 'linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 50%)' : 'linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 60%)' }} transition={{ duration: 0.5, ease: 'circOut' }}>
                        <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${review.legacyId}`}>{review.title}</motion.h3>
                        {review.date && <p className={styles.cardDate}>{review.date.split(' - ')[0]}</p>}
                    </motion.div>
                </motion.div>
            </a>
        </div>
    );
});
VanguardCard.displayName = "VanguardCard";

const KineticNavigator = ({ reviews, currentIndex, navigateToIndex }: { reviews: CardProps[], currentIndex: number, navigateToIndex: (index: number) => void }) => {
    const itemRefs = useRef<(HTMLButtonElement | null)[]>([]);
    useEffect(() => { const activeItem = itemRefs.current[currentIndex]; if (activeItem) { activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' }); } }, [currentIndex]);
    return (
        <div className={styles.kineticNavigator}>
            <div className={styles.navTrack}>
                {reviews.map((review, index) => {
                    const isActive = currentIndex === index;
                    return (
                        <motion.button 
                            key={review.id} 
                            ref={el => { itemRefs.current[index] = el }} 
                            className={styles.navItem} 
                            data-active={isActive} 
                            onTap={() => navigateToIndex(index)}
                            whileTap={{ scale: 0.95 }}
                            animate={{ width: isActive ? 100 : 50, height: isActive ? 60 : 40 }} 
                            transition={{ type: 'spring', stiffness: 400, damping: 30 }}
                        >
                            <Image src={`${review.imageUrl.split('?')[0]}?w=200&auto=format`} alt={review.title} fill sizes="10vw" className={styles.navImage} unoptimized />
                            <AnimatePresence>{isActive && <motion.div className={styles.navTitle} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{review.title}</motion.div>}</AnimatePresence>
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
};

export default function VanguardReviews({ reviews }: { reviews: CardProps[] }) {
    const containerRef = useRef(null);
    const hasAnimatedIn = useInView(containerRef, { once: true, amount: 0.1 });
    const isCurrentlyInView = useInView(containerRef, { amount: 0.4 });
    const [initialAnimHasRun, setInitialAnimHasRun] = useState(false);
    const [isManualHover, setIsManualHover] = useState(false);

    const {
        currentIndex,
        hoveredId,
        setHoveredId,
        navigateToIndex,
        getCardState,
        isMobile
    } = useVanguardCarousel(reviews.length, isCurrentlyInView);

    useEffect(() => {
        if (hasAnimatedIn && !initialAnimHasRun) {
            const timer = setTimeout(() => setInitialAnimHasRun(true), 800);
            return () => clearTimeout(timer);
        }
    }, [hasAnimatedIn, initialAnimHasRun]);

    const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
        const swipeThreshold = 50;
        if (info.offset.x < -swipeThreshold) {
            navigateToIndex((currentIndex + 1) % reviews.length);
        } else if (info.offset.x > swipeThreshold) {
            navigateToIndex((currentIndex - 1 + reviews.length) % reviews.length);
        }
    };

    if (reviews.length === 0) return null;

    const centerCardState = getCardState(currentIndex, reviews[currentIndex].id);
    const centerStyle = centerCardState.style;
    const initialAnimationConfig = {
        ...centerStyle,
        opacity: 0,
        transform: centerStyle.transform ? centerStyle.transform.replace(/scale\([0-9.]+\)/, 'scale(0.8)') : 'scale(0.8)',
    };


    return (
        <div 
            ref={containerRef} 
            className={`${styles.vanguardContainer} ${isManualHover ? styles['manual-hover'] : ''}`}
        >
            <motion.div className={styles.spotlightGlow} animate={{ opacity: hoveredId ? 0.5 : 1 }} />
            
            <motion.div
                style={{ position: 'relative', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                drag={isMobile ? "x" : false}
                dragConstraints={{ left: 0, right: 0 }}
                dragElastic={0.1}
                onDragEnd={handleDragEnd}
                onTouchEnd={() => initialAnimHasRun && setHoveredId(null)}
                onTouchCancel={() => initialAnimHasRun && setHoveredId(null)}
                onMouseEnter={() => setIsManualHover(true)}
                onMouseLeave={() => setIsManualHover(false)}
            >
                {reviews.map((review, reviewIndex) => {
                    const { style, isCenter } = getCardState(reviewIndex, review.id);
                    const isHovered = hoveredId === review.id;
                    
                    return (
                        <motion.div 
                            key={review.id} 
                            className={styles.cardSlot} 
                            onMouseEnter={() => initialAnimHasRun && setHoveredId(review.id)} 
                            onMouseLeave={() => initialAnimHasRun && setHoveredId(null)}
                            onTouchStart={() => initialAnimHasRun && setHoveredId(review.id)}
                            initial={!initialAnimHasRun ? initialAnimationConfig : false}
                            animate={style}
                            transition={{
                                ease: [0.4, 0, 0.2, 1],
                                duration: 0.7,
                                delay: !initialAnimHasRun ? (isCenter ? 0 : 0.2) : 0,
                            }}
                        >
                            <VanguardCard 
                                review={review} 
                                isCenter={isCenter} 
                                isInView={hasAnimatedIn}
                                isPriority={isCenter}
                                isMobile={isMobile}
                                isHovered={isHovered}
                                isInteractive={initialAnimHasRun}
                            />
                        </motion.div>
                    );
                })}
            </motion.div>
            
            {hasAnimatedIn && <KineticNavigator reviews={reviews} currentIndex={currentIndex} navigateToIndex={navigateToIndex} />}
        </div>
    );
}

--- END OF FILE components/VanguardReviews/VanguardReviews.tsx ---

================================================================================

--- START OF FILE hooks/useAsyncValidation.ts ---

// hooks/useAsyncValidation.ts
'use client';

import { useState, useEffect, useTransition } from 'react';
import { useDebounce } from './useDebounce';

type ValidationStatus = 'idle' | 'checking' | 'valid' | 'invalid';
type ValidationResult = { type: ValidationStatus; message: string };

/**
 * A hook to perform debounced, asynchronous validation on an input value.
 * @param value The current value of the input to be validated.
 * @param validationFn The server action or async function to call for validation.
 * @param initialValue The original/initial value of the field to compare against.
 * @param delay The debounce delay in milliseconds.
 * @returns A validation result object: { type: ValidationStatus; message: string }.
 */
export function useAsyncValidation<T>(
    value: T,
    validationFn: (value: T, ...args: any[]) => Promise<{ isValid?: boolean; available?: boolean; message: string }>,
    initialValue?: T,
    delay: number = 500
): ValidationResult {
    const [status, setStatus] = useState<ValidationResult>({ type: 'idle', message: '' });
    const [isPending, startTransition] = useTransition();
    const debouncedValue = useDebounce(value, delay);

    useEffect(() => {
        // Don't validate if the value is empty or hasn't changed from its initial state
        if (!debouncedValue || debouncedValue === initialValue) {
            setStatus({ type: 'idle', message: '' });
            return;
        }

        setStatus({ type: 'checking', message: 'جارٍ التحقق...' });

        startTransition(async () => {
            const result = await validationFn(debouncedValue);
            const isValid = result.isValid ?? result.available ?? false;
            setStatus({
                type: isValid ? 'valid' : 'invalid',
                message: result.message,
            });
        });
    }, [debouncedValue, initialValue, validationFn]);

    return status;
}




--- END OF FILE hooks/useAsyncValidation.ts ---

================================================================================

--- START OF FILE hooks/useBodyClass.ts ---

// hooks/useBodyClass.ts
'use client';

import { useEffect } from 'react';

/**
 * A custom hook to manage adding and removing classes from the `<body>` element.
 * @param {string | string[]} classNames - The class name or an array of class names to apply.
 * @param {boolean} [condition=true] - A boolean condition. The class is applied if true, removed if false.
 */
export function useBodyClass(classNames: string | string[], condition: boolean = true) {
    useEffect(() => {
        const classes = Array.isArray(classNames) ? classNames : [classNames];

        if (condition) {
            document.body.classList.add(...classes);
        } else {
            document.body.classList.remove(...classes);
        }

        // Cleanup function to remove the class when the component unmounts
        // or when the condition becomes false in the next render.
        return () => {
            document.body.classList.remove(...classes);
        };
    }, [classNames, condition]); // Re-run the effect if the class name or condition changes
}




--- END OF FILE hooks/useBodyClass.ts ---

================================================================================

--- START OF FILE hooks/useClickOutside.ts ---

// hooks/useClickOutside.ts
import { useEffect, RefObject } from 'react';

type Event = MouseEvent | TouchEvent;

export const useClickOutside = <T extends HTMLElement = HTMLElement>(
  // MODIFIED: The ref can be null initially, so we accept RefObject<T | null>.
  ref: RefObject<T | null>,
  handler: (event: Event) => void
) => {
  useEffect(() => {
    const listener = (event: Event) => {
      const el = ref?.current;
      // Do nothing if clicking ref's element or descendent elements
      if (!el || el.contains((event?.target as Node) || null)) {
        return;
      }
      handler(event);
    };

    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);

    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler]); // Reload only if ref or handler changes
};

--- END OF FILE hooks/useClickOutside.ts ---

================================================================================

--- START OF FILE hooks/useDebounce.ts ---

'use client'

import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
const [debouncedValue, setDebouncedValue] = useState<T>(value)

useEffect(() => {
const handler = setTimeout(() => {
setDebouncedValue(value)
}, delay)

return () => {
clearTimeout(handler)
}
}, [value, delay])

return debouncedValue
}
































--- END OF FILE hooks/useDebounce.ts ---

================================================================================

--- START OF FILE hooks/useEngagementScores.ts ---

// hooks/useEngagementScores.ts

'use client';

import { useState, useEffect } from 'react';
import type { EngagementScore } from '@/types'; // Import from global types

// Define the API error response structure
type EngagementErrorResponse = {
    error: string;
};

type EngagementApiResponse = EngagementScore[] | EngagementErrorResponse;

// Type guard to check if the response is an error object
function isEngagementErrorResponse(response: EngagementApiResponse): response is EngagementErrorResponse {
    return (response as EngagementErrorResponse).error !== undefined;
}

/**
 * Fetches and maintains viral engagement scores (likes + shares) for all content types.
 * Returns an array of { id: legacyId, engagementScore: number }.
 */
export const useEngagementScores = () => {
    const [scores, setScores] = useState<EngagementScore[]>([]);
    
    useEffect(() => {
        const fetchScores = async () => {
            try {
                const res = await fetch('/api/engagement-scores');
                const data: EngagementApiResponse = await res.json();
                
                // Use the type guard to handle the error case
                if (isEngagementErrorResponse(data)) {
                    console.error("Engagement fetch error:", data.error);
                } else {
                    // Data is guaranteed to be EngagementScore[] here
                    setScores(data);
                }
            } catch (e) {
                console.error("Engagement fetch failed", e);
            }
        };
        
        fetchScores();
        // Set up polling for real-time scores updates
        const intervalId = setInterval(fetchScores, 60000); 
        return () => clearInterval(intervalId);

    }, []);
    return scores;
}




--- END OF FILE hooks/useEngagementScores.ts ---

================================================================================

--- START OF FILE hooks/useLivingCard.ts ---

// hooks/useLivingCard.ts
'use client';

import { useRef, useState } from 'react';
import { MotionValue, useMotionValue, useSpring, useTransform } from 'framer-motion';
import { useTheme } from 'next-themes';

const springConfig = { stiffness: 250, damping: 25 };

/**
 * A custom hook to apply a "living card" 3D tilt and shadow effect.
 * @param {object} options - Optional configuration.
 * @param {boolean} options.isLead - If true, applies a more subtle rotation effect.
 * @returns An object containing the ref and motion props to apply to a Framer Motion component.
 */
// THE FIX: Made the hook generic to support HTMLAnchorElement, HTMLDivElement, etc.
export function useLivingCard<T extends HTMLElement = HTMLDivElement>({ isLead = false } = {}) {
    const ref = useRef<T>(null);
    const { resolvedTheme } = useTheme();
    const [isHovered, setIsHovered] = useState(false);

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);

    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);

    const rotateMultiplier = isLead ? 8 / 15 : 1;
    const rotateX = useTransform(smoothMouseY, [0, 1], [15 * rotateMultiplier, -15 * rotateMultiplier]);
    const rotateY = useTransform(smoothMouseX, [0, 1], [-15 * rotateMultiplier, 15 * rotateMultiplier]);
    const scale = useSpring(isHovered ? 1.03 : 1, { stiffness: 400, damping: 30 });

    const transform = useTransform(
        [rotateX, rotateY, scale],
        ([rX, rY, s]: (string | number)[]) => `perspective(1000px) rotateX(${rX}deg) rotateY(${rY}deg) scale(${s})`
    );

    const boxShadow = useTransform<number, string>(
        [smoothMouseX, smoothMouseY],
        ([x, y]: number[]) => {
            const offsetX = (0.5 - x) * 30;
            const offsetY = (0.5 - y) * 30;
            const shadowOpacity = isHovered ? 0.1 : 0;
            const shadowColor = resolvedTheme === 'dark' 
                ? `rgba(0, 229, 255, ${shadowOpacity})`
                : `rgba(0, 0, 0, ${shadowOpacity * 1.5})`;
            return `${offsetX}px ${offsetY}px 35px ${shadowColor}`;
        }
    );

    // THE FIX: Updated event type to accept the generic T
    const handlePointerMove = (e: React.MouseEvent<T> | React.TouchEvent<T>) => {
        if (!ref.current) return;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        
        const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent<T>).clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent<T>).clientY;

        mouseX.set((clientX - left) / width);
        mouseY.set((clientY - top) / height);
    };
    
    const onPointerEnter = () => {
        setIsHovered(true);
    };

    const onPointerLeave = () => {
        setIsHovered(false);
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    return {
        livingCardRef: ref,
        livingCardAnimation: {
            style: {
                transform,
                boxShadow,
            },
            onMouseMove: handlePointerMove,
            onTouchMove: handlePointerMove,
            onMouseEnter: onPointerEnter,
            onMouseLeave: onPointerLeave,
            // THE FIX: Updated event type to accept the generic T
            onTouchStart: (e: React.TouchEvent<T>) => {
                onPointerEnter();
                handlePointerMove(e);
            },
            onTouchEnd: onPointerLeave,
            onTouchCancel: onPointerLeave,
        },
    };
}

--- END OF FILE hooks/useLivingCard.ts ---

================================================================================

--- START OF FILE hooks/usePopoverManager.ts ---

// hooks/usePopoverManager.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

type PopoverIdentifier = string | null;

export function usePopoverManager() {
    const [openPopover, setOpenPopover] = useState<PopoverIdentifier>(null);
    const popoverRef = useRef<HTMLDivElement>(null);

    const togglePopover = useCallback((popoverId: string) => {
        setOpenPopover(current => (current === popoverId ? null : popoverId));
    }, []);

    const closePopover = useCallback(() => {
        setOpenPopover(null);
    }, []);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            // THE DEFINITIVE FIX:
            // The ref is now placed on the container of the popovers and their triggers.
            // If a click happens AND the popoverRef exists AND the click is OUTSIDE the ref's boundary,
            // then we close the currently open popover.
            if (popoverRef.current && !popoverRef.current.contains(event.target as Node)) {
                closePopover();
            }
        };
        
        // We only add the listener if a popover is open.
        if (openPopover) {
            document.addEventListener('mousedown', handleClickOutside);
        }

        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [openPopover, closePopover]); // Re-run effect when the open popover changes

    return { popoverRef, openPopover, togglePopover, closePopover };
}

--- END OF FILE hooks/usePopoverManager.ts ---

================================================================================

--- START OF FILE hooks/useScrolled.ts ---

// hooks/useScrolled.ts
'use client';

import { useState, useEffect } from 'react';

export function useScrolled(threshold: number = 50): boolean {
    const [isScrolled, setIsScrolled] = useState(false);

    useEffect(() => {
        const handleScroll = () => {
            setIsScrolled(window.scrollY > threshold);
        };

        handleScroll();

        window.addEventListener('scroll', handleScroll, { passive: true });

        return () => {
            window.removeEventListener('scroll', handleScroll);
        };
    }, [threshold]);

    return isScrolled;
}




--- END OF FILE hooks/useScrolled.ts ---

================================================================================

--- START OF FILE hooks/useSearchablePopover.ts ---

// hooks/useSearchablePopover.ts
'use client';

import { useState, useEffect, useRef, useTransition, useCallback } from 'react';

interface UseSearchablePopoverProps<T> {
    searchAction: (query: string) => Promise<T[]>;
    initialResults?: T[];
}

export function useSearchablePopover<T>({ searchAction, initialResults = [] }: UseSearchablePopoverProps<T>) {
    const [isOpen, setIsOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [results, setResults] = useState<T[]>(initialResults);
    const [isSearching, startSearchTransition] = useTransition();
    const popoverRef = useRef<HTMLDivElement>(null);

    const togglePopover = useCallback(() => setIsOpen(prev => !prev), []);
    const closePopover = useCallback(() => setIsOpen(false), []);
    const openPopover = useCallback(() => setIsOpen(true), []);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (popoverRef.current && !popoverRef.current.contains(event.target as Node)) {
                closePopover();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [closePopover]);

    useEffect(() => {
        if (!isOpen) {
            setSearchTerm('');
            setResults(initialResults);
            return;
        }

        startSearchTransition(async () => {
            if (searchTerm.length > 0) {
                const searchResults = await searchAction(searchTerm);
                setResults(searchResults);
            } else {
                setResults(initialResults);
            }
        });
    }, [isOpen, searchTerm, searchAction, initialResults]);

    return {
        popoverRef,
        isOpen,
        searchTerm,
        results,
        isSearching,
        setSearchTerm,
        togglePopover,
        closePopover,
        openPopover,
    };
}




--- END OF FILE hooks/useSearchablePopover.ts ---

================================================================================

--- START OF FILE hooks/useUpscaler.ts ---

// hooks/useUpscaler.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

export type UpscaleStatus = 'idle' | 'init' | 'downloading' | 'processing' | 'complete' | 'error';

interface UpscalerState {
    status: UpscaleStatus;
    progress: number; // 0-100
    message: string;
    resultSrc: string | null;
    originalSrc: string | null;
}

export function useUpscaler() {
    const [state, setState] = useState<UpscalerState>({
        status: 'idle',
        progress: 0,
        message: '',
        resultSrc: null,
        originalSrc: null,
    });

    const workerRef = useRef<Worker | null>(null);

    useEffect(() => {
        // Initialize Worker
        workerRef.current = new Worker(new URL('../lib/workers/upscaler.worker.ts', import.meta.url), {
            type: 'module'
        });

        workerRef.current.onmessage = (event) => {
            const { status, message, progress, result } = event.data;

            switch (status) {
                case 'init':
                    setState(prev => ({ ...prev, status: 'init', message: message || 'البدء...', progress: 0 }));
                    break;
                case 'downloading':
                    setState(prev => ({ ...prev, status: 'downloading', progress: progress || 0, message: 'تحميل نموذج الذكاء الاصطناعي...' }));
                    break;
                case 'processing':
                    // Update progress bar during tile processing
                    setState(prev => ({ ...prev, status: 'processing', progress: progress || 0, message: message || 'جارٍ المعالجة...' }));
                    break;
                case 'complete':
                    setState(prev => ({ ...prev, status: 'complete', resultSrc: result, progress: 100 }));
                    break;
                case 'error':
                    setState(prev => ({ ...prev, status: 'error', message: message || 'حدث خطأ.' }));
                    break;
            }
        };

        return () => {
            workerRef.current?.terminate();
        };
    }, []);

    const upscaleImage = useCallback((file: File) => {
        const originalUrl = URL.createObjectURL(file);
        setState({
            status: 'init',
            progress: 0,
            message: 'جارٍ التهيئة...',
            resultSrc: null,
            originalSrc: originalUrl
        });

        workerRef.current?.postMessage({ type: 'upscale', image: originalUrl });
    }, []);

    const reset = useCallback(() => {
        setState({
            status: 'idle',
            progress: 0,
            message: '',
            resultSrc: null,
            originalSrc: null,
        });
    }, []);

    return { ...state, upscaleImage, reset };
}

--- END OF FILE hooks/useUpscaler.ts ---

================================================================================

--- START OF FILE hooks/useVanguardCarousel.ts ---

// hooks/useVanguardCarousel.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

const VANGUARD_SLOTS = 5;
// THE DEFINITIVE FIX: The cooldown is now synchronized with the component's 0.7s animation duration.
// This prevents new navigation actions from being dispatched while an animation is still in progress.
export const ANIMATION_COOLDOWN = 700;
const AUTO_NAVIGATE_INTERVAL = 2500;
const MOBILE_BREAKPOINT = 1024;
const CENTER_SLOT_INDEX = 2;

export function useVanguardCarousel(itemCount: number, isCurrentlyInView: boolean) {
    const [currentIndex, setCurrentIndex] = useState(0);
    const [hoveredId, setHoveredId] = useState<string | number | null>(null);
    const [isAnimating, setIsAnimating] = useState(false);
    const [isPageVisible, setIsPageVisible] = useState(true);
    const [isMobile, setIsMobile] = useState(false);
    const intervalRef = useRef<NodeJS.Timeout | null>(null);
    
    useEffect(() => {
        const checkDevice = () => setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
        checkDevice();
        window.addEventListener('resize', checkDevice);
        return () => window.removeEventListener('resize', checkDevice);
    }, []);

    useEffect(() => {
        const handleVisibilityChange = () => setIsPageVisible(document.visibilityState === 'visible');
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
    }, []);

    const stopInterval = useCallback(() => {
        if (intervalRef.current) clearInterval(intervalRef.current);
    }, []);

    const startInterval = useCallback(() => {
        stopInterval();
        if (itemCount > 0) {
            intervalRef.current = setInterval(() => {
                setIsAnimating(true);
                setCurrentIndex(prevIndex => (prevIndex + 1) % itemCount);
                setTimeout(() => setIsAnimating(false), ANIMATION_COOLDOWN);
            }, AUTO_NAVIGATE_INTERVAL);
        }
    }, [itemCount, stopInterval]);

    const navigateToIndex = useCallback((index: number) => {
        if (isAnimating || index === currentIndex) return;
        setIsAnimating(true);
        setCurrentIndex(index);
        startInterval(); 
        setTimeout(() => {
            setIsAnimating(false);
        }, ANIMATION_COOLDOWN);
    }, [isAnimating, currentIndex, startInterval]);

    useEffect(() => {
        if (!hoveredId && isCurrentlyInView && isPageVisible) {
            startInterval();
        } else {
            stopInterval();
        }
        return () => stopInterval();
    }, [hoveredId, isCurrentlyInView, isPageVisible, startInterval, stopInterval]);

    const handleSetHoveredId = useCallback((id: string | number | null) => {
        if (isAnimating) return;
        setHoveredId(id);
    }, [isAnimating]);

    const getCardState = useCallback((reviewIndex: number, itemId: string | number) => {
        if (itemCount === 0) return { style: { opacity: 0 }, isCenter: false, isVisible: false };

        let diff = reviewIndex - currentIndex;
        if (diff > itemCount / 2) diff -= itemCount;
        if (diff < -itemCount / 2) diff += itemCount;
        const slotIndex = diff + CENTER_SLOT_INDEX;

        if (slotIndex < 0 || slotIndex >= VANGUARD_SLOTS) {
            const isFarRight = diff > 0;
            return {
                style: { opacity: 0, transform: `translateX(${isFarRight ? '150%' : '-150%'}) scale(0.5)`, zIndex: -1 },
                isCenter: false, isVisible: false,
            };
        }

        const isCenter = slotIndex === CENTER_SLOT_INDEX;
        const style: any = { opacity: 1, zIndex: 0 };
        let transform = '';

        if (isMobile) {
            style.left = '50%';
            const offsetPx = 140; 
            const baseTranslateX = '-50%';

            switch (slotIndex) {
                case 0: // Far Left
                    transform = `translateX(calc(${baseTranslateX} - ${offsetPx * 1.6}px)) scale(0.75)`;
                    style.zIndex = 0;
                    break;
                case 1: // Near Left
                    transform = `translateX(calc(${baseTranslateX} - ${offsetPx * 0.9}px)) scale(0.8)`;
                    style.zIndex = 1;
                    break;
                case 2: // Center
                    transform = `translateX(${baseTranslateX}) scale(1)`;
                    style.zIndex = 2;
                    break;
                case 3: // Near Right
                    transform = `translateX(calc(${baseTranslateX} + ${offsetPx * 0.9}px)) scale(0.8)`;
                    style.zIndex = 1;
                    break;
                case 4: // Far Right
                    transform = `translateX(calc(${baseTranslateX} + ${offsetPx * 1.6}px)) scale(0.75)`;
                    style.zIndex = 0;
                    break;
            }
        } else { // Desktop
            const offset = 250;
            switch (slotIndex) {
                case 0: transform = `translateX(${-offset * 1.6}px) scale(0.6)`; break;
                case 1: transform = `translateX(${-offset * 0.9}px) scale(0.65)`; style.zIndex = 1; break;
                case 2: transform = `translateX(0) scale(1)`; style.zIndex = 2; break;
                case 3: transform = `translateX(${offset * 0.9}px) scale(0.65)`; style.zIndex = 1; break;
                case 4: transform = `translateX(${offset * 1.6}px) scale(0.6)`; break;
            }
        }
        
        // Apply universal vertical lift
        transform += ' translateY(-50px)';

        if (hoveredId === itemId && !isMobile) {
            style.zIndex = 3;
            transform += ' translateY(-15px)'; // This composes with the base lift
        }
        
        const isVisibleOnMobile = isMobile ? slotIndex >= 1 && slotIndex <= 3 : true;
        if (!isVisibleOnMobile) {
             style.pointerEvents = 'none';
             style.opacity = 0;
        }


        style.transform = transform;
        return { style, isCenter, isVisible: true };
    }, [currentIndex, itemCount, hoveredId, isMobile]);
    
    return {
        currentIndex,
        hoveredId,
        setHoveredId: handleSetHoveredId,
        navigateToIndex,
        getCardState,
        isMobile,
    };
}

--- END OF FILE hooks/useVanguardCarousel.ts ---

================================================================================

--- START OF FILE lib/adapters.ts ---

// lib/adapters.ts
import { urlFor } from '@/sanity/lib/image';
import { CardProps } from '@/types';

const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];

// THE OPTIMIZATION: Added `options` parameter with `width`
export const adaptToCardProps = (item: any, options: { width?: number } = {}): CardProps | null => {
    if (!item || item.legacyId === null || item.legacyId === undefined) {
        return null;
    }

    const imageAsset = item.mainImage?.asset || item.mainImageRef;
    let imageUrl = null;
    let blurDataURL: string = '';
    
    // Default to 1200 if not specified (safe default), but pages will now override this
    const targetWidth = options.width || 1200;
    // Calculate height based on 16:9 aspect ratio approximation for efficiency
    const targetHeight = Math.round(targetWidth * 0.5625);

    if (imageAsset) {
        // THE FIX: Request the specific dimension from Sanity CDN
        imageUrl = urlFor(imageAsset).width(targetWidth).height(targetHeight).fit('crop').auto('format').url();
        blurDataURL = urlFor(imageAsset).width(20).blur(10).auto('format').url();
    }

    if (!imageUrl) return null;

    let formattedDate = '';
    let publishedYear = null;

    if (item.publishedAt) {
        const date = new Date(item.publishedAt);
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        formattedDate = `${day} ${arabicMonths[monthIndex]} ${year}`;
        publishedYear = year;
    }

    let primaryCreators = [];
    if (item._type === 'review' || item._type === 'article') {
        primaryCreators = item.authors || [];
    } else if (item._type === 'news') {
        primaryCreators = item.reporters || [];
    }
    
    if (primaryCreators.length === 0) {
        primaryCreators = item.authors || item.reporters || [];
    }

    return {
        type: item._type,
        id: item._id, 
        legacyId: item.legacyId,
        slug: item.slug?.current ?? item.slug ?? '',
        game: item.game?.title,
        title: item.title,
        authors: primaryCreators,
        designers: item.designers || [],
        date: formattedDate,
        year: publishedYear,
        imageUrl: imageUrl,
        mainImageRef: imageAsset,
        score: item.score,
        tags: (item.tags || []).map((t: any) => ({ title: t.title, slug: t.slug })).filter(Boolean),
        blurDataURL: blurDataURL,
        category: item.category?.title,
        verdict: item.verdict || '',
        pros: item.pros || [],
        cons: item.cons || [],
        content: item.content || [],
        relatedReviewIds: item.relatedReviewIds || [],
        synopsis: item.synopsis,
    };
};

--- END OF FILE lib/adapters.ts ---

================================================================================

--- START OF FILE lib/auth.ts ---

// lib/auth.ts
'use server';

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { Session } from 'next-auth';
import prisma from '@/lib/prisma';

/**
 * A server-side helper to get the authenticated user's session with FRESH roles from the database.
 * Throws an error if the user is not authenticated.
 * @returns {Promise<Session>} The user's session object with up-to-date roles.
 * @throws {Error} If the user is not signed in.
 */
export async function getAuthenticatedSession(): Promise<Session> {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.id) {
        throw new Error('Authentication required. Please sign in.');
    }

    // THE DEFINITIVE FIX:
    // Fetch fresh roles from the database to ensure immediate access control changes apply
    // without requiring a re-login. We bypass the potentially stale JWT roles here.
    const user = await prisma.user.findUnique({
        where: { id: session.user.id },
        select: { 
            roles: { select: { name: true } }, 
            username: true, 
            name: true, 
            image: true, 
            email: true 
        }
    });

    if (!user) {
        throw new Error('User record not found.');
    }

    // Overwrite session data with fresh DB data
    session.user.roles = user.roles.map((r: any) => r.name);
    session.user.username = user.username;
    session.user.name = user.name;
    session.user.image = user.image;
    session.user.email = user.email;

    return session;
}

--- END OF FILE lib/auth.ts ---

================================================================================

--- START OF FILE lib/badges.tsx ---

// lib/badges.tsx
import React from 'react';

export type BadgeId = 'DIRECTOR' | 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER' | 'FOUNDER' | 'FIRST_COMMENT' | 'ENGAGED_COMMENTER' | 'TOP_CONTRIBUTOR';

export interface Badge {
    id: BadgeId;
    name: string;
    description: string;
    Icon: (props: { className?: string }) => React.JSX.Element;
}

const DirectorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2z"/></svg>;
const ReviewerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5.17 11.17l-2.83-2.83-2.83 2.83-1.17-1.17 2.83-2.83-2.83-2.83 1.17-1.17 2.83 2.83 2.83-2.83 1.17 1.17-2.83 2.83 2.83 2.83-1.17 1.17z"/></svg>;
const AuthorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>;
const ReporterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg>;
const DesignerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-2.5-11.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm5 0c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm-2.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>;

const FounderIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>;
const FirstCommentIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 12H5v-2h14v2zm0-3H5V9h14v2zm0-3H5V6h14v2z"/></svg>;
const EngagedCommenterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/></svg>;
const TopContributorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l-5.5 9h11zM12 21.8l-5.5-9h11z"/></svg>;

export const BADGES: Record<BadgeId, Badge> = {
    DIRECTOR: { id: 'DIRECTOR', name: 'مدير', description: 'يشرف على مشروع EternalGames.', Icon: DirectorIcon },
    REVIEWER: { id: 'REVIEWER', name: 'مُراجع', description: 'صوت موثوق لمراجعات الألعاب.', Icon: ReviewerIcon },
    AUTHOR: { id: 'AUTHOR', name: 'كاتب', description: 'يخطُّ المقالات والمواضيع.', Icon: AuthorIcon },
    REPORTER: { id: 'REPORTER', name: 'مراسل', description: 'يقتفي أثر أخبار الصناعة.', Icon: ReporterIcon },
    DESIGNER: { id: 'DESIGNER', name: 'مصمم', description: 'يضفي رونقًا على المحتوى.', Icon: DesignerIcon },
    FOUNDER: { id: 'FOUNDER', name: 'مؤسس', description: 'التحق بركب EternalGames في شهره الأول.', Icon: FounderIcon },
    FIRST_COMMENT: { id: 'FIRST_COMMENT', name: 'مبادر', description: 'خطَّ أول تعليقٍ له.', Icon: FirstCommentIcon },
    ENGAGED_COMMENTER: { id: 'ENGAGED_COMMENTER', name: 'مساهم', description: 'جاوزت تعليقاته العشرة.', Icon: EngagedCommenterIcon },
    TOP_CONTRIBUTOR: { id: 'TOP_CONTRIBUTOR', name: 'عمود المجتمع', description: 'جاوز الخمسين تعليقًا.', Icon: TopContributorIcon },
};

export function getBadgesForUser(user: { createdAt: Date; _count: { comments: number }, roles: string[] }): Badge[] {
    const earnedBadges: Badge[] = [];
    const roles = new Set(user.roles);

    if (roles.has('DIRECTOR')) earnedBadges.push(BADGES.DIRECTOR);
    if (roles.has('REVIEWER')) earnedBadges.push(BADGES.REVIEWER);
    if (roles.has('AUTHOR')) earnedBadges.push(BADGES.AUTHOR);
    if (roles.has('REPORTER')) earnedBadges.push(BADGES.REPORTER);
    if (roles.has('DESIGNER')) earnedBadges.push(BADGES.DESIGNER);

    const founderCutoffDate = new Date('2025-11-01');
    if (user.createdAt < founderCutoffDate) {
        earnedBadges.push(BADGES.FOUNDER);
    }

    const commentCount = user._count.comments;
    if (commentCount >= 50) earnedBadges.push(BADGES.TOP_CONTRIBUTOR);
    else if (commentCount >= 10) earnedBadges.push(BADGES.ENGAGED_COMMENTER);
    else if (commentCount >= 1) earnedBadges.push(BADGES.FIRST_COMMENT);

    return earnedBadges;
}




--- END OF FILE lib/badges.tsx ---

================================================================================

--- START OF FILE lib/countries.ts ---

// lib/countries.ts

export const countries: string[] = [
  'Afghanistan', 'Albania', 'Algeria', 'Andorra', 'Angola', 'Antigua and Barbuda', 'Argentina', 'Armenia', 'Australia', 'Austria',
  'Azerbaijan', 'Bahamas', 'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium', 'Belize', 'Benin', 'Bhutan',
  'Bolivia', 'Bosnia and Herzegovina', 'Botswana', 'Brazil', 'Brunei', 'Bulgaria', 'Burkina Faso', 'Burundi', 'Cabo Verde', 'Cambodia',
  'Cameroon', 'Canada', 'Central African Republic', 'Chad', 'Chile', 'China', 'Colombia', 'Comoros', 'Congo, Democratic Republic of the', 'Congo, Republic of the',
  'Costa Rica', 'Cote d\'Ivoire', 'Croatia', 'Cuba', 'Cyprus', 'Czech Republic', 'Denmark', 'Djibouti', 'Dominica', 'Dominican Republic',
  'Ecuador', 'Egypt', 'El Salvador', 'Equatorial Guinea', 'Eritrea', 'Estonia', 'Eswatini', 'Ethiopia', 'Fiji', 'Finland',
  'France', 'Gabon', 'Gambia', 'Georgia', 'Germany', 'Ghana', 'Greece', 'Grenada', 'Guatemala', 'Guinea',
  'Guinea-Bissau', 'Guyana', 'Haiti', 'Honduras', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq',
  'Ireland', 'Israel', 'Italy', 'Jamaica', 'Japan', 'Jordan', 'Kazakhstan', 'Kenya', 'Kiribati', 'Kuwait',
  'Kyrgyzstan', 'Laos', 'Latvia', 'Lebanon', 'Lesotho', 'Liberia', 'Libya', 'Liechtenstein', 'Lithuania', 'Luxembourg',
  'Madagascar', 'Malawi', 'Malaysia', 'Maldives', 'Mali', 'Malta', 'Marshall Islands', 'Mauritania', 'Mauritius', 'Mexico',
  'Micronesia', 'Moldova', 'Monaco', 'Mongolia', 'Montenegro', 'Morocco', 'Mozambique', 'Myanmar', 'Namibia', 'Nauru',
  'Nepal', 'Netherlands', 'New Zealand', 'Nicaragua', 'Niger', 'Nigeria', 'North Korea', 'North Macedonia', 'Norway', 'Oman',
  'Pakistan', 'Palau', 'Palestine State', 'Panama', 'Papua New Guinea', 'Paraguay', 'Peru', 'Philippines', 'Poland', 'Portugal',
  'Qatar', 'Romania', 'Russia', 'Rwanda', 'Saint Kitts and Nevis', 'Saint Lucia', 'Saint Vincent and the Grenadines', 'Samoa', 'San Marino', 'Sao Tome and Principe',
  'Saudi Arabia', 'Senegal', 'Serbia', 'Seychelles', 'Sierra Leone', 'Singapore', 'Slovakia', 'Slovenia', 'Solomon Islands', 'Somalia',
  'South Africa', 'South Korea', 'South Sudan', 'Spain', 'Sri Lanka', 'Sudan', 'Suriname', 'Sweden', 'Switzerland', 'Syria',
  'Taiwan', 'Tajikistan', 'Tanzania', 'Thailand', 'Timor-Leste', 'Togo', 'Tonga', 'Trinidad and Tobago', 'Tunisia', 'Turkey',
  'Turkmenistan', 'Tuvalu', 'Uganda', 'Ukraine', 'United Arab Emirates', 'United Kingdom', 'United States of America', 'Uruguay', 'Uzbekistan', 'Vanuatu',
  'Vatican City', 'Venezuela', 'Vietnam', 'Yemen', 'Zambia', 'Zimbabwe'
];







--- END OF FILE lib/countries.ts ---

================================================================================

--- START OF FILE lib/editorStore.ts ---

// lib/editorStore.ts
import { create } from 'zustand';
import { UploadQuality } from '@/lib/image-optimizer';

interface EditorState {
  isEditorActive: boolean;
  liveUrl: string | null;
  blockUploadQuality: UploadQuality;
  setEditorActive: (isActive: boolean) => void;
  setLiveUrl: (url: string | null) => void;
  setBlockUploadQuality: (quality: UploadQuality) => void;
}

export const useEditorStore = create<EditorState>((set) => ({
  isEditorActive: false,
  liveUrl: null,
  blockUploadQuality: '1080p',
  setEditorActive: (isActive) => set({ isEditorActive: isActive }),
  setLiveUrl: (url) => set({ liveUrl: url }),
  setBlockUploadQuality: (quality) => set({ blockUploadQuality: quality }),
}));

--- END OF FILE lib/editorStore.ts ---

================================================================================

--- START OF FILE lib/enrichment.ts ---

import prisma from '@/lib/prisma';
import { SanityAuthor } from '@/types/sanity';
import { unstable_cache } from 'next/cache';

export const getCachedEnrichedCreators = unstable_cache(
    async (creatorIds: string[]): Promise<[string, string | null][]> => {
        if (creatorIds.length === 0) return [];
        try {
            const users = await prisma.user.findMany({
                where: { id: { in: creatorIds } },
                select: { id: true, username: true },
            });
            return users.map((u: any) => [u.id, u.username || null]);
        } catch (error) {
            console.warn(`[CACHE WARNING] Database connection failed during cached creator enrichment. Skipping. Error:`, error);
            return [];
        }
    },
    ['enriched-creators'],
    { tags: ['enriched-creators'] }
);

export async function enrichCreators(creators: SanityAuthor[] | undefined): Promise<SanityAuthor[]> {
    if (!creators || creators.length === 0) return [];
    
    const userIds = creators.map(c => c.prismaUserId).filter(Boolean);
    if (userIds.length === 0) return creators;

    const usernameArray = await getCachedEnrichedCreators(userIds);
    const usernameMap = new Map(usernameArray);

    return creators.map(creator => ({
        ...creator,
        username: usernameMap.get(creator.prismaUserId) || creator.username || null,
    }));
}

export async function enrichContentList(items: any[]) {
    if (!items || items.length === 0) return [];
    
    // Collect all creator IDs to fetch them in one batch if possible, 
    // but for now, parallelizing the existing function is efficient enough with unstable_cache
    return Promise.all(items.map(async (item) => {
        const newItem = { ...item };
        if (newItem.authors) newItem.authors = await enrichCreators(newItem.authors);
        if (newItem.reporters) newItem.reporters = await enrichCreators(newItem.reporters);
        if (newItem.designers) newItem.designers = await enrichCreators(newItem.designers);
        return newItem;
    }));
}

--- END OF FILE lib/enrichment.ts ---

================================================================================

--- START OF FILE lib/image-optimizer.ts ---

// lib/image-optimizer.ts

export type UploadQuality = '1080p' | '4k' | '8k';

const RESOLUTIONS: Record<UploadQuality, { width: number; height: number }> = {
    '1080p': { width: 1920, height: 1080 },
    '4k': { width: 3840, height: 2160 },
    '8k': { width: 7680, height: 4320 },
};

const MAX_UPLOAD_SIZE_BYTES = 4.5 * 1024 * 1024; // 4.5MB Target, aligned with Vercel's Pro plan body limit
const MAX_INITIAL_FILE_SIZE_BYTES = 25 * 1024 * 1024; // 25MB Hard Limit for initial file read

/**
 * A robust, goal-oriented image optimizer.
 * It guarantees the output file will be under MAX_UPLOAD_SIZE_BYTES, or it will fail with a clear error.
 * THE FIX: Returns an object with the file and the final quality setting.
 */
export function optimizeImageForUpload(file: File, quality: UploadQuality): Promise<{ file: File; finalQuality: number; }> {
  return new Promise((resolve, reject) => {
    if (file.size > MAX_INITIAL_FILE_SIZE_BYTES) {
        return reject(new Error(`حجم الملف يتجاوز الحد الأقصى (25MB).`));
    }
    if (!file.type.startsWith('image/')) {
        return reject(new Error("الملف ليس صورة صالحة."));
    }

    const resolution = RESOLUTIONS[quality];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target?.result as string;
      img.onload = () => {
        if (!img.width || !img.height) {
            return reject(new Error("تعذر قراءة أبعاد الصورة. قد يكون الملف تالفًا."));
        }

        let { width, height } = img;
        const aspectRatio = width / height;

        if (img.width > resolution.width || img.height > resolution.height) {
            const widthRatio = resolution.width / img.width;
            const heightRatio = resolution.height / img.height;
            const ratio = Math.min(widthRatio, heightRatio);
            width = Math.round(img.width * ratio);
            height = Math.round(img.height * ratio);
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return reject(new Error('لا يمكن إنشاء سياق الكانفاس.'));

        ctx.drawImage(img, 0, 0, width, height);
        
        let currentQuality = 0.92;
        
        const attemptCompression = () => {
            canvas.toBlob(
              (blob) => {
                if (!blob) return reject(new Error('فشل تحويل الكانفاس إلى Blob.'));
                
                if (blob.size > MAX_UPLOAD_SIZE_BYTES && currentQuality > 0.5) {
                    currentQuality -= 0.08;
                    attemptCompression();
                } else {
                    if (blob.size > MAX_UPLOAD_SIZE_BYTES) {
                        reject(new Error("تعذر ضغط الصورة إلى حجم مقبول (<4.5MB). الرجاء اختيار جودة أقل أو استخدم صورة مختلفة."));
                    } else {
                        const newFileName = file.name.replace(/\.[^/.]+$/, ".jpg");
                        const optimizedFile = new File([blob], newFileName, { type: 'image/jpeg', lastModified: Date.now() });
                        // THE FIX: Resolve with the object containing file and quality
                        resolve({ file: optimizedFile, finalQuality: currentQuality });
                    }
                }
              }, 'image/jpeg', currentQuality );
        };

        attemptCompression();
      };
      img.onerror = () => reject(new Error("تعذر تحميل الصورة. قد يكون الملف تالفًا أو غير مدعوم."));
    };
    reader.onerror = () => reject(new Error("فشل قراءة الملف."));
  });
}




--- END OF FILE lib/image-optimizer.ts ---

================================================================================

--- START OF FILE lib/layoutIdStore.ts ---

// lib/layoutIdStore.ts
import { create } from 'zustand';

interface LayoutIdState {
    prefix: string;
    setPrefix: (prefix: string) => void;
}

export const useLayoutIdStore = create<LayoutIdState>((set) => ({
    prefix: 'default',
    setPrefix: (prefix) => set({ prefix }),
}));







--- END OF FILE lib/layoutIdStore.ts ---

================================================================================

--- START OF FILE lib/lightboxStore.ts ---

// lib/lightboxStore.ts
import { create } from 'zustand';

interface LightboxState {
  isOpen: boolean;
  imageUrls: string[];
  currentIndex: number;
  openLightbox: (urls: string[], startIndex: number) => void;
  closeLightbox: () => void;
  goToNext: () => void;
  goToPrevious: () => void;
}

export const useLightboxStore = create<LightboxState>((set, get) => ({
  isOpen: false,
  imageUrls: [],
  currentIndex: 0,
  openLightbox: (urls, startIndex = 0) => set({ 
    isOpen: true, 
    imageUrls: urls,
    currentIndex: startIndex 
  }),
  closeLightbox: () => set({ 
    isOpen: false, 
    imageUrls: [], 
    currentIndex: 0 
  }),
  goToNext: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const nextIndex = (currentIndex + 1) % imageUrls.length;
      set({ currentIndex: nextIndex });
    }
  },
  goToPrevious: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const prevIndex = (currentIndex - 1 + imageUrls.length) % imageUrls.length;
      set({ currentIndex: prevIndex });
    }
  },
}));




--- END OF FILE lib/lightboxStore.ts ---

================================================================================

--- START OF FILE lib/notificationStore.ts ---

// lib/notificationStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { getNotifications } from '@/app/actions/notificationActions';

interface NotificationState {
    notifications: any[];
    unreadCount: number;
    isFetching: boolean;
    lastFetched: number;
    // Fetch now accepts a 'force' flag
    fetchNotifications: (force?: boolean) => Promise<void>;
    setUnreadCount: (count: number | ((prev: number) => number)) => void;
    setNotifications: (notifs: any[] | ((prev: any[]) => any[])) => void;
}

export const useNotificationStore = create<NotificationState>()(
    persist(
        (set, get) => ({
            notifications: [],
            unreadCount: 0,
            isFetching: false,
            lastFetched: 0,

            fetchNotifications: async (force = false) => {
                const { isFetching, lastFetched, notifications } = get();
                const now = Date.now();
                
                // DATA FRESHNESS POLICY:
                // If we have data and it was fetched less than 15 minutes ago,
                // we consider it "fresh" and DO NOT fetch again on page load/refresh.
                const STALE_TIME = 15 * 60 * 1000; 
                const isFresh = (now - lastFetched < STALE_TIME);
                const hasData = notifications.length > 0;

                // If a fetch is already in progress, abort.
                if (isFetching) return;

                // If NOT forced (e.g., page load), AND we have fresh data, abort.
                if (!force && hasData && isFresh) {
                    return;
                }

                set({ isFetching: true });
                try {
                    const result = await getNotifications();
                    if (result.success) {
                        set({
                            notifications: result.notifications || [],
                            unreadCount: result.unreadCount || 0,
                            lastFetched: Date.now()
                        });
                    }
                } catch (error) {
                    console.error("Store failed to fetch notifications:", error);
                } finally {
                    set({ isFetching: false });
                }
            },

            setUnreadCount: (updater) => set(state => ({
                unreadCount: typeof updater === 'function' ? updater(state.unreadCount) : updater
            })),
            setNotifications: (updater) => set(state => ({
                notifications: typeof updater === 'function' ? updater(state.notifications) : updater
            }))
        }),
        {
            name: 'eternalgames-notifications-v1', // LocalStorage key
            // Only persist data, not the loading state
            partialize: (state) => ({ 
                notifications: state.notifications, 
                unreadCount: state.unreadCount, 
                lastFetched: state.lastFetched 
            }),
        }
    )
);

--- END OF FILE lib/notificationStore.ts ---

================================================================================

--- START OF FILE lib/prisma.ts ---

// lib/prisma.ts
import { PrismaClient } from './generated/client'
import { Pool } from 'pg'
import { PrismaPg } from '@prisma/adapter-pg'

const prismaClientSingleton = () => {
    const connectionString = process.env.DATABASE_URL

    if (!connectionString) {
        throw new Error('DATABASE_URL is not set in your environment variables')
    }

    // Configure the connection pool
    const pool = new Pool({ connectionString })
    // Create the adapter
    const adapter = new PrismaPg(pool)
    
    // Pass the adapter to the client
    return new PrismaClient({ adapter })
}

declare global {
    var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma

--- END OF FILE lib/prisma.ts ---

================================================================================

--- START OF FILE lib/rippleStore.ts ---

// lib/rippleStore.ts
import { create } from 'zustand';

type Ripple = {
  id: number;
  x: number;
  y: number;
};

interface RippleState {
  ripples: Ripple[];
  addRipple: (x: number, y: number) => void;
  removeRipple: (id: number) => void;
}

export const useRippleStore = create<RippleState>((set) => ({
  ripples: [],
  addRipple: (x, y) => {
    const newRipple = { id: Date.now(), x, y };
    set((state) => ({ ripples: [...state.ripples, newRipple] }));
  },
  removeRipple: (id) => {
    set((state) => ({ ripples: state.ripples.filter((r) => r.id !== id) }));
  },
}));




--- END OF FILE lib/rippleStore.ts ---

================================================================================

--- START OF FILE lib/sanity.client.ts ---

// lib/sanity.client.ts

import { createClient, type SanityClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

// Helper function to determine if we are on the server
const isServer = typeof window === 'undefined';

export const client = createClient({
    projectId,
    dataset,
    apiVersion,
    // THE DEFINITIVE FIX: Use CDN only on the client-side.
    // On the server (during builds, revalidation, RSC), always fetch fresh data from the API.
    // This eliminates the race condition between Vercel's build and Sanity's CDN propagation.
    useCdn: !isServer, 
    // Perspective should be 'published' for the main client.
    // Preview client will handle 'previewDrafts'.
    perspective: 'published',
});

--- END OF FILE lib/sanity.client.ts ---

================================================================================

--- START OF FILE lib/sanity.env.ts ---

// lib/sanity.env.ts

function assertValue<T>(v: T | undefined, errorMessage: string): T {
    if (v === undefined) {
        throw new Error(errorMessage)
    }
    return v
}

export const apiVersion = process.env.SANITY_API_VERSION || '2025-09-28'

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable, falling back to the server-only one.
// This makes the file safe for both client and server environments.
export const dataset = assertValue(
    process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_DATASET,
    'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_DATASET'
)

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable for the project ID as well.
export const projectId = assertValue(
    process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_PROJECT_ID,
    'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_PROJECT_ID'
)

--- END OF FILE lib/sanity.env.ts ---

================================================================================

--- START OF FILE lib/sanity.loader.ts ---

// lib/sanity.loader.ts
'use client'

interface SanityImageLoaderProps {
  src: string
  width: number
  quality?: number
}

export const sanityLoader = ({ src, width, quality }: SanityImageLoaderProps) => {
  const url = new URL(src)
  if (url.hostname !== 'cdn.sanity.io') {
    return src
  }
  
  const params = url.searchParams

  const originalWidth = params.get('w');
  const originalHeight = params.get('h');

  // Set common params
  params.set('auto', 'format')
  params.set('w', width.toString())
  params.delete('q');

  if (originalWidth && originalHeight) {
    const aspectRatio = parseInt(originalHeight, 10) / parseInt(originalWidth, 10);
    const newHeight = Math.round(width * aspectRatio);
    params.set('h', newHeight.toString());
  }
  
  return `${url.origin}${url.pathname}?${params.toString()}`
}




--- END OF FILE lib/sanity.loader.ts ---

================================================================================

--- START OF FILE lib/sanity.queries.ts ---

// lib/sanity.queries.ts

import {groq} from 'next-sanity'

// --- Base Fields & Projections (Optimized) ---
const mainImageFields = groq`asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt`
const creatorFields = groq`_id, name, prismaUserId, image, bio`
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- Projections ---
const cardProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}}, 
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}`
const cardListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- API Projections ---
const apiListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- News Hub Specific Queries ---

export const newsHeroQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...4] {
  ${cardProjection}, synopsis
}`

export const newsGridInitialQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...50] {
  ${cardListProjection}
}`

export const paginatedNewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "news" && ${publishedFilter} && defined(mainImage.asset)`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' || ')
    filter += ` && (${tagFilter})`
  }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Reviews API/Page Queries ---
export const paginatedReviewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  scoreRange?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'score' = 'latest',
) => {
  let filter = `_type == "review" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  if (scoreRange) {
    if (scoreRange === '9-10') filter += ` && score >= 9 && score <= 10`
    else if (scoreRange === '8-8.9') filter += ` && score >= 8 && score < 9`
    else if (scoreRange === '7-7.9') filter += ` && score >= 7 && score < 8`
    else if (scoreRange === '<7') filter += ` && score < 7`
  }

  const orderBy = sort === 'score' ? 'score desc, publishedAt desc' : 'publishedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Articles API/Page Queries ---
export const paginatedArticlesQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "article" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- List Page Queries ---
export const vanguardReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] { ${cardProjection} }`
export const featuredHeroReviewQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} }`
export const featuredShowcaseArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...7] { ${cardProjection} }`
export const allReviewsListQuery = groq`*[_type == "review" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allArticlesListQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByGameListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByTagListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc) { ${cardListProjection} }`

// --- Detail Page Queries ---
const contentProjection = groq`content[]{ ..., _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} }, _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}}, _type == "gameDetails" => { ... }, _type == 'youtube' => { ... } }`
const relatedContentProjection = groq`{ _id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score, "authors": authors[]->{name, prismaUserId}, "reporters": reporters[]->{name, prismaUserId}, "publishedAt": publishedAt }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{${tagFields}},
  "relatedReviews": relatedReviews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{_id, title, "slug": slug.current},
  "relatedArticles": relatedArticles[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "reporters": reporters[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "category": category->{_id, title, "slug": slug.current},
  "relatedNews": relatedNews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`

// --- Fallback & Miscellaneous Queries ---
export const latestReviewsFallbackQuery = groq`*[_type == "review" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestArticlesFallbackQuery = groq`*[_type == "article" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsFallbackQuery = groq`*[_type == "news" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...15] { _id, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, "reporters": reporters[]->{name, prismaUserId}, publishedAt, "tags": tags[]->{${tagFields}} }`
export const heroContentQuery = groq`{
  "featuredReview": *[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} },
  "latestNews": *[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} },
  "featuredArticle": *[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} }
}`
export const featuredReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const featuredArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && (title match $searchTerm + "*" || pt::text(content) match $searchTerm)] | order(publishedAt desc) [0...10] {
  _id, _type, title, "slug": slug.current, "imageUrl": mainImage.asset->url + '?w=200&h=120&fit=crop&auto=format', publishedAt,
  "authors": authors[]->{name}, "reporters": reporters[]->{name}, 
  "gameTitle": game->title, "tags": tags[]->{title}
}`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${cardProjection} }`
export const allReleasesQuery = groq`*[_type == "gameRelease" && defined(releaseDate)] | order(releaseDate asc) { 
  _id, legacyId, title, releaseDate, platforms, synopsis, "mainImage": mainImage{${mainImageFields}},
  "game": game->{ "slug": slug.current },
  "slug": game->slug.current
}`

// --- Studio Editor Queries ---
export const allGamesForStudioQuery = groq`*[_type == "game"] | order(title asc){_id, title, "slug": slug.current}`
export const allTagsForStudioQuery = groq`*[_type == "tag"] | order(title asc){_id, title, category}`
export const allCreatorsForStudioQuery = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId}`

export const editorDocumentQuery = groq`*[_id in [$id, 'drafts.' + $id]] | order(_updatedAt desc)[0]{
  ...,
  "authors": authors[]->{_id, name, prismaUserId},
  "reporters": reporters[]->{_id, name, prismaUserId},
  "designers": designers[]->{_id, name, prismaUserId},
  "game": game->{_id, title},
  "tags": tags[]->{_id, title},
  "category": category->{_id, title},
  "mainImage": mainImage.asset->{
    "_ref": _id,
    "url": url,
    "metadata": metadata
  },
  content[]{
    ...,
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } },
    _type == "imageCompare" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "twoImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "fourImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}},
      "image3": image3{..., asset->{_id, url, metadata}},
      "image4": image4{..., asset->{_id, url, metadata}}
    },
    _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}},
    _type == "gameDetails" => { ... },
    _type == 'youtube' => { ... }
  }
}`

// --- Homepage Feed Queries ---
export const homepageArticlesQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...12] { ${cardListProjection} }`
export const homepageNewsQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...18] { ${cardListProjection} }`

--- END OF FILE lib/sanity.queries.ts ---

================================================================================

--- START OF FILE lib/sanity.server.ts ---

// lib/sanity.server.ts

import { createClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

export const sanityWriteClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN!,
    // THE DEFINITIVE FIX: Explicitly tell this client to fetch drafts.
    perspective: 'previewDrafts',
});

--- END OF FILE lib/sanity.server.ts ---

================================================================================

--- START OF FILE lib/store.ts ---

// lib/store.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { setBookmarkAction, setLikeAction, recordShareAction } from '@/app/actions/contentActions';
import useToastStore from './toastStore'; // <-- THE FIX: Import the raw store, not the hook

const createContentKey = (id: number, type: string) => `${type}-${id}`;

const debounceTimers: { [key: string]: NodeJS.Timeout } = {};

const initialState = {
    bookmarks: [] as string[],
    likes: [] as string[],
    shares: [] as string[],
    isSignInModalOpen: false,
    isSyncedWithDb: false,
};

type UserState = typeof initialState & { _hasHydrated: boolean };

type UserActions = {
    toggleBookmark: (contentId: number, contentType: string) => void;
    setSignInModalOpen: (isOpen: boolean) => void;
    toggleLike: (contentId: number, contentType: string, contentSlug: string) => void;
    addShare: (contentId: number, contentType: string, contentSlug: string) => void;
    syncWithDb: (dbData: { 
        engagements: { contentId: number, contentType: string, type: 'LIKE' | 'BOOKMARK' }[],
        shares: { contentId: number, contentType: string }[]
    }) => void;
    setIsSyncedWithDb: (isSynced: boolean) => void;
    reset: () => void;
};

export const useUserStore = create<UserState & UserActions>()(
    persist(
        (set, get) => ({
            ...initialState,
            _hasHydrated: false,

            toggleBookmark: (contentId, contentType) => {
                const key = createContentKey(contentId, contentType);
                const originalBookmarks = get().bookmarks;
                const isCurrentlyBookmarked = originalBookmarks.includes(key);
                const finalState = !isCurrentlyBookmarked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);
                
                set({ bookmarks: finalState ? [...originalBookmarks, key] : originalBookmarks.filter(k => k !== key) });

                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setBookmarkAction(contentId, contentType, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        // THE FIX: Call the raw store's action directly
                        useToastStore.getState().addToast('فشل الحفظ.', 'error');
                        set({ bookmarks: originalBookmarks });
                    }
                }, 500);
            },
            
            setSignInModalOpen: (isOpen: boolean) => set({ isSignInModalOpen: isOpen }),

            toggleLike: (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                const originalLikes = get().likes;
                const isCurrentlyLiked = originalLikes.includes(key);
                const finalState = !isCurrentlyLiked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);

                set({ likes: finalState ? [...originalLikes, key] : originalLikes.filter(k => k !== key) });
                
                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setLikeAction(contentId, contentType, contentSlug, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        // THE FIX: Call the raw store's action directly
                        useToastStore.getState().addToast('أخفق تسجيل الإعجاب.', 'error');
                        set({ likes: originalLikes });
                    }
                }, 500);
            },

            addShare: async (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                if (get().shares.includes(key)) return;
                set(state => ({ shares: [...state.shares, key] }));
                const result = await recordShareAction(contentId, contentType, contentSlug);
                if (result.success && result.shares) {
                    set({ shares: result.shares.map((s: any) => createContentKey(s.contentId, s.contentType)) });
                }
            },

            syncWithDb: (dbData) => {
                const dbLikes: string[] = [];
                const dbBookmarks: string[] = [];
                (dbData.engagements || []).forEach(engagement => {
                    const key = createContentKey(engagement.contentId, engagement.contentType);
                    if (engagement.type === 'LIKE') dbLikes.push(key);
                    else if (engagement.type === 'BOOKMARK') dbBookmarks.push(key);
                });
                const dbShares = (dbData.shares || []).map(s => createContentKey(s.contentId, s.contentType));
                set({ likes: dbLikes, bookmarks: dbBookmarks, shares: dbShares });
            },

            setIsSyncedWithDb: (isSynced: boolean) => set({ isSyncedWithDb: isSynced }),
            reset: () => set(initialState),
        }),
        {
            name: 'eternalgames-user-preferences-v3',
            onRehydrateStorage: () => (state) => { if (state) { state._hasHydrated = true; } },
            partialize: (state) => ({
                bookmarks: state.bookmarks,
                likes: state.likes,
                shares: state.shares,
            }),
        }
    )
);




--- END OF FILE lib/store.ts ---

================================================================================

--- START OF FILE lib/toastStore.ts ---

// lib/toastStore.ts

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

export type ToastType = 'success' | 'error' | 'info';
export type ToastPosition = 'right' | 'left'; // <-- NEW TYPE

interface ToastMessage {
id: string;
message: string;
type: ToastType;
position?: ToastPosition; // <-- NEW PROPERTY
}

interface ToastState {
toasts: ToastMessage[];
addToast: (message: string, type: ToastType, position?: ToastPosition) => void; // <-- MODIFIED
dismissToast: (id: string) => void;
}

const useToastStore = create<ToastState>((set) => ({
toasts: [],
addToast: (message, type, position = 'right') => { // <-- SET DEFAULT TO RIGHT
const id = uuidv4();
set((state) => ({ toasts: [...state.toasts, { id, message, type, position }] }));
},
dismissToast: (id) => {
set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id) }));
},
}));

// This is the public hook that components will use.
export const useToast = () => {
const { addToast } = useToastStore();
return {
success: (message: string, position?: ToastPosition) => addToast(message, 'success', position),
error: (message: string, position?: ToastPosition) => addToast(message, 'error', position),
info: (message: string, position?: ToastPosition) => addToast(message, 'info', position),
};
};

export default useToastStore;
































--- END OF FILE lib/toastStore.ts ---

================================================================================

--- START OF FILE lib/translations.ts ---

// lib/translations.ts

const TAG_TRANSLATIONS: Record<string, string> = {
    // === Game Tags (For Reviews & Articles) ===
    "Action": "أكشن",
    "Adventure": "مغامرات",
    "RPG": "تقمص الأدوار",
    "JRPG": "تقمص أدوار ياباني",
    "Strategy": "استراتيجية",
    "Simulation": "محاكاة",
    "Sports": "رياضة",
    "Racing": "سباقات",
    "Puzzle": "ألغاز",
    "Fighting": "قتال",
    "Horror": "رُعب",
    "Survival": "نجاة",
    "Platformer": "منصات",
    "FPS": "منظور الشخص الأول",
    "TPS": "منظور الشخص الثالث",
    "Sci-Fi": "خيال علمي",
    "Fantasy": "فانتازيا",
    "Historical": "تاريخي",
    "Post-Apocalyptic": "ما بعد الفناء",
    "Cyberpunk": "سايبربنك",
    "Mystery": "غموض",
    "Atmospheric": "أجواء غامرة",
    "Open World": "عالم مفتوح",
    "Single-Player": "طور فردي",
    "Multiplayer": "طور جماعي",
    "Co-op": "طور تعاوني",
    "Competitive": "طور تنافسي",
    "Story-Driven": "عمق قصصي",
    "Pixel Art": "فن البكسل",
    "Anime": "أنمي",
    "Classic": "كلاسيكي",
    "Indie": "ألعاب مستقلة",

    // === News-Specific Tags (Now also used for Category) ===
    "Acquisition": "استحواذ",
    "Sales": "أرقام المبيعات",
    "Game Announcement": "الكشف عن لعبة",
    "Industry News": "نبض الصناعة",
    "Financials": "شؤون مالية",
    "Technology": "تقنية",
    "Esports": "المنافسات الإلكترونية",
    "Game Update": "تحديث للعبة",
    "Layoffs": "تسريح موظفين",
    "Game Size": "حجم اللعبة",
    "Release Date": "موعد الإصدار",
    "Age Ratings": "تقييمات عمرية",

    // === Article-Specific Tags ===
    "Opinion": "رأي",
    "Guide": "إعانة",
    "Everything You Need to Know": "الدليل الشامل",
    "Analysis": "تحليل",
    "Biography": "سيرة",
    "Story": "قصة",
};

// THE FIX: Added role translations
const ROLE_TRANSLATIONS: Record<string, string> = {
    "DIRECTOR": "المدير",
    "ADMIN": "المسؤول",
    "REVIEWER": "المُراجع",
    "AUTHOR": "الكاتب",
    "REPORTER": "المراسل",
    "DESIGNER": "المصمم",
    "USER": "عضو"
};

export const translateTag = (tagTitle: string): string => {
    return TAG_TRANSLATIONS[tagTitle] || tagTitle;
};

export const translateRole = (roleName: string): string => {
    return ROLE_TRANSLATIONS[roleName] || roleName;
};

--- END OF FILE lib/translations.ts ---

================================================================================

--- START OF FILE lib/uiStore.ts ---

import { create } from 'zustand';

interface UIState {
    isMobileMenuOpen: boolean;
    toggleMobileMenu: () => void;
    setMobileMenuOpen: (isOpen: boolean) => void;
}

export const useUIStore = create<UIState>((set) => ({
    isMobileMenuOpen: false,
    toggleMobileMenu: () => set((state) => ({ isMobileMenuOpen: !state.isMobileMenuOpen })),
    setMobileMenuOpen: (isOpen) => set({ isMobileMenuOpen: isOpen }),
}));

--- END OF FILE lib/uiStore.ts ---

================================================================================

--- START OF FILE lib/app/api/articles/route.ts ---



--- END OF FILE lib/app/api/articles/route.ts ---

================================================================================

--- START OF FILE lib/app/api/reviews/route.ts ---



--- END OF FILE lib/app/api/reviews/route.ts ---

================================================================================

--- START OF FILE lib/workers/upscaler.worker.ts ---

// lib/workers/upscaler.worker.ts

// Stubbed worker to preserve architecture without the heavy dependency
self.addEventListener('message', async (event) => {
  const { type } = event.data;

  if (type === 'upscale') {
      // Simulate initialization delay
      self.postMessage({ status: 'init', message: 'جاري الاتصال بالمسبك...' });
      
      setTimeout(() => {
          // Return specific maintenance error to UI
          self.postMessage({ 
              status: 'error', 
              message: 'المسبك البصري يخضع للصيانة حالياً. يرجى المحاولة لاحقاً.' 
          });
      }, 1500);
  }
});

--- END OF FILE lib/workers/upscaler.worker.ts ---

================================================================================

--- START OF FILE prisma/schema.prisma ---

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/client"
}

datasource db {
  provider = "postgresql"
}

model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[] @relation("RoleToUser")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  username            String?              @unique
  email               String?              @unique
  emailVerified       DateTime?
  image               String?
  password            String?
  createdAt           DateTime             @default(now())
  bio                 String?
  twitterHandle       String?
  age                 Int?
  country             String?
  agePublic           Boolean              @default(true)
  countryPublic       Boolean              @default(true)
  instagramHandle     String?
  
  // --- BAN SYSTEM FIELDS ---
  isBanned            Boolean              @default(false)
  banReason           String?
  bannedAt            DateTime?

  accounts            Account[]
  engagements         Engagement[]
  comments            Comment[]
  commentVotes        CommentVote[]
  passwordResetTokens PasswordResetToken[]
  sessions            Session[]
  shares              Share[]
  roles               Role[]               @relation("RoleToUser")

  // --- NOTIFICATION RELATIONS ---
  receivedNotifications Notification[]     @relation("ReceivedNotifications")
  sentNotifications     Notification[]     @relation("SentNotifications")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  token   String   @unique
  expires DateTime
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Engagement {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  type        EngagementType
  userId      String
  contentId   Int
  contentType String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId, contentType, type])
}

model Share {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  userId      String
  contentId   Int
  contentType String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Comment {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  content     String
  contentSlug String
  isDeleted   Boolean       @default(false)
  authorId    String
  parentId    String?
  author      User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent      Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies     Comment[]     @relation("CommentReplies")
  votes       CommentVote[]
}

model CommentVote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  type      VoteType
  userId    String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
}

model Notification {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  userId       String           // The user receiving the notification
  senderId     String           // The user who triggered it
  type         NotificationType
  resourceId   String           // e.g., the Comment ID
  resourceSlug String           // The content slug
  link         String           // Deep link to the content
  read         Boolean          @default(false)

  user         User             @relation("ReceivedNotifications", fields: [userId], references: [id], onDelete: Cascade)
  sender       User             @relation("SentNotifications", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum NotificationType {
  REPLY
}

enum VoteType {
  LIKE
  DISLIKE
}

enum EngagementType {
  LIKE
  BOOKMARK
}

--- END OF FILE prisma/schema.prisma ---

================================================================================

--- START OF FILE prisma/seed.ts ---

// prisma/seed.ts
import { PrismaClient } from '../lib/generated/client';
import { Pool } from 'pg';
import { PrismaPg } from '@prisma/adapter-pg';

const connectionString = process.env.DATABASE_URL;
if (!connectionString) throw new Error('DATABASE_URL is not set');

const pool = new Pool({ connectionString });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const ROLES_TO_CREATE = [
  'DIRECTOR',
  'ADMIN',
  'REVIEWER',
  'AUTHOR',
  'REPORTER',
  'DESIGNER',
  'USER'
];

async function main() {
  console.log('Start seeding roles...');
  for (const roleName of ROLES_TO_CREATE) {
    const role = await prisma.role.upsert({
      where: { name: roleName },
      update: {},
      create: { name: roleName },
    });
    console.log(`Created or found role: ${role.name}`);
  }
  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    await pool.end();
  });

--- END OF FILE prisma/seed.ts ---

================================================================================

--- START OF FILE prisma/migrations/migration_lock.toml ---

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"








--- END OF FILE prisma/migrations/migration_lock.toml ---

================================================================================

--- START OF FILE prisma/migrations/0_baseline/migration.sql ---

-- CreateEnum
CREATE TYPE "VoteType" AS ENUM ('LIKE', 'DISLIKE');

-- CreateTable
CREATE TABLE "Role" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "Role_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "username" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "password" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "bio" TEXT,
    "twitterHandle" TEXT,
    "instagramHandle" TEXT,
    "age" INTEGER,
    "country" TEXT,
    "agePublic" BOOLEAN NOT NULL DEFAULT true,
    "countryPublic" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "Like" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Like_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Share" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Share_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Bookmark" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Bookmark_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "content" TEXT NOT NULL,
    "contentSlug" TEXT NOT NULL,
    "isDeleted" BOOLEAN NOT NULL DEFAULT false,
    "authorId" TEXT NOT NULL,
    "parentId" TEXT,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CommentVote" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "VoteType" NOT NULL,
    "userId" TEXT NOT NULL,
    "commentId" TEXT NOT NULL,

    CONSTRAINT "CommentVote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_RoleToUser" (
    "A" INTEGER NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_RoleToUser_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Role_name_key" ON "Role"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "Like_userId_contentId_contentType_key" ON "Like"("userId", "contentId", "contentType");

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_key" ON "Bookmark"("userId", "contentId");

-- CreateIndex
CREATE UNIQUE INDEX "CommentVote_userId_commentId_key" ON "CommentVote"("userId", "commentId");

-- CreateIndex
CREATE INDEX "_RoleToUser_B_index" ON "_RoleToUser"("B");

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Like" ADD CONSTRAINT "Like_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Share" ADD CONSTRAINT "Share_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Bookmark" ADD CONSTRAINT "Bookmark_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "Comment"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_A_fkey" FOREIGN KEY ("A") REFERENCES "Role"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_B_fkey" FOREIGN KEY ("B") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;









--- END OF FILE prisma/migrations/0_baseline/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

-- CreateTable
CREATE TABLE "PasswordResetToken" (
    "id" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "PasswordResetToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "PasswordResetToken_token_key" ON "PasswordResetToken"("token");

-- AddForeignKey
ALTER TABLE "PasswordResetToken" ADD CONSTRAINT "PasswordResetToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;








--- END OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

/*
  Warnings:

  - A unique constraint covering the columns `[userId,contentId,contentType]` on the table `Bookmark` will be added. If there are existing duplicate values, this will fail.

*/
-- DropIndex
DROP INDEX "public"."Bookmark_userId_contentId_key";

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_contentType_key" ON "Bookmark"("userId", "contentId", "contentType");








--- END OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

/*
  Warnings:

  - You are about to drop the `Bookmark` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Like` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "EngagementType" AS ENUM ('LIKE', 'BOOKMARK');

-- DropForeignKey
ALTER TABLE "public"."Bookmark" DROP CONSTRAINT "Bookmark_userId_fkey";

-- DropForeignKey
ALTER TABLE "public"."Like" DROP CONSTRAINT "Like_userId_fkey";

-- DropTable
DROP TABLE "public"."Bookmark";

-- DropTable
DROP TABLE "public"."Like";

-- CreateTable
CREATE TABLE "Engagement" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "EngagementType" NOT NULL,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Engagement_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Engagement_userId_contentId_contentType_type_key" ON "Engagement"("userId", "contentId", "contentType", "type");

-- AddForeignKey
ALTER TABLE "Engagement" ADD CONSTRAINT "Engagement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;








--- END OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

================================================================================

--- START OF FILE sanity/.env ---

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"

--- END OF FILE sanity/.env ---

================================================================================

--- START OF FILE sanity/.env.local ---

# This file is for local Sanity Studio development (npx sanity dev)
# It should NOT be committed to version control.

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"
SANITY_STUDIO_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"

--- END OF FILE sanity/.env.local ---

================================================================================

--- START OF FILE sanity/env.ts ---

export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '2025-09-28'

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_STUDIO_DATASET,
  'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_STUDIO_DATASET'
)

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_STUDIO_PROJECT_ID,
  'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_STUDIO_PROJECT_ID'
)

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage)
  }

  return v
}

--- END OF FILE sanity/env.ts ---

================================================================================

--- START OF FILE sanity/package-lock.json ---

{
  "name": "eternalgames-studio",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "eternalgames-studio",
      "version": "1.0.0",
      "license": "UNLICENSED",
      "dependencies": {
        "styled-components": "^6.1.19"
      }
    },
    "node_modules/@emotion/is-prop-valid": {
      "version": "1.2.2",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.8.1"
      }
    },
    "node_modules/@emotion/memoize": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@emotion/unitless": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@types/stylis": {
      "version": "4.2.5",
      "license": "MIT"
    },
    "node_modules/camelize": {
      "version": "1.0.1",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/css-color-keywords": {
      "version": "1.0.0",
      "license": "ISC",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/css-to-react-native": {
      "version": "3.2.0",
      "license": "MIT",
      "dependencies": {
        "camelize": "^1.0.0",
        "css-color-keywords": "^1.0.0",
        "postcss-value-parser": "^4.0.2"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.4.49",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.7",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "license": "MIT"
    },
    "node_modules/shallowequal": {
      "version": "1.1.0",
      "license": "MIT"
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/styled-components": {
      "version": "6.1.19",
      "resolved": "https://registry.npmjs.org/styled-components/-/styled-components-6.1.19.tgz",
      "integrity": "sha512-1v/e3Dl1BknC37cXMhwGomhO8AkYmN41CqyX9xhUDxry1ns3BFQy2lLDRQXJRdVVWB9OHemv/53xaStimvWyuA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/is-prop-valid": "1.2.2",
        "@emotion/unitless": "0.8.1",
        "@types/stylis": "4.2.5",
        "css-to-react-native": "3.2.0",
        "csstype": "3.1.3",
        "postcss": "8.4.49",
        "shallowequal": "1.1.0",
        "stylis": "4.3.2",
        "tslib": "2.6.2"
      },
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/styled-components"
      },
      "peerDependencies": {
        "react": ">= 16.8.0",
        "react-dom": ">= 16.8.0"
      }
    },
    "node_modules/stylis": {
      "version": "4.3.2",
      "license": "MIT"
    },
    "node_modules/tslib": {
      "version": "2.6.2",
      "license": "0BSD"
    }
  }
}





--- END OF FILE sanity/package-lock.json ---

================================================================================

--- START OF FILE sanity/package.json ---

{
  "name": "eternalgames-studio",
  "private": true,
  "version": "1.0.0",
  "main": "package.json",
  "license": "UNLICENSED",
  "scripts": {
    "dev": "sanity dev",
    "start": "sanity start",
    "build": "sanity build",
    "deploy": "sanity deploy",
    "deploy-graphql": "sanity graphql deploy"
  },
  "dependencies": {
    "@sanity/vision": "^4.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-is": "^18.3.1",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19"
  }
}




--- END OF FILE sanity/package.json ---

================================================================================

--- START OF FILE sanity/sanity.config.ts ---

// sanity/sanity.config.ts
import {defineConfig} from 'sanity'
import {structureTool, StructureBuilder} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'
import {apiVersion, dataset, projectId} from './env'
import {ColorWheelIcon} from '@sanity/icons'

// Custom desk structure for singletons
export const singletonStructure = (S: StructureBuilder) =>
  S.list()
    .title('Content')
    .items([
      // Our singleton document
      S.listItem()
        .title('Color Dictionary')
        .id('colorDictionary')
        .icon(ColorWheelIcon)
        .child(
          S.document()
            .schemaType('colorDictionary')
            .documentId('colorDictionary')
            .title('Automatic Word Color Dictionary')
        ),
      S.divider(),
      // The rest of our document types
      ...S.documentTypeListItems().filter(
        (listItem) => !['colorDictionary'].includes(listItem.getId() || '')
      ),
    ])

export default defineConfig({
  basePath: '/studio',
  projectId,
  dataset,
  // THE DEFINITIVE FIX: Add the API token to the Sanity config
  // This allows the local studio to see drafts and make authenticated requests.
  token: process.env.SANITY_STUDIO_API_WRITE_TOKEN,
  schema: {
    types: schemaTypes,
  },
  plugins: [
    structureTool({
      structure: singletonStructure,
    }),
    visionTool({defaultApiVersion: apiVersion}),
  ],
})

--- END OF FILE sanity/sanity.config.ts ---

================================================================================

--- START OF FILE sanity/data/initial-categories.ndjson ---

{"_id":"news-category-acquisition","_type":"tag","title":"Acquisition","category":"News","slug":{"_type":"slug","current":"acquisition"}}
{"_id":"news-category-sales","_type":"tag","title":"Sales","category":"News","slug":{"_type":"slug","current":"sales"}}
{"_id":"news-category-game-announcement","_type":"tag","title":"Game Announcement","category":"News","slug":{"_type":"slug","current":"game-announcement"}}
{"_id":"news-category-industry-news","_type":"tag","title":"Industry News","category":"News","slug":{"_type":"slug","current":"industry-news"}}
{"_id":"news-category-financials","_type":"tag","title":"Financials","category":"News","slug":{"_type":"slug","current":"financials"}}
{"_id":"news-category-technology","_type":"tag","title":"Technology","category":"News","slug":{"_type":"slug","current":"technology"}}
{"_id":"news-category-esports","_type":"tag","title":"Esports","category":"News","slug":{"_type":"slug","current":"esports"}}
{"_id":"news-category-game-update","_type":"tag","title":"Game Update","category":"News","slug":{"_type":"slug","current":"game-update"}}
{"_id":"news-category-layoffs","_type":"tag","title":"Layoffs","category":"News","slug":{"_type":"slug","current":"layoffs"}}
{"_id":"news-category-game-size","_type":"tag","title":"Game Size","category":"News","slug":{"_type":"slug","current":"game-size"}}
{"_id":"news-category-release-date","_type":"tag","title":"Release Date","category":"News","slug":{"_type":"slug","current":"release-date"}}
{"_id":"news-category-age-ratings","_type":"tag","title":"Age Ratings","category":"News","slug":{"_type":"slug","current":"age-ratings"}}
{"_id":"article-category-opinion","_type":"tag","title":"Opinion","category":"Article","slug":{"_type":"slug","current":"opinion"}}
{"_id":"article-category-guide","_type":"tag","title":"Guide","category":"Article","slug":{"_type":"slug","current":"guide"}}
{"_id":"article-category-everything-you-need-to-know","_type":"tag","title":"Everything You Need to Know","category":"Article","slug":{"_type":"slug","current":"everything-you-need-to-know"}}
{"_id":"article-category-analysis","_type":"tag","title":"Analysis","category":"Article","slug":{"_type":"slug","current":"analysis"}}
{"_id":"article-category-biography","_type":"tag","title":"Biography","category":"Article","slug":{"_type":"slug","current":"biography"}}
{"_id":"article-category-story","_type":"tag","title":"Story","category":"Article","slug":{"_type":"slug","current":"story"}}

--- END OF FILE sanity/data/initial-categories.ndjson ---

================================================================================

--- START OF FILE sanity/lib/client.ts ---

import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId } from '../env'

export const client = createClient({
projectId,
dataset,
apiVersion,
useCdn: true, // Set to false if statically generating pages, using ISR or tag-based revalidation
})

--- END OF FILE sanity/lib/client.ts ---

================================================================================

--- START OF FILE sanity/lib/image.ts ---

// sanity/lib/image.ts
import createImageUrlBuilder from '@sanity/image-url'
import { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source: SanityImageSource) => {
  return builder.image(source).auto('format').fit('max')
}

--- END OF FILE sanity/lib/image.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/articleType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'article',
title: 'Article',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'slug', title: 'slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'authors', title: 'Authors', type: 'array', of: [{type: 'reference', to: {type: 'author'}}], validation: (Rule) => Rule.required().min(1)}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
// THE DEFINITIVE FIX: This is now a single reference for the primary category.
defineField({
    name: 'category',
    title: 'Category',
    type: 'reference',
    to: [{type: 'tag'}],
    options: { filter: 'category == "Article"' },
    validation: (Rule) => Rule.required()
}),
// The multi-select 'tags' field is now for general game tags.
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
defineField({name: 'content', title: 'Content', type: 'blockContent'}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
defineField({name: 'relatedArticles', title: 'Related Articles', type: 'array', of: [{type: 'reference', to: {type: 'article'}}]}),
],
preview: {
select: {title: 'title', media: 'mainImage'},
},
})

--- END OF FILE sanity/schemaTypes/articleType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/blockContentType.ts ---

// sanity/schemaTypes/blockContentType.ts

import {defineType, defineArrayMember, defineField} from 'sanity'

/**
 * This is the schema definition for the rich text fields used for
 * author biography, collaborator details, and sub-descriptions.
 **/
export default defineType({
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    defineArrayMember({
      title: 'Block',
      type: 'block',
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H1', value: 'h1'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      marks: {
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              defineField({
                title: 'URL',
                name: 'href',
                type: 'url',
              }),
            ],
          },
          {
            name: 'color',
            title: 'Color',
            type: 'object',
            fields: [
              {
                name: 'hex',
                title: 'Hex',
                type: 'string',
              },
            ],
          },
        ],
      },
    }),
    defineArrayMember({
      type: 'image',
      options: {hotspot: true},
    }),
    defineArrayMember({
      type: 'imageCompare',
    }),
    defineArrayMember({
      type: 'twoImageGrid',
    }),
    defineArrayMember({
      type: 'fourImageGrid',
    }),
    defineArrayMember({
      type: 'gameDetails',
    }),
    defineArrayMember({
      // ADDED
      type: 'table',
    }),
    defineArrayMember({
      type: 'youtube',
    }),
  ],
})

--- END OF FILE sanity/schemaTypes/blockContentType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/fourImageGridType.ts ---

// sanity/schemaTypes/fourImageGridType.ts
import { defineType, defineField } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'fourImageGrid',
    title: 'Four Image Grid',
    type: 'object',
    fields: [
        defineField({ name: 'image1', title: 'Image 1', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image2', title: 'Image 2', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image3', title: 'Image 3', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image4', title: 'Image 4', type: 'image', options: { hotspot: true } }),
    ],
    preview: {
        select: { media: 'image1' },
        prepare({ media }: { media: Image }) {
            return { title: 'Four Image Grid', media };
        },
    },
});




--- END OF FILE sanity/schemaTypes/fourImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameDetailsType.ts ---

// sanity/schemaTypes/gameDetailsType.ts
import { defineType, defineField, defineArrayMember } from 'sanity';

export default defineType({
  name: 'gameDetails',
  title: 'Game Details',
  type: 'object',
  fields: [
    defineField({
      name: 'details',
      title: 'Details',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          name: 'detailItem',
          fields: [
            defineField({
              name: 'label',
              title: 'Label (Arabic)',
              type: 'string',
              validation: (Rule) => Rule.required(),
            }),
            defineField({
              name: 'value',
              title: 'Value (English or Arabic)',
              type: 'string',
              validation: (Rule) => Rule.required(),
            }),
          ],
          preview: {
            select: {
              title: 'value',
              subtitle: 'label',
            },
          },
        }),
      ],
    }),
    defineField({
      name: 'width',
      title: 'Width',
      type: 'string',
      readOnly: true,
      description: 'This value is set automatically by resizing the block in the editor.',
    }),
  ],
  preview: {
    select: {
      details: 'details',
    },
    prepare({ details }) {
      const count = details ? details.length : 0;
      return {
        title: 'Game Details Block',
        subtitle: `${count} detail(s)`,
      };
    },
  },
});

--- END OF FILE sanity/schemaTypes/gameDetailsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameReleaseType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'gameRelease',
title: 'Game Release',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'releaseDate', title: 'Release Date', type: 'date', validation: (Rule) => Rule.required()}),
defineField({name: 'platforms', title: 'Platforms', type: 'array', of: [{type: 'string'}], options: {list: ['PC', 'PlayStation', 'Xbox', 'Switch']}}),
defineField({name: 'mainImage', title: 'Main Image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'synopsis', title: 'Synopsis', type: 'text', validation: (Rule) => Rule.required()}),
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', subtitle: 'releaseDate', media: 'mainImage'},
},
})

--- END OF FILE sanity/schemaTypes/gameReleaseType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'game',
title: 'Game',
type: 'document',
fields: [
defineField({
name: 'title',
title: 'Title',
type: 'string',
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'slug',
title: 'Slug',
type: 'slug',
options: {
source: 'title',
maxLength: 96,
},
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'mainImage',
title: 'Main Image',
type: 'image',
options: {
hotspot: true,
},
}),
],
})




--- END OF FILE sanity/schemaTypes/gameType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/imageCompareType.ts ---

// sanity/schemaTypes/imageCompareType.ts
import { defineType, defineField, Rule } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'imageCompare',
    title: 'Image Comparison',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1 (Before)',
            type: 'image',
            options: { hotspot: true },
            validation: (Rule) => Rule.required(),
        }),
        defineField({
            name: 'image2',
            title: 'Image 2 (After)',
            type: 'image',
            options: { hotspot: true },
            validation: (Rule) => Rule.required(),
        }),
        defineField({
            name: 'size',
            title: 'Display Size',
            type: 'string',
            options: {
                list: [
                    { title: 'Small', value: 'small' },
                    { title: 'Medium', value: 'medium' },
                    { title: 'Large', value: 'large' },
                ],
                layout: 'radio',
            },
            initialValue: 'large',
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }: { media?: Image, media2?: Image }) {
            return {
                title: 'Image Comparison',
                media: media || media2,
            };
        },
    },
});




--- END OF FILE sanity/schemaTypes/imageCompareType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/index.ts ---

// sanity/schemaTypes/index.ts
import blockContent from './blockContentType'
import tag from './tagType'
import review from './reviewType'
import article from './articleType'
import news from './newsType'
import game from './gameType'
import gameRelease from './gameReleaseType'
import imageCompare from './imageCompareType'
import twoImageGrid from './twoImageGridType'
import fourImageGrid from './fourImageGridType'
import gameDetails from './gameDetailsType'
import table from './tableType'
import author from './creators/authorType'
import designer from './creators/designerType'
import reporter from './creators/reporterType'
import reviewer from './creators/reviewerType'
import colorDictionary from './custom_inputs/colorDictionaryType'
import youtube from './custom_objects/youtubeType'

export const schemaTypes = [
  // Documents
  review,
  article,
  news,
  game,
  gameRelease,
  tag,
  // Creators
  author,
  designer,
  reporter,
  reviewer,
  // Singleton Documents
  colorDictionary, // ADDED
  // Objects & Custom Inputs
  blockContent,
  imageCompare,
  twoImageGrid,
  fourImageGrid,
  gameDetails,
  table,
  youtube,
]

--- END OF FILE sanity/schemaTypes/index.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/newsType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'news',
    title: 'News',
    type: 'document',
    fields: [
        defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
        defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
        defineField({name: 'reporters', title: 'Reporters', type: 'array', of: [{type: 'reference', to: {type: 'reporter'}}], validation: (Rule) => Rule.required().min(1)}),
        defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
        // THE DEFINITIVE FIX: Changed from a static string list to a single reference to a categorized tag.
        defineField({
            name: 'category',
            title: 'Category',
            type: 'reference',
            to: {type: 'tag'},
            options: {
                filter: 'category == "News"'
            },
            validation: (Rule) => Rule.required()
        }),
        defineField({name: 'game', title: 'Game (Optional)', type: 'reference', to: {type: 'game'}}),
        defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
        defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
        defineField({name: 'content', title: 'Content', type: 'blockContent'}),
        defineField({name: 'relatedNews', title: 'Related News', type: 'array', of: [{type: 'reference', to: {type: 'news'}}]}),
        defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
    ],
    preview: {
        select: {title: 'title', media: 'mainImage', category: 'category.title'},
        prepare(selection) {
            const { category } = selection
            return {...selection, subtitle: category}
        }
    },
})

--- END OF FILE sanity/schemaTypes/newsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/reviewType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'review',
title: 'Review',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'authors', title: 'Reviewers', type: 'array', of: [{type: 'reference', to: {type: 'reviewer'}}], validation: (Rule) => Rule.required().min(1)}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'score', title: 'Score', type: 'number', validation: (Rule) => Rule.required().min(0).max(10)}),
defineField({name: 'verdict', title: 'Verdict', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'pros', title: 'Pros', type: 'array', of: [{type: 'string'}]}),
defineField({name: 'cons', title: 'Cons', type: 'array', of: [{type: 'string'}]}),
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
defineField({name: 'content', title: 'Content', type: 'blockContent', validation: (Rule) => Rule.required()}),
defineField({name: 'relatedReviews', title: 'Related Reviews', type: 'array', of: [{type: 'reference', to: {type: 'review'}}]}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', author: 'authors.0.name', media: 'mainImage'},
prepare(selection: {author: string}) {
const {author} = selection
return {...selection, subtitle: author && `by ${author}`}
},
},
})

--- END OF FILE sanity/schemaTypes/reviewType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/tableType.ts ---

// sanity/schemaTypes/tableType.ts
import {defineType, defineField, defineArrayMember} from 'sanity'
import {ListIcon} from '@sanity/icons'

export default defineType({
  name: 'table',
  title: 'Table',
  type: 'object',
  icon: ListIcon,
  fields: [
    defineField({
      name: 'rows',
      title: 'Rows',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          name: 'row',
          fields: [
            defineField({
              name: 'cells',
              title: 'Cells',
              type: 'array',
              of: [
                defineArrayMember({
                  type: 'object',
                  name: 'cell',
                  fields: [
                    defineField({
                      name: 'content',
                      title: 'Content',
                      type: 'array',
                      of: [defineArrayMember({type: 'block'})],
                    }),
                    defineField({
                      name: 'isHeader',
                      title: 'Is Header Cell?',
                      type: 'boolean',
                      initialValue: false,
                    }),
                  ],
                  preview: {
                    select: {
                      content: 'content',
                    },
                    prepare({content}) {
                      const text = content?.[0]?.children?.[0]?.text || 'Empty Cell'
                      return {title: text}
                    },
                  },
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  ],
  preview: {
    select: {
      rows: 'rows',
    },
    prepare({rows}) {
      const rowCount = rows ? rows.length : 0
      const colCount = rows?.[0]?.cells?.length || 0
      return {
        title: 'Table Block',
        subtitle: rowCount > 0 ? `${rowCount} rows, ${colCount} columns` : 'Empty table',
      }
    },
  },
})

--- END OF FILE sanity/schemaTypes/tableType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/tagType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'tag',
    title: 'Tag',
    type: 'document',
    fields: [
        defineField({
            name: 'title',
            title: 'Title',
            type: 'string',
        }),
        defineField({
            name: 'slug',
            title: 'Slug',
            type: 'slug',
            options: {
                source: 'title',
                maxLength: 96,
            },
        }),
        defineField({
            name: 'category',
            title: 'Category',
            type: 'string',
            options: {
                list: [
                    { title: 'Game Tag (For Reviews & Releases)', value: 'Game' },
                    { title: 'Article Category (For Articles)', value: 'Article' },
                    { title: 'News Category (For News)', value: 'News' }
                ],
                layout: 'radio'
            },
            validation: (Rule) => Rule.required(),
            initialValue: 'Game'
        }),
    ],
})

--- END OF FILE sanity/schemaTypes/tagType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/twoImageGridType.ts ---

// sanity/schemaTypes/twoImageGridType.ts
import { defineType, defineField } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'twoImageGrid',
    title: 'Two Image Grid',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1',
            type: 'image',
            options: { hotspot: true },
        }),
        defineField({
            name: 'image2',
            title: 'Image 2',
            type: 'image',
            options: { hotspot: true },
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }: { media?: Image, media2?: Image }) {
            return {
                title: 'Two Image Grid',
                media: media || media2,
            };
        },
    },
});




--- END OF FILE sanity/schemaTypes/twoImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/authorType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'author',
    title: 'Author', // For Articles
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/authorType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/designerType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'designer',
    title: 'Designer',
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/designerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reporterType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'reporter',
    title: 'Reporter', // For News
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/reporterType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'reviewer',
    title: 'Reviewer', // For Reviews
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom_inputs/colorDictionaryType.ts ---

// sanity/schemaTypes/custom_inputs/colorDictionaryType.ts
import {defineField, defineType} from 'sanity'
import {ColorWheelIcon} from '@sanity/icons'
import React from 'react' // ADDED: Import React

export default defineType({
  name: 'colorDictionary',
  title: 'Color Dictionary',
  type: 'document',
  icon: ColorWheelIcon,
  fields: [
    defineField({
      name: 'title',
      title: 'Title',
      type: 'string',
      hidden: true, // This is a singleton, title is not needed for display
    }),
    defineField({
      name: 'autoColors',
      title: 'Automatic Word Colors',
      description: 'Define words that should be automatically colored when typed in the editor.',
      type: 'array',
      of: [
        {
          type: 'object',
          name: 'colorMapping',
          fields: [
            defineField({
              name: 'word',
              title: 'Word',
              type: 'string',
              description: 'The exact word to color (case-sensitive).',
              validation: (Rule) => Rule.required(),
            }),
            defineField({
              name: 'color',
              title: 'Color',
              type: 'string',
              description: 'The hex color code (e.g., #00E5FF).',
              validation: (Rule) =>
                Rule.required().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, {
                  name: 'hexColor',
                  invert: false,
                }),
            }),
          ],
          preview: {
            select: {
              title: 'word',
              subtitle: 'color',
            },
            prepare({title, subtitle}) {
              return {
                title: title,
                subtitle: subtitle,
                // THE DEFINITIVE FIX: Use a function that returns a React element
                // This is valid in a .ts file and avoids the JSX syntax error.
                media: React.createElement('div', {
                  style: {
                    backgroundColor: subtitle || 'grey',
                    width: '100%',
                    height: '100%',
                  },
                }),
              }
            },
          },
        },
      ],
    }),
  ],
})

--- END OF FILE sanity/schemaTypes/custom_inputs/colorDictionaryType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom_objects/youtubeType.ts ---

// sanity/schemaTypes/custom_objects/youtubeType.ts
import {defineType, defineField} from 'sanity'
import {PlayIcon} from '@sanity/icons'

export default defineType({
  name: 'youtube',
  title: 'YouTube Embed',
  type: 'object',
  icon: PlayIcon,
  fields: [
    defineField({
      name: 'url',
      title: 'YouTube Video URL',
      type: 'url',
      validation: (Rule) =>
        Rule.required().regex(
          /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/,
          {
            name: 'youtube-url',
            invert: false,
          },
        ),
    }),
  ],
  preview: {
    select: {
      url: 'url',
    },
    prepare({url}) {
      return {
        title: 'YouTube Embed',
        subtitle: url,
      }
    },
  },
})

--- END OF FILE sanity/schemaTypes/custom_objects/youtubeType.ts ---

================================================================================

--- START OF FILE sanity/scripts/backfillLegacyIds.ts ---

// This is a standalone script to be executed with tsx or ts-node.
// It loads environment variables from the root .env file.
import 'dotenv/config';
import { createClient } from '@sanity/client';

// --- Script Configuration ---
const projectId = process.env.SANITY_PROJECT_ID;
const dataset = process.env.SANITY_DATASET;
const token = process.env.SANITY_API_WRITE_TOKEN;
const apiVersion = '2025-09-28';
const DOC_TYPES = ['review', 'article', 'news', 'gameRelease'];

// --- Validation ---
if (!projectId || !dataset || !token) {
  console.error('Error: Missing SANITY_PROJECT_ID, SANITY_DATASET, or SANITY_API_WRITE_TOKEN in your root .env file.');
  process.exit(1);
}

// --- Create a dedicated, authenticated Sanity client for this script ---
const client = createClient({
  projectId,
  dataset,
  token,
  apiVersion,
  useCdn: false, // Always use fresh data for a script
});

async function backfillLegacyIds() {
  console.log('Starting comprehensive backfill process for legacyIds...');

  // 1. Fetch ALL documents of the relevant types to identify duplicates and find the max ID.
  const query = `*[_type in $types] {_id, _type, title, legacyId}`;
  const allDocs = await client.fetch<{ _id: string, _type: string, title: string, legacyId: number | null }[]>(query, { types: DOC_TYPES });

  if (allDocs.length === 0) {
    console.log('No documents found to process.');
    return;
  }

  // 2. Find the true highest legacyId and identify all documents that need patching.
  const seenIds = new Set<number>();
  const docsToPatch: { _id: string, _type: string, title: string }[] = [];
  let maxId = 0;

  for (const doc of allDocs) {
    if (doc.legacyId !== null && doc.legacyId !== undefined) {
      if (seenIds.has(doc.legacyId)) {
        // This is a duplicate ID, mark for patching.
        docsToPatch.push(doc);
      } else {
        // This is the first time we've seen this ID, it's valid for now.
        seenIds.add(doc.legacyId);
        if (doc.legacyId > maxId) {
          maxId = doc.legacyId;
        }
      }
    } else {
      // The ID is missing entirely, mark for patching.
      docsToPatch.push(doc);
    }
  }

  if (docsToPatch.length === 0) {
    console.log('All documents have unique legacyIds. No action needed.');
    return;
  }

  console.log(`Current highest unique legacyId found: ${maxId}`);
  console.log(`Found ${docsToPatch.length} documents with missing or duplicate legacyIds. Starting patching process...`);

  // 3. Create a transaction to patch all corrupt documents.
  let currentIdCounter = maxId;
  const transaction = client.transaction();

  docsToPatch.forEach(doc => {
    currentIdCounter++;
    console.log(`  - Assigning NEW legacyId: ${currentIdCounter} to document [${doc._type}] "${doc.title}" (${doc._id})`);
    transaction.patch(doc._id, { set: { legacyId: currentIdCounter } });
  });

  // 4. Commit the transaction.
  try {
    const result = await transaction.commit();
    console.log(`Successfully patched ${result.results.length} documents.`);
    console.log('Backfill complete. Your data is now consistent.');
  } catch (error) {
    console.error('An error occurred while committing the transaction:', error);
    console.error('No documents were حُدِّثت. Please try again or check your Sanity token permissions.');
  }
}

// Execute the function
backfillLegacyIds();

--- END OF FILE sanity/scripts/backfillLegacyIds.ts ---

================================================================================

--- START OF FILE types/index.ts ---

// types/index.ts
import type { SanityAuthor } from "./sanity";

// This type represents the standardized data structure for all content cards,
// as produced by the `adaptToCardProps` adapter.
export type CardProps = {
    type: 'review' | 'article' | 'news';
    id: string; // Sanity _id
    legacyId: number; // Numeric legacy ID
    slug: string;
    game?: string;
    title: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    date?: string;
    year?: number | null;
    imageUrl: string;
    mainImageRef?: any; // For components needing custom aspect ratios
    score?: number;
    tags: { title: string, slug: string }[]; // Changed to object array
    blurDataURL: string;
    category?: string; // ADDED: For news/article categories
    verdict?: string;
    pros?: any[];
    cons?: any[];
    content?: any[];
    relatedReviewIds?: any[];
    synopsis?: string;
};

// Global type for engagement scores (Note: id should match CardProps.legacyId, which is number for viral score lookups)
export type EngagementScore = { id: number; engagementScore: number };

--- END OF FILE types/index.ts ---

================================================================================

--- START OF FILE types/sanity.ts ---

// types/sanity.ts
import type { Image, PortableTextBlock } from '@sanity/types'

export interface SanityImage extends Image {
    url: string;
    blurDataURL: string;
    alt?: string;
}

export interface SanityTag {
    _id: string;
    title: string;
    slug: string;
}

export interface SanityAuthor {
    _id: string;
    name: string;
    slug: string;
    prismaUserId: string;
    // --- ENRICHED DATA ---
    username?: string | null;
    image?: string | null;
    bio?: string | null;
}

export interface SanityGame {
    _id: string;
    title: string;
    slug: string;
    mainImage?: SanityImage;
}

export interface SanityReview {
    _id: string;
    _type: 'review';
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { _id: string, title: string };
    mainImage: SanityImage;
    score: number;
    verdict: string;
    pros: string[];
    cons: string[];
    content: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string;
    relatedReviews: {
        _id: string;
        legacyId: number;
        title: string;
        slug: string;
        mainImage: SanityImage;
        score: number;
        author: { name: string };
        publishedAt: string;
    }[];
}

export interface SanityArticle {
    _id: string;
    _type: 'article';
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { title: string };
    mainImage: SanityImage; // THE FIX
    content?: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string; 
    relatedArticles?: any[];
}

export interface SanityNews {
    _id: string;
    _type: 'news';
    legacyId: number;
    title: string;
    slug: string;
    reporters: SanityAuthor[];
    designers?: SanityAuthor[];
    mainImage: SanityImage; // THE FIX
    category: string;
    tags: { _id: string, title: string }[];
    publishedAt: string; 
    content?: PortableTextBlock[];
}

export interface SanityGameRelease {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    releaseDate: string;
    // THE DEFINITIVE FIX: Include the legacy 'PlayStation 5' value to make the type check pass.
    platforms: ('PC' | 'PlayStation' | 'PlayStation 5' | 'Xbox' | 'Switch')[];
    synopsis: string;
    mainImage: SanityImage; // THE FIX
}

export interface SanitySearchResult {
    _id: string;
    _type: 'review' | 'article' | 'news';
    title: string;
    slug: string;
    imageUrl?: string;
    publishedAt?: string;
    authorName?: string;
    gameTitle?: string;
    category?: string;
}

--- END OF FILE types/sanity.ts ---

================================================================================

