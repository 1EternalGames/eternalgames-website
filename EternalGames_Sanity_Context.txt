--- START OF FILE lib\sanity.server.ts ---

// lib/sanity.server.ts

import { createClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

export const sanityWriteClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN!,
});

--- END OF FILE lib\sanity.server.ts ---

================================================================================

--- START OF FILE lib\sanity.queries.ts ---

// lib/sanity.queries.ts

import {groq} from 'next-sanity'

// --- Base Fields & Projections (Optimized) ---
const mainImageFields = groq`asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt`
const creatorFields = groq`_id, name, prismaUserId, image, bio`
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- Projections ---
const cardProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}}, 
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}`
const cardListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- API Projections ---
const apiListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- News Hub Specific Queries ---

export const newsHeroQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...4] {
  ${cardProjection}, synopsis
}`

export const newsGridInitialQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...50] {
  ${cardListProjection}
}`

export const paginatedNewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "news" && ${publishedFilter} && defined(mainImage.asset)`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' || ')
    filter += ` && (${tagFilter})`
  }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Reviews API/Page Queries ---
export const paginatedReviewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  scoreRange?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'score' = 'latest',
) => {
  let filter = `_type == "review" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  if (scoreRange) {
    if (scoreRange === '9-10') filter += ` && score >= 9 && score <= 10`
    else if (scoreRange === '8-8.9') filter += ` && score >= 8 && score < 9`
    else if (scoreRange === '7-7.9') filter += ` && score >= 7 && score < 8`
    else if (scoreRange === '<7') filter += ` && score < 7`
  }

  const orderBy = sort === 'score' ? 'score desc, publishedAt desc' : 'publishedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Articles API/Page Queries ---
export const paginatedArticlesQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "article" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- List Page Queries ---
export const vanguardReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] { ${cardProjection} }`
export const featuredHeroReviewQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} }`
export const featuredShowcaseArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...7] { ${cardProjection} }`
export const allReviewsListQuery = groq`*[_type == "review" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allArticlesListQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByGameListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByTagListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc) { ${cardListProjection} }`

// --- Detail Page Queries ---
const contentProjection = groq`content[]{ ..., _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} }, _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}}, _type == "gameDetails" => { ... }, _type == 'youtube' => { ... } }`
const relatedContentProjection = groq`{ _id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score, "authors": authors[]->{name, prismaUserId}, "reporters": reporters[]->{name, prismaUserId}, "publishedAt": publishedAt }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{${tagFields}},
  "relatedReviews": relatedReviews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{_id, title, "slug": slug.current},
  "relatedArticles": relatedArticles[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "reporters": reporters[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "category": category->{_id, title, "slug": slug.current},
  "relatedNews": relatedNews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`

// --- Fallback & Miscellaneous Queries ---
export const latestReviewsFallbackQuery = groq`*[_type == "review" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestArticlesFallbackQuery = groq`*[_type == "article" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsFallbackQuery = groq`*[_type == "news" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...15] { _id, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, "reporters": reporters[]->{name, prismaUserId}, publishedAt, "tags": tags[]->{${tagFields}} }`
export const heroContentQuery = groq`{
  "featuredReview": *[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} },
  "latestNews": *[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} },
  "featuredArticle": *[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} }
}`
export const featuredReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const featuredArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && (title match $searchTerm + "*" || pt::text(content) match $searchTerm)] | order(publishedAt desc) [0...10] {
  _id, _type, title, "slug": slug.current, "imageUrl": mainImage.asset->url + '?w=200&h=120&fit=crop&auto=format', publishedAt,
  "authors": authors[]->{name}, "reporters": reporters[]->{name}, 
  "gameTitle": game->title, "tags": tags[]->{title}
}`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${cardProjection} }`
export const allReleasesQuery = groq`*[_type == "gameRelease" && defined(releaseDate)] | order(releaseDate asc) { 
  _id, legacyId, title, releaseDate, platforms, synopsis, "mainImage": mainImage{${mainImageFields}},
  "game": game->{ "slug": slug.current },
  "slug": game->slug.current
}`

// --- Studio Editor Queries ---
export const allGamesForStudioQuery = groq`*[_type == "game"] | order(title asc){_id, title, "slug": slug.current}`
export const allTagsForStudioQuery = groq`*[_type == "tag"] | order(title asc){_id, title, category}`
export const allCreatorsForStudioQuery = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId}`

export const editorDocumentQuery = groq`*[_id == $id || _id == 'drafts.' + $id] | order(_updatedAt desc)[0]{
  ...,
  "authors": authors[]->{_id, name, prismaUserId},
  "reporters": reporters[]->{_id, name, prismaUserId},
  "designers": designers[]->{_id, name, prismaUserId},
  "game": game->{_id, title},
  "tags": tags[]->{_id, title},
  "category": category->{_id, title},
  "mainImage": mainImage.asset->{
    "_ref": _id,
    "url": url,
    "metadata": metadata
  },
  content[]{
    ...,
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } },
    _type == "imageCompare" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "twoImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "fourImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}},
      "image3": image3{..., asset->{_id, url, metadata}},
      "image4": image4{..., asset->{_id, url, metadata}}
    },
    _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}},
    _type == "gameDetails" => { ... },
    _type == 'youtube' => { ... }
  }
}`

// --- Homepage Feed Queries ---
export const homepageArticlesQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...12] { ${cardListProjection} }`
export const homepageNewsQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...18] { ${cardListProjection} }`

--- END OF FILE lib\sanity.queries.ts ---

================================================================================

--- START OF FILE lib\sanity.loader.ts ---

// lib/sanity.loader.ts
'use client'

interface SanityImageLoaderProps {
  src: string
  width: number
  quality?: number
}

export const sanityLoader = ({ src, width, quality }: SanityImageLoaderProps) => {
  const url = new URL(src)
  if (url.hostname !== 'cdn.sanity.io') {
    return src
  }
  
  const params = url.searchParams

  const originalWidth = params.get('w');
  const originalHeight = params.get('h');

  // Set common params
  params.set('auto', 'format')
  params.set('w', width.toString())
  params.delete('q');

  if (originalWidth && originalHeight) {
    const aspectRatio = parseInt(originalHeight, 10) / parseInt(originalWidth, 10);
    const newHeight = Math.round(width * aspectRatio);
    params.set('h', newHeight.toString());
  }
  
  return `${url.origin}${url.pathname}?${params.toString()}`
}




--- END OF FILE lib\sanity.loader.ts ---

================================================================================

--- START OF FILE lib\sanity.env.ts ---

// lib/sanity.env.ts

function assertValue<T>(v: T | undefined, errorMessage: string): T {
    if (v === undefined) {
        throw new Error(errorMessage)
    }
    return v
}

export const apiVersion = process.env.SANITY_API_VERSION || '2025-09-28'

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable, falling back to the server-only one.
// This makes the file safe for both client and server environments.
export const dataset = assertValue(
    process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_DATASET,
    'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_DATASET'
)

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable for the project ID as well.
export const projectId = assertValue(
    process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_PROJECT_ID,
    'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_PROJECT_ID'
)

--- END OF FILE lib\sanity.env.ts ---

================================================================================

--- START OF FILE lib\sanity.client.ts ---

// lib/sanity.client.ts

import { createClient, type SanityClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

// Helper function to determine if we are on the server
const isServer = typeof window === 'undefined';

export const client = createClient({
    projectId,
    dataset,
    apiVersion,
    // THE DEFINITIVE FIX: Use CDN only on the client-side.
    // On the server (during builds, revalidation, RSC), always fetch fresh data from the API.
    // This eliminates the race condition between Vercel's build and Sanity's CDN propagation.
    useCdn: !isServer, 
    // Perspective should be 'published' for the main client.
    // Preview client will handle 'previewDrafts'.
    perspective: 'published',
});

--- END OF FILE lib\sanity.client.ts ---

================================================================================

--- START OF FILE sanity\.env ---

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"

--- END OF FILE sanity\.env ---

================================================================================

--- START OF FILE sanity\.env.local ---

# This file is for local Sanity Studio development (npx sanity dev)
# It should NOT be committed to version control.

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"
SANITY_STUDIO_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"

--- END OF FILE sanity\.env.local ---

================================================================================

--- START OF FILE sanity\env.ts ---

export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '2025-09-28'

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_STUDIO_DATASET,
  'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_STUDIO_DATASET'
)

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_STUDIO_PROJECT_ID,
  'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_STUDIO_PROJECT_ID'
)

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage)
  }

  return v
}

--- END OF FILE sanity\env.ts ---

================================================================================

--- START OF FILE sanity\package.json ---

{
  "name": "eternalgames-studio",
  "private": true,
  "version": "1.0.0",
  "main": "package.json",
  "license": "UNLICENSED",
  "scripts": {
    "dev": "sanity dev",
    "start": "sanity start",
    "build": "sanity build",
    "deploy": "sanity deploy",
    "deploy-graphql": "sanity graphql deploy"
  },
  "dependencies": {
    "@sanity/vision": "^4.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-is": "^18.3.1",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19"
  }
}




--- END OF FILE sanity\package.json ---

================================================================================

--- START OF FILE sanity\sanity.config.ts ---

// sanity/sanity.config.ts
import {defineConfig} from 'sanity'
import {structureTool, StructureBuilder} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'
import {apiVersion, dataset, projectId} from './env'
import {ColorWheelIcon} from '@sanity/icons'

// Custom desk structure for singletons
export const singletonStructure = (S: StructureBuilder) =>
  S.list()
    .title('Content')
    .items([
      // Our singleton document
      S.listItem()
        .title('Color Dictionary')
        .id('colorDictionary')
        .icon(ColorWheelIcon)
        .child(
          S.document()
            .schemaType('colorDictionary')
            .documentId('colorDictionary')
            .title('Automatic Word Color Dictionary')
        ),
      S.divider(),
      // The rest of our document types
      ...S.documentTypeListItems().filter(
        (listItem) => !['colorDictionary'].includes(listItem.getId() || '')
      ),
    ])

export default defineConfig({
  basePath: '/studio',
  projectId,
  dataset,
  // THE DEFINITIVE FIX: Add the API token to the Sanity config
  // This allows the local studio to see drafts and make authenticated requests.
  token: process.env.SANITY_STUDIO_API_WRITE_TOKEN,
  schema: {
    types: schemaTypes,
  },
  plugins: [
    structureTool({
      structure: singletonStructure,
    }),
    visionTool({defaultApiVersion: apiVersion}),
  ],
})

--- END OF FILE sanity\sanity.config.ts ---

================================================================================

--- START OF FILE sanity\lib\image.ts ---

import createImageUrlBuilder from '@sanity/image-url'
import { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source: SanityImageSource) => {
return builder.image(source)
}
































--- END OF FILE sanity\lib\image.ts ---

================================================================================

--- START OF FILE sanity\lib\client.ts ---

import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId } from '../env'

export const client = createClient({
projectId,
dataset,
apiVersion,
useCdn: true, // Set to false if statically generating pages, using ISR or tag-based revalidation
})

--- END OF FILE sanity\lib\client.ts ---

================================================================================

