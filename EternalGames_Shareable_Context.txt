--- START OF FILE next.config.ts ---

// next.config.ts
/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,

    images: {
        remotePatterns: [
            { protocol: 'https', hostname: 'cdn.sanity.io' },
            { protocol: 'https', hostname: '*.public.blob.vercel-storage.com' },
            { protocol: 'https', hostname: 'lh3.googleusercontent.com' },
            { protocol: 'https', hostname: 'avatars.githubusercontent.com' },
        ],
    },

    experimental: {
        serverActions: {
            bodySizeLimit: '10mb',
        },
    },
};

export default nextConfig;

--- END OF FILE next.config.ts ---

================================================================================

--- START OF FILE next-env.d.ts ---

/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--- END OF FILE next-env.d.ts ---

================================================================================

--- START OF FILE package.json ---

{
  "name": "eternalgames-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "cross-env IS_BUILDING=true next build",
    "start": "next start",
    "lint": "eslint",
    "prisma:seed": "npx ts-node -r dotenv/config prisma/seed.ts",
    "type-check": "tsc --noEmit",
    "type-watch": "tsc --noEmit --watch"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@portabletext/react": "^4.0.3",
    "@prisma/client": "^6.16.1",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@react-three/postprocessing": "^3.0.4",
    "@sanity/client": "^7.12.0",
    "@sanity/icons": "^3.7.4",
    "@sanity/image-url": "^1.2.0",
    "@sanity/vision": "^4.10.1",
    "@tiptap/extension-color": "^2.27.1",
    "@tiptap/extension-image": "^2.5.5",
    "@tiptap/extension-link": "^2.5.5",
    "@tiptap/extension-placeholder": "^2.5.5",
    "@tiptap/extension-table": "^2.5.5",
    "@tiptap/extension-table-cell": "^2.5.5",
    "@tiptap/extension-table-header": "^2.5.5",
    "@tiptap/extension-table-row": "^2.5.5",
    "@tiptap/extension-text-style": "^2.27.1",
    "@tiptap/react": "^2.5.5",
    "@tiptap/starter-kit": "^2.5.5",
    "@types/bcryptjs": "^2.4.6",
    "@vercel/blob": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "dotenv": "^17.2.2",
    "framer-motion": "^12.23.12",
    "next": "16.0.1",
    "next-auth": "^4.24.11",
    "next-sanity": "^11.4.2",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-compare-slider": "^3.1.0",
    "react-dom": "19.1.0",
    "react-image-crop": "^11.0.10",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19",
    "three": "^0.180.0",
    "transliteration": "^2.3.5",
    "uuid": "^9.0.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@fullhuman/postcss-purgecss": "^7.0.2",
    "@sanity/types": "^4.10.1",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "@types/uuid": "^9.0.8",
    "cross-env": "^10.1.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "postcss": "^8.5.6",
    "postcss-cli": "^11.0.1",
    "prisma": "^6.16.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5"
  }
}

--- END OF FILE package.json ---

================================================================================

--- START OF FILE .env ---

# .env (COMBINED AND CLEANED)

# --- Primary Application Secrets ---
NEXTAUTH_SECRET=newS3cl7686ZQEQZWop8o7kQ2oiuAmWiA1OV/hDaQp6Xg=
NEXTAUTH_URL=http://localhost:3000
# ADDED: Public URL for metadata generation
NEXT_PUBLIC_SITE_URL=http://eternalgames.vercel.app

# --- Third-Party Services ---
# THE DEFINITIVE FIX: Using the free, official MyMemory Translation API.
# This endpoint does not require an API key or a credit card.
TRANSLATION_API_URL="https://api.mymemory.translated.net/get"

# --- Database (Used by Prisma and Runtime) ---
# RUNTIME POOLED CONNECTION for Serverless functions
DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&pgbouncer=true&pool_timeout=60"

# BUILD-TIME DIRECT CONNECTION for long-lived build processes
BUILD_DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"

# --- Vercel Blob ---
BLOB_READ_WRITE_TOKEN="vercel_blob_rw_0dG10aVH15DAsZWd_NvTqPADY3zK83uptFEkaUZCEY0lC8P"

# --- Sanity Project Config ---
# For server-side fetching (e.g., in Server Components, API routes)
SANITY_PROJECT_ID="0zany1dm"
SANITY_DATASET="production"
# Exposed to the client for the Sanity Studio and client-side fetching.
NEXT_PUBLIC_SANITY_PROJECT_ID="0zany1dm"
NEXT_PUBLIC_SANITY_DATASET="production"

# --- Sanity Tokens ---
# SERVER-SIDE WRITE TOKEN (Used for creating drafts, etc.)
SANITY_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"

# SERVER-SIDE READ TOKEN (Used for fetching data in server components)
SANITY_API_READ_TOKEN="skWyr0w9l0GX2Cm2Zpmu9lApLQFcMxxnJtH8cpIyiWYurpe7FbNQncMSwQxifl2CPjrZKD24UNX1ssTdAvKNQIKD4JXzVH1Ja3AWuepTEtTRwBeOL64AyCG0xcF1UEtW25HInglUx9r8uhJ2HUFxatMJytU4RTdsy84Np8gHsNxDDgJsAhE0"

# --- Revalidation Secret ---
REVALIDATION_SECRET_TOKEN="f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8"

# --- OAuth Keys ---
AUTH_GITHUB_ID=Ov23liESurJ80uqMFTV0
AUTH_GITHUB_SECRET=e2a8a1fcf50a9f8f2e703858a1a84a7db185e035
GOOGLE_CLIENT_ID=239586132598-orantodqlrirebbhpi5f3dvcu12bampv.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
TWITTER_CLIENT_ID=X3dFNFptdlYzZDJwTVc4TWI1NE06MTpjaQ
TWITTER_CLIENT_SECRET=GzXf4VvOHb7N02qvPZ7SwSLQbujQtu9PtRQHZOUBh2x7mVHHNc

# --- Giscus (Public, but kept here for completeness) ---
NEXT_PUBLIC_GISCUS_REPO=1-eyx/eternalgames-comments
NEXT_PUBLIC_GISCUS_REPO_ID=R_kgDOPt_3hA
NEXT_PUBLIC_GISCUS_CATEGORY=Article Comments
NEXT_PUBLIC_GISCUS_CATEGORY_ID=DIC_kwDOPt_3hM4CvTrq

--- END OF FILE .env ---

================================================================================

--- START OF FILE lib\sanity.queries.ts ---

// lib/sanity.queries.ts

import {groq} from 'next-sanity'

// --- Base Fields & Projections (Optimized) ---
const mainImageFields = groq`asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt`
const creatorFields = groq`_id, name, prismaUserId, image, bio`
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- Projections ---
const cardProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}}, 
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}`
const cardListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- API Projections ---
const apiListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- News Hub Specific Queries ---

export const newsHeroQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...4] {
  ${cardProjection}, synopsis
}`

export const newsGridInitialQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...50] {
  ${cardListProjection}
}`

export const paginatedNewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "news" && ${publishedFilter} && defined(mainImage.asset)`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' || ')
    filter += ` && (${tagFilter})`
  }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Reviews API/Page Queries ---
export const paginatedReviewsQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  scoreRange?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'score' = 'latest',
) => {
  let filter = `_type == "review" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  if (scoreRange) {
    if (scoreRange === '9-10') filter += ` && score >= 9 && score <= 10`
    else if (scoreRange === '8-8.9') filter += ` && score >= 8 && score < 9`
    else if (scoreRange === '7-7.9') filter += ` && score >= 7 && score < 8`
    else if (scoreRange === '<7') filter += ` && score < 7`
  }

  const orderBy = sort === 'score' ? 'score desc, publishedAt desc' : 'publishedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Articles API/Page Queries ---
export const paginatedArticlesQuery = (
  gameSlug?: string,
  tagSlugs?: string[],
  searchTerm?: string,
  offset: number = 0,
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest',
) => {
  let filter = `_type == "article" && ${publishedFilter}`

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && ')
    filter += ` && (${tagFilter})`
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- List Page Queries ---
export const vanguardReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] { ${cardProjection} }`
export const featuredHeroReviewQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} }`
export const featuredShowcaseArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...7] { ${cardProjection} }`
export const allReviewsListQuery = groq`*[_type == "review" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allArticlesListQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByGameListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByTagListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc) { ${cardListProjection} }`

// --- Detail Page Queries ---
const contentProjection = groq`content[]{ ..., _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} }, _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}}, _type == "gameDetails" => { ... }, _type == 'youtube' => { ... } }`
const relatedContentProjection = groq`{ _id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score, "authors": authors[]->{name, prismaUserId}, "reporters": reporters[]->{name, prismaUserId}, "publishedAt": publishedAt }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{${tagFields}},
  "relatedReviews": relatedReviews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{_id, title, "slug": slug.current},
  "relatedArticles": relatedArticles[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "reporters": reporters[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "category": category->{_id, title, "slug": slug.current},
  "relatedNews": relatedNews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`

// --- Fallback & Miscellaneous Queries ---
export const latestReviewsFallbackQuery = groq`*[_type == "review" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestArticlesFallbackQuery = groq`*[_type == "article" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsFallbackQuery = groq`*[_type == "news" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...15] { _id, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, "reporters": reporters[]->{name, prismaUserId}, publishedAt, "tags": tags[]->{${tagFields}} }`
export const heroContentQuery = groq`{
  "featuredReview": *[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} },
  "latestNews": *[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} },
  "featuredArticle": *[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} }
}`
export const featuredReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const featuredArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && (title match $searchTerm + "*" || pt::text(content) match $searchTerm)] | order(publishedAt desc) [0...10] {
  _id, _type, title, "slug": slug.current, "imageUrl": mainImage.asset->url + '?w=200&h=120&fit=crop&auto=format', publishedAt,
  "authors": authors[]->{name}, "reporters": reporters[]->{name}, 
  "gameTitle": game->title, "tags": tags[]->{title}
}`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${cardProjection} }`
export const allReleasesQuery = groq`*[_type == "gameRelease" && defined(releaseDate)] | order(releaseDate asc) { 
  _id, legacyId, title, releaseDate, platforms, synopsis, "mainImage": mainImage{${mainImageFields}},
  "game": game->{ "slug": slug.current },
  "slug": game->slug.current
}`

// --- Studio Editor Queries ---
export const allGamesForStudioQuery = groq`*[_type == "game"] | order(title asc){_id, title, "slug": slug.current}`
export const allTagsForStudioQuery = groq`*[_type == "tag"] | order(title asc){_id, title, category}`
export const allCreatorsForStudioQuery = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId}`

export const editorDocumentQuery = groq`*[_id == $id || _id == 'drafts.' + $id] | order(_updatedAt desc)[0]{
  ...,
  "authors": authors[]->{_id, name, prismaUserId},
  "reporters": reporters[]->{_id, name, prismaUserId},
  "designers": designers[]->{_id, name, prismaUserId},
  "game": game->{_id, title},
  "tags": tags[]->{_id, title},
  "category": category->{_id, title},
  "mainImage": mainImage.asset->{
    "_ref": _id,
    "url": url,
    "metadata": metadata
  },
  content[]{
    ...,
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } },
    _type == "imageCompare" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "twoImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "fourImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}},
      "image3": image3{..., asset->{_id, url, metadata}},
      "image4": image4{..., asset->{_id, url, metadata}}
    },
    _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}},
    _type == "gameDetails" => { ... },
    _type == 'youtube' => { ... }
  }
}`

// --- Homepage Feed Queries ---
export const homepageArticlesQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...12] { ${cardListProjection} }`
export const homepageNewsQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...18] { ${cardListProjection} }`

--- END OF FILE lib\sanity.queries.ts ---

================================================================================

--- START OF FILE app\layout.tsx ---

// app/layout.tsx
import { Cairo } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { ThemeProvider } from '@/components/ThemeProvider';
import NextAuthProvider from '@/components/SessionProvider';
import StudioBar from '@/components/StudioBar';
import ToastProvider from '@/components/ToastProvider';
import UserStoreHydration from '@/components/UserStoreHydration';
import Lightbox from '@/components/Lightbox';
import ScrollToTopButton from '@/components/ui/ScrollToTopButton';
import PageTransitionWrapper from '@/components/PageTransitionWrapper';
import type { Metadata } from 'next';

const cairo = Cairo({
  subsets: ['arabic', 'latin'],
  display: 'swap',
  variable: '--font-main',
  weight: ['400', '500', '700', '800'],
});

const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';

export const metadata: Metadata = {
  metadataBase: new URL(siteUrl),
  title: {
    default: 'EternalGames | حيث لا تفنى الألعاب',
    template: '%s | EternalGames',
  },
  description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
  openGraph: {
    title: 'EternalGames | حيث لا تفنى الألعاب',
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    url: siteUrl,
    siteName: 'EternalGames',
    images: [
      {
        url: '/og.png', // Corrected path
        width: 1200,
        height: 630,
        alt: 'EternalGames Logo',
      },
    ],
    locale: 'ar_SA',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'EternalGames | حيث لا تفنى الألعاب',
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    images: [`${siteUrl}/og.png`], // Corrected path to be absolute for Twitter
  },
};

export default function RootLayout({ children }: { children: React.ReactNode; }) {
  return (
    <html lang="ar" dir="rtl" className={cairo.variable} suppressHydrationWarning>
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link
          rel="preconnect"
          href="https://fonts.gstatic.com"
          crossOrigin="anonymous"
        />
        <link
          rel="preconnect"
          href="https://cdn.sanity.io"
          crossOrigin="anonymous"
        />
      </head>
      <body>
        <NextAuthProvider>
          <UserStoreHydration />
          <ThemeProvider attribute="data-theme" defaultTheme="system" enableSystem disableTransitionOnChange>
            <div style={{ position: 'relative', width: '100%', overflowX: 'clip' }}>
              <ToastProvider />
              <Lightbox />
              <Navbar />
              <main>
                <PageTransitionWrapper>
                  {children}
                </PageTransitionWrapper>
              </main>
              <Footer />
              <StudioBar />
              <ScrollToTopButton />
            </div>
          </ThemeProvider>
        </NextAuthProvider>
      </body>
    </html>
  );
}

--- END OF FILE app\layout.tsx ---

================================================================================

--- START OF FILE app\(content)\[...slug]\page.tsx ---

// app/(content)/[...slug]/page.tsx
import { unstable_cache } from 'next/cache';
import { client } from '@/lib/sanity.client';
import {
    reviewBySlugQuery, latestReviewsFallbackQuery,
    articleBySlugQuery, latestArticlesFallbackQuery,
    newsBySlugQuery, latestNewsFallbackQuery
} from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import prisma from '@/lib/prisma';
import CommentSection from '@/components/comments/CommentSection';
import ContentPageClient from '@/components/content/ContentPageClient';
import { Suspense } from 'react';
import { cache } from 'react';
import { groq } from 'next-sanity';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';

const colorDictionaryQuery = groq`*[_type == "colorDictionary" && _id == "colorDictionary"][0]{ autoColors }`;

const contentConfig = {
    reviews: {
        query: reviewBySlugQuery,
        fallbackQuery: latestReviewsFallbackQuery,
        relatedProp: 'relatedReviews',
        creatorProps: ['authors', 'designers'],
        sanityType: 'review',
    },
    articles: {
        query: articleBySlugQuery,
        fallbackQuery: latestArticlesFallbackQuery,
        relatedProp: 'relatedArticles',
        creatorProps: ['authors', 'designers'],
        sanityType: 'article',
    },
    news: {
        query: newsBySlugQuery,
        fallbackQuery: latestNewsFallbackQuery,
        relatedProp: 'relatedNews',
        creatorProps: ['reporters', 'designers'],
        sanityType: 'news',
    },
};

type Props = {
  params: { slug: string[] };
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug: slugArray } = params;
  if (!slugArray || slugArray.length !== 2) return {};
  
  const [type, slug] = slugArray;
  const config = (contentConfig as any)[type];
  if (!config) return {};

  const item = await getCachedSanityData(config.query, { slug });
  if (!item) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const ogImageUrl = urlFor(item.mainImage).width(1200).height(630).fit('crop').format('jpg').url(); // Added .format('jpg')

  let description = 'اقرأ المزيد على EternalGames.';
  if (item._type === 'review' && item.verdict) {
    description = item.verdict;
  } else if (item.content) {
    const firstTextblock = item.content.find((block: any) => block._type === 'block' && block.children?.some((child: any) => child.text));
    if (firstTextblock) {
      description = firstTextblock.children.map((child: any) => child.text).join(' ').slice(0, 155) + '...';
    }
  }

  return {
    title: item.title,
    description: description,
    openGraph: {
      title: item.title,
      description: description,
      url: `${siteUrl}/${type}/${slug}`,
      images: [
        {
          url: ogImageUrl,
          width: 1200,
          height: 630,
          alt: item.title,
        },
      ],
      type: 'article',
      publishedTime: item.publishedAt,
      authors: (item.authors || item.reporters || []).map((a: any) => a.name),
    },
    twitter: {
      card: 'summary_large_image',
      title: item.title,
      description: description,
      images: [ogImageUrl],
    },
  };
}


const getCachedSanityData = unstable_cache(
    async (query: string, params: Record<string, any> = {}) => {
        return client.fetch(query, params);
    },
    ['sanity-content-detail'],
    {
        tags: ['sanity-content-detail']
    }
);

const getCachedCreatorDetails = unstable_cache(
    async (prismaUserId: string) => {
        try {
            const user = await prisma.user.findUnique({
                where: { id: prismaUserId },
                select: { username: true, image: true, bio: true }
            });
            return {
                username: user?.username || null,
                image: user?.image || null,
                bio: user?.bio || null,
            };
        } catch (error) {
            console.warn(`[CACHE WARNING] Database connection failed for creator enrichment (ID: ${prismaUserId}). Skipping. Error:`, error);
            return { username: null, image: null, bio: null };
        }
    },
    ['enriched-creator-details'],
    { tags: ['enriched-creator-details'] }
);

async function enrichCreator(creator: any) {
    if (!creator || !creator.prismaUserId) return creator;
    const userDetails = await getCachedCreatorDetails(creator.prismaUserId);
    return { ...creator, ...userDetails };
}

export async function generateStaticParams() {
    try {
        const allContent = await client.fetch<any[]>(`*[_type in ["review", "article", "news"]]{ "slug": slug.current, _type }`);
        return allContent.filter(c => c.slug).map(c => {
            const type = c._type === 'review' ? 'reviews' : (c._type === 'article' ? 'articles' : 'news');
            return { slug: [type, c.slug] };
        });
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for generateStaticParams. The build process cannot continue without a connection to the CMS.`, error);
        throw error;
    }
}

export default async function ContentPage({ params }: { params: { slug: string[] } }) {
    const { slug: slugArray } = await params;
    if (!slugArray || slugArray.length !== 2) notFound();
    
    const [type, slug] = slugArray;
    const config = (contentConfig as any)[type];
    if (!config) notFound();

    let [item, colorDictionaryData]: [any, { autoColors: any[] }?] = await Promise.all([
        getCachedSanityData(config.query, { slug }),
        getCachedSanityData(colorDictionaryQuery)
    ]);
    
    if (!item) notFound();

    if (!item[config.relatedProp] || item[config.relatedProp].length === 0) {
        const fallbackContent = await getCachedSanityData(config.fallbackQuery, { currentId: item._id });
        item[config.relatedProp] = fallbackContent;
    }

    for (const prop of config.creatorProps) {
        if (item[prop]) {
            item[prop] = await Promise.all(item[prop].map(enrichCreator));
        }
    }
    
    const colorDictionary = colorDictionaryData?.autoColors || [];

    return (
        <ContentPageClient item={item} type={type as any} colorDictionary={colorDictionary}>
            <Suspense fallback={<div className="spinner" style={{ margin: '8rem auto' }} />}>
                <CommentSection slug={slug} />
            </Suspense>
        </ContentPageClient>
    );
}

--- END OF FILE app\(content)\[...slug]\page.tsx ---

================================================================================

--- START OF FILE app\reviews\page.tsx ---

// app/reviews/page.tsx
import { client } from '@/lib/sanity.client';
import { featuredHeroReviewQuery, allReviewsListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import ReviewsPageClient from './ReviewsPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'المراجعات',
  description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames. تقييمات شاملة، تحليلات دقيقة، وحكم نهائي.',
  openGraph: {
    title: 'مراجعات | EternalGames',
    description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames.',
  },
  twitter: {
    title: 'مراجعات | EternalGames',
    description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current}`;

export default async function ReviewsPage() {
  const [heroReview, initialGridReviews, allGames, allTags]: [SanityReview, SanityReview[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(featuredHeroReviewQuery),
    client.fetch(allReviewsListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allTagsQuery),
  ]);

  if (!heroReview) {
    return (
      <div className="container page-container">
        <h1 className="page-title">المراجعات</h1>
        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>الأرشيفُ خالٍ من المراجعاتِ حاليًا. عُد قريبًا.</p>
      </div>
    );
  }

  const gridReviews = (initialGridReviews || []).filter(review => review._id !== heroReview._id);

  return (
    <Suspense fallback={<div className="spinner page-container" style={{margin: 'auto'}} />}>
      <ReviewsPageClient 
        heroReview={heroReview} 
        initialGridReviews={gridReviews}
        allGames={allGames}
        allTags={allTags}
      />
    </Suspense>
  );
}

--- END OF FILE app\reviews\page.tsx ---

================================================================================

--- START OF FILE app\articles\page.tsx ---

// app/articles/page.tsx
import { client } from '@/lib/sanity.client';
import { featuredShowcaseArticlesQuery, allArticlesListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import ArticlesPageClient from './ArticlesPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'المقالات',
  description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب من خبراء EternalGames.',
  openGraph: {
    title: 'المقالات | EternalGames',
    description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب.',
  },
  twitter: {
    title: 'المقالات | EternalGames',
    description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة لأحدث الظواهر في عالم الألعاب.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allGameTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current, category}`;
const allArticleTypeTagsQuery = groq`*[_type == "tag" && category == "Article"] | order(title asc) {_id, title, "slug": slug.current, category}`;

// Helper function to remove duplicates based on title
const deduplicateTags = (tags: SanityTag[]): SanityTag[] => {
    if (!tags) return [];
    const uniqueMap = new Map<string, SanityTag>();
    tags.forEach(tag => {
        if (tag && tag.title && !uniqueMap.has(tag.title)) {
            uniqueMap.set(tag.title, tag);
        }
    });
    return Array.from(uniqueMap.values());
};

export default async function ArticlesPage() {
  const [featuredArticles, initialGridArticles, allGames, allGameTagsRaw, allArticleTypeTagsRaw]: [SanityArticle[], SanityArticle[], SanityGame[], SanityTag[], SanityTag[]] = await Promise.all([
    client.fetch(featuredShowcaseArticlesQuery),
    client.fetch(allArticlesListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allGameTagsQuery),
    client.fetch(allArticleTypeTagsQuery),
  ]);

  const allGameTags = deduplicateTags(allGameTagsRaw);
  const allArticleTypeTags = deduplicateTags(allArticleTypeTagsRaw);

  if (!featuredArticles || featuredArticles.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">أحدث المقالات</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>بلغتَ المنتهى. مقالاتٌ أخرى تلوحُ في الأفق.</p>
        </div>
    );
  }

  const ArticlesPageFallback = () => (
    <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
      <div className="spinner" />
    </div>
  );

  return (
    <Suspense fallback={<ArticlesPageFallback />}>
      <ArticlesPageClient
        featuredArticles={featuredArticles}
        initialGridArticles={initialGridArticles}
        allGames={allGames}
        allGameTags={allGameTags}
        allArticleTypeTags={allArticleTypeTags}
      />
    </Suspense>
  );
}

--- END OF FILE app\articles\page.tsx ---

================================================================================

--- START OF FILE app\news\page.tsx ---

// app/news/page.tsx
import { client } from '@/lib/sanity.client';
import { newsHeroQuery, newsGridInitialQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import NewsPageClient from './NewsPageClient';
import { Suspense } from 'react';
import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'الأخبار',
  description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب. ابقَ على اطلاع دائم بكل ما هو جديد ومهم.',
  openGraph: {
    title: 'الأخبار | EternalGames',
    description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب.',
  },
  twitter: {
    title: 'الأخبار | EternalGames',
    description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب.',
  }
};

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allNewsTagsQuery = groq`*[_type == "tag" && category == "News"] | order(title asc) {_id, title, "slug": slug.current, category}`;

// Helper function to remove duplicates based on title
const deduplicateTags = (tags: SanityTag[]): SanityTag[] => {
    if (!tags) return [];
    const uniqueMap = new Map<string, SanityTag>();
    tags.forEach(tag => {
        if (tag && tag.title && !uniqueMap.has(tag.title)) {
            uniqueMap.set(tag.title, tag);
        }
    });
    return Array.from(uniqueMap.values());
};

export default async function NewsPage() {
  const [heroNewsRaw, initialGridNewsRaw, allGames, allTagsRaw]: [SanityNews[], SanityNews[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(newsHeroQuery),
    client.fetch(newsGridInitialQuery),
    client.fetch(allGamesQuery),
    client.fetch(allNewsTagsQuery),
  ]);

  const allTags = deduplicateTags(allTagsRaw);

  if (!heroNewsRaw || heroNewsRaw.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">موجز الأنباء</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لا أنباءَ تُذكَر. سنوافيكم بالجديد.</p>
        </div>
    );
  }

  const NewsPageFallback = () => (
    <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center', minHeight: '80vh'}}>
      <div className="spinner" />
    </div>
  );

  return (
    <Suspense fallback={<NewsPageFallback />}>
      <NewsPageClient
        heroArticles={heroNewsRaw || []}
        initialGridArticles={initialGridNewsRaw || []}
        allGames={allGames || []}
        allTags={allTags || []}
      />
    </Suspense>
  );
}

--- END OF FILE app\news\page.tsx ---

================================================================================

--- START OF FILE app\games\[slug]\page.tsx ---

// app/games/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByGameListQuery } from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';

export const dynamicParams = true;

type Props = {
  params: { slug: string };
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = params;
  const gameSlug = decodeURIComponent(slug);

  const game = await client.fetch(
    `*[_type == "game" && slug.current == $slug][0]{title, mainImage}`,
    { slug: gameSlug }
  );

  if (!game) return {};
  
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `محور لعبة: ${game.title}`;
  const description = `استكشف كل المحتوى المتعلق بلعبة ${game.title} على EternalGames، من مراجعات ومقالات إلى آخر الأخبار.`;
  const ogImageUrl = game.mainImage 
    ? urlFor(game.mainImage).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/games/${gameSlug}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: game.title }],
      type: 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "game" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            slug,
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for game hub pages. Build cannot continue.`, error);
        throw error;
    }
}

export default async function GameHubPage({ params }: { params: { slug: string } }) {
    const { slug } = await params;
    const gameSlug = decodeURIComponent(slug);

    const gameMeta = await client.fetch(
        `*[_type == "game" && slug.current == $slug][0]{title}`,
        { slug: gameSlug }
    );

    if (!gameMeta) {
        notFound();
    }

    const allItems = await client.fetch(allContentByGameListQuery, { slug: gameSlug });
    
    if (!allItems || allItems.length === 0) {
        return (
             <div className="container page-container">
                <h1 className="page-title">محور لعبة:&quot;{gameMeta.title}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)', fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto'}}>
                    لم يُخطَّ حرفٌ بعدُ عن هذه اللعبة. الأرشيفُ يترقب.
                </p>
            </div>
        );
    }

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={gameMeta.title}
            hubType="اللعبة"
        />
    );
}

--- END OF FILE app\games\[slug]\page.tsx ---

================================================================================

--- START OF FILE app\tags\[tag]\page.tsx ---

// app/tags/[tag]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByTagListQuery } from '@/lib/sanity.queries';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import { translateTag } from '@/lib/translations';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';

export const dynamicParams = true;

type Props = {
  params: { tag: string };
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { tag } = params;
  const tagSlug = decodeURIComponent(tag);

  const data = await client.fetch(
    `{
      "tag": *[_type == "tag" && slug.current == $slug][0]{title},
      "latestItem": *[_type in ["review", "article", "news"] && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc)[0]{mainImage}
    }`,
    { slug: tagSlug }
  );

  if (!data.tag) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const translatedTitle = translateTag(data.tag.title);
  const title = `وسم: ${translatedTitle}`;
  const description = `تصفح كل المحتوى الموسوم بـ "${translatedTitle}" على EternalGames واكتشف أحدث المقالات والمراجعات.`;
  const ogImageUrl = data.latestItem?.mainImage
    ? urlFor(data.latestItem.mainImage).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/tags/${tagSlug}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: title }],
      type: 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}


export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "tag" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            tag: slug,
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch slugs for tag hub pages. Build cannot continue.`, error);
        throw error;
    }
}

export default async function TagPage({ params }: { params: { tag: string } }) {
    const { tag } = await params;
    const tagSlug = decodeURIComponent(tag);

    const tagMeta = await client.fetch(
        `*[_type == "tag" && slug.current == $slug][0]{title}`,
        { slug: tagSlug }
    );

    if (!tagMeta) {
        notFound();
    }

    const allItems = await client.fetch(allContentByTagListQuery, { slug: tagSlug });

    if (!allItems || allItems.length === 0) {
        return (
            <div className="container page-container">
                <h1 className="page-title">وسم: &quot;{translateTag(tagMeta.title)}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُنشر عملٌ بهذا الوسم بعد.</p>
            </div>
        );
    }
    
    return (
         <HubPageClient
            initialItems={allItems}
            hubTitle={translateTag(tagMeta.title)}
            hubType="وسم"
        />
    );
}

--- END OF FILE app\tags\[tag]\page.tsx ---

================================================================================

--- START OF FILE app\creators\[username]\page.tsx ---

// app/creators/[username]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByCreatorListQuery } from '@/lib/sanity.queries';
import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import Link from 'next/link';
import { cache } from 'react';
import type { Metadata } from 'next';

export const dynamicParams = true;

type Props = {
  params: { username: string };
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { username: encodedUsername } = params;
  const username = decodeURIComponent(encodedUsername);
  
  const user = await getCachedUserByUsername(username);
  if (!user) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `أعمال ${user.name || username}`;
  const description = `استكشف جميع مساهمات ${user.name || username} على منصة EternalGames.`;
  // Use the user's avatar for the OG image if available, otherwise fallback
  const ogImageUrl = user.image || `${siteUrl}/og-image.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/creators/${username}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: user.name || username }],
      type: 'profile',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export const generateStaticParams = cache(async () => {
    try {
        const usersWithUsernames = await prisma.user.findMany({
            where: {
                username: { not: null },
                roles: { some: { name: { in: ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'] } } }
            },
            select: { username: true },
        });

        return usersWithUsernames.map((user) => ({
            username: encodeURIComponent(user.username!),
        }));
    } catch (error) {
        console.error(`[BUILD ERROR] CRITICAL: Failed to fetch usernames for creator pages. Build cannot continue.`, error);
        throw error;
    }
});

const getCachedUserByUsername = cache(async (username: string) => {
    try {
        return await prisma.user.findUnique({
            where: { username: username },
            select: { id: true, name: true, username: true, image: true }, // Added image to selection
        });
    } catch (error) {
        console.warn(`[BUILD WARNING] Database connection failed for creator page: "${username}".`, error);
        return null;
    }
});

export default async function CreatorHubPage({ params }: { params: { username: string } }) {
    const { username: encodedUsername } = await params;
    const username = decodeURIComponent(encodedUsername);

    const user = await getCachedUserByUsername(username);

    if (!user) {
        notFound();
    }

    const creatorDocs = await client.fetch< { _id: string }[] >(
        `*[_type in ["author", "reviewer", "reporter", "designer"] && prismaUserId == $prismaUserId]{_id}`,
        { prismaUserId: user.id }
    );

    if (!creatorDocs || creatorDocs.length === 0) {
        return (
             <div className="container page-container">
                <h1 className="page-title">{user.name || 'Creator'}</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُرَ لهذا المستخدمِ أثرٌ بعد.</p>
                <div style={{textAlign: 'center', marginTop: '2rem'}}>
                    <Link href={`/profile/${user.username}`} className="primary-button">ملف المستخدم</Link>
                </div>
            </div>
        );
    }
    
    const creatorIds = creatorDocs.map(doc => doc._id);
    const allItems = await client.fetch(allContentByCreatorListQuery, { creatorIds });

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={user.name || 'Creator'}
            hubType="أعمال"
            headerAction={
                <Link href={`/profile/${user.username}`} className="outline-button no-underline" style={{ backgroundColor: 'color-mix(in srgb, var(--bg-secondary) 80%, transparent)', backdropFilter: 'blur(4px)' }}>
                    → الملف الشخصي
                </Link>
            }
        />
    );
}

--- END OF FILE app\creators\[username]\page.tsx ---

================================================================================

--- START OF FILE public\og.png ---



--- END OF FILE public\og.png ---

================================================================================

--- START OF FILE public\fonts\Cairo-Bold.ttf ---

!!! FILE NOT FOUND AT THIS PATH !!!


--- END OF FILE public\fonts\Cairo-Bold.ttf ---

================================================================================

