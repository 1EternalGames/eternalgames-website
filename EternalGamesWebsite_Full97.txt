--- START OF FILE .env ---

# .env (COMBINED AND CLEANED)

# --- Primary Application Secrets ---
NEXTAUTH_SECRET=newS3cl7686ZQEQZWop8o7kQ2oiuAmWiA1OV/hDaQp6Xg=
NEXTAUTH_URL=http://localhost:3000

# --- Database (Used by Prisma and Runtime) ---
DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&pgbouncer=true"

# --- Vercel Blob ---
BLOB_READ_WRITE_TOKEN="vercel_blob_rw_0dG10aVH15DAsZWd_NvTqPADY3zK83uptFEkaUZCEY0lC8P"

# --- Sanity Tokens ---
# SERVER-SIDE WRITE TOKEN (Used for creating drafts, etc.)
SANITY_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"
# CLIENT-SIDE WRITE TOKEN (Used for direct image uploads from the browser)
NEXT_PUBLIC_SANITY_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"
# SERVER-SIDE READ TOKEN (Used for fetching data in server components)
SANITY_API_READ_TOKEN="skWyr0w9l0GX2Cm2Zpmu9lApLQFcMxxnJtH8cpIyiWYurpe7FbNQncMSwQxifl2CPjrZKD24UNX1ssTdAvKNQIKD4JXzVH1Ja3AWuepTEtTRwBeOL64AyCG0xcF1UEtW25HInglUx9r8uhJ2HUFxatMJytU4RTdsy84Np8gHsNxDDgJsAhE0"

# --- Revalidation Secret ---
REVALIDATION_SECRET_TOKEN="f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8"

# --- OAuth Keys ---
AUTH_GITHUB_ID=Ov23liESurJ80uqMFTV0
AUTH_GITHUB_SECRET=e2a8a1fcf50a9f8f2e703858a1a84a7db185e035
GOOGLE_CLIENT_ID=239586132598-orantodqlrirebbhpi5f3dvcu12bampv.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
TWITTER_CLIENT_ID=X3dFNFptdlYzZDJwTVc4TWI1NE06MTpjaQ
TWITTER_CLIENT_SECRET=GzXf4VvOHb7N02qvPZ7SwSLQbujQtu9PtRQHZOUBh2x7mVHHNc

# --- Giscus (Public, but kept here for completeness) ---
NEXT_PUBLIC_GISCUS_REPO=1-eyx/eternalgames-comments
NEXT_PUBLIC_GISCUS_REPO_ID=R_kgDOPt_3hA
NEXT_PUBLIC_GISCUS_CATEGORY=Article Comments
NEXT_PUBLIC_GISCUS_CATEGORY_ID=DIC_kwDOPt_3hM4CvTrq




--- END OF FILE .env ---

================================================================================

--- START OF FILE next-auth.d.ts ---

// next-auth.d.ts

import NextAuth, { DefaultSession } from "next-auth"
import { JWT } from "next-auth/jwt"

declare module "next-auth" {
    interface Session {
        user?: {
            id: string;
            roles: string[];
            username?: string | null; // <-- ADD THIS LINE
        } & DefaultSession["user"];
        needsOnboarding?: boolean; // <-- ADD THIS LINE
    }
}

declare module "next-auth/jwt" {
    interface JWT {
        id: string;
        roles: string[];
        username?: string | null; // <-- ADD THIS LINE
        needsOnboarding?: boolean; // <-- ADD THIS LINE
    }
}




--- END OF FILE next-auth.d.ts ---

================================================================================

--- START OF FILE next.config.ts ---

// next.config.ts

/** @type {import('next').NextConfig} */
const nextConfig = {
    // Inject public Sanity environment variables here since .env.local is consolidated.
    env: {
        NEXT_PUBLIC_SANITY_PROJECT_ID: '0zany1dm',
        NEXT_PUBLIC_SANITY_DATASET: 'production',
        NEXT_PUBLIC_SANITY_API_VERSION: '2025-09-30',
    },
    images: {
        // --- THE DEFINITIVE FIX IS HERE ---
        // Replace the unreliable wildcard with an explicit list of all trusted image sources.
        remotePatterns: [
            // Sanity CMS
            {
                protocol: 'https',
                hostname: 'cdn.sanity.io',
            },
            // Vercel Blob Storage (for user avatars)
            {
                protocol: 'https',
                hostname: '*.public.blob.vercel-storage.com',
            },
            // Google OAuth Avatars
            {
                protocol: 'https',
                hostname: 'lh3.googleusercontent.com',
            },
            // GitHub OAuth Avatars
            {
                protocol: 'https',
                hostname: 'avatars.githubusercontent.com',
            },
        ],
    },
    experimental: {
        serverActions: {
            bodySizeLimit: '10mb',
        },
    },
};

export default nextConfig;

--- END OF FILE next.config.ts ---

================================================================================

--- START OF FILE package.json ---

{
  "name": "eternalgames-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint",
    "prisma:seed": "npx ts-node -r dotenv/config prisma/seed.ts"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@portabletext/react": "^4.0.3",
    "@prisma/client": "^6.16.1",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@react-three/postprocessing": "^3.0.4",
    "@sanity/client": "^7.12.0",
    "@sanity/icons": "^3.7.4",
    "@sanity/image-url": "^1.2.0",
    "@sanity/vision": "^4.10.1",
    "@tiptap/extension-image": "^2.5.5",
    "@tiptap/extension-link": "^2.5.5",
    "@tiptap/extension-placeholder": "^2.5.5",
    "@tiptap/react": "^2.5.5",
    "@tiptap/starter-kit": "^2.5.5",
    "@types/bcryptjs": "^2.4.6",
    "@vercel/blob": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "dotenv": "^17.2.2",
    "framer-motion": "^12.23.12",
    "next": "15.5.2",
    "next-auth": "^4.24.11",
    "next-sanity": "^11.4.2",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-compare-slider": "^3.1.0",
    "react-dom": "19.1.0",
    "react-image-crop": "^11.0.10",
    "react-spring": "^10.0.3",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19",
    "three": "^0.180.0",
    "transliteration": "^2.3.5",
    "uuid": "^9.0.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@fullhuman/postcss-purgecss": "^7.0.2",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "@types/uuid": "^9.0.8",
    "cross-env": "^10.1.0",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "postcss": "^8.5.6",
    "postcss-cli": "^11.0.1",
    "prisma": "^6.16.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5"
  }
}

--- END OF FILE package.json ---

================================================================================

--- START OF FILE tsconfig.json ---

{
"compilerOptions": {
"lib": [
"dom",
"dom.iterable",
"esnext"
],
"allowJs": true,
"skipLibCheck": true,
"strict": true,
"noEmit": true,
"esModuleInterop": true,
"module": "esnext",
"moduleResolution": "bundler",
"resolveJsonModule": true,
"isolatedModules": true,
"jsx": "preserve",
"incremental": true,
"plugins": [
{
"name": "next"
}
],
"baseUrl": ".",
"paths": {
"@/*": [
"./*"
]
},
"target": "ES2017"
},
"include": [
"next-env.d.ts",
"**/*.ts",
"**/*.tsx",
".next/types/**/*.ts"
],
"exclude": [
"node_modules"
]
}

--- END OF FILE tsconfig.json ---

================================================================================

--- START OF FILE sanity.cli.ts ---

import { defineCliConfig } from 'sanity/cli'

// DEFINITIVE FIX: Hardcode the public, non-secret values.
// The CLI does not have access to the Next.js process.env variables.
const projectId = '0zany1dm'
const dataset = 'production'

export default defineCliConfig({
  api: { projectId, dataset },
  project: {
    path: './sanity',
  },
})




--- END OF FILE sanity.cli.ts ---

================================================================================

--- START OF FILE app/globals.css ---

:root{
--bg-primary:#F9FAFB;
--bg-secondary:#FFFFFF;
--text-primary:#1F2937;
--text-secondary:#6B7280;
--accent:#0891B2;
--overlay-color:rgba(249,250,251,0.7);
--border-color:#E5E7EB;
--nav-height:8rem;
--nav-height-scrolled:6rem;
}
[data-theme="dark"]{
--bg-primary:#0A0B0F;
--bg-secondary:#14161D;
--text-primary:#E1E1E6;
--text-secondary:#7D808C;
--accent:#00E5FF;
--overlay-color:rgba(10,11,15,0.7);
--border-color:#2a2e3c;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0;}
html{
font-size:62.5%;
scroll-behavior:smooth;
scrollbar-width:thin;
scrollbar-color:var(--accent) transparent;
direction: rtl;
}
body::-webkit-scrollbar{width:8px;}
body::-webkit-scrollbar-track{background:transparent;}
body::-webkit-scrollbar-thumb{background-color:var(--accent);border-radius:4px;}
body{
background-color:var(--bg-primary);
color:var(--text-primary);
font-family:var(--font-main), sans-serif;
font-size:1.8rem;
line-height:1.7;
overflow-x:hidden;
transition:background-color 0.3s ease,color 0.3s ease;
}
h1,h2,h3,h4,h5,h6{
font-family:var(--font-main), sans-serif;
font-weight:700;
line-height:1.2;
}
h1{font-size:5.6rem;}
h2{font-size:4.0rem;}
h3{font-size:2.8rem;}
a{color:var(--accent);text-decoration:none;position:relative;display:inline-block;}
a:not(.no-underline)::after{
content:'';position:absolute;width:100%;transform:scaleX(0);height:2px;
bottom:-4px;right:0;
background-color:var(--accent);
transform-origin:bottom right;
transition:transform 0.3s ease-out;
}
a:not(.no-underline):hover::after{transform:scaleX(1);}
img{max-width:100%;height:auto;display:block;}
.container{max-width:1200px;margin:0 auto;padding:0 2rem;}
.section{padding:8rem 0;}
.section-title{text-align:center;margin-bottom:4rem;font-weight:800;color:var(--text-primary);}
.sr-only{
position:absolute;width:1px;height:1px;padding:0;margin:-1px;
overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0;
}
.page-container{padding-top:calc(var(--nav-height-scrolled) + 4rem);padding-bottom:6rem;min-height:80vh;}
.page-title{font-size:4.8rem;font-weight:800;text-align:center;margin-bottom:4rem;color:var(--text-primary);}
.content-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(320px,1fr));gap:3rem;grid-auto-rows:1fr;}

.portable-text-content {
  overflow-wrap: break-word;
  word-break: break-word;
}

.toast-container-global {
position: fixed;
bottom: 2rem;
left: 2rem;
z-index: 9999;
display: flex;
flex-direction: column;
gap: 1rem;
}
.toast-container-global[style*="right: 2rem"] {
    right: 2rem;
    left: auto;
}
.toast-container-global[style*="left: 2rem"] {
    left: 2rem;
    right: auto;
}

.primary-button.delete-forever:hover {
  box-shadow: 0 0 20px color-mix(in srgb, #DC2626 50%, transparent) !important;
  transform: scale(1.05) translateY(-1px) !important;
}

.primary-button{background-color:var(--accent);color:#fff;border:none;padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:700;cursor:pointer;box-shadow:0 0 15px color-mix(in srgb,var(--accent) 30%,transparent);transition:transform 0.2s ease-out,box-shadow 0.2s ease-out;}
.primary-button:hover:not(:disabled){transform:scale(1.05) translateY(-1px);box-shadow:0 0 25px color-mix(in srgb,var(--accent) 50%,transparent);}
.primary-button:disabled{background-color:var(--border-color);color:var(--text-secondary);box-shadow:none;cursor:not-allowed;opacity:0.6;}
.outline-button{background:transparent;border:1px solid var(--border-color);color:var(--text-secondary);padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:500;cursor:pointer;transition:background-color 0.15s ease-out,color 0.15s ease-out,border-color 0.15s ease-out;}
.outline-button:hover:not(:disabled){border-color:var(--accent);color:var(--accent);background-color:color-mix(in srgb,var(--accent) 10%,transparent);}
.outline-button:disabled{opacity:0.6;cursor:not-allowed;}

.profile-form-group{
  position:relative;
  margin-bottom:2.5rem;
}

.profile-form-label{
  position:absolute;
  right:1.5rem;
  left: auto;
  top:1rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-secondary);
  pointer-events:none;
  transition:all 0.2s ease-out;
}

.profile-input:focus ~ .profile-form-label,
.profile-input:not([value=""]):not(:placeholder-shown) ~ .profile-form-label {
  top:-2rem;
  right:0;
  left: auto;
  font-size:1.4rem;
  font-weight:600;
  color:var(--accent);
}

.profile-input{
  width:100%;
  background-color:var(--bg-secondary);
  border:1px solid var(--border-color);
  border-radius:8px;
  padding: 1.2rem 1.5rem;
  height: 4.8rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-primary);
  transition:border-color 0.3s ease,box-shadow 0.3s ease;
  text-align: right;
}

.profile-input:focus{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 3px color-mix(in srgb,var(--accent) 20%,transparent);
}

/* THE DEFINITIVE PLACEHOLDER FIX */
.profile-input::placeholder {
  color: var(--text-secondary);
  opacity: 0.7;
}

.profile-input:focus::placeholder {
  opacity: 0.5;
}

.profile-input[type=number]::-webkit-inner-spin-button, 
.profile-input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
}
.profile-input[type=number] {
    -moz-appearance: textfield;
}

.user-avatar{
  border-radius:50%;
  border:2px solid transparent;
  transition:border-color 0.3s ease;
}

.primary-button.delete-forever {
  background-color: #DC2626;
  box-shadow: 0 0 15px color-mix(in srgb, #DC2626 30%, transparent);
}

.country-picker-button {
    display: block;
    width: 100%;
    padding: 0.75rem 1.5rem;
    text-align: right;
    background: none;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.country-picker-button:hover {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}

.info-tooltip-container {
    position: relative;
}
.info-tooltip-text {
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.75rem 1rem;
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 1px solid var(--border-color);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease-out, visibility 0.2s;
    pointer-events: none;
}
.info-tooltip-container:hover .info-tooltip-text {
    opacity: 1;
    visibility: visible;
}

.toggle {
  width: 44px;
  height: 24px;
  background-color: var(--border-color);
  border-radius: 999px;
  padding: 2px;
  display: flex;
  cursor: pointer;
  justify-content: flex-start;
  border: none;
  transition: background-color 0.2s ease-out;
}
.toggle.active {
  background-color: var(--accent);
  justify-content: flex-end;
}
.toggle-handle {
  width: 20px;
  height: 20px;
  background-color: white;
  border-radius: 50%;
}

.creator-credit-link {
  color: var(--accent);
  font-weight: 500;
}

/* --- FINAL UI POLISH FIXES --- */

/* RTL Placeholder Text Alignment for Studio Inputs */
.sidebar-input::placeholder,
div[class*="sidebarInput"] > span {
    text-align: right;
    color: var(--text-secondary);
}

div[class*="sidebarInput"] > span[style*="position: absolute"] {
    right: 1rem !important;
    left: auto !important;
}

/* Disable Main Scroll & Hide Navbar/Footer in Editor */
body.editor-active {
    overflow: hidden !important;
}
body.editor-active > header,
body.editor-active > footer {
    display: none !important;
}

/* Hide Footer in Constellation view */
body.constellation-active > footer {
    display: none !important;
}

/* Fullscreen mode for immersive views */
body.fullscreen-active > header,
body.fullscreen-active > footer,
body.fullscreen-active > div[class*="StudioBar_studioBar"] {
    display: none !important;
}

body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"] {
    background: transparent !important;
    border-color: transparent !important;
    color: rgba(255,255,255,0.4) !important;
}

body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"]:hover {
    color: var(--accent) !important;
    box-shadow: none !important;
}

/* --- IMAGE LIGHTBOX HOVER EFFECT --- */
.image-lightbox-trigger {
    position: relative;
    display: block;
    cursor: zoom-in;
    border-radius: 8px;
    overflow: hidden;
}

.image-lightbox-trigger::after {
    content: 'عرض الصورة كاملة';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-main);
    font-weight: 600;
    font-size: 1.6rem;
    color: white;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(2px);
    opacity: 0;
    transition: opacity 0.2s ease-out;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3Cline x1='11' y1='8' x2='11' y2='14'%3E%3C/line%3E%3Cline x1='8' y1='11' x2='14' y2='11'%3E%3C/line%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center 25%;
    padding-top: 40px;
}

.image-lightbox-trigger:hover::after {
    opacity: 1;
}

.image-lightbox-trigger img {
    transition: transform 0.3s ease-out;
}

.image-lightbox-trigger:hover img {
    transform: scale(1.03);
}

/* --- THE DEFINITIVE SCROLL LOCK FOR LIGHTBOX --- */
body.lightbox-active {
    overflow: hidden !important;
}

--- END OF FILE app/globals.css ---

================================================================================

--- START OF FILE app/layout.tsx ---

// app/layout.tsx
import { Cairo } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { ThemeProvider } from '@/components/ThemeProvider';
import NextAuthProvider from '@/components/SessionProvider';
import StudioBar from '@/components/StudioBar';
import ToastProvider from '@/components/ToastProvider';
import UserStoreHydration from '@/components/UserStoreHydration';
import Lightbox from '@/components/Lightbox'; // <-- IMPORT LIGHTBOX

const cairo = Cairo({
subsets: ['arabic', 'latin'],
display: 'swap',
variable: '--font-main',
weight: ['400', '500', '700', '800'],
});

export const metadata = { title: 'EternalGames | الألعاب أبدية', description: 'الألعاب أبدية.', };

export default function RootLayout({ children }: { children: React.ReactNode; }) {
return (
<html lang="ar" dir="rtl" className={cairo.variable} suppressHydrationWarning>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link
    rel="preconnect"
    href="https://fonts.gstatic.com"
    crossOrigin="anonymous"
/>
<link
    rel="preconnect"
    href="https://cdn.sanity.io"
    crossOrigin="anonymous"
/>
</head>
<body>
<NextAuthProvider>
<UserStoreHydration />
<ThemeProvider attribute="data-theme" defaultTheme="system" enableSystem disableTransitionOnChange>
<ToastProvider />
<Lightbox /> 
<Navbar />
<main>{children}</main>
<Footer />
<StudioBar />
</ThemeProvider>
</NextAuthProvider>
</body>
</html>
);
}

--- END OF FILE app/layout.tsx ---

================================================================================

--- START OF FILE app/page.tsx ---

// app/page.tsx
import { client } from '@/lib/sanity.client';
import { heroContentQuery, latestNewsQuery, allReleasesQuery, vanguardReviewsQuery, featuredArticlesQuery } from '@/lib/sanity.queries';
import DigitalAtriumHomePage from '@/components/DigitalAtriumHomePage';
import { Suspense } from 'react';
import AnimatedReleases from '@/components/AnimatedReleases';
import prisma from '@/lib/prisma';
import { SanityAuthor } from '@/types/sanity';

export const revalidate = 60;

// Helper to enrich an array of creator documents with usernames from Prisma
async function enrichCreators(creators: SanityAuthor[] | undefined): Promise<SanityAuthor[]> {
    if (!creators || creators.length === 0) return [];
    
    const userIds = creators.map(c => c.prismaUserId).filter(Boolean);
    if (userIds.length === 0) return creators;

    const users = await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, username: true },
    });
    const usernameMap = new Map(users.map(u => [u.id, u.username]));

    return creators.map(creator => ({
        ...creator,
        username: usernameMap.get(creator.prismaUserId) || creator.username || null,
    }));
}


async function ReleasesSection() {
    const releases = await client.fetch(allReleasesQuery);
    const sanitizedReleases = (releases || []).filter(item => item?.mainImage);
    return <AnimatedReleases releases={sanitizedReleases} />;
}

export default async function HomePage() {
    const [heroContent, reviews, articles, latestNews] = await Promise.all([
        client.fetch(heroContentQuery),
        client.fetch(vanguardReviewsQuery),
        client.fetch(featuredArticlesQuery),
        client.fetch(latestNewsQuery)
    ]);
    
    // --- THE DEFINITIVE FIX ---
    // Enrich all fetched content with usernames from Prisma before sending to client components.
    const enrichedReviews = await Promise.all(
        reviews.map(async (review) => ({
            ...review,
            authors: await enrichCreators(review.authors),
            designers: await enrichCreators(review.designers),
        }))
    );

    const enrichedArticles = await Promise.all(
        articles.map(async (article) => ({
            ...article,
            authors: await enrichCreators(article.authors),
            designers: await enrichCreators(article.designers),
        }))
    );
    
    // The sanitizer was removing the enriched data. We apply enrichment AFTER.
    let sanitizedHeroContent = {
        featuredReview: heroContent?.featuredReview?.mainImage ? heroContent.featuredReview : null,
        latestNews: heroContent?.latestNews?.mainImage ? heroContent.latestNews : null,
        featuredArticle: heroContent?.featuredArticle?.mainImage ? heroContent.featuredArticle : null,
    };

    if (sanitizedHeroContent.featuredReview) {
        sanitizedHeroContent.featuredReview.authors = await enrichCreators(sanitizedHeroContent.featuredReview.authors);
        sanitizedHeroContent.featuredReview.designers = await enrichCreators(sanitizedHeroContent.featuredReview.designers);
    }

    return (
        <DigitalAtriumHomePage
            heroContent={sanitizedHeroContent}
            reviews={enrichedReviews}
            articles={enrichedArticles}
            latestNews={latestNews} // This one has no bubbles, so it's safe.
        >
            <Suspense fallback={<div className="spinner" style={{margin: '12rem auto'}} />}>
                {/* @ts-expect-error Async Server Component */}
                <ReleasesSection />
            </Suspense>
        </DigitalAtriumHomePage>
    );
}

--- END OF FILE app/page.tsx ---

================================================================================

--- START OF FILE app/template.tsx ---

'use client';

import { motion } from 'framer-motion';

export default function Template({ children }: { children: React.ReactNode }) {
  return (
    <motion.div
      initial={{ y: 20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      transition={{ ease: 'easeInOut', duration: 0.75 }}
    >
      {children}
    </motion.div>
  );
}




--- END OF FILE app/template.tsx ---

================================================================================

--- START OF FILE app/actions/authActions.ts ---

// app/actions/authActions.ts
'use server';

import prisma from '@/lib/prisma';
import crypto from 'crypto';
import bcrypt from 'bcryptjs';

// This would be your email sending function. For now, it logs to the console.
async function sendPasswordResetEmail(email: string, token: string) {
    const resetLink = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`;
    console.log(`--- PASSWORD RESET EMAIL ---`);
    console.log(`To: ${email}`);
    console.log(`Link: ${resetLink}`);
    console.log(`--------------------------`);
    // In production, you would use a service like Resend, SendGrid, or Nodemailer here.
}

export async function requestPasswordReset(email: string) {
    try {
        const user = await prisma.user.findUnique({ where: { email } });
        if (!user || !user.password) {
            // Don't reveal if a user exists or not for security reasons.
            // Also, don't allow password resets for OAuth users.
            return { success: true, message: 'إن كان البريد مسجلاً، فقد أُرسِلَ إليه رابط.' };
        }

        // Invalidate any existing tokens for this user
        await prisma.passwordResetToken.deleteMany({ where: { userId: user.id } });

        const token = crypto.randomBytes(32).toString('hex');
        const expires = new Date(new Date().getTime() + 60 * 60 * 1000); // 1 hour expiry

        await prisma.passwordResetToken.create({
            data: {
                userId: user.id,
                token,
                expires,
            },
        });

        await sendPasswordResetEmail(email, token);

        return { success: true, message: 'إن كان البريد مسجلاً، فقد أُرسِلَ إليه رابط.' };
    } catch (error) {
        console.error('Password reset request failed:', error);
        return { success: false, message: 'طرأ خطأ غير متوقع.' };
    }
}

export async function resetPassword(token: string, newPassword: string) {
    try {
        if (!token || !newPassword) {
            return { success: false, message: 'Invalid request.' };
        }

        const resetToken = await prisma.passwordResetToken.findUnique({
            where: { token },
        });

        if (!resetToken || resetToken.expires < new Date()) {
            if (resetToken) {
                await prisma.passwordResetToken.delete({ where: { id: resetToken.id } });
            }
            return { success: false, message: 'الرمز باطل أو منتهي الصلاحية.' };
        }

        if (newPassword.length < 8) {
            return { success: false, message: 'يجب ألا تقل كلمة السر عن ثمانية أحرف.' };
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await prisma.user.update({
            where: { id: resetToken.userId },
            data: { password: hashedPassword },
        });

        await prisma.passwordResetToken.delete({
            where: { id: resetToken.id },
        });

        return { success: true, message: 'تم استعادة كلمة السر بنجاح.' };
    } catch (error) {
        console.error('Password reset failed:', error);
        return { success: false, message: 'طرأ خطأ غير متوقع.' };
    }
}




--- END OF FILE app/actions/authActions.ts ---

================================================================================

--- START OF FILE app/actions/commentActions.ts ---

// app/actions/commentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { VoteType } from '@prisma/client';
import { getAuthenticatedSession } from '@/lib/auth'; // <-- IMPORT HELPER

export async function postReplyOrComment(contentSlug: string, content: string, parentId?: string) {
    try {
        const session = await getAuthenticatedSession();
        if (!content || content.trim().length === 0) return { success: false, error: 'لا يمكن نشر تعليق فارغ.' };

        const newComment = await prisma.comment.create({
            data: { contentSlug, content, authorId: session.user.id, parentId },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });
        return { success: true, comment: newComment };
    } catch (error: any) {
        return { success: false, error: error.message || "تعذر نشر التعليق." };
    }
}

export async function deleteComment(commentId: string) {
    try {
        const session = await getAuthenticatedSession();
        const commentToDelete = await prisma.comment.findUnique({
            where: { id: commentId },
            include: { _count: { select: { replies: true } } }
        });
        if (!commentToDelete || commentToDelete.authorId !== session.user.id) return { success: false, error: 'غير مصرح لك.' };

        if (commentToDelete._count.replies > 0) {
            const updatedComment = await prisma.comment.update({
                where: { id: commentId },
                data: { content: '[Comment deleted]', isDeleted: true }
            });
            return { success: true, wasDeleted: false, updatedComment };
        } else {
            await prisma.comment.delete({ where: { id: commentId } });
            return { success: true, wasDeleted: true, deletedId: commentId };
        }
    } catch (error: any) {
        return { success: false, error: error.message || 'Could not delete comment.' };
    }
}

export async function updateComment(commentId: string, content: string) {
    try {
        const session = await getAuthenticatedSession();
        if (!content || content.trim().length === 0) return { success: false, error: 'لا يمكن نشر تعليق فارغ.' };

        const comment = await prisma.comment.findUnique({ where: { id: commentId }, select: { authorId: true, contentSlug: true } });
        if (!comment || comment.authorId !== session.user.id) return { success: false, error: 'غير مصرح لك.' };

        const updatedComment = await prisma.comment.update({
            where: { id: commentId },
            data: { content },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });

        revalidatePath(`/reviews/${comment.contentSlug}`);
        revalidatePath(`/articles/${comment.contentSlug}`);
        revalidatePath(`/news/${comment.contentSlug}`);
        return { success: true, updatedComment };
    } catch (error: any) {
        return { success: false, error: error.message || "فشل التحديث." };
    }
}

export async function voteOnComment(commentId: string, voteType: VoteType) {
    try {
        const session = await getAuthenticatedSession();
        const existingVote = await prisma.commentVote.findUnique({ where: { userId_commentId: { userId: session.user.id, commentId } } });
        
        if (existingVote) {
            if (existingVote.type === voteType) { await prisma.commentVote.delete({ where: { id: existingVote.id } }); } 
            else { await prisma.commentVote.update({ where: { id: existingVote.id }, data: { type: voteType } }); }
        } else {
            await prisma.commentVote.create({ data: { userId: session.user.id, commentId, type: voteType } });
        }
        
        const updatedComment = await prisma.comment.findUnique({ where: { id: commentId }, select: { votes: true } });
        if (!updatedComment) throw new Error("Comment not found after vote update.");
        return { success: true, updatedVotes: updatedComment.votes };
    } catch (error: any) {
        return { success: false, error: error.message || 'تعذر تسجيل التصويت.' };
    }
}

export async function getReplies(parentId: string) {
    try {
        const replies = await prisma.comment.findMany({
            where: { parentId },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            },
            orderBy: { createdAt: 'asc' }
        });
        return { success: true, replies };
    } catch (error) {
        return { success: false, error: 'فشل جلب الردود.' };
    }
}







--- END OF FILE app/actions/commentActions.ts ---

================================================================================

--- START OF FILE app/actions/contentActions.ts ---

// app/actions/contentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { getAuthenticatedSession } from '@/lib/auth';
import { EngagementType } from '@prisma/client';

/**
 * An idempotent function to set the state of an engagement.
 * It ensures the final state in the DB matches the desired `isEngaged` state.
 */
async function setEngagement(userId: string, contentId: number, contentType: string, engagementType: EngagementType, isEngaged: boolean) {
    const whereClause = {
        userId_contentId_contentType_type: { userId, contentId, contentType, type: engagementType },
    };

    if (isEngaged) {
        // If we want it to exist, create it if it doesn't. Do nothing if it already exists.
        await prisma.engagement.upsert({
            where: whereClause,
            update: {},
            create: { userId, contentId, contentType, type: engagementType },
        });
    } else {
        // If we want it to NOT exist, delete it. It's safe to call delete even if it's not there.
        // Using `deleteMany` with a `where` is a safe way to handle this without checking existence first.
        await prisma.engagement.deleteMany({
            where: { userId, contentId, contentType, type: engagementType },
        });
    }
}

export async function setBookmarkAction(contentId: number, contentType: string, isBookmarked: boolean) {
    try {
        const session = await getAuthenticatedSession();
        await setEngagement(session.user.id, contentId, contentType, 'BOOKMARK', isBookmarked);
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setBookmarkAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطأ غير متوقع.' };
    }
}

export async function setLikeAction(contentId: number, contentType: string, contentSlug: string, isLiked: boolean) {
    try {
        const session = await getAuthenticatedSession();
        await setEngagement(session.user.id, contentId, contentType, 'LIKE', isLiked);
        
        // Revalidation is still useful here
        revalidatePath(`/${contentType}s/${contentSlug}`);
        
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setLikeAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطأ غير متوقع.' };
    }
}

// recordShareAction remains unchanged as it's not a toggle.
export async function recordShareAction(contentId: number, contentType: string, contentSlug: string) {
    try {
        const session = await getAuthenticatedSession();
        const userId = session.user.id;

        await prisma.share.create({
            data: { userId, contentId, contentType },
        });

        revalidatePath(`/${contentType}s/${contentSlug}`);
        
        const updatedShares = await prisma.share.findMany({
            where: { userId },
            select: { contentId: true, contentType: true }
        });
        
        return { success: true, shares: updatedShares, message: 'Share recorded.' };
    } catch (error: any) {
        console.error("CRITICAL: recordShareAction failed:", error);
        return { success: false, error: error.message || 'Could not record share.' };
    }
}




--- END OF FILE app/actions/contentActions.ts ---

================================================================================

--- START OF FILE app/actions/creatorActions.ts ---

'use server';

import prisma from '@/lib/prisma';

export async function getCreatorUsernames(creatorIds: string[]) {
    if (!creatorIds || creatorIds.length === 0) {
        return {};
    }

    try {
        const users = await prisma.user.findMany({
            where: {
                id: { in: creatorIds }
            },
            select: {
                id: true,
                username: true
            }
        });

        // Create a map of prismaUserId -> username
        const usernameMap = users.reduce((acc, user) => {
            if (user.username) {
                acc[user.id] = user.username;
            }
            return acc;
        }, {} as Record<string, string>);

        return usernameMap;
    } catch (error) {
        console.error("Failed to fetch creator usernames:", error);
        return {};
    }
}

--- END OF FILE app/actions/creatorActions.ts ---

================================================================================

--- START OF FILE app/actions/userActions.ts ---

// app/actions/userActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { put } from '@vercel/blob';
import bcrypt from 'bcryptjs';
import { getAuthenticatedSession } from '@/lib/auth';

export async function getUserState() {
    try {
        const session = await getAuthenticatedSession();
        // Fetch all user state in parallel
        const [engagements, shares] = await Promise.all([
            prisma.engagement.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true, type: true } 
            }),
            prisma.share.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true } 
            }),
        ]);
        return { success: true, data: { engagements, shares } };
    } catch (error) {
        // This will happen if the user is not logged in, which is expected.
        return { success: false, data: null };
    }
}

// ... (rest of userActions.ts)
export async function updateUserProfile(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        
        const username = (formData.get('username') as string)?.toLowerCase();
        const bio = formData.get('bio') as string;
        const twitterHandle = formData.get('twitterHandle') as string;
        const instagramHandle = formData.get('instagramHandle') as string;
        const agePublic = formData.get('agePublic') === 'on';
        const countryPublic = formData.get('countryPublic') === 'on';

        if (username) {
            const validation = validateUsername(username);
            if (!validation.success) throw new Error(validation.message);
            const existingUser = await prisma.user.findUnique({ where: { username } });
            if (existingUser && existingUser.id !== session.user.id) {
                throw new Error('اسم المستخدم محجوز.');
            }
        }
        
        await prisma.user.update({
            where: { id: session.user.id },
            data: {
                username: username || undefined,
                bio: bio.slice(0, 500),
                twitterHandle,
                instagramHandle,
                agePublic,
                countryPublic,
            },
        });

        revalidatePath('/profile');
        revalidatePath(`/profile/${session.user.id}`);
        if (username) revalidatePath(`/creators/${username}`);

        return { success: true, message: 'تم تحديث الملف الشخصي بنجاح.' };
    } catch (error: any) {
        return { success: false, message: error.message || 'Failed to update profile.' };
    }
}

export async function completeOnboardingAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });

        // THE DEFINITIVE FIX: The guard clause that checked if onboarding was complete
        // was incorrectly blocking credential-based signups. It has been removed.
        // The act of submitting this form is the user's intent to complete onboarding.

        const fullName = formData.get('fullName') as string;
        const username = (formData.get('username') as string)?.toLowerCase();
        const ageStr = formData.get('age') as string;
        const country = formData.get('country') as string;

        // This validation is more explicit and provides clearer user feedback.
        if (!fullName || fullName.trim() === '') {
            return { success: false, message: 'الاسم الكامل مطلوب.' };
        }
        if (!username) {
            return { success: false, message: 'اسم المستخدم مطلوب.' };
        }

        // If the user is trying to set a username that is different from their current one
        // (which only happens in the OAuth flow), we must validate it.
        if (username !== user?.username) {
            const usernameValidation = await checkUsernameAvailability(username);
            if (!usernameValidation.available) {
                return { success: false, message: usernameValidation.message };
            }
        }

        await prisma.user.update({
            where: { id: session.user.id },
            data: {
                name: fullName,
                username: username,
                age: ageStr ? parseInt(ageStr, 10) : null,
                country: country || null,
            },
        });

        revalidatePath('/profile');
        if (username) revalidatePath(`/profile/${username}`);
        
        return { success: true };

    } catch (error: any) {
        return { success: false, message: error.message || 'An unexpected error occurred during onboarding.' };
    }
}
export async function changePasswordAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });

        if (!user?.password) {
            return { success: false, message: 'لا يمكن تغيير كلمة السر للحسابات المرتبطة.' };
        }

        const currentPassword = formData.get('currentPassword') as string;
        const newPassword = formData.get('newPassword') as string;
        const confirmPassword = formData.get('confirmPassword') as string;

        if (!currentPassword || !newPassword || !confirmPassword) {
            return { success: false, message: 'كافة الحقول إلزامية.' };
        }

        const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
        if (!isPasswordValid) {
            return { success: false, message: 'كلمة السر الحالية غير صحيحة.' };
        }

        if (newPassword.length < 8) {
            return { success: false, message: 'كلمة السر الجديدة يجب ألا تقل عن ٨ أحرف.' };
        }

        if (newPassword !== confirmPassword) {
            return { success: false, message: 'كلمتا السر الجديدتان غير متطابقتين.' };
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await prisma.user.update({
            where: { id: user.id },
            data: { password: hashedPassword },
        });

        return { success: true, message: 'تم تغيير كلمة السر بنجاح.' };

    } catch (error: any) {
        return { success: false, message: error.message || 'طرأ خطأ غير متوقع.' };
    }
}
const validateUsername = (username: string) => {
    if (!username) return { success: false, message: 'اسم المستخدم مطلوب.' };
    const usernameRegex = /^[a-z0-9_]{3,20}$/;
    if (!usernameRegex.test(username)) {
        return { success: false, message: 'اسم المستخدم يجب أن يتكون من 3-20 حرفًا إنجليزيًا.' };
    }
    return { success: true };
};
export async function checkUsernameAvailability(username: string) {
    const validation = validateUsername(username);
    if (!validation.success) {
        return { available: false, message: validation.message };
    }
    const existingUser = await prisma.user.findUnique({ where: { username } });
    if (existingUser) {
        return { available: false, message: 'اسم المستخدم محجوز.' };
    }
    return { available: true, message: 'اسم المستخدم متاح.' };
}
export async function signUp(formData: FormData) {
    const name = formData.get('name') as string;
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;
    const username = (formData.get('username') as string)?.toLowerCase();
    if (!name || !email || !password || !username) {
        return { success: false, message: 'كافة الحقول إلزامية.' };
    }
    if (!/\S+@\S+\.\S+/.test(email)) {
        return { success: false, message: 'البريد الإلكتروني غير صالح.' };
    }
    if (password.length < 8) {
        return { success: false, message: 'يجب ألا تقل كلمة السر عن ثمانية أحرف.' };
    }
    const usernameValidation = await checkUsernameAvailability(username);
    if (!usernameValidation.available) {
        return { success: false, message: usernameValidation.message };
    }
    const existingEmail = await prisma.user.findUnique({ where: { email } });
    if (existingEmail) {
        return { success: false, message: 'هذا البريد مسجل بالفعل.' };
    }
    return { success: true, message: 'Validation successful.' };
}
export async function setUsernameAction(username: string) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });
        if (user?.username) return { success: false, message: 'Username has already been set.' };

        const cleanUsername = username.toLowerCase();
        const validation = await checkUsernameAvailability(cleanUsername);
        if (!validation.available) return { success: false, message: validation.message };

        await prisma.user.update({
            where: { id: session.user.id },
            data: { username: cleanUsername },
        });
        revalidatePath('/profile');
        return { success: true };
    } catch (error: any) {
        return { success: false, message: error.message || 'Failed to update username.' };
    }
}
export async function updateUserAvatar(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const avatarFile = formData.get('avatar') as File | null;
        if (!avatarFile || avatarFile.size === 0) return { success: true, message: 'لا يوجد ملف صورة جديد.' };

        const sanitizedFilename = `${session.user.id}-${Date.now()}-${avatarFile.name.replace(/[^a-zA-Z0-9._-]/g, '-')}`;
        const blob = await put(sanitizedFilename, avatarFile, { access: 'public', contentType: avatarFile.type });
        await prisma.user.update({ where: { id: session.user.id }, data: { image: blob.url } });
        
        revalidatePath('/profile');
        return { success: true, message: 'تم تحديث الصورة الرمزية.' };
    } catch (error: any) {
        return { success: false, message: error.message || 'فشل الرفع.' };
    }
}
export async function getCommentedContentIds() {
    try {
        const session = await getAuthenticatedSession();
        const comments = await prisma.comment.findMany({
            where: { authorId: session.user.id, isDeleted: false },
            select: { contentSlug: true },
            distinct: ['contentSlug'],
        });
        return comments.map(c => c.contentSlug);
    } catch (error) {
        return [];
    }
}




--- END OF FILE app/actions/userActions.ts ---

================================================================================

--- START OF FILE app/api/auth/[...nextauth]/route.ts ---

// app/api/auth/[...nextauth]/route.ts

import NextAuth, { NextAuthOptions } from "next-auth"
import GithubProvider from "next-auth/providers/github"
import GoogleProvider from "next-auth/providers/google"
import TwitterProvider from "next-auth/providers/twitter"
import CredentialsProvider from "next-auth/providers/credentials"
import { PrismaAdapter } from "@next-auth/prisma-adapter"
import prisma from "@/lib/prisma"
import bcrypt from "bcryptjs"
import { checkUsernameAvailability } from "@/app/actions/userActions";

export const authOptions: NextAuthOptions = {
    adapter: PrismaAdapter(prisma),
    providers: [
        CredentialsProvider({
            id: 'credentials',
            name: "Credentials",
            credentials: {
                email: { label: "البريد الإلكتروني", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) throw new Error("البيانات ناقصة.");
                const user = await prisma.user.findUnique({ where: { email: credentials.email } });
                if (!user) throw new Error("لا حساب بهذا البريد. تفضل بالتسجيل.");
                if (!user.password) throw new Error("هذا الحساب مرتبط بمزود خارجي.");
                const isPasswordValid = await bcrypt.compare(credentials.password, user.password);
                if (isPasswordValid) return user;
                else throw new Error("كلمة السر غير صحيحة.");
            }
        }),
        CredentialsProvider({
            id: 'signup',
            name: "SignUp",
            credentials: {
                email: { label: "البريد الإلكتروني", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials) throw new Error("Missing sign-up details.");
                const { email, password } = credentials;
                if (!email || !password) throw new Error("كافة الحقول إلزامية.");
                if (!/\S+@\S+\.\S+/.test(email)) throw new Error('البريد الإلكتروني غير صالح.');
                if (password.length < 8) throw new Error('يجب ألا تقل كلمة السر عن ثمانية أحرف.');
                
                const existingEmail = await prisma.user.findUnique({ where: { email } });
                if (existingEmail) throw new Error('هذا البريد مسجل بالفعل.');

                const hashedPassword = await bcrypt.hash(credentials.password, 10);
                const newUser = await prisma.user.create({
                    data: {
                        email: credentials.email,
                        password: hashedPassword,
                    }
                });
                return newUser;
            }
        }),
        GithubProvider({ clientId: process.env.AUTH_GITHUB_ID as string, clientSecret: process.env.AUTH_GITHUB_SECRET as string, }),
        GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID as string, clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, }),
        TwitterProvider({ clientId: process.env.TWITTER_CLIENT_ID as string, clientSecret: process.env.TWITTER_CLIENT_SECRET as string, version: "2.0", }),
    ],
    events: {
        createUser: async ({ user }) => {
            const userRole = await prisma.role.findUnique({ where: { name: 'USER' } });
            if (userRole) {
                await prisma.user.update({ where: { id: user.id }, data: { roles: { connect: { id: userRole.id } } } });
            }
        }
    },
    session: { strategy: "jwt" },
    secret: process.env.NEXTAUTH_SECRET,
    callbacks: {
        async signIn({ user }) {
            // This callback is now simplified. It just allows the sign-in to proceed.
            // The JWT callback will handle the onboarding logic.
            return true;
        },
        async jwt({ token, user, trigger }) {
            // This block now runs on initial sign-in AND on session updates.
            if (user || trigger === "update") {
                const dbUser = await prisma.user.findUnique({
                    where: { id: token.id as string || user.id },
                    include: { roles: true }
                });

                if (dbUser) {
                    // Update all user details in the token
                    token.id = dbUser.id;
                    token.picture = dbUser.image;
                    token.name = dbUser.name;
                    token.roles = dbUser.roles.map(role => role.name);
                    token.username = dbUser.username;
                    
                    // THE DEFINITIVE FIX: Re-evaluate the onboarding status every time
                    // the token is generated or updated. This ensures that after the user
                    // completes the welcome form, the flag is correctly set to false.
                    token.needsOnboarding = !dbUser.name || !dbUser.username;
                }
            }
            return token;
        },
        async session({ session, token }) {
            if (token && session.user) {
                session.user.id = token.id;
                session.user.roles = token.roles;
                session.user.name = token.name;
                session.user.email = token.email;
                session.user.image = token.picture;
                session.user.username = token.username;
                (session as any).needsOnboarding = token.needsOnboarding;
            }
            return session;
        },
    },
    pages: { signIn: '/', error: '/', },
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };




--- END OF FILE app/api/auth/[...nextauth]/route.ts ---

================================================================================

--- START OF FILE app/api/blob/upload/route.ts ---

// app/api/blob/upload/route.ts
import { handleUpload } from '@vercel/blob/client'; // <-- THE FIX IS HERE
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

export async function POST(request: Request): Promise<NextResponse> {
  const body = await request.json();

  try {
    const jsonResponse = await handleUpload({
      body,
      request,
      onBeforeGenerateToken: async (pathname: string) => {
        const session = await getServerSession(authOptions);
        if (!session || !session.user?.id) {
          throw new Error('Not authenticated.');
        }

        const userRoles = session.user.roles || [];
        const isCreatorOrAdmin = userRoles.some(role => 
            ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role)
        );

        if (!isCreatorOrAdmin) {
            throw new Error('Insufficient permissions for upload.');
        }

        return {
          allowedContentTypes: ['image/jpeg', 'image/png', 'image/webp'],
          tokenPayload: JSON.stringify({ userId: session.user.id }),
        };
      },
      onUploadCompleted: async ({ blob, tokenPayload }) => {
        console.log('Blob upload completed:', blob.pathname, JSON.parse(tokenPayload));
      },
    });

    return NextResponse.json(jsonResponse);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 400 },
    );
  }
}

--- END OF FILE app/api/blob/upload/route.ts ---

================================================================================

--- START OF FILE app/api/content-by-ids/route.ts ---

// app/api/content-by-ids/route.ts

import { NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { contentByIdsQuery } from '@/lib/sanity.queries';

// This is the API endpoint the Constellation component calls.
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { ids } = body;

    // Validate the input from the client
    if (!Array.isArray(ids) || ids.length === 0) {
      // If no IDs are provided, return an empty array immediately.
      return NextResponse.json([]);
    }

    // Use the existing, correct query from your queries file
    const content = await client.fetch(contentByIdsQuery, { ids });

    // Return the found content to the client
    return NextResponse.json(content);
    
  } catch (error) {
    console.error('API Error in /api/content-by-ids:', error);
    // If anything goes wrong, return a server error status
    return NextResponse.json(
      { error: 'Failed to fetch content by IDs.' },
      { status: 500 }
    );
  }
}




--- END OF FILE app/api/content-by-ids/route.ts ---

================================================================================

--- START OF FILE app/api/cron/revalidate-scheduled/route.ts ---

// app/api/cron/revalidate-scheduled/route.ts

import { revalidatePath } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';

// This is the CRON job handler. It is secured by a secret token from Vercel.
export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('غير مصرح لك.', { status: 401 });
  }

  // Find all documents that were scheduled to be published in the last minute
  // and are now past their publication date.
  const now = new Date();
  const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);

  const query = groq`*[_type in ["مراجعة", "مقالة", "خبر"] && publishedAt >= $oneMinuteAgo && publishedAt < $now] {
    _type,
    "slug": slug.current
  }`;

  try {
    const docsToRevalidate: { _type: string; slug: string }[] = await sanityWriteClient.fetch(query, {
      oneMinuteAgo: oneMinuteAgo.toISOString(),
      now: now.toISOString(),
    });

    if (docsToRevalidate.length === 0) {
      return NextResponse.json({ success: true, message: 'No documents to revalidate.' });
    }

    // Use a Set to avoid revalidating the same path multiple times
    const pathsToRevalidate = new Set<string>();
    docsToRevalidate.forEach(doc => {
      const contentTypePlural = doc._type === 'خبر' ? 'خبر' : `${doc._type}s`;
      pathsToRevalidate.add(`/${contentTypePlural}`); // e.g., /articles
      pathsToRevalidate.add(`/${contentTypePlural}/${doc.slug}`); // e.g., /articles/my-slug
    });

    // Trigger revalidation for all unique paths
    pathsToRevalidate.forEach(path => {
      revalidatePath(path);
    });

    return NextResponse.json({ success: true, revalidatedPaths: Array.from(pathsToRevalidate) });

  } catch (error) {
    console.error('Cron job failed:', error);
    return NextResponse.json({ success: false, message: 'Cron job failed.' }, { status: 500 });
  }
}
















--- END OF FILE app/api/cron/revalidate-scheduled/route.ts ---

================================================================================

--- START OF FILE app/api/news-engagement/route.ts ---

// app/api/news-engagement/route.ts

import prisma from '@/lib/prisma';
import { NextResponse } from 'next/server';

export const revalidate = 60; // Cache this data for 60 seconds

export async function GET() {
  try {
    // 1. Find all unique legacyIds (contentIds) tagged as 'خبر' and of type 'LIKE'
    const contentIdsQuery = await prisma.engagement.findMany({
        where: { contentType: 'خبر', type: 'LIKE' },
        select: { contentId: true },
        distinct: ['contentId']
    });
    const ids = contentIdsQuery.map(i => i.contentId);

    // 2. Aggregate Likes and Shares separately
    const likes = await prisma.engagement.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر', type: 'LIKE' },
        _count: { userId: true },
    });

    const shares = await prisma.share.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر' },
        _count: { userId: true },
    });
    
    // Note: We cannot reliably calculate comments in this API without complex database mappings, 
    // so we maintain the weighted scoring structure based on available data (Likes/Shares).

    // 3. Aggregate results and calculate viral score
    const result = ids.map(id => {
        const likeCount = likes.find(s => s.contentId === id)?._count.userId || 0;
        const shareCount = shares.find(s => s.contentId === id)?._count.userId || 0;
        
        // Weighted viral score: Shares (x5) + Likes (x2)
        const engagementScore = likeCount * 2 + shareCount * 5; 
        
        return {
            id,
            engagementScore,
        };
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Failed to fetch news engagement:', error);
    return NextResponse.json({ error: 'Failed to fetch engagement metrics' }, { status: 500 });
  }
}




--- END OF FILE app/api/news-engagement/route.ts ---

================================================================================

--- START OF FILE app/api/revalidate/route.ts ---

// app/api/revalidate/route.ts

import { revalidatePath } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

// Helper function to delay execution
const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export async function POST(request: NextRequest) {
  const body = await request.json();
  const { path, delay, token } = body;

  // 1. Security Check: Validate the secret token
  if (token !== process.env.REVALIDATION_SECRET_TOKEN) {
    return NextResponse.json({ message: 'Invalid token' }, { status: 401 });
  }

  // 2. Input Validation
  if (!path || typeof path !== 'string' || typeof delay !== 'number') {
    return NextResponse.json({ message: 'Invalid request body' }, { status: 400 });
  }

  // 3. Perform the delayed revalidation
  if (delay > 0) {
    await wait(delay);
  }

  try {
    revalidatePath(path);
    return NextResponse.json({ revalidated: true, path, now: Date.now() });
  } catch (err) {
    return NextResponse.json({ message: `Error revalidating path: ${path}` }, { status: 500 });
  }
}
















--- END OF FILE app/api/revalidate/route.ts ---

================================================================================

--- START OF FILE app/api/search/route.ts ---

//  FIX #1: Revert to the correct, project-wide authenticated client
import { client } from '@/lib/sanity.client';
import { searchQuery } from '@/lib/sanity.queries';
import { SanitySearchResult } from '@/types/sanity';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
const { searchParams } = new URL(request.url);
const query = searchParams.get('q');

if (!query || query.length < 3) {
return NextResponse.json([], { status: 200 });
}

try {
const results: SanitySearchResult[] = await client.fetch(searchQuery, { query: `*${query}*` });
return NextResponse.json(results);
} catch (error) {
console.error('Sanity search failed:', error);
// This is where the "Search failed" message comes from.
return NextResponse.json({ error: 'An error occurred while searching.' }, { status: 500 });
}
}





























--- END OF FILE app/api/search/route.ts ---

================================================================================

--- START OF FILE app/articles/ArticlesPage.module.css ---

/* app/articles/ArticlesPage.module.css */

.articlesPageContainer {
  position: relative;
  padding-top: var(--nav-height-scrolled);
}

.articlesPageBg {
  position: fixed;
  top: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}
.articlesPageBgOverlay {
  position: absolute;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 80%, transparent);
  backdrop-filter: blur(16px) saturate(120%);
}

/* Horizontal Showcase */
.horizontalShowcaseWrapper {
  position: relative;
  height: 450px;
  display: flex;
  align-items: center;
  overflow: hidden;
  cursor: grab;
}
.horizontalShowcaseWrapper:active {
  cursor: grabbing;
}

.horizontalShowcaseList {
  display: flex;
  align-items: center;
}

:root {
  --showcase-card-width: 50vw;
  --showcase-card-max-width: 600px;
  --showcase-card-gap: 2rem;
}
@media (max-width: 768px) {
  :root {
    --showcase-card-width: 80vw;
  }
}

.showcaseItemWrapper {
  flex-shrink: 0;
  width: var(--showcase-card-width);
  max-width: var(--showcase-card-max-width);
  margin-right: var(--showcase-card-gap);
}
.showcaseItemWrapper:first-child {
  margin-left: var(--showcase-card-gap);
}

.showcaseCardContainer {
  width: 100%;
  perspective: 1000px;
}

.showcaseCardLink {
  display: block;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 16 / 9;
  box-shadow: 0 20px 40px -15px color-mix(in srgb, var(--text-primary) 20%, transparent);
  background-color: var(--bg-secondary);
}

.showcaseCardImageWrapper {
  position: absolute;
  inset: 0;
}
.showcaseCardImage {
  transition: transform 0.4s ease;
}
.showcaseCardLink:hover .showcaseCardImage {
  transform: scale(1.05);
}

.showcaseCardContent {
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  padding: 2.5rem;
  color: #fff;
  background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
}
.showcaseCardTitle {
  font-family: var(--font-main);
  font-size: 2.8rem;
  line-height: 1.2;
}
.showcaseCardGame {
  font-family: var(--font-ui);
  color: var(--text-secondary);
  font-weight: 500;
  margin-top: 0.75rem;
}
[data-theme="dark"] .showcaseCardGame {
  color: color-mix(in srgb, var(--text-secondary) 80%, #fff);
}

/* Arrow Buttons */
.showcaseArrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 10;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(8px);
}
.showcaseArrow.left {
  left: 3rem;
}
.showcaseArrow.right {
  right: 3rem;
}




--- END OF FILE app/articles/ArticlesPage.module.css ---

================================================================================

--- START OF FILE app/articles/ArticlesPageClient.tsx ---

// app/articles/ArticlesPageClient.tsx
'use client';

import React, { useState, useMemo, useCallback } from 'react';
import { useSearchParams } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import HorizontalShowcase from '@/components/HorizontalShowcase';
import ArticleFilters from '@/components/filters/ArticleFilters';
import ArticleGrid from '@/components/ArticleGrid';
import { ContentBlock } from '@/components/ContentBlock';
import Image from 'next/image';
import AnimatedGridBackground from '@/components/AnimatedGridBackground';
import { useEngagementScores } from '@/hooks/useEngagementScores';
import { adaptToCardProps } from '@/lib/adapters';
import styles from './ArticlesPage.module.css';

export default function ArticlesPageClient({ featuredArticles, gridArticles, allGames, allGameTags, allArticleTypeTags }: {
  featuredArticles: SanityArticle[];
  gridArticles: SanityArticle[];
  allGames: SanityGame[];
  allGameTags: SanityTag[];
  allArticleTypeTags: SanityTag[];
}) {
  const searchParams = useSearchParams();
  const engagementScores = useEngagementScores();

  const [activeIndex, setActiveIndex] = useState(() => 0);
  const [sortOrder, setSortOrder] = useState(() => 'latest'); 
  const [searchTerm, setSearchTerm] = useState(() => '');
  
  const [selectedGame, setSelectedGame] = useState<SanityGame | null>(() => {
    const gameSlug = searchParams.get('game');
    return gameSlug ? allGames.find(g => g.slug === gameSlug) || null : null;
  });
  const [selectedGameTags, setSelectedGameTags] = useState<SanityTag[]>(() => {
    const tagSlugs = searchParams.get('tags')?.split(',').filter(Boolean) || [];
    return tagSlugs.map(slug => allGameTags.find(t => t.slug === slug)).filter((t): t is SanityTag => !!t);
  });
  const [selectedArticleType, setSelectedArticleType] = useState<SanityTag | null>(null);
  
  const featuredForShowcase = useMemo(() => featuredArticles.map(adaptToCardProps).filter(Boolean), [featuredArticles]);
  const activeBackgroundUrl = featuredForShowcase[activeIndex]?.imageUrl;

  const handleGameSelect = (game: SanityGame | null) => setSelectedGame(game);
  
  const handleGameTagToggle = useCallback((tag: SanityTag) => {
      const newTags = selectedGameTags.some(t => t._id === tag._id) ? selectedGameTags.filter(t => t._id !== tag._id) : [...selectedGameTags, tag];
      setSelectedGameTags(newTags);
  }, [selectedGameTags]);

  const handleArticleTypeSelect = (tag: SanityTag | null) => {
    setSelectedArticleType(tag);
  };
  
  const handleClearAllFilters = () => {
    setSelectedGame(null);
    setSelectedGameTags([]);
    setSelectedArticleType(null);
    setSearchTerm('');
  };

  const filteredAndSortedGridArticles = useMemo(() => {
    const scoresMap = new Map(engagementScores.map(s => [s.id, s.engagementScore]));
    let articles = gridArticles;

    if (searchTerm) {
        articles = articles.filter(article => article.title.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    if (selectedGame) {
        articles = articles.filter(article => article.game?._id === selectedGame._id);
    }
    if (selectedGameTags.length > 0) {
        const selectedTagIds = new Set(selectedGameTags.map(t => t._id));
        articles = articles.filter(article => (article.tags || []).some(tagRef => tagRef && selectedTagIds.has(tagRef._id)));
    }
    if (selectedArticleType) {
        articles = articles.filter(article => (article.tags || []).some(tagRef => tagRef && tagRef._id === selectedArticleType._id));
    }

    if (sortOrder === 'viral') {
      articles.sort((a, b) => (scoresMap.get(b.legacyId) || 0) - (scoresMap.get(a.legacyId) || 0));
    } else {
      articles.sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());
    }
    
    return articles.map(adaptToCardProps).filter(Boolean);

  }, [gridArticles, sortOrder, searchTerm, selectedGame, selectedGameTags, selectedArticleType, engagementScores]);

  return (
    <React.Fragment>
      <AnimatedGridBackground />
      <div className={styles.articlesPageContainer}>
        <AnimatePresence>
          {activeBackgroundUrl && (
            <motion.div key={activeBackgroundUrl} className={styles.articlesPageBg} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
              <Image src={activeBackgroundUrl} alt="Dynamic background" fill style={{ objectFit: 'cover' }} />
              <div className={styles.articlesPageBgOverlay} />
            </motion.div>
          )}
        </AnimatePresence>
        
        <div className="container" style={{ paddingTop: '4rem', paddingBottom: '6rem', minHeight: '80vh' }}>
          <h1 className="page-title" style={{ color: '#fff', textShadow: '0 3px 15px rgba(0,0,0,0.5)', fontSize: '5rem', marginTop: '0.7rem', marginBottom: '-2rem' }}>ديوان الفن</h1>
          
          <div style={{ marginBottom: '2rem' }}>
            <HorizontalShowcase articles={featuredForShowcase} onActiveIndexChange={setActiveIndex} />
          </div>
          
          <div style={{marginTop: '-2rem'}}> 
            <ContentBlock title="جميع المقالات">
              <ArticleFilters 
                sortOrder={sortOrder}
                onSortChange={setSortOrder}
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                allGames={allGames}
                selectedGame={selectedGame}
                onGameSelect={handleGameSelect}
                allGameTags={allGameTags}
                selectedGameTags={selectedGameTags}
                onGameTagToggle={handleGameTagToggle}
                allArticleTypeTags={allArticleTypeTags}
                selectedArticleType={selectedArticleType}
                onArticleTypeSelect={handleArticleTypeSelect}
                onClearAllFilters={handleClearAllFilters}
              />
              {filteredAndSortedGridArticles.length > 0 ? (
                  <ArticleGrid articles={filteredAndSortedGridArticles} />
              ) : (
                  <p style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0'}}>لم نعثر على مقالات تطابق مرادك.</p>
              )}
            </ContentBlock>
          </div>
        </div>
      </div>
    </React.Fragment>
  );
}




--- END OF FILE app/articles/ArticlesPageClient.tsx ---

================================================================================

--- START OF FILE app/articles/page.tsx ---

// app/articles/page.tsx
import { client } from '@/lib/sanity.client';
import { featuredShowcaseArticlesQuery, allArticlesListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import ArticlesPageClient from './ArticlesPageClient';

export const revalidate = 60;

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
// THE FIX: Create two distinct queries for each tag category.
const allGameTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current}`;
const allArticleTypeTagsQuery = groq`*[_type == "tag" && category == "Article"] | order(title asc) {_id, title, "slug": slug.current}`;

export default async function ArticlesPage() {
  const [featuredArticles, gridArticles, allGames, allGameTags, allArticleTypeTags]: [SanityArticle[], SanityArticle[], SanityGame[], SanityTag[], SanityTag[]] = await Promise.all([
    client.fetch(featuredShowcaseArticlesQuery),
    client.fetch(allArticlesListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allGameTagsQuery),
    client.fetch(allArticleTypeTagsQuery),
  ]);

  if (!featuredArticles || featuredArticles.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">ديوان الفن</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>الأرشيف هادئ. المزيد من المقالات قريبًا.</p>
        </div>
    );
  }

  return (
    <ArticlesPageClient
      featuredArticles={featuredArticles}
      gridArticles={gridArticles}
      allGames={allGames}
      allGameTags={allGameTags}
      allArticleTypeTags={allArticleTypeTags}
    />
  );
}




--- END OF FILE app/articles/page.tsx ---

================================================================================

--- START OF FILE app/articles/[slug]/ArticlePage.module.css ---

/* app/articles/[slug]/ArticlePage.module.css */

.articleHeaderImage {
    position: relative;
    width: 100%;
    height: 40vh;
    max-height: 450px;
    margin-bottom: 3rem;
}

/* --- DEFINITIVE FIX: LAYOUT STYLES ADDED --- */
.reviewLayout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
}
@media (min-width: 1024px) {
  .reviewLayout {
    grid-template-columns: 2fr 1fr;
  }
  /* --- THE FIX --- */
  .reviewLayout > main {
    min-width: 0;
  }
}

.reviewSidebar {
    margin-top: 3rem;
}

.relatedArticlesGrid {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}




--- END OF FILE app/articles/[slug]/ArticlePage.module.css ---

================================================================================

--- START OF FILE app/articles/[slug]/ArticlePageClient.tsx ---

// app/articles/[slug]/ArticlePageClient.tsx
'use client';

import type { SanityArticle } from '@/types/sanity';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { useEffect } from 'react';
import { adaptToCardProps } from '@/lib/adapters';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

import TagLinks from '@/components/TagLinks';
import { ContentBlock } from '@/components/ContentBlock';
import ContentActionBar from '@/components/ContentActionBar';
import PortableTextComponent from '@/components/PortableTextComponent';
import ArticleCard from '@/components/ArticleCard';
import CreatorCredit from '@/components/CreatorCredit';
import styles from './ArticlePage.module.css';

export default function ArticlePageClient({ article, comments }: { article: SanityArticle; comments: React.ReactNode }) {
    const layoutIdPrefix = useLayoutIdStore((state) => state.prefix) || 'articles-grid';
    
    useEffect(() => {
        window.scrollTo(0, 0);
    }, []);
        
    if (!article) return null;

    const uniqueRelatedArticles = article.relatedArticles
        ? Array.from(new Map(article.relatedArticles.map(item => [item._id, item])).values())
        : [];

    const adaptedRelatedArticles = (uniqueRelatedArticles || []).map(adaptToCardProps).filter(Boolean);
    
    // Unified Date Formatting (copied from lib/adapters.ts to unify here)
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const publishedDate = new Date(article.publishedAt);
    const day = publishedDate.getDate();
    const year = publishedDate.getFullYear();
    const monthIndex = publishedDate.getMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

    return (
        <>
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.5 }}>
                <motion.div layoutId={`${layoutIdPrefix}-card-image-${article.legacyId}`} className={styles.articleHeaderImage}>
                    <Image src={article.mainImage.url} alt={article.title} fill style={{ objectFit: 'cover' }} priority placeholder="blur" blurDataURL={article.mainImage.blurDataURL} />
                </motion.div>

                <div className="container page-container" style={{ paddingTop: '0' }}>
                    <div className={styles.reviewLayout}>
                        <main>
                            <motion.h1 layoutId={`${layoutIdPrefix}-card-title-${article.legacyId}`} className="page-title" style={{ textAlign: 'right', marginTop: '1.5rem' }}>{article.title}</motion.h1>
                            
                            {/* --- UNIFIED METADATA BLOCK START --- */}
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '3rem' }}>
                                {/* RIGHT SIDE (Creator/Date) */}
                                <div style={{ color: 'var(--text-secondary)', textAlign: 'right', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                    <CreatorCredit label="بقلم" creators={article.authors} />
                                    <CreatorCredit label="تصميم" creators={article.designers} />
                                    <p style={{ margin: 0, fontSize: '1.5rem', color: 'var(--text-secondary)' }}>نُشر في: {formattedDate}</p>
                                </div>

                                {/* LEFT SIDE (Actions) */}
                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '1.5rem' }}>
                                    <ContentActionBar contentId={article.legacyId} contentType="مقالة" contentSlug={article.slug} />
                                </div>
                            </div>
                            {/* --- UNIFIED METADATA BLOCK END --- */}
                            
                            <div className="article-body"><PortableTextComponent content={article.content || []} /></div>
                            <div style={{ marginTop: '4rem', paddingTop: '2rem', borderTop: '1px solid var(--border-color)' }}><TagLinks tags={(article.tags || []).map(t => t.title)} /></div>
                        </main>
                        <aside className={styles.reviewSidebar}>
                            <ContentBlock title="قد يروق لك"><div className={styles.relatedArticlesGrid}>{adaptedRelatedArticles.map(related => ( <ArticleCard key={related.id} article={related} layoutIdPrefix="related-article" isArticle={true} /> ))}</div></ContentBlock>
                        </aside>
                    </div>
                </div>
                <div className="container" style={{ paddingBottom: '6rem' }}>
                    <ContentBlock title="حديث المجتمع">{comments}</ContentBlock>
                </div>
            </motion.div>
        </>
    );
}




--- END OF FILE app/articles/[slug]/ArticlePageClient.tsx ---

================================================================================

--- START OF FILE app/articles/[slug]/page.tsx ---

// app/articles/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { articleBySlugQuery, latestArticlesFallbackQuery } from '@/lib/sanity.queries';
import type { SanityArticle } from '@/types/sanity';
import { notFound } from 'next/navigation';
import ArticlePageClient from './ArticlePageClient';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import CommentSection from '@/components/comments/CommentSection';
import { Suspense } from 'react';

export const revalidate = 60;

// Enrich creator with prisma username, image, and bio
async function enrichCreator(creator: any) {
    if (!creator || !creator.prismaUserId) return creator;
    const user = await prisma.user.findUnique({
        where: { id: creator.prismaUserId },
        select: { username: true, image: true, bio: true }
    });
    return { 
        ...creator, 
        username: user?.username || null,
        image: user?.image || null,
        bio: user?.bio || null,
    };
}

export async function generateStaticParams() {
    const articles = await client.fetch<any[]>(`*[_type == "مقالة"]{ "slug": slug.current }`);
    return articles.filter(a => a.slug).map(a => ({ slug: a.slug }));
}

async function Comments({ slug }: { slug: string }) {
    const [comments, session] = await Promise.all([
        prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } }, replies: { take: 2, include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } } }, orderBy: { createdAt: 'asc' } } },
            orderBy: { createdAt: 'desc' },
        }),
        getServerSession(authOptions)
    ]);
    return <CommentSection slug={slug} initialComments={comments} session={session} />;
}

export default async function ArticlePage({ params }: { params: { slug: string } }) {
    const resolvedParams = await params;
    const slug = resolvedParams.slug;
    
    let article: SanityArticle = await client.fetch(articleBySlugQuery, { slug });

    if (!article) {
        notFound();
    }

    // Add related articles fallback logic
    if (!article.relatedArticles || article.relatedArticles.length === 0) {
        const fallbackArticles = await client.fetch(latestArticlesFallbackQuery, { currentId: article._id });
        article.relatedArticles = fallbackArticles;
    }
    
    // Enrich creator data
    if (article.authors) {
        article.authors = await Promise.all(article.authors.map(enrichCreator));
    }
    if (article.designers) {
        article.designers = await Promise.all(article.designers.map(enrichCreator));
    }

    return (
        <ArticlePageClient 
            article={article}
            comments={
                <Suspense fallback={<div className="spinner" style={{margin: '8rem auto'}} />}>
                    {/* @ts-expect-error Async Server Component */}
                    <Comments slug={slug} />
                </Suspense>
            }
        />
    );
}




--- END OF FILE app/articles/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/CelestialAlmanacLoader.tsx ---

// app/celestial-almanac/CelestialAlmanacLoader.tsx

'use client';

import dynamic from 'next/dynamic';
import type { SanityGameRelease } from '@/types/sanity';

// Dynamic import of the main client component containing the Three.js canvas.
// This is critical for performance and to avoid SSR errors with browser-only APIs.
const CelestialAlmanac = dynamic(() => import('@/app/celestial-almanac'), {
  ssr: false,
  loading: () => (
    <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <div className="spinner" style={{ width: '60px', height: '60px' }} />
    </div>
  ),
});

// This simple wrapper component passes the server-fetched data to the client component.
export default function CelestialAlmanacLoader({ releases }: { releases: SanityGameRelease[] }) {
  return <CelestialAlmanac releases={releases} />;
}




















--- END OF FILE app/celestial-almanac/CelestialAlmanacLoader.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/Scene.tsx ---

// app/celestial-almanac/Scene.tsx

import React, { useRef, useMemo, Suspense, useCallback, useState } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Line, Text } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition, Placement, OrbitalSystemData } from './config';
import { ConstellationSettings } from '@/components/constellation/ConstellationControlPanel';

// Background starfield component (repurposed directly from Constellation)
const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
  const positions = useMemo(() => {
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
      pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
    }
    return pos;
  }, [count, radius]);
  return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
  const ref = useRef<THREE.Group>(null!);
  useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 60; });
  return (
    <group ref={ref}>
      <StarLayer count={Math.floor(1500 * countMultiplier)} radius={8} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
      <StarLayer count={Math.floor(1000 * countMultiplier)} radius={12} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
    </group>
  );
};

// Interactive game release "planet" component
const ReleasePlanet = ({ body, colors, onHover, onClick }: {
  body: OrbitalBodyData, colors: typeof THEME_CONFIG.dark,
  onHover: (body: OrbitalBodyData | null) => void,
  onClick: (body: OrbitalBodyData) => void
}) => {
  const ref = useRef<THREE.Mesh>(null!);
  const [isHovered, setIsHovered] = useState(false);

  useFrame(() => {
    ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.8 : 1), 0.2);
  });

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    document.body.style.cursor = 'pointer';
    setIsHovered(true);
    onHover(body);
  };

  const handlePointerOut = () => {
    document.body.style.cursor = 'auto';
    setIsHovered(false);
    onHover(null);
  };

  return (
    <mesh ref={ref} position={body.position} onClick={(e) => { e.stopPropagation(); onClick(body); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
      <sphereGeometry args={[0.04, 16, 16]} />
      <meshBasicMaterial color={isHovered ? colors.hoverStarColor : colors.starColor} toneMapped={false} />
    </mesh>
  );
};

// Main Scene Logic
function InteractiveLayer({ orbitalData, themeColors, setActiveStar, settings }: any) {
  const [hoveredBody, setHoveredBody] = useState<OrbitalBodyData | null>(null);
  const { camera, gl } = useThree();

  const handleBodyClick = useCallback((body: OrbitalBodyData) => {
    const canvasRect = gl.domElement.getBoundingClientRect();
    const vec = new THREE.Vector3().copy(body.position);
    vec.project(camera);
    const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
    const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
    const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
    let finalX = x;
    const cardWidth = 300; const padding = 20;
    if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
    if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
    setActiveStar(body, { top: y, left: finalX, placement });
  }, [camera, gl.domElement, setActiveStar]);

  const controlsRef = useRef<any>();
  useFrame(() => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = !hoveredBody;
      controlsRef.current.update();
    }
  });

  const { bloomIntensity } = settings;
  const isBloomEnabled = bloomIntensity > 0;

  return (
    <>
      {isBloomEnabled ? (
        <Selection>
          <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={0}>
            <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
          </EffectComposer>
          <Select enabled>
            <mesh>
              <sphereGeometry args={[0.5, 32, 32]} />
              <meshStandardMaterial color={themeColors.sunColor} emissive={themeColors.sunColor} emissiveIntensity={3} toneMapped={false} />
            </mesh>
          </Select>
        </Selection>
      ) : (
        <mesh>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshBasicMaterial color={themeColors.sunColor} toneMapped={false} />
        </mesh>
      )}

      {orbitalData.map((monthSystem: OrbitalSystemData) => {
        const circlePoints = useMemo(() => {
          const points = [];
          for (let i = 0; i <= 64; i++) {
            const angle = (i / 64) * Math.PI * 2;
            points.push(new THREE.Vector3(Math.cos(angle) * monthSystem.radius, Math.sin(angle) * monthSystem.radius, 0));
          }
          return points;
        }, [monthSystem.radius]);

        return (
          <group key={monthSystem.month}>
            <Line points={circlePoints} color={themeColors.orbitColor} lineWidth={1} />
            <Text
              position={[monthSystem.radius + 0.2, 0, 0]}
              color={themeColors.orbitColor}
              fontSize={0.15}
              anchorX="left"
              anchorY="middle"
            >
              {monthSystem.month}
            </Text>
            {monthSystem.bodies.map(body => (
              <ReleasePlanet key={body.id} body={body} colors={themeColors} onHover={setHoveredBody} onClick={handleBodyClick} />
            ))}
          </group>
        );
      })}

      <OrbitControls
        ref={controlsRef}
        enableZoom
        autoRotate={true}
        autoRotateSpeed={0.1}
        minDistance={3}
        maxDistance={15}
        zoomSpeed={0.5}
        enablePan={false}
      />
    </>
  );
}

export const Scene = ({ orbitalData, themeColors, setActiveStar, settings }: any) => {
  return (
    <Suspense fallback={null}>
      <color attach="background" args={[themeColors.bgColor]} />
      <ambientLight intensity={0.8} />
      <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
      <InteractiveLayer orbitalData={orbitalData} themeColors={themeColors} setActiveStar={setActiveStar} settings={settings} />
    </Suspense>
  );
};




















--- END OF FILE app/celestial-almanac/Scene.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

// app/celestial-almanac/StarPreviewCard.tsx

import React from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { OrbitalBodyData, ScreenPosition } from './config';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
  'PC': PCIcon,
  'PS5': PS5Icon,
  'Xbox': XboxIcon,
  'Switch': SwitchIcon,
};

export const StarPreviewCard = ({ orbitalBody, position, onClose }: {
    orbitalBody: OrbitalBodyData;
    position: ScreenPosition;
    onClose: () => void;
}) => {
  const { content } = orbitalBody;
  const imageUrl = content.mainImage?.url;
  const linkPath = '/games/' + content.slug;

  const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
  const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const date = new Date(content.releaseDate);
  const day = date.getUTCDate();
  const year = date.getUTCFullYear();
  const monthIndex = date.getUTCMonth();
  const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

  return (
    <motion.div
      onClick={(e) => e.stopPropagation()}
      initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }}
      transition={{ type: 'spring', damping: 25, stiffness: 300 }}
      style={{
        position: 'fixed', top: position.top, left: position.left,
        width: '300px',
        background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px',
        boxShadow: '0 10px 30px rgba(0,0,0,0.3)', overflow: 'hidden', zIndex: 10001,
        transform: position.placement === 'below'
          ? 'translate(-50%, 20px)'
          : 'translate(-50%, calc(-100% - 20px))',
        transformOrigin: position.placement === 'below' ? 'top center' : 'bottom center',
      }}
    >
      <motion.button
        onClick={onClose} whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
        style={{
          position: 'absolute', top: '10px', right: '10px', zIndex: 2, width: '32px', height: '32px',
          borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.3)', color: 'white',
          display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
        }} aria-label="إغلاق المعاينة"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
      </motion.button>

      <div style={{ position: 'relative', width: '100%', height: '150px' }}>
        {imageUrl ? (
          <Image src={imageUrl} alt={content.title} fill style={{ objectFit: 'cover' }} />
        ) : (
          <div style={{ width: '100%', height: '100%', backgroundColor: 'var(--border-color)' }} />
        )}
      </div>

      <div style={{ padding: '1.5rem', textAlign: 'right' }}>
        <p style={{ color: 'var(--text-secondary)', fontFamily: 'var(--font-main)', fontSize: '1.3rem', margin: '0 0 0.5rem 0' }}>
          الإصدار: {formattedDate}
        </p>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.7rem' }}>{content.title}</h3>
        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1.5rem', justifyContent: 'flex-end' }}>
          {(content.platforms || []).map(p => {
            const Icon = PlatformIcons[p];
            return Icon ? <Icon key={p} className="platform-icon" title={p} /> : null;
          })}
        </div>
        <Link href={linkPath} onClick={onClose} className="primary-button no-underline" style={{ display: 'block', textAlign: 'center' }}>
          عرض محور اللعبة
        </Link>
      </div>
    </motion.div>
  );
};




--- END OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/config.ts ---

// app/celestial-almanac/config.ts

import * as THREE from 'three';
import type { SanityGameRelease } from '@/types/sanity';

//  Type Definitions adapted for the Almanac
export type ContentObject = SanityGameRelease;

export type OrbitalBodyData = {
  id: string; // Sanity document _id
  position: THREE.Vector3;
  content: ContentObject;
};

export type OrbitalSystemData = {
  month: string;
  radius: number;
  bodies: OrbitalBodyData[];
};

export type Placement = 'above' | 'below';

export type ScreenPosition = {
  top: number;
  left: number;
  placement: Placement;
};

//  Theme-aware Color & Size Mapping (Retained from Constellation)
export const THEME_CONFIG = {
  dark: {
    sunColor: '#00E5FF', // As requested
    orbitColor: 'rgba(255, 255, 255, 0.2)',
    starColor: '#FFFFFF',
    hoverStarColor: '#00E5FF',
    pathColor: '#FFFFFF',
    bgStarColor: '#FFFFFF',
    bgColor: '#0A0B0F',
  },
  light: {
    sunColor: '#0891B2',
    orbitColor: 'rgba(0, 0, 0, 0.15)',
    starColor: '#1F2937',
    hoverStarColor: '#0891B2',
    pathColor: '#1F2937',
    bgStarColor: '#1F2937',
    bgColor: '#F0F2F5',
  },
};




















--- END OF FILE app/celestial-almanac/config.ts ---

================================================================================

--- START OF FILE app/celestial-almanac/index.tsx ---

// app/celestial-almanac/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from '@/components/constellation/ConstellationControlPanel';
import type { SanityGameRelease } from '@/types/sanity';
import styles from '@/components/constellation/ConstellationControlPanel.module.css';

const CelestialGearIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
    <circle cx="12" cy="12" r="8"></circle>
    <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
  </svg>
);

export default function CelestialAlmanac({ releases }: { releases: SanityGameRelease[] }) {
  const [isHydrated, setIsHydrated] = useState(false);
  useEffect(() => { setIsHydrated(true); }, []);

  const [isFullscreen, setIsFullscreen] = useState(false);

  useEffect(() => {
      document.body.classList.add('constellation-active');
      if (isFullscreen) {
          document.body.classList.add('fullscreen-active');
      } else {
          document.body.classList.remove('fullscreen-active');
      }
      return () => {
          document.body.classList.remove('constellation-active');
          document.body.classList.remove('fullscreen-active');
      };
  }, [isFullscreen]);

  const { resolvedTheme } = useTheme();
  const [activeBody, setActiveBody] = useState<OrbitalBodyData | null>(null);
  const [activeBodyPosition, setActiveBodyPosition] = useState<ScreenPosition | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
    'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1 },
    'متوازن': { activePreset: 'متوازن', starCountMultiplier: 1.0, bloomIntensity: 1.1, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
    'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.8, alwaysShowOrbits: false, flawlessPathThickness: 2.0 },
  }), []);

  const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['متوازن']);
  const lastValidBloom = useRef(settings.bloomIntensity);

  useEffect(() => { if (settings.bloomIntensity > 0) lastValidBloom.current = settings.bloomIntensity; }, [settings.bloomIntensity]);
  useEffect(() => { if (resolvedTheme === 'light') { if (settings.bloomIntensity > 0) setSettings(s => ({ ...s, bloomIntensity: 0, activePreset: 'custom' })); } else { setSettings(s => ({ ...s, bloomIntensity: lastValidBloom.current })); } }, [resolvedTheme]);

  const handlePresetChange = (preset: Preset) => { let newSettings = PRESETS[preset]; if (resolvedTheme === 'light') newSettings.bloomIntensity = 0; setSettings(newSettings); };

  const isDark = resolvedTheme === 'dark';
  const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;
  
  const orbitalData = useMemo(() => {
    if (!isHydrated || releases.length === 0) return [];
    
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    const releasesByMonth = releases.reduce((acc, release) => {
        const date = new Date(release.releaseDate);
        const year = date.getUTCFullYear();
        const monthIndex = date.getUTCMonth();
        const monthKey = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;
        
        if (!acc[monthKey]) acc[monthKey] = [];
        acc[monthKey].push(release);
        return acc;
    }, {} as Record<string, SanityGameRelease[]>);
    
    const sortedMonths = Object.keys(releasesByMonth).sort((a, b) => {
        const dateA = new Date(a.split(' - ')[1]);
        const dateB = new Date(b.split(' - ')[1]);
        return dateA.getTime() - dateB.getTime();
    });

    const startRadius = 2; const radiusIncrement = 0.8;
    return sortedMonths.map((month, index) => {
      const monthReleases = releasesByMonth[month]; const radius = startRadius + index * radiusIncrement;
      const bodies = monthReleases.map((release, bodyIndex) => {
        const angle = (bodyIndex / monthReleases.length) * Math.PI * 2;
        const position = new THREE.Vector3( radius * Math.cos(angle), radius * Math.sin(angle), (Math.random() - 0.5) * 0.1 );
        return { id: release._id, position, content: release };
      });
      return { month, radius, bodies };
    });
  }, [isHydrated, releases]);

  const handleSetActiveBody = useCallback((body: OrbitalBodyData, position: ScreenPosition) => { setActiveBody(body); setActiveBodyPosition(position); }, []);
  const handleClosePreview = useCallback(() => { setActiveBody(null); setActiveBodyPosition(null); }, []);

  if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

  return (
    <>
      <AnimatePresence>
        {activeBody && activeBodyPosition && (
          <motion.div style={{ position: 'fixed', inset: 0, zIndex: 10000 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
            <StarPreviewCard orbitalBody={activeBody} position={activeBodyPosition} onClose={handleClosePreview} />
          </motion.div>
        )}
        {isPanelOpen && <ConstellationControlPanel settings={settings} setSettings={setSettings} onClose={() => setIsPanelOpen(false)} onPresetChange={handlePresetChange} isFullscreen={isFullscreen} onToggleFullscreen={() => setIsFullscreen(!isFullscreen)} />}
      </AnimatePresence>
      <div style={{ position: 'relative', width: '100%', height: 'calc(100vh - var(--nav-height-scrolled))' }}>
        <motion.button className={styles.settingsButton} onClick={() => setIsPanelOpen(true)} title="فتح إعدادات التقويم" whileHover={{ scale: 1.1, rotate: 90 }} transition={{ type: 'spring', stiffness: 500, damping: 20 }} whileTap={{ scale: 0.9 }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.5 } }}>
          <CelestialGearIcon />
        </motion.button>
        <Canvas camera={{ position: [0, 0, 8], fov: 60 }}>
          <Scene settings={settings} orbitalData={orbitalData} themeColors={themeColors} setActiveStar={handleSetActiveBody} />
        </Canvas>
        {orbitalData.length === 0 && (
          <div style={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', textAlign: 'center', pointerEvents: 'none', padding: '2rem' }}>
            <motion.h1 className="page-title" style={{ fontSize: '6rem' }} initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.2, ease: 'easeOut' }}>
              التقويم يرسم...
            </motion.h1>
            <motion.p style={{ maxWidth: '600px', fontSize: '2rem', color: 'var(--text-secondary)' }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.4, ease: 'easeOut' }}>
              يتم جمع بيانات الإصدار. ستظهر الخريطة السماوية قريبًا.
            </motion.p>
          </div>
        )}
      </div>
    </>
  );
}




--- END OF FILE app/celestial-almanac/index.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/page.tsx ---

// app/celestial-almanac/page.tsx
import { client } from '@/lib/sanity.client';
import { allReleasesQuery } from '@/lib/sanity.queries';
import type { SanityGameRelease } from '@/types/sanity';
import CelestialAlmanacLoader from './CelestialAlmanacLoader';
import { unstable_noStore as noStore } from 'next/cache';

export const revalidate = 3600;

// NOTE: The CelestialAlmanacLoader already uses dynamic import internally.
// This file structure is correct and requires no changes. It already isolates the heavy component.
export default async function CelestialAlmanacPage() {
  noStore();

  const releases: SanityGameRelease[] = await client.fetch(allReleasesQuery);
  const sanitizedReleases = (releases || []).filter(item =>
    item?.mainImage?.url && item.releaseDate && item.title && item.slug
  );

  return (
    <div style={{ paddingTop: 'var(--nav-height-scrolled)' }}>
      <CelestialAlmanacLoader releases={sanitizedReleases} />
    </div>
  );
}










--- END OF FILE app/celestial-almanac/page.tsx ---

================================================================================

--- START OF FILE app/constellation/ConstellationPageClient.tsx ---

// app/constellation/ConstellationPageClient.tsx
'use client';

import dynamic from 'next/dynamic';

const ConstellationLoader = dynamic(() => import('@/components/constellation/ConstellationLoader'), {
    ssr: false,
    loading: () => (
        <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <div className="spinner" style={{ width: '60px', height: '60px' }} />
        </div>
    ),
});

export default function ConstellationPageClient() {
    return (
        <div style={{ paddingTop: 'var(--nav-height-scrolled)' }}>
            <ConstellationLoader />
        </div>
    );
}




--- END OF FILE app/constellation/ConstellationPageClient.tsx ---

================================================================================

--- START OF FILE app/constellation/page.tsx ---

// app/constellation/page.tsx
import ConstellationPageClient from './ConstellationPageClient';

// This is a Server Component. Its only job is to render the client boundary.
export default function ConstellationPage() {
    return <ConstellationPageClient />;
}




--- END OF FILE app/constellation/page.tsx ---

================================================================================

--- START OF FILE app/creators/[username]/page.tsx ---

// app/creators/[username]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByCreatorListQuery } from '@/lib/sanity.queries';
import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import Link from 'next/link';

export default async function CreatorHubPage({ params }: { params: { username: string } }) {
    const username = decodeURIComponent(params.username);

    const user = await prisma.user.findUnique({
        where: { username: username },
        select: { id: true, name: true, username: true },
    });

    if (!user) {
        notFound();
    }

    // Find all Sanity creator documents linked to this Prisma user ID
    const creatorDocs = await client.fetch< { _id: string }[] >(
        `*[_type in ["author", "reviewer", "reporter", "designer"] && prismaUserId == $prismaUserId]{_id}`,
        { prismaUserId: user.id }
    );

    // If the user has no corresponding creator documents in Sanity, they have no content.
    if (!creatorDocs || creatorDocs.length === 0) {
        return (
             <div className="container page-container">
                <h1 className="page-title">{user.name || 'Creator'}</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم ينشر هذا المستخدم أي محتوى عام بعد.</p>
                <div style={{textAlign: 'center', marginTop: '2rem'}}>
                    <Link href={`/profile/${user.username}`} className="primary-button">عرض الملف الشخصي للمستخدم</Link>
                </div>
            </div>
        );
    }
    
    // Extract the _id's into an array
    const creatorIds = creatorDocs.map(doc => doc._id);
    
    // Fetch all content that references any of these creator IDs
    const allItems = await client.fetch(allContentByCreatorListQuery, { 
        creatorIds: creatorIds
    });

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={user.name || 'Creator'}
            hubType="أعمال"
            headerAction={
                <Link href={`/profile/${user.username}`} className="outline-button no-underline" style={{ backgroundColor: 'color-mix(in srgb, var(--bg-secondary) 80%, transparent)', backdropFilter: 'blur(4px)' }}>
                    → عرض الملف الشخصي
                </Link>
            }
        />
    );
}




--- END OF FILE app/creators/[username]/page.tsx ---

================================================================================

--- START OF FILE app/games/[slug]/page.tsx ---

// app/games/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByGameListQuery } from '@/lib/sanity.queries'; // Use LEAN query
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';

export default async function GameHubPage({ params }: { params: { slug: string } }) {
    const gameSlug = decodeURIComponent(params.slug);

    const gameMeta = await client.fetch(
        `*[_type == "game" && slug.current == $slug][0]{title}`,
        { slug: gameSlug }
    );

    if (!gameMeta) {
        notFound();
    }

    // MODIFIED: Using lean query for initial content load
    const allItems = await client.fetch(allContentByGameListQuery, { slug: gameSlug });

    return (
        <HubPageClient
            initialItems={allItems}
            hubTitle={gameMeta.title}
            hubType="اللعبة"
        />
    );
}




--- END OF FILE app/games/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/news/NewsPage.module.css ---

/* app/news/NewsPage.module.css */

.chronosFeedLayout {
  display: grid;
  grid-template-columns: 2.5fr 1fr;
  gap: 4rem;
  margin-top: 3rem;
}

.chronosFeedSidebar {
  position: sticky;
  top: calc(var(--nav-height-scrolled) + 2rem);
  align-self: start;
}

@media (max-width: 1024px) {
  .chronosFeedLayout {
    grid-template-columns: 1fr;
  }
}

/* Neural Cascade Grid */
.neuralCascadeGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 3rem;
}
.neuralCascadeGrid > div.leadStoryItem {
  grid-column: span 2;
}

@media (max-width: 768px) {
  .neuralCascadeGrid {
    grid-template-columns: 1fr;
  }
  .neuralCascadeGrid > div.leadStoryItem {
    grid-column: span 1;
  }
}

/* Base Card Overrides for Chronos Feed */
.newsCard {
  border-radius: 12px;
}
.leadNewsCard {
  border-radius: 12px;
}
.leadNewsCard .newsCardImageContainer {
  height: 220px;
}
.leadNewsCard .newsCardContent {
  padding: 1.5rem 2.5rem;
}
.leadNewsCard h3 {
  font-size: 2.5rem;
  line-height: 1.2;
}

/* News Filter "Command Bar" */
.newsFilterBar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  padding: 1rem 2rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  flex-wrap: wrap;
  gap: 1rem;
}
.categoryTabs {
  display: flex;
  gap: 1.5rem;
}
.categoryTab {
  position: relative;
  background: none;
  border: none;
  cursor: pointer;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-secondary);
  padding: 0.5rem 0;
  transition: color 0.2s ease;
}
.categoryTab:hover {
  color: var(--text-primary);
}
.categoryTab.active {
  color: var(--accent);
}
.categoryUnderline {
  position: absolute;
  bottom: -0.5rem;
  right: 0;
  left: 0;
  height: 2px;
  background: var(--accent);
}
.filterControls {
  display: flex;
  gap: 1rem;
  align-items: center;
}

/* Terminal Ticker Sidebar */
.terminalTickerContainer {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 2rem;
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
}
.terminalTickerTitle {
  font-size: 1.4rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 2px;
  color: var(--text-secondary);
  margin: 0 0 1.5rem 0;
  padding-bottom: 1.5rem;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
}
.terminalTickerContent {
  height: 120px;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.terminalTickerCategory {
  color: var(--accent);
  font-size: 1.3rem;
  font-weight: 700;
  margin: 0 0 0.5rem 0;
}
.terminalTickerHeadline {
  color: var(--text-primary);
  font-size: 1.6rem;
  line-height: 1.5;
  margin: 0;
  min-height: 72px; /* Prevents layout shift */
}







--- END OF FILE app/news/NewsPage.module.css ---

================================================================================

--- START OF FILE app/news/NewsPageClient.tsx ---

// app/news/NewsPageClient.tsx
'use client';

import { useState, useMemo, useCallback, useRef } from 'react';
import { useSearchParams, useRouter, usePathname } from 'next/navigation';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import AnimatedGridBackground from '@/components/AnimatedGridBackground';
import NewsFilterBar from '@/components/filters/NewsFilterBar';
import TerminalTicker from '@/components/TerminalTicker';
import NewsCard from '@/components/NewsCard';
import { useEngagementScores } from '@/hooks/useEngagementScores'; // <-- RE-INTRODUCE HOOK
import { adaptToCardProps } from '@/lib/adapters';
import styles from './NewsPage.module.css';

type SortOption = 'latest' | 'viral';
type NewsTypeFilter = 'الكل' | 'Internal' | 'External';

export default function NewsPageClient({
  allNews, latestHeadlines, allGames, allTags
}: {
  allNews: SanityNews[]; latestHeadlines: SanityNews[]; allGames: SanityGame[]; allTags: SanityTag[];
}) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const engagementScores = useEngagementScores(); // <-- FETCH SCORES ON CLIENT
  
  const [activeCategory, setActiveCategory] = useState<string>(() => searchParams.get('category') || 'الكل');
  const [activeSort, setActiveSort] = useState<SortOption>(() => (searchParams.get('sort') as SortOption) || 'latest');
  const [newsTypeFilter, setNewsTypeFilter] = useState<NewsTypeFilter>(() => (searchParams.get('type') as NewsTypeFilter) || 'الكل');
  const [selectedGame, setSelectedGame] = useState<SanityGame | null>(() => {
    const gameSlug = searchParams.get('game');
    return gameSlug ? allGames.find(g => g.slug === gameSlug) || null : null;
  });
  const [selectedTags, setSelectedTags] = useState<SanityTag[]>(() => {
    const tagSlugs = searchParams.get('tags')?.split(',').filter(Boolean) || [];
    return tagSlugs.map(slug => allTags.find(t => t.slug === slug)).filter((t): t is SanityTag => !!t);
  });

  const contentRef = useRef(null);
  const isInView = useInView(contentRef, { once: true, amount: 0.1 });

  const allCategories = useMemo(() => ['الكل', ...Array.from(new Set(allNews.map(s => s.category)))], [allNews]);

  const updateURL = useCallback((sort: SortOption, category: string, type: NewsTypeFilter, game: SanityGame | null, tags: SanityTag[]) => {
    const params = new URLSearchParams();
    if (sort !== 'latest') params.set('sort', sort);
    if (category !== 'الكل') params.set('category', category);
    if (type !== 'الكل') params.set('type', type);
    if (game) params.set('game', game.slug);
    if (tags.length > 0) params.set('tags', tags.map(t => t.slug).join(','));
    router.push(`${pathname}?${params.toString()}`, { scroll: false });
  }, [pathname, router]);

  const handleSortChange = (sort: SortOption) => { setActiveSort(sort); updateURL(sort, activeCategory, newsTypeFilter, selectedGame, selectedTags); };
  const handleTypeChange = (type: NewsTypeFilter) => { setNewsTypeFilter(type); updateURL(activeSort, activeCategory, type, selectedGame, selectedTags); };
  const handleCategoryChange = (cat: string) => { setActiveCategory(cat); updateURL(activeSort, cat, newsTypeFilter, selectedGame, selectedTags); };
  const handleGameSelect = (game: SanityGame | null) => { setSelectedGame(game); updateURL(activeSort, activeCategory, newsTypeFilter, game, selectedTags); };
  const handleTagToggle = (tag: SanityTag) => { const newTags = selectedTags.some(t => t._id === tag._id) ? selectedTags.filter(t => t._id !== tag._id) : [...selectedTags, tag]; setSelectedTags(newTags); updateURL(activeSort, activeCategory, newsTypeFilter, selectedGame, newTags); };
  const handleClearAll = () => { setSelectedGame(null); setSelectedTags([]); updateURL(activeSort, activeCategory, newsTypeFilter, null, []); };

  const filteredNews = useMemo(() => {
    const scoresMap = new Map(engagementScores.map(s => [s.id, s.engagementScore]));
    let reviews = allNews;
    if (newsTypeFilter === 'Internal') { reviews = reviews.filter((r: any) => r.gameRef); }
    else if (newsTypeFilter === 'External') { reviews = reviews.filter((r: any) => !r.gameRef); }
    if (activeCategory !== 'الكل') { reviews = reviews.filter((r: any) => r.category === activeCategory); }
    if (selectedGame) { reviews = reviews.filter((r: any) => r.gameRef === selectedGame._id); }
    if (selectedTags.length > 0) { const selectedTagIds = new Set(selectedTags.map(t => t._id)); reviews = reviews.filter((r: any) => (r.tags || []).some((tagRef: any) => tagRef && selectedTagIds.has(tagRef._id))); }
    if (activeSort === 'viral') { reviews.sort((a, b) => (scoresMap.get(b.legacyId) || 0) - (scoresMap.get(a.legacyId) || 0)); }
    else { reviews.sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()); }
    return reviews.map(adaptToCardProps).filter(Boolean);
  }, [allNews, activeCategory, selectedGame, selectedTags, activeSort, engagementScores, newsTypeFilter]);

  const containerVariants = { hidden: { opacity: 0, y: 40 }, visible: { opacity: 1, y: 0, transition: { duration: 0.7, ease: [0.22, 1, 0.36, 1] } } };

  return (
    <>
      <AnimatedGridBackground />
      <div className="container page-container">
        <h1 className="page-title">موجز الأنباء</h1>
        <motion.div ref={contentRef} variants={containerVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'}>
          <NewsFilterBar allCategories={allCategories} activeCategory={activeCategory} onCategoryChange={handleCategoryChange} allGames={allGames} selectedGame={selectedGame} onGameSelect={handleGameSelect} allTags={allTags} selectedTags={selectedTags} onTagToggle={handleTagToggle} onClearAll={handleClearAll} activeSort={activeSort} onSortChange={handleSortChange} newsTypeFilter={newsTypeFilter} onNewsTypeChange={handleTypeChange} />
        </motion.div>
        <motion.div className={styles.chronosFeedLayout} initial="hidden" animate={isInView ? 'visible' : 'hidden'} transition={{ delay: 0.15 }}>
          <main className="chronos-feed-main">
            <motion.div layout className={styles.neuralCascadeGrid}>
              <AnimatePresence>
                {filteredNews.map((item, index) => (
                  <motion.div key={item.id} layout className={index === 0 ? styles.leadStoryItem : ''} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.5 }} transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
                    <NewsCard item={item} isLead={index === 0} />
                  </motion.div>
                ))}
              </AnimatePresence>
            </motion.div>
            {filteredNews.length === 0 && ( <p style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0'}}>لا توجد أخبار تطابق ما اخترت.</p> )}
          </main>
          <aside className={styles.chronosFeedSidebar}>
            <TerminalTicker headlines={latestHeadlines} />
          </aside>
        </motion.div>
      </div>
    </>
  );
}




--- END OF FILE app/news/NewsPageClient.tsx ---

================================================================================

--- START OF FILE app/news/page.tsx ---

// app/news/page.tsx
import { client } from '@/lib/sanity.client';
import { allNewsListQuery } from '@/lib/sanity.queries'; // Use LEAN query
import { groq } from 'next-sanity';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import NewsPageClient from './NewsPageClient';

export const revalidate = 60;

// Fetch all filter options (unchanged)
const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
// THE FIX: Only fetch tags relevant to news.
const allTagsQuery = groq`*[_type == "tag" && category == "News"] | order(title asc) {_id, title, "slug": slug.current}`;

export default async function NewsPage() {
  // REVERTED: Fetch only fast Sanity data.
  const [allNews, allGames, allTags]: [SanityNews[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(allNewsListQuery),
    client.fetch(allGamesQuery),
    client.fetch(allTagsQuery),
  ]);

  if (!allNews || allNews.length === 0) {
    return (
      <div className="container page-container">
        <h1 className="page-title">موجز كرونوس</h1>
        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>أرشيف الأخبار فارغ حاليًا. يرجى العودة لاحقًا.</p>
      </div>
    );
  }
  
  const latestHeadlines = allNews.slice(0, 7);

  // Pass fast data to client. Client will fetch slow engagement data.
  return (
    <NewsPageClient
      allNews={allNews}
      latestHeadlines={latestHeadlines}
      allGames={allGames}
      allTags={allTags}
    />
  );
}




--- END OF FILE app/news/page.tsx ---

================================================================================

--- START OF FILE app/news/[slug]/NewsPage.module.css ---

/* app/news/[slug]/NewsPage.module.css */

.newsHeroImage {
  position: relative;
  width: 100%;
  height: 450px;
  margin-bottom: 3rem;
  border-radius: 12px;
  overflow: hidden;
}

.articleBody {
  /* You can add specific article body styles here if needed later */
}

/* --- DEFINITIVE FIX: LAYOUT STYLES ADDED --- */
.reviewLayout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
}
@media (min-width: 1024px) {
  .reviewLayout {
    grid-template-columns: 2fr 1fr;
  }
  /* --- THE FIX --- */
  .reviewLayout > main {
    min-width: 0;
  }
}

.reviewSidebar {
    margin-top: 3rem;
}

.relatedArticlesGrid {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}




--- END OF FILE app/news/[slug]/NewsPage.module.css ---

================================================================================

--- START OF FILE app/news/[slug]/NewsPageClient.tsx ---

// app/news/[slug]/NewsPageClient.tsx
'use client';

import type { SanityNews } from '@/types/sanity';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { adaptToCardProps } from '@/lib/adapters';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

import TagLinks from '@/components/TagLinks';
import ContentActionBar from '@/components/ContentActionBar';
import PortableTextComponent from '@/components/PortableTextComponent';
import { ContentBlock } from '@/components/ContentBlock';
import ArticleCard from '@/components/ArticleCard';
import CreatorCredit from '@/components/CreatorCredit';
import styles from './NewsPage.module.css';

export default function NewsPageClient({ newsItem, children }: { newsItem: SanityNews & { relatedNews?: any[] }; children: React.ReactNode }) {
    const layoutIdPrefix = useLayoutIdStore((state) => state.prefix) || 'news-grid';

    if (!newsItem) return null;

    const uniqueRelatedNews = newsItem.relatedNews
        ? Array.from(new Map(newsItem.relatedNews.map(item => [item._id, item])).values())
        : [];
        
    const adaptedRelatedNews = (uniqueRelatedNews || []).map(adaptToCardProps).filter(Boolean);

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const date = new Date(newsItem.publishedAt);
    const day = date.getDate();
    const year = date.getFullYear();
    const monthIndex = date.getMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

    return (
        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.5 }}>
            <motion.div layoutId={`${layoutIdPrefix}-card-container-${newsItem.legacyId}`}>
                <motion.div className={styles.newsHeroImage} layoutId={`${layoutIdPrefix}-card-image-${newsItem.legacyId}`}><Image src={newsItem.mainImage.url} alt={newsItem.title} fill style={{ objectFit: 'cover' }} priority placeholder="blur" blurDataURL={newsItem.mainImage.blurDataURL} /></motion.div>
            </motion.div>
            <div className="container page-container" style={{ paddingTop: '0' }}>
                <div className={styles.reviewLayout}>
                    <main>
                        <p className="news-card-category" style={{ textAlign: 'right', margin: '1.5rem 0' }}>{newsItem.category}</p>
                        <motion.h1 className="page-title" layoutId={`${layoutIdPrefix}-card-title-${newsItem.legacyId}`} style={{ textAlign: 'right', marginTop: 0 }}>{newsItem.title}</motion.h1>
                        
                        {/* --- UNIFIED METADATA BLOCK START --- */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '3rem' }}>
                            {/* RIGHT SIDE (Creator/Date) */}
                            <div style={{ color: 'var(--text-secondary)', textAlign: 'right', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                <CreatorCredit label="بقلم" creators={newsItem.reporters} />
                                <CreatorCredit label="تصميم" creators={newsItem.designers} />
                                <p style={{ margin: 0, fontSize: '1.5rem', color: 'var(--text-secondary)' }}>نُشر في: {formattedDate}</p>
                            </div>

                            {/* LEFT SIDE (Actions) */}
                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '1.5rem' }}>
                                <ContentActionBar contentId={newsItem.legacyId} contentType="خبر" contentSlug={newsItem.slug} />
                            </div>
                        </div>
                        {/* --- UNIFIED METADATA BLOCK END --- */}

                        <div className={styles.articleBody}><PortableTextComponent content={newsItem.content || []} /></div>
                        <div style={{ marginTop: '4rem', paddingTop: '2rem', borderTop: '1px solid var(--border-color)' }}><TagLinks tags={(newsItem.tags || []).map(t => t.title)} /></div>
                    </main>
                    <aside className={styles.reviewSidebar}>
                        <ContentBlock title="قد يروق لك"><div className={styles.relatedArticlesGrid}>{adaptedRelatedNews.map(related => ( <ArticleCard key={related.id} article={related} layoutIdPrefix="related-news" /> ))}</div></ContentBlock>
                    </aside>
                </div>
            </div>
            <div className="container" style={{ paddingBottom: '6rem' }}>
                <div className="comments-block">{children}</div>
            </div>
        </motion.div>
    );
}




--- END OF FILE app/news/[slug]/NewsPageClient.tsx ---

================================================================================

--- START OF FILE app/news/[slug]/page.tsx ---

// app/news/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { newsBySlugQuery, latestNewsFallbackQuery } from '@/lib/sanity.queries';
import type { SanityNews } from '@/types/sanity';
import { notFound } from 'next/navigation';
import NewsPageClient from './NewsPageClient';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import CommentSection from '@/components/comments/CommentSection';
import { Suspense } from 'react';

export const revalidate = 60;

// Enrich creator with prisma username, image, and bio
async function enrichCreator(creator: any) {
    if (!creator || !creator.prismaUserId) return creator;
    const user = await prisma.user.findUnique({
        where: { id: creator.prismaUserId },
        select: { username: true, image: true, bio: true }
    });
    return { 
        ...creator, 
        username: user?.username || null,
        image: user?.image || null,
        bio: user?.bio || null,
    };
}

export async function generateStaticParams() {
    const newsItems = await client.fetch<any[]>(`*[_type == "خبر"]{ "slug": slug.current }`);
    return newsItems.filter(item => item.slug).map(item => ({ slug: item.slug }));
}

async function Comments({ slug }: { slug: string }) {
    const [comments, session] = await Promise.all([
        prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } }, replies: { take: 2, include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } } }, orderBy: { createdAt: 'asc' } } },
            orderBy: { createdAt: 'desc' },
        }),
        getServerSession(authOptions)
    ]);
    return <CommentSection slug={slug} initialComments={comments} session={session} />;
}

export default async function NewsArticlePage({ params }: { params: { slug: string } }) {
    const resolvedParams = await params;
    const slug = resolvedParams.slug;
    
    let newsItem: SanityNews & { relatedNews?: any[] } = await client.fetch(newsBySlugQuery, { slug });

    if (!newsItem) {
        notFound();
    }
    
    // Enrich creator data
    if (newsItem.reporters) {
        newsItem.reporters = await Promise.all(newsItem.reporters.map(enrichCreator));
    }
    if (newsItem.designers) {
        newsItem.designers = await Promise.all(newsItem.designers.map(enrichCreator));
    }

    if (!newsItem.relatedNews || newsItem.relatedNews.length === 0) {
        const fallbackNews = await client.fetch(latestNewsFallbackQuery, { 
            currentId: newsItem._id
        });
        newsItem.relatedNews = fallbackNews;
    }

    return (
        <NewsPageClient newsItem={newsItem}>
            <Suspense fallback={<div className="spinner" style={{margin: '8rem auto'}} />}>
                {/* @ts-expect-error Async Server Component */}
                <Comments slug={slug} />
            </Suspense>
        </NewsPageClient>
    );
}




--- END OF FILE app/news/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/profile/ProfilePage.module.css ---

/* app/profile/ProfilePage.module.css */
.profileGrid{display:grid;grid-template-columns:1fr;gap:5rem}
@media (min-width:1024px){.profileGrid{grid-template-columns:300px 1fr}}
.profileAvatar{border-radius:50%;border:4px solid var(--border-color);margin:0 auto 2rem;transition:all .3s ease-out}
.profileAvatar:hover{transform:scale(1.05);filter:drop-shadow(0 0 20px color-mix(in srgb,var(--accent) 50%,transparent))}
.profileName{font-size:3.2rem;font-family:var(--font-main);margin:0;text-align:center}
.profileMeta{font-size:1.6rem;color:var(--text-secondary);margin-top:.5rem;text-align:center}
.profileMain{border-top:1px solid var(--border-color);padding-top:5rem}
@media (min-width:1024px){.profileMain{border-top:none;padding-top:0;border-right:1px solid var(--border-color);border-left: none; padding-right:5rem; padding-left: 0;}}
.profileSection{margin-top:6rem}
.profileSection:first-child{margin-top:0}
.profileSectionTitle{font-size:2.8rem;font-family:var(--font-main);margin-bottom:2rem;border-bottom:2px solid var(--accent);padding-bottom:1rem;display:inline-block}
.badgeGrid{display:flex;flex-wrap:wrap;gap:1.5rem}
.badgeItem{display:flex;align-items:center;gap:1rem;background-color:var(--bg-secondary);padding:1rem 1.5rem;border-radius:8px;border:1px solid var(--border-color);transition:all .2s ease-out}
.badgeItem:hover{transform:translateY(-2px);border-color:var(--accent)}
.badgeIcon{width:24px;height:24px;color:var(--accent)}
@keyframes glint{0%,100%{transform:scale(1)}50%{transform:scale(1.2) rotate(10deg);filter:brightness(1.5)}}
.badgeItem:hover .badgeIconFOUNDER{animation:glint .7s ease-in-out}




--- END OF FILE app/profile/ProfilePage.module.css ---

================================================================================

--- START OF FILE app/profile/page.tsx ---

// app/profile/page.tsx
export const maxDuration = 60;
import { getServerSession } from 'next-auth';
import { authOptions } from '../api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import ProfileEditForm from '@/components/ProfileEditForm';
import PasswordChangeForm from '@/components/PasswordChangeForm';
import { ContentBlock } from '@/components/ContentBlock';

export default async function ProfilePage() {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) { redirect('/api/auth/signin'); }
    
    // Fetch user and check if they have a password set (i.e., not an OAuth user)
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id }, 
        select: { password: true, id: true, name: true, email: true, username: true, image: true, createdAt: true, bio: true, twitterHandle: true, instagramHandle: true, age: true, country: true, agePublic: true, countryPublic: true }
    });

    if (!user) { redirect('/api/auth/signin'); }

    const hasPasswordAuth = !!user.password;

    return (
        <div className="container page-container">
            <h1 className="page-title">إعدادات الحساب</h1>
            <ContentBlock title="تحرير بياناتك">
                <ProfileEditForm user={user} />
            </ContentBlock>
            
            {hasPasswordAuth && (
                <ContentBlock title="تغيير كلمة السر">
                    <PasswordChangeForm />
                </ContentBlock>
            )}
        </div>
    );
}




--- END OF FILE app/profile/page.tsx ---

================================================================================

--- START OF FILE app/profile/bookmarks/page.tsx ---

// app/profile/bookmarks/page.tsx
import BookmarksGrid from "@/components/BookmarksGrid";
import { getAuthenticatedSession } from "@/lib/auth";
import { client } from "@/lib/sanity.client";
import { contentByIdsQuery } from "@/lib/sanity.queries";
import prisma from "@/lib/prisma";
import { redirect } from "next/navigation";

async function getBookmarkedContent() {
    try {
        const session = await getAuthenticatedSession();

        // THE FIX: Query the 'engagement' table and filter by type 'BOOKMARK'
        const bookmarks = await prisma.engagement.findMany({
            where: { userId: session.user.id, type: 'BOOKMARK' },
            select: { contentId: true, contentType: true },
            orderBy: { createdAt: 'desc' }
        });
        
        const ids = bookmarks.map(b => b.contentId);
        if (ids.length === 0) return [];
        
        const content = await client.fetch(contentByIdsQuery, { ids });
        return content;
    } catch (error) {
        // This catch block is what was causing the redirect.
        redirect('/');
    }
}

export default async function BookmarksPage() {
    const bookmarkedItems = await getBookmarkedContent();

    return (
        <div className="container page-container">
            <h1 className="page-title">محفوظاتك</h1>
            <BookmarksGrid initialItems={bookmarkedItems} />
        </div>
    );
}




--- END OF FILE app/profile/bookmarks/page.tsx ---

================================================================================

--- START OF FILE app/profile/[username]/page.tsx ---

// app/profile/[username]/page.tsx

import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import Image from 'next/image';
import { getBadgesForUser } from '@/lib/badges.tsx';
import Link from 'next/link';
import styles from '../ProfilePage.module.css';

function hasCreatorRole(userRoles: string[]): boolean {
    return userRoles.some(role => ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
}

function getCommentLink(comment: { contentSlug: string, content: string }) {
    const path = comment.contentSlug.startsWith('review-') ? 'reviews' : comment.contentSlug.startsWith('article-') ? 'articles' : 'خبر';
    return ( <Link href={`/${path}/${comment.contentSlug}`} className="author-link">{comment.content.slice(0, 30)}...</Link> );
}

export default async function PublicProfilePage({ params }: { params: { username: string } }) {
    const resolvedParams = await params;
    const username = decodeURIComponent(resolvedParams.username);

    const user = await prisma.user.findUnique({
        where: { username: username },
        include: {
            roles: { select: { name: true } },
            _count: { select: { comments: true } },
            comments: { orderBy: { createdAt: 'desc' }, take: 5 },
        },
    });

    if (!user) { notFound(); }
    
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const joinDate = new Date(user.createdAt);
    const year = joinDate.getFullYear();
    const monthIndex = joinDate.getMonth();
    const formattedJoinDate = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;


    const userRoles = user.roles.map(r => r.name);
    const earnedBadges = getBadgesForUser({ createdAt: user.createdAt, _count: user._count, roles: userRoles });
    const avatarSrc = user.image || '/default-avatar.svg';

    return (
        <div className="container page-container">
            <div className={styles.profileGrid}>
                <aside className={styles.profileSidebar}>
                    <Image src={avatarSrc} alt={user.name || 'صورة المستخدم'} width={150} height={150} className={styles.profileAvatar} priority />
                    <h1 className={styles.profileName}>{user.name}</h1>
                    {user.username && <p className={styles.profileMeta} style={{color: 'var(--accent)'}}>@{user.username}</p>}
                    <p className={styles.profileMeta}>عضو منذ {formattedJoinDate}</p>
                    
                    {user.username && hasCreatorRole(userRoles) && (
                         <Link href={`/creators/${user.username}`} className="primary-button" style={{marginTop: '2rem', display: 'block', textAlign: 'center'}}>
                            عرض كل الأعمال
                        </Link>
                    )}
                </aside>

                <main className={styles.profileMain}>
                    {user.bio && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>حول</h2> <p style={{ fontSize: '1.8rem', lineHeight: 1.7 }}>{user.bio}</p> </section> )}
                    {earnedBadges.length > 0 && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>الأوسمة</h2> <div className={styles.badgeGrid}> {earnedBadges.map(badge => ( <div key={badge.id} title={badge.description} className={styles.badgeItem}> <badge.Icon className={`${styles.badgeIcon} ${styles[`badgeIcon${badge.id}`]}`} /> <span>{badge.name}</span> </div> ))} </div> </section> )}
                    <section className={styles.profileSection}>
                        <h2 className={styles.profileSectionTitle}>النشاط الأخير</h2>
                        {user.comments.length > 0 ? (
                            <ul style={{listStyle: 'none', padding: 0, display: 'flex', flexDirection: 'column', gap: '2rem'}}>
                                {user.comments.map(comment => (
                                    <li key={comment.id}>
                                        <p style={{margin: '0 0 0.5rem 0'}}>علّق على {getCommentLink(comment)}</p>
                                        <blockquote style={{margin: 0, padding: '1rem', background: 'var(--bg-secondary)', borderRight: '3px solid var(--border-color)', borderLeft: 'none', borderRadius: '4px'}}>
                                            &quot;{comment.content.slice(0, 150)}{comment.content.length > 150 ? '...' : ''}&quot;
                                        </blockquote>
                                    </li>
                                ))}
                            </ul>
                        ) : ( <p>{user.name} لم ينشر أي تعليقات بعد.</p> )}
                    </section>
                </main>
            </div>
        </div>
    );
}




--- END OF FILE app/profile/[username]/page.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasePageClient.tsx ---

// app/releases/ReleasePageClient.tsx
'use client';

import { useState, useMemo, useRef } from 'react';
import type { SanityGameRelease } from '@/types/sanity';
import TimelineCard from '@/components/TimelineCard';
import { motion, useInView, AnimatePresence } from 'framer-motion';
import styles from './ReleasesPage.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

type Platform = 'الكل' | 'PC' | 'PS5' | 'Xbox' | 'Switch';
const PLATFORMS: Platform[] = ['الكل', 'PC', 'PS5', 'Xbox', 'Switch'];
const PLATFORM_LABELS: Record<Platform, string> = { 'الكل': 'الكل', 'PC': 'PC', 'PS5': 'PS5', 'Xbox': 'Xbox', 'Switch': 'Switch' };

const PlatformFilters = ({ activeFilter, onFilterChange }: { activeFilter: Platform, onFilterChange: (platform: Platform) => void }) => {
  const ref = useRef(null);
  const isInView = useInView(ref, { once: true, amount: 0.5 });
  const animationVariants = { hidden: { opacity: 0, y: 50 }, visible: { opacity: 1, y: 0, transition: { duration: 0.6, ease: 'easeOut' } } };

  return (
    <motion.div ref={ref} variants={animationVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'} className={styles.platformFilters}>
      <span>تصفية حسب المنصة:</span>
      <div className={filterStyles.filterButtonsGroup}>
        {PLATFORMS.map(platform => {
          const isActive = activeFilter === platform;
          return (
            <motion.button 
                key={platform} 
                onClick={() => onFilterChange(platform)} 
                className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`} 
                whileHover={{ scale: 1.05 }} 
                whileTap={{ scale: 0.95 }}
            >
              {PLATFORM_LABELS[platform]}
              {isActive && ( <motion.div layoutId="release-filter-highlight" className={filterStyles.filterHighlight} transition={{ type: 'spring', stiffness: 300, damping: 25 }}/> )}
            </motion.button>
          );
        })}
      </div>
    </motion.div>
  );
};

export default function ReleasePageClient({ releases }: { releases: SanityGameRelease[] }) {
  const [activeFilter, setActiveFilter] = useState<Platform>('الكل');
  const mainRef = useRef(null);
  const isInView = useInView(mainRef, { once: true, amount: 0.1 });
  
  const flatAnimatedContent = useMemo(() => {
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    
    const sortedReleases = [...releases].sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    
    const isFilteringActive = activeFilter !== 'الكل';
    const filteredReleases = isFilteringActive 
        ? sortedReleases.filter(release => release.platforms && release.platforms.includes(activeFilter)) 
        : sortedReleases;
    
    let currentMonth = '';
    let flatList: { type: 'header' | 'card', key: string, data: SanityGameRelease | string }[] = [];

    filteredReleases.forEach(release => {
      const date = new Date(release.releaseDate);
      const monthIndex = date.getUTCMonth();
      const monthLabel = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;
      
      if (monthLabel !== currentMonth) {
        currentMonth = monthLabel;
        flatList.push({ type: 'header', key: `header-${monthLabel}-${date.getFullYear()}`, data: monthLabel });
      }
      flatList.push({ type: 'card', key: `card-${release._id}`, data: release });
    });
    return flatList;
  }, [releases, activeFilter]);

  const cardVariants = { initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, };
  const isListEmpty = flatAnimatedContent.length === 0 && activeFilter !== 'الكل';

  return (
    <div className={styles.chronoStreamLayoutWrapper}>
      <div className={styles.chronoContentWrapper}>
          <h1 className="page-title">الإصدارات القادمة لسنة 2025</h1>
          <PlatformFilters activeFilter={activeFilter} onFilterChange={setActiveFilter} />
      </div>
      <div ref={mainRef} className={styles.chronoTimelineSections} style={{ position: 'relative' }}>
          <motion.div layout className={styles.chronoGamesGrid} initial="hidden" animate={isInView ? "visible" : "hidden"} transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
            <AnimatePresence>
              {isListEmpty ? (
                <motion.p key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0', gridColumn: '1 / -1'}}>
                  لا إصدارات لهذه المنصة بعد.
                </motion.p>
              ) : (
                flatAnimatedContent.map(item => {
                  if (item.type === 'header') {
                    return (
                      <motion.div key={item.key} layout style={{ gridColumn: '1 / -1', padding: '1rem 0 0 0', display: 'flex', justifyContent: 'flex-start' }} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                        <h2 className={styles.timelineMonthTitle}>{item.data as string}</h2>
                      </motion.div>
                    );
                  }
                  const release = item.data as SanityGameRelease;
                  return (
                    <motion.div key={item.key} layout variants={cardVariants} initial="initial" animate="animate" exit="exit" transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
                      <TimelineCard release={release} />
                    </motion.div>
                  );
                })
              )}
            </AnimatePresence>
          </motion.div>
      </div>
    </div>
  );
}




--- END OF FILE app/releases/ReleasePageClient.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasesPage.module.css ---

/* app/releases/ReleasesPage.module.css */

.chronoStreamLayoutWrapper {
  position: relative;
  min-height: 80vh;
  padding-bottom: 6rem;
}

.chronoContentWrapper {
  max-width: 1200px;
  margin: 0 auto;
}

.chronoTimelineSections {
  padding-top: 2rem;
  padding-right: 2rem;
  padding-left: 2rem;
}

.platformFilters {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  padding: 2rem 2rem 3rem 2rem;
  font-family: var(--font-ui);
}

.platformFilters > span {
  font-size: 1.6rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.timelineMonthTitle {
  font-size: 3.6rem;
  border-bottom: none;
  padding-bottom: 0.5rem;
  display: block;
  text-align: left;
  margin: 0;
  width: max-content;
  border-bottom: 2px solid var(--accent);
  color: var(--text-primary);
  text-shadow: none;
}

.chronoGamesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 3rem;
  margin: 0 auto;
  width: 100%;
}

.chronoGamesGrid > div[style*="grid-column: 1 / -1"] {
    margin-bottom: 1.5rem; 
}







--- END OF FILE app/releases/ReleasesPage.module.css ---

================================================================================

--- START OF FILE app/releases/page.tsx ---

// app/releases/page.tsx

import { client } from '@/lib/sanity.client';
import { allReleasesQuery } from '@/lib/sanity.queries';
import type { SanityGameRelease } from '@/types/sanity';
import ReleasePageClient from './ReleasePageClient';

export const revalidate = 60; // Revalidate every 60 seconds

export default async function ReleasesPage() {
  const releases: SanityGameRelease[] = await client.fetch(allReleasesQuery);

  const sanitizedReleases = (releases || []).filter(item =>
    item?.mainImage?.url && item.releaseDate && item.title && item.slug
  );

  return (
    <div className="container page-container">
      <ReleasePageClient releases={sanitizedReleases} />
    </div>
  );
}

















--- END OF FILE app/releases/page.tsx ---

================================================================================

--- START OF FILE app/reset-password/page.tsx ---

// app/reset-password/page.tsx
'use client';

import { useState, useTransition } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { resetPassword } from '@/app/actions/authActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function ResetPasswordPage() {
    const router = useRouter();
    const searchParams = useSearchParams();
    const token = searchParams.get('token');
    const toast = useToast();

    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [message, setMessage] = useState<{ type: 'error' | 'success', text: string } | null>(null);
    const [isPending, startTransition] = useTransition();

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);

        if (!token) {
            setMessage({ type: 'error', text: 'Invalid or missing reset token.' });
            return;
        }

        if (newPassword !== confirmPassword) {
            setMessage({ type: 'error', text: 'Passwords do not match.' });
            return;
        }

        startTransition(async () => {
            const result = await resetPassword(token, newPassword);
            if (result.success) {
                toast.success(result.message || 'Password reset successfully!');
                router.push('/'); // Redirect to homepage on success
            } else {
                setMessage({ type: 'error', text: result.message || 'Failed to reset password.' });
            }
        });
    };
    
    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
            <motion.div 
                style={{ maxWidth: '420px', width: '100%' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <form onSubmit={handleSubmit} className="profile-form" style={{ background: 'var(--bg-secondary)', padding: '3rem', borderRadius: '12px', border: '1px solid var(--border-color)' }}>
                    <h1 className="page-title" style={{ fontSize: '2.8rem', marginTop: 0 }}>Reset Your Password</h1>
                    <p style={{ color: 'var(--text-secondary)', textAlign: 'center', marginTop: '-2rem', marginBottom: '3rem' }}>
                        Enter a new password for your account.
                    </p>

                    <div className="profile-form-group">
                        <input id="newPassword" type="password" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} required minLength={8} className="profile-input" placeholder=" " />
                        <label htmlFor="newPassword" className="profile-form-label">كلمة السر الجديدة</label>
                    </div>
                    <div className="profile-form-group">
                        <input id="confirmPassword" type="password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} required className="profile-input" placeholder=" " />
                        <label htmlFor="confirmPassword" className="profile-form-label">تأكيد كلمة السر الجديدة</label>
                    </div>
                    
                    <AnimatePresence>
                        {message && (
                            <motion.p
                                initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}
                                style={{
                                    fontSize: '1.4rem', textAlign: 'center', margin: '0 0 1.5rem 0',
                                    color: message.type === 'error' ? '#DC2626' : '#16A34A'
                                }}
                            >
                                {message.text}
                            </motion.p>
                        )}
                    </AnimatePresence>

                    <button type="submit" className="primary-button" style={{ width: '100%' }} disabled={isPending}>
                        {isPending ? <ButtonLoader /> : 'إعادة تعيين كلمة السر'}
                    </button>
                </form>
            </motion.div>
        </div>
    );
}




--- END OF FILE app/reset-password/page.tsx ---

================================================================================

--- START OF FILE app/reviews/ReviewsPage.module.css ---

/* app/reviews/ReviewsPage.module.css (CORRECTED) */

/* === Featured Review Hero === */
.featuredHeroContainer {
  position: relative;
  width: 100%;
  height: 70vh;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  color: #fff;
  overflow: hidden;
  padding-top: var(--nav-height-scrolled);
}

.featuredHeroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
  transform: scale(1.1); /* Slightly zoomed in for parallax */
}

.featuredHeroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.8) 100%);
  z-index: -1;
}

.featuredHeroContent {
  position: relative;
  max-width: 800px;
}

.featuredHeroLabel {
  font-family: var(--font-ui);
  font-size: 1.6rem;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 1rem;
}

.featuredHeroTitle {
  font-family: var(--font-heading);
  font-size: 6rem;
  font-weight: 800;
  line-height: 1.1;
  margin: 0 0 2rem 0;
  text-shadow: 0 5px 20px rgba(0,0,0,0.5);
}

.featuredHeroMeta {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  margin-bottom: 3rem;
  font-family: var(--font-heading);
  font-size: 2.4rem;
}

.featuredHeroScore {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background-color: var(--accent);
  color: var(--bg-primary);
  font-weight: 800;
  font-size: 2.8rem;
  box-shadow: 0 0 20px 0 color-mix(in srgb, var(--accent) 80%, transparent);
}

.featuredHeroGame {
  color: #fff;
  font-weight: 700;
}

@media (max-width: 768px) {
  .featuredHeroTitle {
    font-size: 4.8rem;
  }
  .featuredHeroMeta {
    flex-direction: column;
    gap: 1rem;
  }
}

/* --- Review Filters Container --- */
.reviewFiltersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-ui);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-ui), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative; /* REQUIRED for z-index to work on active state */
  overflow: hidden;
}
.filterButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.filterButton.active {
  color: #fff;
  z-index: 2; /* Ensure text is above the highlight */
}
[data-theme="dark"] .filterButton.active {
  color: var(--bg-primary);
}

.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

@media (max-width: 768px) {
  .filterGroup {
    flex-direction: column;
    align-items: flex-start;
  }
}

/* --- Filter Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: left;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-ui);
  transition: background-color 0.1s ease-out;
}
.popoverItemButton:hover {
  background-color: var(--bg-primary);
}
.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

/* Game Clear Button Alignment Fix (Requires styles for the container) */
.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem;
  flex-shrink: 0;
  cursor: pointer;
  color: #000000; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
}
.gameClearButton:hover {
  opacity: 1;
}
.gameSelectedButton.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}







--- END OF FILE app/reviews/ReviewsPage.module.css ---

================================================================================

--- START OF FILE app/reviews/ReviewsPageClient.tsx ---

// app/reviews/ReviewsPageClient.tsx
'use client';

import { useState, useMemo, useRef, useCallback } from 'react';
import { useSearchParams, useRouter, usePathname } from 'next/navigation';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import { motion, useInView } from 'framer-motion';

import FeaturedReviewHero from '@/components/FeaturedReviewHero';
import ReviewFilters from '@/components/filters/ReviewFilters';
import FilteredReviewsGrid from '@/components/FilteredReviewsGrid';
import { ContentBlock } from '@/components/ContentBlock';
import { adaptToCardProps } from '@/lib/adapters';

// The incorrect import that caused the build error has been removed.

export default function ReviewsPageClient({ heroReview, otherReviews, allGames, allTags }: { heroReview: SanityReview, otherReviews: SanityReview[], allGames: SanityGame[], allTags: SanityTag[] }) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedScoreRange, setSelectedScoreRange] = useState<'الكل' | '9-10' | '8-8.9' | '7-7.9' | '<7'>(() => (searchParams.get('score') as 'الكل' | '9-10' | '8-8.9' | '7-7.9' | '<7') || 'الكل');
  const [activeSort, setActiveSort] = useState<'latest' | 'score'>(() => (searchParams.get('sort') as 'latest' | 'score') || 'latest');
  const [selectedGame, setSelectedGame] = useState<SanityGame | null>(() => {
    const gameSlug = searchParams.get('game');
    return gameSlug ? allGames.find(g => g.slug === gameSlug) || null : null;
  });
  const [selectedTags, setSelectedTags] = useState<SanityTag[]>(() => {
    const tagSlugs = searchParams.get('tags')?.split(',').filter(Boolean) || [];
    return tagSlugs.map(slug => allTags.find(t => t.slug === slug)).filter((t): t is SanityTag => !!t);
  });

  const filtersRef = useRef(null);
  const isInView = useInView(filtersRef, { once: true, amount: 0.2 });

  const updateURLParams = useCallback((sort: 'latest' | 'score', score: string, game: SanityGame | null, tags: SanityTag[]) => {
    const params = new URLSearchParams();
    if (sort !== 'latest') params.set('sort', sort);
    if (score !== 'الكل') params.set('score', score);
    if (game) params.set('game', game.slug);
    if (tags.length > 0) params.set('tags', tags.map(t => t.slug).join(','));
    router.push(`${pathname}?${params.toString()}`, { scroll: false });
  }, [pathname, router]);

  const handleSortChange = (sort: 'latest' | 'score') => { setActiveSort(sort); updateURLParams(sort, selectedScoreRange, selectedGame, selectedTags); };
  const handleScoreSelect = (score: string) => { setSelectedScoreRange(score as any); updateURLParams(activeSort, score, selectedGame, selectedTags); };
  const handleGameSelect = (game: SanityGame | null) => { setSelectedGame(game); updateURLParams(activeSort, selectedScoreRange, game, selectedTags); };
  
  const handleTagToggle = (tagOrArray: SanityTag | SanityTag[]) => {
    if (Array.isArray(tagOrArray)) {
        setSelectedTags([]);
        updateURLParams(activeSort, selectedScoreRange, selectedGame, []);
        return;
    }
    const tag = tagOrArray;
    const newTags = selectedTags.some(t => t._id === tag._id) ? selectedTags.filter(t => t._id !== tag._id) : [...selectedTags, tag];
    setSelectedTags(newTags);
    updateURLParams(activeSort, selectedScoreRange, selectedGame, newTags);
  };
  
  const handleClearAll = () => {
    setSelectedScoreRange('الكل');
    setSelectedGame(null);
    setSelectedTags([]);
    setSearchTerm('');
    updateURLParams(activeSort, 'الكل', null, []);
  };
  
  const filteredAndSortedReviews = useMemo(() => {
    let reviews = [...otherReviews];

    if (searchTerm) {
        reviews = reviews.filter(r => r.title.toLowerCase().includes(searchTerm.toLowerCase()));
    }

    if (selectedScoreRange !== 'الكل') {
      switch (selectedScoreRange) {
        case '9-10': reviews = reviews.filter(r => r.score >= 9 && r.score <= 10); break;
        case '8-8.9': reviews = reviews.filter(r => r.score >= 8 && r.score < 9); break;
        case '7-7.9': reviews = reviews.filter(r => r.score >= 7 && r.score < 8); break;
        case '<7': reviews = reviews.filter(r => r.score < 7); break;
      }
    }

    if (selectedGame) reviews = reviews.filter(r => r.game?._id === selectedGame._id);

    if (selectedTags.length > 0) {
      const selectedTagIds = new Set(selectedTags.map(t => t._id));
      reviews = reviews.filter(r => (r.tags || []).some(tagRef => tagRef && selectedTagIds.has(tagRef._id)));
    }

    if (activeSort === 'score') reviews.sort((a, b) => b.score - a.score);
    else reviews.sort((a, b) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());

    return reviews.map(adaptToCardProps).filter(Boolean);

  }, [otherReviews, activeSort, selectedScoreRange, selectedGame, selectedTags, searchTerm]);

  const animationVariants = { hidden: { opacity: 0, y: 50 }, visible: { opacity: 1, y: 0, transition: { duration: 0.6, ease: 'easeOut' } } };

  return (
    <>
      <FeaturedReviewHero review={heroReview} />
      
      <div className="container page-container" style={{paddingTop: '4rem'}}>
        <motion.div ref={filtersRef} variants={animationVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'}>
          <ReviewFilters
            activeSort={activeSort} onSortChange={handleSortChange}
            selectedScoreRange={selectedScoreRange} onScoreSelect={handleScoreSelect}
            allGames={allGames} selectedGame={selectedGame} onGameSelect={handleGameSelect}
            allTags={allTags} selectedTags={selectedTags} onTagToggle={handleTagToggle} onClearAll={handleClearAll}
            searchTerm={searchTerm} onSearchChange={setSearchTerm}
          />
        </motion.div>

        <motion.div variants={animationVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'} transition={{ delay: 0.2 }}>
          <ContentBlock title="جميع المراجعات">
             {filteredAndSortedReviews.length > 0 ? (
              <FilteredReviewsGrid reviews={filteredAndSortedReviews} />
            ) : (
              <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} style={{ textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)' }}>
                <p>لا توجد مراجعات تطابق ما اخترت.</p>
              </motion.div>
            )}
          </ContentBlock>
        </motion.div>
      </div>
    </>
  );
}







--- END OF FILE app/reviews/ReviewsPageClient.tsx ---

================================================================================

--- START OF FILE app/reviews/page.tsx ---

// app/reviews/page.tsx
import { client } from '@/lib/sanity.client';
// MODIFIED: Import both heavy and lean queries
import { featuredHeroReviewQuery, allReviewsListQuery } from '@/lib/sanity.queries';
import { groq } from 'next-sanity';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import ReviewsPageClient from './ReviewsPageClient';

export const revalidate = 60;

const allGamesQuery = groq`*[_type == "game"] | order(title asc) {_id, title, "slug": slug.current}`;
// THE FIX: Only fetch tags relevant to reviews.
const allTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current}`;

export default async function ReviewsPage() {
  // MODIFIED: Fetch hero and list data in parallel
  const [heroReview, otherReviews, allGames, allTags]: [SanityReview, SanityReview[], SanityGame[], SanityTag[]] = await Promise.all([
    client.fetch(featuredHeroReviewQuery),      // Fetches one "heavy" review for the hero
    client.fetch(allReviewsListQuery),         // Fetches all reviews "lean" for the grid
    client.fetch(allGamesQuery),
    client.fetch(allTagsQuery),
  ]);

  // Ensure hero review exists to prevent crashes
  if (!heroReview) {
    return (
      <div className="container page-container">
        <h1 className="page-title">المراجعات</h1>
        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>لا توجد حاليًا أي مراجعات في الأرشيف. عد قريبًا.</p>
      </div>
    );
  }

  // Filter the main list to exclude the hero review, preventing duplication
  const gridReviews = (otherReviews || []).filter(review => review._id !== heroReview._id);

  return (
    <ReviewsPageClient 
      heroReview={heroReview} 
      otherReviews={gridReviews}
      allGames={allGames}
      allTags={allTags}
    />
  );
}




--- END OF FILE app/reviews/page.tsx ---

================================================================================

--- START OF FILE app/reviews/[slug]/ReviewPage.module.css ---

/* app/reviews/[slug]/ReviewPage.module.css */

.reviewLayout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
}
@media (min-width: 1024px) {
  .reviewLayout {
    grid-template-columns: 2fr 1fr;
  }
  .reviewLayout > main {
    min-width: 0;
  }
}

.reviewMetadata {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 3rem;
  color: var(--text-secondary);
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
}

.reviewHeroImage {
  position: relative;
  width: 100%;
  height: 450px;
  margin-bottom: 3rem;
  border-radius: 12px;
  overflow: hidden;
}

.reviewHeroImageSm {
  position: relative;
  width: 100%;
  height: 40vh;
  max-height: 450px;
  margin-bottom: 3rem;
  border-radius: 12px;
  overflow: hidden;
}

.tagLinksContainer {
  margin-top: 4rem;
  border-top: 1px solid var(--border-color);
  padding-top: 3rem;
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.relatedArticlesGrid .articleCard {
  flex-direction: column;
}

/* Score Box Styles */
.reviewScoreBox {
  background-color: transparent;
  border: 1px solid var(--border-color);
  box-shadow: 0 8px 30px rgba(0,0,0,0.08);
  border-radius: 12px;
  padding: 4rem;
  margin-top: 5rem;
  text-align: center;
  position: relative;
  overflow: hidden;
  transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}
[data-theme="dark"] .reviewScoreBox {
  border: 1px solid var(--border-color);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 15%, transparent);
}

.scoreBoxBorder {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}
[data-theme="dark"] .scoreBoxBorder {
  filter: drop-shadow(0 0 10px color-mix(in srgb, var(--accent) 70%, transparent));
}

.scoreBoxScore {
  font-family: var(--font-main), sans-serif;
  font-size: 9rem;
  font-weight: 800;
  color: var(--accent);
  line-height: 1;
  text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.scoreBoxVerdictLabel {
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-top: 0.5rem;
}

.scoreBoxVerdictText {
  font-size: 1.8rem;
  font-style: italic;
  max-width: 600px;
  margin: 1.5rem auto 3rem auto;
  color: var(--text-primary);
}

.scoreBoxDivider {
  width: 100%;
  height: 1px;
  background-color: var(--border-color);
  margin-bottom: 3rem;
}

.scoreBoxProsCons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3rem;
  text-align: right;
}
@media (min-width: 640px) {
  .scoreBoxProsCons {
    grid-template-columns: 1fr 1fr;
  }
}

.scoreBoxProsCons h4 {
  font-family: var(--font-main), sans-serif;
  font-weight: 700;
  font-size: 1.8rem;
  margin-bottom: 1rem;
}

.scoreBoxProsCons ul {
  list-style: none;
  padding-right: 0;
}

.scoreBoxProsCons li {
  display: flex;
  flex-direction: row-reverse;
  justify-content: flex-end;
  align-items: flex-start;
  margin-bottom: 1rem;
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  gap: 1rem;
}




--- END OF FILE app/reviews/[slug]/ReviewPage.module.css ---

================================================================================

--- START OF FILE app/reviews/[slug]/ReviewPageClient.tsx ---

// app/reviews/[slug]/ReviewPageClient.tsx
'use client';

import type { SanityReview } from '@/types/sanity';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { useEffect, useState, useRef } from 'react';
import { useLayoutIdStore } from '@/lib/layoutIdStore';

import PortableTextComponent from '@/components/PortableTextComponent';
import ScoreBox from '@/components/ScoreBox';
import ArticleCard from '@/components/ArticleCard';
import GameLink from '@/components/GameLink';
import ContentActionBar from '@/components/ContentActionBar';
import TagLinks from '@/components/TagLinks';
import ReadingHud from '@/components/ReadingHud';
import { ContentBlock } from '@/components/ContentBlock';
import { adaptToCardProps } from '@/lib/adapters';
import CreatorCredit from '@/components/CreatorCredit';
import styles from './ReviewPage.module.css';

export type Heading = { id: string; title: string; top: number; };
const contentVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { delay: 0.3, duration: 0.5 } }, };
const adaptReviewForScoreBox = (review: SanityReview) => ({ score: review.score, verdict: review.verdict, pros: review.pros, cons: review.cons });

export default function ReviewPageClient({ review, searchParams, children }: { 
    review: SanityReview, 
    searchParams?: { [key: string]: string | string[] | undefined },
    children?: React.ReactNode
}) {
    const layoutIdPrefix = useLayoutIdStore((state) => state.prefix) || (searchParams?.prefix as string) || 'reviews';
    const [headings, setHeadings] = useState<Heading[]>([]);
    const contentContainerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        window.scrollTo(0, 0);
    }, []);

    useEffect(() => { 
        const contentElement = contentContainerRef.current; if (!contentElement) return; const measureHeadings = () => { const containerRect = contentElement.getBoundingClientRect(); const headingElements = Array.from(contentElement.querySelectorAll('h2')); const navbarOffset = 90; 
        
        // --- THE DEFINITIVE FIX FOR DUPLICATE KEYS ---
        const seenIds = new Set<string>();
        const newHeadings = headingElements.map((h, index) => {
            let id = h.id;
            // If we've seen this ID before, make it unique by appending the index.
            if (seenIds.has(id)) {
                id = `${id}-${index}`;
            }
            seenIds.add(id);
            h.id = id; // IMPORTANT: Update the actual DOM element's ID for the click handler.
            
            const headingRect = h.getBoundingClientRect(); 
            const relativeTop = (headingRect.top - containerRect.top); 
            return { id: id, title: h.textContent || '', top: Math.max(0, relativeTop - navbarOffset) }; 
        });
        setHeadings(newHeadings); 
        
        }; const imagePromises = Array.from(contentElement.querySelectorAll('img')).filter(img => !img.complete).map(img => new Promise(resolve => { img.onload = resolve; img.onerror = resolve; })); Promise.all(imagePromises).then(measureHeadings); if (imagePromises.length === 0) measureHeadings(); 
    }, [review]);

    if (!review) return null;
    const adaptedRelatedReviews = (review.relatedReviews || []).map(adaptToCardProps).filter(Boolean);

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const publishedDate = new Date(review.publishedAt);
    const day = publishedDate.getDate();
    const year = publishedDate.getFullYear();
    const monthIndex = publishedDate.getMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;
    
    const baseUrl = review.mainImage.url.split('?')[0];
    const imageUrl = `${baseUrl}?auto=format&q=85`;

    return (
        <>
            <motion.div initial="hidden" animate="visible" variants={contentVariants}><ReadingHud contentContainerRef={contentContainerRef} headings={headings} /></motion.div>
            <div className="page-transition-canvas">
                <motion.div layoutId={`${layoutIdPrefix}-card-container-${review.legacyId}`} className={styles.reviewHeroImageSm} style={{ position: 'relative', zIndex: 1060, overflow: 'hidden' }} transition={{ duration: 0.4, ease: [0.4, 0, 0.2, 1] }}>
                    <motion.div layoutId={`${layoutIdPrefix}-card-image-${review.legacyId}`} style={{ position: 'absolute', inset: 0 }}><Image src={imageUrl} alt={review.title} fill style={{ objectFit: 'cover' }} priority placeholder="blur" blurDataURL={review.mainImage.blurDataURL} unoptimized /></motion.div>
                </motion.div>
                <motion.div initial="hidden" animate="visible" variants={contentVariants}>
                    <div className="container page-container" style={{ paddingTop: 0 }}>
                        <div className={styles.reviewLayout}>
                            <main>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                    <motion.h1 layoutId={`${layoutIdPrefix}-card-title-${review.legacyId}`} className="page-title" style={{ textAlign: 'right', margin: 0 }}>{review.title}</motion.h1>
                                    
                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '1.5rem' }}>
                                        <GameLink gameName={review.game?.title} className="kinetic-game-tag" />
                                    </div>
                                </div>
                                
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '3rem' }}>
                                    <div style={{ textAlign: 'right', display: 'flex', flexDirection: 'column', gap: '0.5rem', fontSize: '1.5rem', color: 'var(--text-secondary)' }}>
                                        <CreatorCredit label="بقلم" creators={review.authors} />
                                        <CreatorCredit label="تصميم" creators={review.designers} />
                                        <p style={{ margin: 0 }}>نُشر في {formattedDate}</p>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start', gap: '1.5rem' }}>
                                        <ContentActionBar contentId={review.legacyId} contentType="review" contentSlug={review.slug} />
                                    </div>
                                </div>
                                
                                <div ref={contentContainerRef}><PortableTextComponent content={review.content} /><ScoreBox review={adaptReviewForScoreBox(review) as any} /></div>
                                <div className={styles.tagLinksContainer}><TagLinks tags={(review.tags || []).map(t => t.title)} /></div>
                            </main>
                            <aside className="review-sidebar" style={{ marginTop: '3rem' }}><ContentBlock title="قد يروق لك"><div className={styles.relatedArticlesGrid} style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>{adaptedRelatedReviews.map(related => ( <ArticleCard key={related.id} article={related} layoutIdPrefix="related" /> ))}</div></ContentBlock></aside>
                        </div>
                    </div>
                    <div className="container" style={{ paddingBottom: '6rem' }}>
                        <ContentBlock title="حديث المجتمع">{children}</ContentBlock>
                    </div>
                </motion.div>
            </div>
        </>
    );
}

--- END OF FILE app/reviews/[slug]/ReviewPageClient.tsx ---

================================================================================

--- START OF FILE app/reviews/[slug]/page.tsx ---

// app/reviews/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { reviewBySlugQuery, latestReviewsFallbackQuery } from '@/lib/sanity.queries';
import type { SanityReview } from '@/types/sanity';
import { notFound } from 'next/navigation';
import ReviewPageClient from './ReviewPageClient';
import prisma from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import CommentSection from '@/components/comments/CommentSection';
import { Suspense } from 'react';

export const revalidate = 60;

// Enrich creator with prisma username, image, and bio
async function enrichCreator(creator: any) {
    if (!creator || !creator.prismaUserId) return creator;
    const user = await prisma.user.findUnique({
        where: { id: creator.prismaUserId },
        select: { username: true, image: true, bio: true }
    });
    return { 
        ...creator, 
        username: user?.username || null,
        image: user?.image || null,
        bio: user?.bio || null,
    };
}

export async function generateStaticParams() {
    const reviews = await client.fetch<any[]>(`*[_type == "مراجعة"]{ "slug": slug.current }`);
    return reviews.filter(r => r.slug).map(r => ({ slug: r.slug }));
}

async function Comments({ slug }: { slug: string }) {
    const [comments, session] = await Promise.all([
        prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } }, replies: { take: 2, include: { author: { select: { id: true, name: true, image: true, username: true } }, votes: true, _count: { select: { replies: true } } }, orderBy: { createdAt: 'asc' } } },
            orderBy: { createdAt: 'desc' },
        }),
        getServerSession(authOptions)
    ]);
    return <CommentSection slug={slug} initialComments={comments} session={session} />;
}

export default async function ReviewPage({ params, searchParams }: { params: { slug: string }, searchParams: { [key: string]: string | string[] | undefined } }) {
    const resolvedParams = await params;
    const slug = resolvedParams.slug;
    
    let reviewData: any = await client.fetch(reviewBySlugQuery, { slug });
    if (!reviewData) { notFound(); }

    // Enrich creator data with usernames from Prisma
    if (reviewData.authors) {
        reviewData.authors = await Promise.all(reviewData.authors.map(enrichCreator));
    }
    if (reviewData.designers) {
        reviewData.designers = await Promise.all(reviewData.designers.map(enrichCreator));
    }
    
    const review: SanityReview = { ...reviewData, slug: reviewData.slug.current };

    if (!review.relatedReviews || review.relatedReviews.length === 0) {
        review.relatedReviews = await client.fetch(latestReviewsFallbackQuery, { currentId: review._id });
    }
    
    return (
        <ReviewPageClient review={review} searchParams={searchParams}>
            <Suspense fallback={<div className="spinner" style={{margin: '8rem auto'}} />}>
                {/* @ts-expect-error Async Server Component */}
                <Comments slug={slug} />
            </Suspense>
        </ReviewPageClient>
    );
}




--- END OF FILE app/reviews/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.module.css ---

/* app/studio/ActionDrawer.module.css */

.actionDrawerContainer {
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  z-index: 10;
  overflow: hidden;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  backdrop-filter: blur(8px);
  border-top: 1px solid var(--border-color);
  border-top-left-radius: 12px;
  border-top-left-radius: 12px;
}

.actionDrawerButtons {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
}

.actionDrawerButton {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background-color: transparent;
  border: 1px solid transparent;
  color: var(--text-primary); /* <-- THE FIX IS HERE */
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
}
.actionDrawerButton svg {
  width: 22px;
  height: 22px;
}

.actionDrawerButton:hover {
  background-color: var(--border-color);
  color: var(--accent);
}
.actionDrawerButton.delete:hover {
  background-color: #3f1a1a;
  color: #DC2626;
}




--- END OF FILE app/studio/ActionDrawer.module.css ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.tsx ---

// app/studio/ActionDrawer.tsx
'use client';

import { motion } from 'framer-motion';
import Link from 'next/link';
import { useState } from 'react';
import { EditIcon, PreviewIcon, DeleteIcon } from './StudioIcons';
import { DeleteConfirmationModal } from './DeleteConfirmationModal';
import styles from './ActionDrawer.module.css';

type ContentCanvasItem = { _id: string; _type: string; slug: string; title: string; };

const drawerVariants = {
    hidden: { y: '100%' },
    visible: { y: '0%', transition: { type: 'spring', damping: 25, stiffness: 200 } },
    exit: { y: '100%', transition: { duration: 0.2 } }
};

const itemContainerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.07, delayChildren: 0.2 } },
};

const itemVariants = {
    hidden: { opacity: 0, y: 10 },
    visible: { opacity: 1, y: 0 },
};

export function ActionDrawer({ item, onDelete }: { item: ContentCanvasItem, onDelete: (id: string) => Promise<void> }) {
    const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);

    const getPaths = () => {
        switch (item._type) {
            case 'review': return { plural: 'reviews', live: `/reviews/${item.slug}` };
            case 'article': return { plural: 'articles', live: `/articles/${item.slug}` };
            case 'news': return { plural: 'news', live: `/news/${item.slug}` };
            case 'gameRelease': return { plural: 'releases', live: `/releases` }; // Game releases have a main page, not individual pages
            default: return { plural: '', live: '/' };
        }
    };

    const { plural, live } = getPaths();
    const studioEditUrl = `/studio/${plural}/${item._id}`;
    const livePreviewUrl = live;

    const handleDeleteConfirm = async () => {
        await onDelete(item._id);
        setDeleteModalOpen(false);
    };

    const actions = [
        { label: 'تحرير', icon: <EditIcon />, href: studioEditUrl, isLink: true },
        { label: 'Preview', icon: <PreviewIcon />, href: livePreviewUrl, isLink: true },
        { label: 'حذف', icon: <DeleteIcon />, onClick: () => setDeleteModalOpen(true), isLink: false },
    ];

    return (
        <>
            <DeleteConfirmationModal
                isOpen={isDeleteModalOpen}
                onClose={() => setDeleteModalOpen(false)}
                onConfirm={handleDeleteConfirm}
                itemName={item.title}
            />
            <motion.div
                className={styles.actionDrawerContainer}
                variants={drawerVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
                onClick={(e) => e.stopPropagation()}
            >
                <motion.div className={styles.actionDrawerButtons} variants={itemContainerVariants}>
                    {actions.map((action) => (
                        <motion.div key={action.label} variants={itemVariants}>
                            {action.isLink ? (
                                <Link href={action.href!} className={styles.actionDrawerButton} aria-label={action.label} target={action.label === 'Preview' ? '_blank' : '_self'}>
                                    {action.icon}
                                </Link>
                            ) : (
                                <button className={`${styles.actionDrawerButton} ${styles.delete}`} onClick={action.onClick} aria-label={action.label}>
                                    {action.icon}
                                </button>
                            )}
                        </motion.div>
                    ))}
                </motion.div>
            </motion.div>
        </>
    );
}




--- END OF FILE app/studio/ActionDrawer.tsx ---

================================================================================

--- START OF FILE app/studio/DeleteConfirmationModal.tsx ---

// app/studio/DeleteConfirmationModal.tsx

'use client';

import { useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import modalStyles from '@/components/modals/Modals.module.css'; // <-- CRITICAL FIX: IMPORT THE CSS MODULE

interface DeleteConfirmationModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => Promise<void>;
    itemName: string;
}

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export function DeleteConfirmationModal({ isOpen, onClose, onConfirm, itemName }: DeleteConfirmationModalProps) {
    const [isPending, setIsPending] = useState(false);
    const [isMounted, setIsMounted] = useState(false);

    useEffect(() => {
        setIsMounted(true);
        if (isOpen) {
            setIsPending(false);
        }
    }, [isOpen]);

    const handleConfirm = async () => {
        setIsPending(true);
        await onConfirm();
    };

    const modalContent = (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    className={modalStyles.modalOverlay} // Use modular style
                    style={{ zIndex: 5001 }}
                    onClick={onClose}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                >
                    <motion.div
                        className={modalStyles.modalContent} // Use modular style
                        style={{ padding: '2rem', maxWidth: '450px' }}
                        variants={modalVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <h3 style={{ marginTop: 0, fontFamily: 'var(--font-ui)', fontSize: '2rem' }}>تأكيد الحذف</h3>
                        <p style={{ color: 'var(--text-secondary)', margin: '1rem 0 2rem 0' }}>هل أنت متأكد من رغبتك في حذف<strong style={{ color: 'var(--text-primary)' }}>&quot;{itemName}&quot;</strong>? This action cannot be undone.
                        </p>
                        <div className={modalStyles.modalActions}> {/* Use modular style */}
                            <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                            <motion.button
                                onClick={handleConfirm}
                                className="primary-button delete-forever"
                                style={{
                                    backgroundColor: '#DC2626',
                                    boxShadow: 'none'
                                }}
                                disabled={isPending}
                            >
                                {isPending ? 'جار الحذف...' : 'حذف نهائي'}
                            </motion.button>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) {
        return null;
    }

    return createPortal(modalContent, document.body);
}







--- END OF FILE app/studio/DeleteConfirmationModal.tsx ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.module.css ---

/* components/studio/GenesisOrb.module.css */

.genesisContainer {
  position: fixed;
  bottom: 3rem;
  right: 3rem; /* RTL */
  left: auto;
  z-index: 10;
  width: 80px;
  height: 80px;
}

.genesisOrb {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background-color: var(--accent);
  color: white;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--accent) 50%, transparent);
  z-index: 12;
}
[data-theme="dark"] .genesisOrb {
  color: var(--bg-primary);
}

.genesisSatellites {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  z-index: 11;
  pointer-events: none;
}

.satelliteWrapper {
  position: absolute;
  margin-left: -28px;
  margin-top: -28px;
  pointer-events: auto;
  display: flex;
  align-items: center;
}

.satelliteOrb {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  flex-shrink: 0;
}
.satelliteOrb:hover {
  border-color: var(--accent);
  color: var(--accent);
  transform: scale(1.1);
}

/* --- THE FIX IS HERE --- */
.satelliteOrb svg {
  color: currentColor; /* Inherit color from the parent .satelliteOrb */
  filter: grayscale(0) opacity(1) !important;
}

.satelliteLabel {
  position: absolute;
  left: calc(100% + 1rem); /* RTL */
  right: auto;
  font-family: var(--font-main);
  font-size: 1.4rem;
  font-weight: 500;
  color: var(--text-primary);
  background: var(--bg-secondary);
  padding: 0.4rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out;
}

.satelliteWrapper:hover .satelliteLabel {
  opacity: 1;
}

.closeIcon {
  color: #fff !important;
}
.closeIcon:hover {
  filter: drop-shadow(0 0 10px #DC2626); /* Red glow on hover */
}




--- END OF FILE app/studio/GenesisOrb.module.css ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.tsx ---

// app/studio/GenesisOrb.tsx
'use client';

import { useState, useTransition, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { createDraftAction } from './actions';
import { ReviewIcon, ArticleIcon, NewsIcon, ReleaseIcon } from './StudioIcons';
import { useToast } from '@/lib/toastStore';
import styles from './GenesisOrb.module.css';

const PlusIcon = () => ( <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"> <line x1="12" y1="5" x2="12" y2="19"></line> <line x1="5" y1="12" x2="19" y2="12"></line> </svg> );

const allContentTypes = [
    { type: 'review' as const, label: 'مراجعة جديدة', icon: <ReviewIcon />, requiredRole: 'REVIEWER' },
    { type: 'article' as const, label: 'مقالة جديدة', icon: <ArticleIcon />, requiredRole: 'AUTHOR' },
    { type: 'news' as const, label: 'خبر جديد', icon: <NewsIcon />, requiredRole: 'REPORTER' },
    { type: 'gameRelease' as const, label: 'إصدار جديد', icon: <ReleaseIcon />, requiredRole: 'ADMIN' }, // Restricted
];

const orbContainerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.08, delayChildren: 0.1 } }, };
const satelliteVariants = { hidden: { scale: 0, opacity: 0, x: 0, y: 0 }, visible: (custom: { x: number; y: number }) => ({ scale: 1, opacity: 1, x: custom.x, y: custom.y, transition: { type: 'spring', stiffness: 400, damping: 18 }, }), };
const backdropVariants = { hidden: { scale: 0, opacity: 0, transition: { duration: 0.2, ease: "easeOut" } }, visible: { scale: 1, opacity: 1, transition: { type: "spring", stiffness: 400, damping: 25 } }, };

export function GenesisOrb() {
    const [isOpen, setIsOpen] = useState(false);
    const [isPending, startTransition] = useTransition();
    const router = useRouter();
    const { data: session } = useSession();
    const toast = useToast();

    const userRoles = session?.user?.roles || [];
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    
    const creationPermissions = useMemo(() => new Set( allContentTypes.filter(item => isAdminOrDirector || userRoles.includes(item.requiredRole)).map(item => item.type) ), [isAdminOrDirector, userRoles]);

    const handleCreate = (contentType: 'review' | 'article' | 'news' | 'gameRelease') => {
        if (isPending) return;
        if (!creationPermissions.has(contentType)) { toast.error("ليس لديك الصلاحية لإنشاء هذا المحتوى.", "left"); return; }
        setIsOpen(false);
        startTransition(async () => {
            try {
                const newDraft = await createDraftAction(contentType);
                const contentTypePlural = newDraft._type === 'news' ? 'news' : (newDraft._type === 'gameRelease' ? 'releases' : `${newDraft._type}s`);
                const route = contentType === 'gameRelease' ? `/studio/releases/${newDraft._id}` : `/studio/${contentTypePlural}/${newDraft._id}`;
                router.push(route);
            } catch (error: any) {
                toast.error(error.message || "فشل إنشاء المسودة.", "left");
            }
        });
    };
    
    if (creationPermissions.size === 0 && !isAdminOrDirector) { return null; }

    const availableTypes = allContentTypes.filter(item => creationPermissions.has(item.type));

    return (
        <div className={styles.genesisContainer}>
            <AnimatePresence>
                {isOpen && (
                    <>
                        <motion.div variants={backdropVariants} initial="hidden" animate="visible" exit="hidden" onClick={() => setIsOpen(false)} style={{ position: 'absolute', top: '-110px', right: '-110px', width: '300px', height: '300px', backgroundColor: 'transparent', borderRadius: '50%', zIndex: 10, cursor: 'default' }} />
                        <motion.div className={styles.genesisSatellites} variants={orbContainerVariants} initial="hidden" animate="visible" exit="hidden" >
                            {availableTypes.map((item, i) => {
                                const angleInDegrees = 180 + (i * (90 / (availableTypes.length -1 || 1) ));
                                const angleInRadians = angleInDegrees * (Math.PI / 180);
                                const radius = 100;
                                const x = Math.cos(angleInRadians) * radius;
                                const y = Math.sin(angleInRadians) * radius;

                                return (
                                    <motion.div key={item.type} className={styles.satelliteWrapper} custom={{ x, y }} variants={satelliteVariants} >
                                        <button className={styles.satelliteOrb} onClick={() => handleCreate(item.type)} disabled={isPending} title={item.label}>
                                            {item.icon}
                                        </button>
                                    </motion.div>
                                );
                            })}
                        </motion.div>
                    </>
                )}
            </AnimatePresence>
            <motion.button onClick={() => setIsOpen(!isOpen)} disabled={isPending} className={styles.genesisOrb} whileHover={{ scale: 1.05, boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} whileTap={{ scale: 0.95 }} transition={{ type: 'spring', stiffness: 300, damping: 20 }} animate={{ scale: isOpen ? 1.1 : 1, backgroundColor: isOpen ? '#DC2626' : 'var(--accent)', boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} >
                <motion.div animate={{ rotate: isOpen ? 45 : 0 }} className={isOpen ? styles.closeIcon : ''}>
                    <PlusIcon />
                </motion.div>
            </motion.button>
        </div>
    );
}




--- END OF FILE app/studio/GenesisOrb.tsx ---

================================================================================

--- START OF FILE app/studio/StudioDashboard.tsx ---

// app/studio/StudioDashboard.tsx

'use client';

import { useState, useMemo, useTransition, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { StudioTabs, ContentType } from './StudioTabs';
import { ActionDrawer } from './ActionDrawer';
import { GenesisOrb } from './GenesisOrb';
import { deleteDocumentAction } from './actions';
import { useToast } from '@/lib/toastStore';

type ContentStatus = 'all' | 'draft' | 'published' | 'scheduled';
type ContentCanvasItem = { _id: string; _type: 'review' | 'article' | 'news' | 'gameRelease'; _updatedAt: string; title: string; slug: string; status: ContentStatus; imageUrl?: string; blurDataURL?: string; };

const ContentCanvas = ({ item, onDelete }: { item: ContentCanvasItem; onDelete: (id: string) => void; }) => {
    const [isHovered, setIsHovered] = useState(false);
    const [isClicked, setIsClicked] = useState(false);
    const isDrawerVisible = isHovered || isClicked;
    const rawImageUrlWithBuster = useMemo(() => {
        if (!item.imageUrl) return null;
        return `${item.imageUrl}?${new Date(item._updatedAt).getTime()}`;
    }, [item.imageUrl, item._updatedAt]);

    return (
        <motion.div layoutId={`canvas-card-${item._id}`} style={{ position: 'relative', backgroundColor: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px', overflow: 'hidden', aspectRatio: '16 / 10', cursor: 'pointer' }} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)} onClick={() => setIsClicked(prev => !prev)} >
            <motion.div className="canvas-image-container" animate={{ scale: isDrawerVisible ? 1.05 : 1, filter: isDrawerVisible ? 'brightness(0.8)' : 'brightness(1)' }} transition={{ type: 'spring', damping: 20, stiffness: 150 }} style={{ width: '100%', height: '100%', position: 'absolute', inset: 0, backgroundColor: 'var(--border-color)', display: 'flex', alignItems: 'center', justifyContent: 'center' }} >
                {rawImageUrlWithBuster ? (<img src={rawImageUrlWithBuster} alt={item.title} style={{ position: 'absolute', inset: 0, width: '100%', height: '100%', objectFit: 'cover' }}/>) : (<span style={{color: 'var(--text-secondary)', fontSize: '1.2rem', fontWeight: 600}}>NO IMAGE</span>)}
            </motion.div>
            <div style={{ position: 'absolute', inset: 0, background: 'linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 60%)', pointerEvents: 'none' }} />
            <div style={{ position: 'absolute', bottom: 0, left: 0, padding: '1.25rem', color: 'white', pointerEvents: 'none' }}>
                <span style={{ display: 'inline-block', padding: '0.25rem 0.75rem', fontSize: '0.75rem', fontWeight: 600, borderRadius: '9999px', backgroundColor: item.status === 'published' ? 'rgba(22, 163, 74, 0.8)' : 'rgba(107, 114, 128, 0.8)' }}>{item.status === 'draft' ? 'مسودة' : item.status === 'published' ? 'منشورة' : 'مجدولة'}</span>
                <h3 style={{ marginTop: '0.5rem', fontSize: '1.25rem', fontWeight: 700, fontFamily: 'var(--font-heading)' }}>{item.title}</h3>
            </div>
            <AnimatePresence>{isDrawerVisible && <ActionDrawer item={item} onDelete={onDelete} />}</AnimatePresence>
        </motion.div>
    );
};

export function StudioDashboard({ initialContent, userRoles }: { initialContent: ContentCanvasItem[], userRoles: string[] }) {
    const [content, setContent] = useState(initialContent);
    const [activeTab, setActiveTab] = useState<ContentType>('all');
    const [searchTerm, setSearchTerm] = useState('');
    const toast = useToast();
    const [isPending, startTransition] = useTransition();

    const availableTabs = useMemo(() => {
        const tabs: { label: string; value: ContentType }[] = [];
        const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
        
        if (isAdminOrDirector || userRoles.includes('REVIEWER')) tabs.push({ label: 'المراجعات', value: 'review' });
        if (isAdminOrDirector || userRoles.includes('AUTHOR')) tabs.push({ label: 'المقالات', value: 'article' });
        if (isAdminOrDirector || userRoles.includes('REPORTER')) tabs.push({ label: 'الأخبار', value: 'news' });
        if (isAdminOrDirector) tabs.push({ label: 'الإصدارات', value: 'gameRelease' });
        
        return tabs;
    }, [userRoles]);
    
    useEffect(() => {
        if (availableTabs.length === 1 && activeTab === 'all') {
            setActiveTab(availableTabs[0].value);
        }
    }, [availableTabs, activeTab]);

    const shouldShowTabs = availableTabs.length > 1;

    const filteredContent = useMemo(() => {
        let filtered = content;
        if (activeTab !== 'all' && shouldShowTabs) {
            filtered = filtered.filter(item => item._type === activeTab);
        } else if (!shouldShowTabs && availableTabs.length === 1) {
            filtered = content.filter(item => item._type === availableTabs[0].value);
        }

        if (searchTerm) {
            filtered = filtered.filter(item => item.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }
        return filtered;
    }, [activeTab, content, searchTerm, shouldShowTabs, availableTabs]);
    
    const handleDelete = async (docId: string) => {
        startTransition(async () => {
            const originalContent = content;
            setContent(prev => prev.filter(item => item._id !== docId));
            const result = await deleteDocumentAction(docId);
            if (!result.success) {
                toast.error(result.message || 'فشل الحذف.');
                setContent(originalContent);
            } else {
                toast.success('تم حذف المستند.');
            }
        });
    };

    return (
        <div className="container page-container">
            <header style={{ textAlign: 'center', marginBottom: '3rem' }}>
                <h1 className="page-title">ديوان القيادة</h1>
                <p className="sidebar-subtitle" style={{ fontSize: '1.8rem' }}>قُد دفّة محتواك في رحاب EternalGames.</p>
            </header>

            <div style={{display: 'flex', justifyContent: 'center', marginBottom: '3rem'}}>
                <input type="search" placeholder="ابحث في العناوين..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} style={{width: '100%', maxWidth: '500px'}} className="profile-input" />
            </div>

            {shouldShowTabs && (
                <StudioTabs tabs={availableTabs} activeTab={activeTab} setActiveTab={setActiveTab} />
            )}

            <motion.div layout className="content-grid" style={{gap: '1.5rem'}}>
                <AnimatePresence>
                    {filteredContent.map(item => (
                        <motion.div key={item._id} layout initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }} transition={{ type: 'spring', damping: 20, stiffness: 200 }} >
                            <ContentCanvas item={item} onDelete={handleDelete} />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </motion.div>
            {filteredContent.length === 0 && <p style={{ textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}}>لا يوجد محتوى.</p>}

            <GenesisOrb />
        </div>
    );
}




--- END OF FILE app/studio/StudioDashboard.tsx ---

================================================================================

--- START OF FILE app/studio/StudioIcons.tsx ---

'use client';

// ADDED ICON
export const SingleImageIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg> );

export const ImageIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg> );
export const CompareIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M12 2v20M3 12h18M21 12l-3-3m3 3l-3 3M3 12l3-3m-3 3l3 3"/></svg> );
export const TwoImageIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="7" height="18"></rect><rect x="14" y="3" width="7" height="18"></rect></svg> );
export const FourImageIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg> );
export const ReleaseIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M6 2L3 6v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6l-3-4H6zM3.5 6h17M8 11l4 4 4-4" /> </svg> );
export const ReviewIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon> </svg> );
export const ArticleIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path> <polyline points="14 2 14 8 20 8"></polyline> <line x1="16" y1="13" x2="8" y2="13"></line> <line x1="16" y1="17" x2="8" y2="17"></line> </svg> );
export const NewsIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <circle cx="12" cy="12" r="10"></circle> <line x1="2" y1="12" x2="22" y2="12"></line> <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path> </svg> );
export const EditIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path> </svg> );
export const PreviewIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path> <circle cx="12" cy="12" r="3"></circle> </svg> );
export const DeleteIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <polyline points="3 6 5 6 21 6"></polyline> <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path> <line x1="10" y1="11" x2="10" y2="17"></line> <line x1="14" y1="11" x2="14" y2="17"></line> </svg> );




--- END OF FILE app/studio/StudioIcons.tsx ---

================================================================================

--- START OF FILE app/studio/StudioTabs.module.css ---

/* app/studio/StudioTabs.module.css */

.studioTabsContainer {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 3rem;
    border-bottom: 1px solid var(--border-color);
  }
  
  .studioTabButton {
    position: relative;
    padding: 1rem 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    font-size: 1.6rem;
    color: var(--text-secondary);
    transition: color 0.2s ease-in-out;
  }
  
  .studioTabButton:hover {
    color: var(--text-primary);
  }
  
  .studioTabButton.active {
    color: var(--accent);
  }
  
  .studioTabUnderline {
    position: absolute;
    bottom: -1px;
    right: 0;
    left: 0;
    height: 2px;
    background: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
  }







--- END OF FILE app/studio/StudioTabs.module.css ---

================================================================================

--- START OF FILE app/studio/StudioTabs.tsx ---

// app/studio/StudioTabs.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './StudioTabs.module.css';

export type ContentType = 'review' | 'article' | 'news' | 'gameRelease' | 'all';

interface StudioTabsProps {
    tabs: { label: string; value: ContentType }[];
    activeTab: ContentType;
    setActiveTab: (tab: ContentType) => void;
}

export function StudioTabs({ tabs, activeTab, setActiveTab }: StudioTabsProps) {
    const allTabs = [{ label: 'كل المحتوى', value: 'all' as ContentType }, ...tabs];

    return (
        <div className={styles.studioTabsContainer}>
            {allTabs.map((tab) => (
                <button
                    key={tab.value}
                    onClick={() => setActiveTab(tab.value)}
                    className={`${styles.studioTabButton} ${activeTab === tab.value ? styles.active : ''}`}
                >
                    {tab.label}
                    {activeTab === tab.value && (
                        <motion.div className={styles.studioTabUnderline} layoutId="studioTabUnderline" />
                    )}
                </button>
            ))}
        </div>
    );
}




--- END OF FILE app/studio/StudioTabs.tsx ---

================================================================================

--- START OF FILE app/studio/actions.ts ---

// app/studio/actions.ts
'use server';

import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';
import { slugify } from 'transliteration';
import { tiptapToPortableText } from './utils/tiptapToPortableText';
import { portableTextToTiptap } from './utils/portableTextToTiptap';
import { editorDocumentQuery } from '@/lib/sanity.queries';

// --- uploadImageFromUrlAction REMOVED as it's no longer needed ---

export async function createDraftAction(contentType: 'review' | 'article' | 'news' | 'gameRelease') {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.roles) throw new Error('غير مصرح لك.');
    
    const userRoles = session.user.roles;
    const canCreate = (userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR')) || (contentType === 'review' && userRoles.includes('REVIEWER')) || (contentType === 'article' && userRoles.includes('AUTHOR')) || (contentType === 'news' && userRoles.includes('REPORTER'));
    if (!canCreate) throw new Error('صلاحيات غير كافية.');

    const highestIdQuery = groq`*[_type in ["review", "article", "news", "gameRelease"]] | order(legacyId desc)[0].legacyId`;
    const lastId = await sanityWriteClient.fetch<number>(highestIdQuery);
    const newLegacyId = (lastId || 0) + 1;

    let doc: any = { _type: contentType, title: `Untitled ${contentType.charAt(0).toUpperCase() + contentType.slice(1)}`, legacyId: newLegacyId };

    if (contentType === 'review' || contentType === 'article' || contentType === 'news') {
        let sanityCreator;
        const creatorTypeMap: Record<string, string> = { 'review': 'reviewer', 'article': 'author', 'news': 'reporter' };
        const sanityDocType = creatorTypeMap[contentType];
        const user = await prisma.user.findUnique({ where: { id: session.user.id }, select: { id: true, name: true, image: true } });
        if (!user || !user.name) throw new Error("User not found or name is missing.");
        
        const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityDocType}" && prismaUserId == $userId][0]`, { userId: session.user.id });
        if (existingCreator) {
            sanityCreator = existingCreator;
        } else {
            const newCreatorPayload: any = { _type: sanityDocType, _id: `${sanityDocType}-${session.user.id}`, name: user.name, prismaUserId: session.user.id };
            if (user.image) {
                try {
                    const imageAsset = await sanityWriteClient.assets.upload('image', user.image);
                    newCreatorPayload.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAsset._id }};
                } catch (e) { console.warn('Image upload on draft creation failed', e); }
            }
            sanityCreator = await sanityWriteClient.create(newCreatorPayload);
        }
        if (contentType === 'review' || contentType === 'article') { doc.authors = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
        if (contentType === 'news') { doc.reporters = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
    }
    
    if (contentType === 'review') { doc.score = 0; doc.verdict = '...'; doc.pros = []; doc.cons = []; }
    if (contentType === 'news') doc.category = 'Industry';
    if (contentType === 'article') doc.publishedYear = new Date().getFullYear();
    if (contentType === 'gameRelease') { doc.releaseDate = new Date().toISOString().split('T')[0]; doc.synopsis = '...'; doc.platforms = []; }
    
    const result = await sanityWriteClient.create(doc, { autoGenerateArrayKeys: true });
    revalidatePath('/studio');
    return { _id: result._id, _type: result._type };
}

// ... (rest of the file remains the same)
export async function updateDocumentAction(docId: string, patchData: Record<string, any>) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) return { success: false, message: 'غير مصرح لك.' };

    const publicId = docId.replace('drafts.', '');
    const draftId = `drafts.${publicId}`;

    try {
        const tx = sanityWriteClient.transaction();
        const existingDraft = await sanityWriteClient.getDocument(draftId);

        if (existingDraft) {
            tx.patch(draftId, (p) => p.set(patchData));
        } else {
            const originalDoc = await sanityWriteClient.getDocument(publicId);
            if (!originalDoc) {
                // This case is unlikely but handled: creating a draft from scratch for a non-existent doc.
                const docTypeQuery = groq`*[_id == $id][0]._type`;
                const docType = await sanityWriteClient.fetch(docTypeQuery, { id: publicId });
                const newDoc = { _id: draftId, _type: docType, ...patchData };
                tx.create(newDoc);
            } else {
                // Create a new draft based on the published document, then apply the patch.
                const newDraftPayload = { ...originalDoc, ...patchData, _id: draftId };
                delete newDraftPayload._rev;
                delete newDraftPayload._updatedAt;
                delete newDraftPayload._createdAt;
                tx.create(newDraftPayload);
            }
        }

        await tx.commit({ autoGenerateArrayKeys: true });
        revalidatePath('/studio');
        return { success: true };

    } catch (error: any) {
        console.error("Error during document update:", error);
        return { success: false, message: error.message || "An unexpected error occurred during the save operation." };
    }
}


export async function deleteDocumentAction(docId: string): Promise<{ success: boolean; message?: string }> {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.roles) return { success: false, message: 'غير مصرح لك.' };
    const docToDelete = await sanityWriteClient.fetch(groq`*[_id == $docId][0]{_type}`, { docId });
    if (!docToDelete) return { success: false, message: 'Document not found.' };
    const userRoles = session.user.roles;
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const docType = docToDelete._type;
    const canDelete = isAdminOrDirector || (docType === 'review' && userRoles.includes('REVIEWER')) || (docType === 'article' && userRoles.includes('AUTHOR')) || (docType === 'news' && userRoles.includes('REPORTER'));
    if (!canDelete) return { success: false, message: 'Insufficient permissions.' };
    const result = await sanityWriteClient.delete(docId);
    if (result.results.length > 0) {
        revalidatePath('/studio');
        return { success: true };
    }
    return { success: false, message: 'Could not be deleted.' };
}

export async function searchCreatorsAction(query: string, roleName: 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER'): Promise<{ _id: string; name: string }[]> {
    const usersWithRole = await prisma.user.findMany({ where: { roles: { some: { name: roleName } }, name: { contains: query, mode: 'insensitive' } }, select: { id: true }, take: 10 });
    if (usersWithRole.length === 0) return [];
    const prismaUserIds = usersWithRole.map(u => u.id);
    const sanityTypeMap = { REVIEWER: 'reviewer', AUTHOR: 'author', REPORTER: 'reporter', DESIGNER: 'designer' };
    const sanityType = sanityTypeMap[roleName];
    const sanityQuery = groq`*[_type == $sanityType && prismaUserId in $prismaUserIds]{_id, name}`;
    return await sanityWriteClient.fetch(sanityQuery, { sanityType, prismaUserIds });
}

export async function publishDocumentAction(docId: string, publishTime?: string | null): Promise<{ success: boolean; updatedDocument?: any; message?: string }> {
    const session = await getServerSession(authOptions);
    const userRoles = session?.user?.roles || [];
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const doc = await sanityWriteClient.fetch(groq`*[_id == $docId || _id == 'drafts.' + $docId][0]{_id, _type, "slug": slug.current}`, { docId });
    if (!doc) return { success: false, message: 'Document not found.' };
    
    const docType = doc._type;
    if (docType === 'gameRelease') return { success: false, message: 'Releases do not support publishing.' };

    const canPublish = isAdminOrDirector || (docType === 'review' && userRoles.includes('REVIEWER')) || (docType === 'article' && userRoles.includes('AUTHOR')) || (docType === 'news' && userRoles.includes('REPORTER'));
    if (!canPublish) return { success: false, message: 'صلاحيات غير كافية.' };

    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;

        // UNPUBLISH action
        if (publishTime === null) {
            const tx = sanityWriteClient.transaction();
            tx.delete(publicId);
            tx.patch(draftId, (p) => p.unset(['publishedAt']));
            await tx.commit({ returnDocuments: false });

            const contentTypePlural = docType === 'news' ? 'news' : `${docType}s`;
            revalidatePath(`/${contentTypePlural}`);
            revalidatePath(`/${contentTypePlural}/${doc.slug}`);
            revalidatePath('/studio');

            // Fetch the updated draft to return to the client
            const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: draftId });
            const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
            return { success: true, updatedDocument: docWithTiptap, message: 'Document successfully unpublished.' };
        }

        // PUBLISH action
        const finalTime = publishTime || new Date().toISOString();
        const draft = await sanityWriteClient.getDocument(draftId);

        if (draft) {
            const publishedDoc = { ...draft, _id: publicId, publishedAt: finalTime };
            const tx = sanityWriteClient.transaction();
            tx.createOrReplace(publishedDoc);
            tx.delete(draftId);
            await tx.commit({ returnDocuments: false });
        } else {
            await sanityWriteClient.patch(publicId).set({ publishedAt: finalTime }).commit();
        }

        revalidatePath('/studio');
        if (new Date(finalTime) <= new Date()) {
            const contentTypePlural = docType === 'news' ? 'news' : `${docType}s`;
            revalidatePath(`/${contentTypePlural}`);
            revalidatePath(`/${contentTypePlural}/${doc.slug}`);
        }

        // Fetch the newly published document to return to the client
        const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId });
        const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
        return { success: true, updatedDocument: docWithTiptap, message: 'Document published successfully.' };

    } catch (error) {
        console.error('Failed to publish/unpublish document:', error);
        return { success: false, message: 'Failed to commit publication status.' };
    }
}

export async function searchGamesAction(query: string): Promise<{_id: string, title: string}[]> {
    if (query.length < 2) return [];
    try {
        const results = await sanityWriteClient.fetch(groq`*[_type == "game" && title match $query + "*"][0...10]{_id, title}`, { query });
        return results;
    } catch (error) { console.error("Game search failed:", error); return []; }
}

export async function createGameAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.roles.some(role => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try {
        const newGame = await sanityWriteClient.create({ _type: 'game', title, slug: { _type: 'slug', current: slugify(title, { lower: true, separator: '-' }) } });
        return { _id: newGame._id, title: newGame.title };
    } catch (error) { console.error("Failed to create game:", error); return null; }
}

export async function searchTagsAction(query: string): Promise<{_id: string, title: string}[]> {
    if (query.length < 1) return [];
    try {
        const results = await sanityWriteClient.fetch(groq`*[_type == "tag" && title match $query + "*"][0...10]{_id, title}`, { query });
        return results;
    } catch (error) { console.error("Tag search failed:", error); return []; }
}

export async function createTagAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id || !session.user.roles.some(role => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try {
        const newTag = await sanityWriteClient.create({ _type: 'tag', title, slug: { _type: 'slug', current: slugify(title) } });
        return { _id: newTag._id, title: newTag.title };
    } catch (error) { console.error("Failed to create tag:", error); return null; }
}

export async function getRecentTagsAction(): Promise<{_id: string, title: string}[]> {
    try {
        const results = await sanityWriteClient.fetch(groq`*[_type == "tag"] | order(_createdAt desc)[0...50]{_id, title}`);
        return results;
    } catch (error) { console.error("Recent tags fetch failed:", error); return []; }
}

export async function validateSlugAction(slug: string, docId: string): Promise<{ isValid: boolean; message: string }> {
    // --- THE DEFINITIVE FIX: Add a guard clause ---
    if (!docId) {
        // This can happen briefly on new doc creation. Silently fail validation until docId is available.
        return { isValid: false, message: 'Waiting for document ID...' };
    }
    
    if (!slug || slug.trim() === '') {
        return { isValid: false, message: 'المُعرِّف لا يمكن أن يكون فارغًا.' };
    }
    const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    if (!slugRegex.test(slug)) {
        return { isValid: false, message: 'يمكن أن يحتوي المُعرِّف على أحرف وأرقام وشرطات فقط.' };
    }
    
    const query = groq`!defined(*[
        _type in ["review", "article", "news", "gameRelease"] &&
        slug.current == $slug &&
        !(_id in [$draftId, $publicId])
    ][0])`;
    
    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;
        
        const isUnique = await sanityWriteClient.fetch(query, { slug, draftId, publicId });
        
        if (isUnique) {
            return { isValid: true, message: 'المُعرِّف صالح.' };
        }
        return { isValid: false, message: 'هذا المُعرِّف مستخدم بالفعل.' };

    } catch (error) {
        console.error('Sanity slug validation failed:', error);
        return { isValid: false, message: 'فشل التحقق بسبب خطأ في الخادم.' };
    }
}

--- END OF FILE app/studio/actions.ts ---

================================================================================

--- START OF FILE app/studio/page.tsx ---

// app/studio/page.tsx

import { createClient } from 'next-sanity';
import { groq } from 'next-sanity';
import { StudioDashboard } from './StudioDashboard';
import { projectId, dataset, apiVersion } from '@/lib/sanity.client';
import { unstable_noStore as noStore } from 'next/cache';
import { getServerSession } from 'next-auth';
import { authOptions } from '../api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';

const studioClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN,
});

const allEditableContentQuery = groq`
*[_type in $allowedTypes] | order(_updatedAt desc) {
    _id,
    _type,
    _updatedAt,
    title,
    "slug": slug.current,
    "status": select(
        _type == "gameRelease" => "published",
        defined(publishedAt) && publishedAt < now() => "published",
        !defined(publishedAt) => "draft",
        "scheduled"
    ),
    "imageUrl": mainImage.asset->url,
    "blurDataURL": mainImage.asset->metadata.lqip
}
`;

export default async function StudioPage() {
    noStore();
    
    const session = await getServerSession(authOptions);
    const userRoles = session?.user?.roles || [];
    
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const allowedContentTypes: string[] = [];

    if (isAdminOrDirector) {
        allowedContentTypes.push('review', 'article', 'news', 'gameRelease');
    } else {
        if (userRoles.includes('REVIEWER')) allowedContentTypes.push('review');
        if (userRoles.includes('AUTHOR')) allowedContentTypes.push('article');
        if (userRoles.includes('REPORTER')) allowedContentTypes.push('news');
    }
    
    if (allowedContentTypes.length === 0 && !userRoles.includes('DESIGNER')) {
        redirect('/'); 
    }

    const content = allowedContentTypes.length > 0
        ? await studioClient.fetch(allEditableContentQuery, { allowedTypes: allowedContentTypes })
        : [];

    return (
        <main>
            <StudioDashboard initialContent={content} userRoles={userRoles} />
        </main>
    );
}




--- END OF FILE app/studio/page.tsx ---

================================================================================

--- START OF FILE app/studio/director/EditRolesModal.tsx ---

// app/studio/director/EditRolesModal.tsx

'use client';

import { useState, useTransition, useMemo, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import { updateUserRolesAction } from './actions';
import { useToast } from '@/lib/toastStore';
import type { User, Role } from '@prisma/client';
import modalStyles from '@/components/modals/Modals.module.css'; // <-- THE FIX: Import shared modal styles

type UserWithRoles = User & { roles: { name: string }[] };

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export function EditRolesModal({ user, allRoles, onClose, onUpdate }: { user: UserWithRoles, allRoles: Role[], onClose: () => void, onUpdate: (userId: string, newRoles: Role[]) => void }) {
    const [selectedRoleIds, setSelectedRoleIds] = useState<Set<number>>(() => new Set(user.roles.map(r => allRoles.find(ar => ar.name === r.name)!.id)));
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    const [isMounted, setIsMounted] = useState(false); // <-- THE FIX: State for portal hydration

    useEffect(() => {
        setIsMounted(true);
    }, []);

    const manageableRoles = useMemo(() => allRoles.filter(role => role.name !== 'USER'), [allRoles]);
    const userRoleId = useMemo(() => allRoles.find(role => role.name === 'USER')?.id, [allRoles]);

    const handleRoleToggle = (roleId: number) => {
        setSelectedRoleIds(prev => {
            const newSet = new Set(prev);
            if (newSet.has(roleId)) {
                newSet.delete(roleId);
            } else {
                newSet.add(roleId);
            }
            return newSet;
        });
    };

    const handleSave = () => {
        startTransition(async () => {
            const finalRoleIds = new Set(selectedRoleIds);
            if (userRoleId) {
                finalRoleIds.add(userRoleId);
            }

            const result = await updateUserRolesAction(user.id, Array.from(finalRoleIds));
            if (result.success && result.updatedRoles) {
                onUpdate(user.id, result.updatedRoles);
                toast.success(`Roles for ${user.name} updated.`);
                onClose();
            } else {
                toast.error(result.message || 'فشل تحديث الأدوار.');
            }
        });
    };

    // --- THE FIX: The entire modal is now structured for portal rendering ---
    const modalContent = (
        <AnimatePresence>
            <motion.div
                className={modalStyles.modalOverlay}
                onClick={onClose}
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
            >
                <motion.div
                    className={modalStyles.modalContent}
                    variants={modalVariants}
                    initial="hidden"
                    animate="visible"
                    exit="exit"
                    onClick={(e) => e.stopPropagation()}
                >
                    <h3 style={{ marginTop: 0 }}>Edit Roles for {user.name}</h3>
                    <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem' }}>حدد الأدوار التي يجب أن يمتلكها هذا المستخدم.</p>
                    <div className="roles-checklist" style={{ 
                        display: 'grid', 
                        gridTemplateColumns: '1fr 1fr', 
                        gap: '1rem', 
                        margin: '2rem 0' 
                    }}>
                        {manageableRoles.map(role => (
                            <label key={role.id} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', cursor: 'pointer', fontFamily: 'var(--font-ui)' }}>
                                <input
                                    type="checkbox"
                                    checked={selectedRoleIds.has(role.id)}
                                    onChange={() => handleRoleToggle(role.id)}
                                    style={{ width: '1.6rem', height: '1.6rem' }}
                                />
                                <span style={{ fontWeight: role.name === 'DIRECTOR' ? 700 : 500, color: role.name === 'DIRECTOR' ? 'gold' : 'inherit' }}>
                                    {role.name}
                                </span>
                            </label>
                        ))}
                    </div>
                    <div className={modalStyles.modalActions}>
                        <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                        <button onClick={handleSave} className="primary-button" disabled={isPending}>
                            {isPending ? 'جار الحفظ...' : 'حفظ التغييرات'}
                        </button>
                    </div>
                </motion.div>
            </motion.div>
        </AnimatePresence>
    );

    if (!isMounted) {
        return null;
    }

    return createPortal(modalContent, document.body);
}




--- END OF FILE app/studio/director/EditRolesModal.tsx ---

================================================================================

--- START OF FILE app/studio/director/UserManagementClient.tsx ---

// app/studio/director/UserManagementClient.tsx

'use client';

import { useState, useMemo } from 'react';
import Image from 'next/image';
import { AnimatePresence, motion } from 'framer-motion';
import { EditRolesModal } from './EditRolesModal';
import type { User, Role } from '@prisma/client';

// Define a more specific type for the user object with roles included
type UserWithRoles = User & { roles: { name: string }[] };

const UserRow = ({ user, allRoles, onEdit }: { user: UserWithRoles, allRoles: Role[], onEdit: (user: UserWithRoles) => void }) => {
    // Determine user's current roles for display
    const currentRoleNames = user.roles.map(r => r.name);
    // Remove "USER" if other roles are present, and display only badges (Director, Reviewer, etc.)
    const rolesToDisplay = currentRoleNames.filter(name => name !== 'USER').sort();
    
    // Fallback if no roles other than USER are assigned
    const displayString = rolesToDisplay.length > 0 ? rolesToDisplay.join(', ') : 'User (Default)';
    
    return (
        <motion.div
            layout
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="user-row"
        >
            <div className="user-info">
                <Image src={user.image || '/default-avatar.svg'} alt={user.name || 'avatar'} width={40} height={40} className="user-avatar" />
                <div>
                    <p className="user-name">{user.name}</p>
                    <p className="user-email">{user.email}</p>
                </div>
            </div>
            <div className="user-roles">
                <span className="roles-badge">{displayString}</span>
            </div>
            <div className="user-actions">
                <button className="outline-button" onClick={() => onEdit(user)}>تعديل الأدوار</button>
            </div>
        </motion.div>
    );
};


export function UserManagementClient({ initialUsers, allRoles }: { initialUsers: UserWithRoles[], allRoles: Role[] }) {
    const [users, setUsers] = useState<UserWithRoles[]>(initialUsers);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedUser, setSelectedUser] = useState<UserWithRoles | null>(null);

    const filteredUsers = useMemo(() => {
        if (!searchTerm) return users;
        return users.filter(u =>
            u.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
            u.email?.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [users, searchTerm]);

    const handleUpdateUserRoles = (userId: string, newRoles: Role[]) => {
        setUsers(currentUsers => currentUsers.map(u => 
            u.id === userId ? { ...u, roles: newRoles.map(r => ({ name: r.name })) } : u
        ));
    };

    return (
        <>
            <style jsx>{`
                .user-management-container { max-width: 960px; margin: 0 auto; }
                .search-input { width: 100%; margin-bottom: 2rem; }
                .user-list-header, .user-row { 
                    display: grid; 
                    grid-template-columns: 2fr 1.5fr 0.5fr; 
                    align-items: center; 
                    gap: 1rem; 
                    padding: 1rem; 
                    border-bottom: 1px solid var(--border-color); 
                }
                .user-list-header { font-weight: 600; color: var(--text-secondary); font-family: var(--font-ui); }
                .user-info { display: flex; align-items: center; gap: 1rem; }
                .user-name { font-weight: 600; margin: 0; }
                .user-email { font-size: 1.4rem; color: var(--text-secondary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
                .roles-badge { 
                    background-color: var(--bg-secondary); 
                    padding: 0.4rem 0.8rem; 
                    border-radius: 6px; 
                    font-size: 1.3rem; 
                    border: 1px solid var(--border-color); 
                    white-space: nowrap; 
                    overflow: hidden; 
                    text-overflow: ellipsis;
                }
                .user-actions { text-align: right; }
            `}</style>
            <div className="user-management-container">
                <input
                    type="search"
                    placeholder="ابحث بالاسم أو البريد الإلكتروني..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="profile-input search-input"
                />
                <div className="user-list">
                    <div className="user-list-header">
                        <span>المستخدم</span>
                        <span>الأدوار</span>
                        <span></span>
                    </div>
                    <AnimatePresence>
                        {filteredUsers.map(user => (
                            <UserRow key={user.id} user={user} allRoles={allRoles} onEdit={setSelectedUser} />
                        ))}
                    </AnimatePresence>
                </div>
            </div>
            
            <AnimatePresence>
                {selectedUser && (
                    <EditRolesModal
                        user={selectedUser}
                        allRoles={allRoles}
                        onClose={() => setSelectedUser(null)}
                        onUpdate={handleUpdateUserRoles}
                    />
                )}
            </AnimatePresence>
        </>
    );
}

















--- END OF FILE app/studio/director/UserManagementClient.tsx ---

================================================================================

--- START OF FILE app/studio/director/actions.ts ---

// app/studio/director/actions.ts

'use server';

import { getServerSession } from "next-auth";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import prisma from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { Role } from "@prisma/client";
import { sanityWriteClient } from "@/lib/sanity.server";

const ROLE_TO_SANITY_TYPE: Record<string, string> = {
    REVIEWER: 'reviewer',
    AUTHOR: 'author',
    REPORTER: 'reporter',
    DESIGNER: 'designer',
};

// This helper function creates or updates a specific creator type in Sanity
async function findOrCreateSanityCreator(userId: string, sanityType: string) {
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { id: true, name: true, image: true } });
    if (!user || !user.name) throw new Error('User details are incomplete.');

    const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityType}" && prismaUserId == $userId][0]`, { userId });

    if (existingCreator) {
        return; // Already exists, nothing to do.
    }

    const newCreator: any = {
        _type: sanityType,
        _id: `${sanityType}-${userId}`, // Create a predictable, unique ID
        name: user.name,
        prismaUserId: user.id,
    };
    
    if (user.image) {
        try {
            const imageAsset = await sanityWriteClient.assets.upload('image', user.image);
            newCreator.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAsset._id } };
        } catch (e) {
            console.warn(`Could not upload user image to Sanity for ${user.name}:`, e);
        }
    }

    await sanityWriteClient.create(newCreator);
    console.log(`Created Sanity ${sanityType} for ${user.name}.`);
}

export async function updateUserRolesAction(userId: string, roleIds: number[]) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.roles.includes('DIRECTOR')) {
        return { success: false, message: "غير مصرح لك." };
    }

    try {
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { roles: { set: roleIds.map(id => ({ id })) } },
            include: { roles: true }
        });

        // --- THE NEW LOGIC ---
        const userRoles = updatedUser.roles.map(r => r.name);
        
        for (const roleName of userRoles) {
            const sanityType = ROLE_TO_SANITY_TYPE[roleName];
            if (sanityType) {
                try {
                    await findOrCreateSanityCreator(userId, sanityType);
                } catch (sanityError: any) {
                    console.error(`Failed to sync Sanity ${sanityType} for user ${userId}:`, sanityError.message);
                }
            }
        }
        // --- END NEW LOGIC ---

        revalidatePath('/studio/director');
        revalidatePath(`/profile/${userId}`);
        if(updatedUser.username) {
            revalidatePath(`/creators/${updatedUser.username}`);
        }

        return { success: true, updatedRoles: updatedUser.roles as Role[] };
    } catch (error) {
        console.error("Failed to update user roles:", error);
        return { success: false, message: "A database error occurred." };
    }
}




--- END OF FILE app/studio/director/actions.ts ---

================================================================================

--- START OF FILE app/studio/director/page.tsx ---

// app/studio/director/page.tsx

import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import { UserManagementClient } from './UserManagementClient';
import { unstable_noStore as noStore } from 'next/cache';

export default async function DirectorPage() {
    noStore(); // Ensure data is always fresh

    const session = await getServerSession(authOptions);

    // Secure the route: only allow users with the 'DIRECTOR' role
    if (!session?.user?.roles.includes('DIRECTOR')) {
        redirect('/studio');
    }

    // Fetch all users and all available roles from the database
    const users = await prisma.user.findMany({
        include: {
            roles: {
                select: { name: true }
            }
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    const allRoles = await prisma.role.findMany();

    return (
        <div className="container page-container">
            <header style={{ textAlign: 'center', marginBottom: '3rem' }}>
                <h1 className="page-title">الإدارة</h1>
                <p className="sidebar-subtitle" style={{ fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto' }}>تعيين وإدارة الأدوار لجميع المستخدمين. تسري التغييرات في الجلسة التالية للمستخدم.</p>
            </header>
            <UserManagementClient initialUsers={users} allRoles={allRoles} />
        </div>
    );
}

















--- END OF FILE app/studio/director/page.tsx ---

================================================================================

--- START OF FILE app/studio/utils/portableTextToTiptap.ts ---

// app/studio/utils/portableTextToTiptap.ts

import { PortableTextBlock } from 'sanity';

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
    type: string;
    attrs?: Record<string, any>;
    content?: TiptapNode[];
    text?: string;
    marks?: { type: string; attrs?: Record<string, any> }[];
}

/**
 * Converts a Sanity Portable Text array to Tiptap's JSON format.
 * @param blocks The array of Portable Text blocks from Sanity.
 * @returns A Tiptap-compatible JSON object representing the document content.
 */
export function portableTextToTiptap(blocks: PortableTextBlock[] = []): Record<string, any> {
    const content: TiptapNode[] = [];
    let currentList: TiptapNode | null = null;

    // --- THE DEFINITIVE FIX ---
    // Filter out any null/undefined items from the array that can result from
    // broken references in Sanity, preventing a server-side crash.
    const validBlocks = (blocks || []).filter(Boolean);

    validBlocks.forEach((block) => {
        // --- HANDLE LIST ITEMS ---
        if (block.listItem === 'bullet') {
            if (!currentList) {
                currentList = { type: 'bulletList', content: [] };
            }
            const listItemContent = processBlockChildren(block);
            currentList.content?.push({
                type: 'listItem',
                content: [{ type: 'paragraph', content: listItemContent }],
            });
            return; // Continue to next block
        }

        if (currentList) {
            content.push(currentList);
            currentList = null;
        }

        // --- HANDLE CUSTOM BLOCKS ---
        if (block._type === 'imageCompare') {
            const { image1, image2, size } = block as any;
            content.push({ type: 'imageCompare', attrs: { src1: image1?.asset?.url, assetId1: image1?.asset?._id, src2: image2?.asset?.url, assetId2: image2?.asset?._id, 'data-size': size || 'large' } });
            return;
        }
        if (block._type === 'twoImageGrid') {
            const { image1, image2 } = block as any;
            content.push({ type: 'twoImageGrid', attrs: { src1: image1?.asset?.url, assetId1: image1?.asset?._id, src2: image2?.asset?.url, assetId2: image2?.asset?._id } });
            return;
        }
        if (block._type === 'fourImageGrid') {
            const { image1, image2, image3, image4 } = block as any;
            content.push({ type: 'fourImageGrid', attrs: { src1: image1?.asset?.url, assetId1: image1?.asset?._id, src2: image2?.asset?.url, assetId2: image2?.asset?._id, src3: image3?.asset?.url, assetId3: image3?.asset?._id, src4: image4?.asset?.url, assetId4: image4?.asset?._id } });
            return;
        }
        if (block._type === 'image' && block.asset) {
            const asset = block.asset as any;
            const size = (block as any).size || 'large';
            if (asset?._id && asset?.url) {
                content.push({ type: 'image', attrs: { src: asset.url, assetId: asset._id, 'data-size': size } });
            }
            return;
        }
        
        // --- HANDLE TEXT BLOCKS ---
        if (block._type === 'block' && block.style) {
            const children = processBlockChildren(block);
            switch (block.style) {
                case 'h2':
                    content.push({ type: 'heading', attrs: { level: 2 }, content: children });
                    break;
                case 'blockquote':
                    content.push({ type: 'blockquote', content: [{ type: 'paragraph', content: children }] });
                    break;
                default:
                    content.push({ type: 'paragraph', content: children });
            }
        }
    });

    if (currentList) {
        content.push(currentList);
    }

    return { type: 'doc', content };
}

function processBlockChildren(block: PortableTextBlock): TiptapNode[] {
    return block.children?.map(span => {
        const marks = span.marks?.map(mark => {
            const markDef = block.markDefs?.find(def => def._key === mark);
            if (markDef?._type === 'link') {
                return { type: 'link', attrs: { href: markDef.href } };
            }
            if (mark === 'strong') return { type: 'bold' };
            if (mark === 'em') return { type: 'italic' };
            return null;
        }).filter(Boolean) as { type: string }[] || [];
        return { type: 'text', text: span.text, marks };
    }) || [];
}




--- END OF FILE app/studio/utils/portableTextToTiptap.ts ---

================================================================================

--- START OF FILE app/studio/utils/tiptapToPortableText.ts ---

// app/studio/utils/tiptapToPortableText.ts

import { v4 as uuidv4 } from 'uuid';

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
    type: string;
    attrs?: Record<string, any>;
    content?: TiptapNode[];
    text?: string;
    marks?: { type: string; attrs?: Record<string, any> }[];
}

/**
 * Converts a Tiptap JSON object to a Sanity Portable Text array.
 * @param tiptapJSON The Tiptap JSON object.
 * @returns An array of Portable Text blocks.
 */
export function tiptapToPortableText(tiptapJSON: TiptapNode): any[] {
    if (!tiptapJSON || tiptapJSON.type !== 'doc' || !tiptapJSON.content) {
        return [];
    }

    const portableTextBlocks: any[] = [];

    tiptapJSON.content.forEach((node) => {
        // --- IMAGE COMPARE ---
        if (node.type === 'imageCompare') {
            const { assetId1, assetId2, 'data-size': size } = node.attrs || {};
            portableTextBlocks.push({
                _type: 'imageCompare',
                _key: uuidv4(),
                image1: assetId1 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId1 } } : undefined,
                image2: assetId2 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId2 } } : undefined,
                size: size || 'large',
            });
            return;
        }

        // --- TWO IMAGE GRID ---
        if (node.type === 'twoImageGrid') {
            const { assetId1, assetId2 } = node.attrs || {};
            portableTextBlocks.push({
                _type: 'twoImageGrid',
                _key: uuidv4(),
                image1: assetId1 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId1 } } : undefined,
                image2: assetId2 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId2 } } : undefined,
            });
            return;
        }

        // --- FOUR IMAGE GRID ---
        if (node.type === 'fourImageGrid') {
            const { assetId1, assetId2, assetId3, assetId4 } = node.attrs || {};
            portableTextBlocks.push({
                _type: 'fourImageGrid',
                _key: uuidv4(),
                image1: assetId1 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId1 } } : undefined,
                image2: assetId2 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId2 } } : undefined,
                image3: assetId3 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId3 } } : undefined,
                image4: assetId4 ? { _type: 'image', asset: { _type: 'reference', _ref: assetId4 } } : undefined,
            });
            return;
        }

        // --- IMAGE (DEFINITIVE FIX) ---
        if (node.type === 'image') {
            // Prioritize the assetId attribute, which is the source of truth.
            const assetId = node.attrs?.assetId;
            if (assetId) {
                portableTextBlocks.push({
                    _type: 'image',
                    _key: uuidv4(),
                    asset: { _type: 'reference', _ref: assetId },
                });
            }
            // Fallback for pasted/dragged images that might still be processing, though less likely now.
            else if (node.attrs?.src) {
                 // Attempt to parse assetId from a Sanity CDN URL
                 const matches = node.attrs.src.match(/image-([a-fA-F0-9]+-[0-9]+x[0-9]+-[a-z]+)/);
                 if (matches && matches[1]) {
                     const parsedId = `image-${matches[1]}`;
                     portableTextBlocks.push({
                         _type: 'image',
                         _key: uuidv4(),
                         asset: { _type: 'reference', _ref: parsedId },
                     });
                 }
            }
            return;
        }

        // --- BULLET LISTS ---
        if (node.type === 'bulletList') {
            node.content?.forEach(listItem => {
                const paragraph = listItem.content?.[0];
                if (paragraph && paragraph.type === 'paragraph') {
                    const block = processTextBlock(paragraph);
                    if (block) {
                        block.level = 1;
                        block.listItem = 'bullet';
                        portableTextBlocks.push(block);
                    }
                }
            });
            return;
        }
        
        // --- STANDARD TEXT BLOCKS ---
        const block = processTextBlock(node);
        if (block) {
            portableTextBlocks.push(block);
        }
    });

    return portableTextBlocks;
}

// Helper function to process paragraphs, headings, blockquotes
function processTextBlock(node: TiptapNode): any | null {
    if (!node.content && node.type !== 'paragraph') return null;

    const block: any = {
        _type: 'block',
        _key: uuidv4(),
        children: [],
        markDefs: [],
    };

    switch (node.type) {
        case 'heading':
            block.style = `h${node.attrs?.level || 2}`;
            break;
        case 'blockquote':
            block.style = 'blockquote';
            break;
        default:
            block.style = 'normal';
    }

    (node.content || []).forEach(span => {
        if (span.type !== 'text' || typeof span.text === 'undefined') return;

        const spanMarks: string[] = [];
        span.marks?.forEach(mark => {
            if (mark.type === 'bold') spanMarks.push('strong');
            if (mark.type === 'italic') spanMarks.push('em');
            if (mark.type === 'link') {
                const markDef = { _key: uuidv4(), _type: 'link', href: mark.attrs?.href };
                block.markDefs.push(markDef);
                spanMarks.push(markDef._key);
            }
        });

        block.children.push({
            _type: 'span',
            _key: uuidv4(),
            text: span.text,
            marks: spanMarks,
        });
    });

    if (block.children.length === 0) {
        block.children.push({ _type: 'span', _key: uuidv4(), text: '', marks: [] });
    }

    return block;
}

--- END OF FILE app/studio/utils/tiptapToPortableText.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

/* app/studio/[contentType]/[id]/BlockToolbar.module.css */

.blockToolbarContainer {
    position: fixed; /* THE FIX: Lock to viewport */
    bottom: 1rem;
    left: 10rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}

.optionButtonWrapper {
    position: relative;
}

.optionButton {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 46px;
    height: 46px;
}

.optionTooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 0.75rem;
    padding: 0.4rem 0.8rem;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    transform-origin: bottom center;
}

.optionButtonWrapper:hover .optionTooltip {
    opacity: 1;
    transform: translateY(-5px) translateX(-50%);
}




--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

// app/studio/[contentType]/[id]/BlockToolbar.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion } from 'framer-motion';
import { CompareIcon, TwoImageIcon, FourImageIcon, SingleImageIcon } from '../../StudioIcons';
import { QualityToggle } from './editor-components/QualityToggle';
import { UploadQuality } from '@/lib/image-optimizer';
import styles from './BlockToolbar.module.css';
import bubbleStyles from './Editor.module.css';

interface BlockToolbarProps {
    editor: Editor | null;
    onFileUpload: (file: File) => void;
    uploadQuality: UploadQuality;
    onUploadQualityChange: (quality: UploadQuality) => void;
}

const TooltipButton = ({ onClick, title, children, disabled }: { onClick: () => void, title: string, children: React.ReactNode, disabled?: boolean }) => (
    <div className={styles.optionButtonWrapper}>
        <motion.button 
            onClick={onClick} 
            className={`${bubbleStyles.bubbleMenuButton} ${styles.optionButton}`}
            whileHover={{ scale: 1.1 }} 
            whileTap={{ scale: 0.9 }} 
            title={title}
            disabled={disabled}
        >
            {children}
        </motion.button>
        <div className={styles.optionTooltip}>{title}</div>
    </div>
);

export function BlockToolbar({ editor, onFileUpload, uploadQuality, onUploadQualityChange }: BlockToolbarProps) {
    const addBlock = (type: 'image' | 'imageCompare' | 'twoImageGrid' | 'fourImageGrid') => {
        if (!editor) return;
        if (type === 'image') {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = (e.target as HTMLInputElement).files?.[0];
                if (file) { onFileUpload(file); }
            };
            input.click();
        } else {
            editor.chain().focus().insertContent({ type }).run();
        }
    };

    return (
        <motion.div 
            className={styles.blockToolbarContainer}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
            transition={{ type: 'spring', stiffness: 300, damping: 25 }}
        >
            <TooltipButton onClick={() => addBlock('image')} title="صورة واحدة" disabled={!editor}><SingleImageIcon /></TooltipButton>
            <TooltipButton onClick={() => addBlock('imageCompare')} title="مقارنة صور" disabled={!editor}><CompareIcon /></TooltipButton>
            <TooltipButton onClick={() => addBlock('twoImageGrid')} title="شبكة صورتين" disabled={!editor}><TwoImageIcon /></TooltipButton>
            <TooltipButton onClick={() => addBlock('fourImageGrid')} title="شبكة 4 صور" disabled={!editor}><FourImageIcon /></TooltipButton>
            <div style={{ width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.4rem' }} />
            <QualityToggle currentQuality={uploadQuality} onQualityChange={onUploadQualityChange} />
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

/* app/studio/[contentType]/[id]/Editor.module.css (COMPLETE AND CORRECTED) */

.editorHeader { position: relative; z-index: 10; height: 60px; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; width: 100%; flex-shrink: 0; }
.headerLeft, .headerRight { display: flex; align-items: center; gap: 1rem; }
.exitButton { display: flex; align-items: center; gap: 0.75rem; padding: 0.6rem 1.2rem; border-radius: 6px; font-family: var(--font-main); font-weight: 500; font-size: 1.5rem; color: var(--text-secondary); background-color: transparent; border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-out; }
.exitButton:hover { background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); }
.documentStatus { font-family: var(--font-main); font-size: 1.4rem; padding: 0.4rem 1rem; border-radius: 999px; font-weight: 500; }
.statusDraft { background-color: color-mix(in srgb, var(--text-secondary) 15%, transparent); color: var(--text-secondary); }
.statusPublished { background-color: color-mix(in srgb, #16A34A 15%, transparent); color: #16A34A; }
.statusScheduled { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); }
.sanctumContainer { width: 100vw; height: 100vh; background-color: var(--bg-primary); overflow: hidden; display: flex; flex-direction: column; }
.sanctumMain { display: flex; flex-grow: 1; height: calc(100% - 60px); }
.sanctumSidebar { background-color: var(--bg-secondary); border-left: 1px solid var(--border-color); flex-shrink: 0; height: 100%; overflow-y: auto; display: flex; flex-direction: column; }
.sidebarContent { padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
.sidebarTitle { font-family: var(--font-main); font-size: 2rem; margin: 0; color: var(--text-primary); }
.sidebarSubtitle { font-family: var(--font-main); color: var(--text-secondary); margin-top: 0.25rem; font-size: 1.4rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.sidebarSection { padding: 1.5rem; }
.sidebarLabel { display: block; font-family: var(--font-main); font-size: 1.3rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; }
.sidebarInput { width: 100%; background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.8rem 1rem; font-family: var(--font-main); font-size: 1.5rem; color: var(--text-primary); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
.sidebarInput:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent); }
.sidebarFooter { margin-top: auto; padding: 1.5rem; border-top: 1px solid var(--border-color); background-color: var(--bg-secondary); display: flex; justify-content: center; align-items: center; }
.sanctumCanvas { flex-grow: 1; height: 100%; overflow-y: auto; background-color: var(--bg-primary); min-width: 0; }
.canvasContent { max-width: 960px; margin: 0 auto; padding: 4rem 2rem 8rem 2rem; }
.canvasTitleInput { font-family: var(--font-main); font-size: 4.8rem; font-weight: 800; line-height: 1.2; color: var(--text-primary); border: none; background: none; outline: none; width: 100%; padding: 0; margin-bottom: 3rem; text-align: right; }
.canvasTitleInput::placeholder { color: var(--border-color); }
.canvasTitleInput:focus { box-shadow: 0 2px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent); border-radius: 4px; }
.canvasEditorWrapper { position: relative; padding: 3rem; border: 1px solid var(--border-color); border-radius: 12px; background-color: var(--bg-secondary); box-shadow: 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); transition: border-color 0.3s ease, box-shadow 0.3s ease; }
.canvasEditorWrapper:focus-within { border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent), 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); }
.tiptap { outline: none; text-align: right; }
.tiptap > * + * { margin-top: 1.25em; }
.tiptap h2 { font-family: var(--font-main), sans-serif; font-size: 2.8rem; line-height: 1.2; margin: 4rem 0 2rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
.tiptap p.is-editor-empty:first-child::before { content: attr(data-placeholder); float: right; color: var(--text-secondary); opacity: 0.7; pointer-events: none; height: 0; }
.formattingToolbar { position: absolute; display: flex; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--text-primary) 15%, transparent); padding: 0.4rem; z-index: 10; transform: translateX(-100%); }
.bubbleMenuButton { display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 6px; background-color: transparent; border: none; cursor: pointer; color: var(--text-secondary); transition: background-color 0.15s ease-out, color 0.15s ease-out; }
.bubbleMenuButton:hover { background-color: var(--bg-primary); color: var(--accent); }
.bubbleMenuButton.active { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); }
.sanctumSidebarToggle { display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 6px; background-color: transparent; border: 1px solid transparent; color: var(--text-secondary); cursor: pointer; transition: all 0.2s ease-out; }
.sanctumSidebarToggle:hover { background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); }

.tiptap .image-node-container,
.tiptap .image-compare-container,
.tiptap .image-grid-container {
    position: relative;
}

.image-node-menu {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem; /* For RTL */
    z-index: 5;
    display: flex;
    gap: 0.5rem;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    backdrop-filter: blur(4px);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.4rem;
}
.deleteButton:hover { background-color: color-mix(in srgb, #DC2626 15%, transparent); color: #DC2626; }

.tiptap .image-node-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-node-container { box-shadow: 0 0 0 3px var(--accent); }
.tiptap img { max-width: 100%; height: auto; border-radius: 8px; display: block; }
.image-node-container[data-size="small"] { max-width: 33.33%; margin-left: auto; margin-right: auto; }
.image-node-container[data-size="medium"] { max-width: 66.66%; margin-left: auto; margin-right: auto; }
.image-node-container[data-size="large"] { max-width: 100%; }

.tiptap .image-compare-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-compare-container { box-shadow: 0 0 0 3px var(--accent); }
.image-compare-container[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="large"] { max-width: 100%; }

.image-grid-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; padding: 1rem; border: 1px solid var(--border-color); background: var(--bg-primary); }
.tiptap .ProseMirror-selectednode .image-grid-container { box-shadow: 0 0 0 3px var(--accent); }

--- END OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

// app/studio/[contentType]/[id]/EditorCanvas.tsx
'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Editor } from '@tiptap/react';
// BlockToolbar is no longer imported or rendered here
import styles from './Editor.module.css';

const RichTextEditor = dynamic(() => import('./RichTextEditor'), { ssr: false, loading: () => <div className={styles.canvasBodyPlaceholder}><p>جارٍ تحميل المحرر...</p></div> });

interface EditorCanvasProps { document: any; title: string; onTitleChange: (newTitle: string) => void; onEditorCreated: (editor: Editor) => void; editor: Editor | null; }

export function EditorCanvas({ document, title, onTitleChange, onEditorCreated, editor }: EditorCanvasProps) {
    const isRelease = document._type === 'gameRelease';
    return (
        <motion.div className={styles.sanctumCanvas} style={{position: 'relative'}} transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}>
            <div className={styles.canvasContent}>
                <input type="text" value={title} onChange={(e) => onTitleChange(e.target.value)} placeholder="إصدار غير معنون" className={styles.canvasTitleInput} />
                
                <div className={styles.canvasEditorWrapper}>
                    {isRelease ? (
                        <div style={{ minHeight: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', textAlign: 'center' }}>
                            <p>لا يوجد محتوى نصي للإصدارات.<br />يتم تحرير جميع البيانات من الشريط الجانبي.</p>
                        </div>
                    ) : (
                        <RichTextEditor onEditorCreated={onEditorCreated} initialContent={document.tiptapContent} />
                    )}
                </div>
            </div>
            
            {/* BlockToolbar has been moved to the parent EditorClient */}
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

// app/studio/[contentType]/[id]/EditorClient.tsx

'use client';
import { useState, useMemo, useEffect, useReducer, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { EditorSidebar } from './EditorSidebar';
import { EditorCanvas } from './EditorCanvas';
import { BlockToolbar } from './BlockToolbar';
import { Editor } from '@tiptap/react';
import { updateDocumentAction, publishDocumentAction, validateSlugAction } from '../../actions';
import { useToast } from '@/lib/toastStore';
import { useDebounce } from '@/hooks/useDebounce';
import Link from 'next/link';
import { uploadFile } from './RichTextEditor';
import { UploadQuality } from '@/lib/image-optimizer';
import { tiptapToPortableText } from '../../utils/tiptapToPortableText';
import styles from './Editor.module.css';

const SidebarToggleIcon = () => ( <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 18H3M21 12H3M21 6H3"/></svg> );
const ExitIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ transform: 'scaleX(-1)' }}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>;
const clientSlugify = (text: string): string => { if (!text) return ''; return text.toLowerCase().trim().replace(/[^a-z0-9\s-]/g, '').replace(/[\s-]+/g, '-'); };
const initialState = { _id: null, _type: null, title: '', slug: '', score: 0, verdict: '', pros: [], cons: [], game: null, tags: [], mainImage: { assetId: null, assetUrl: null }, authors: [], reporters: [], designers: [], publishedAt: null, isSlugManual: false, releaseDate: '', platforms: [], synopsis: '' };

function editorReducer(state: any, action: { type: string; payload: any }) {
    switch (action.type) {
        case 'INITIALIZE_STATE':
            return {
                ...action.payload,
                isSlugManual: !!action.payload.slug,
            };
        case 'UPDATE_FIELD':
            return { ...state, [action.payload.field]: action.payload.value };
        case 'UPDATE_SLUG':
            return { ...state, slug: clientSlugify(action.payload.slug), isSlugManual: action.payload.isManual };
        default:
            throw new Error(`Unhandled action type: ${action.type}`);
    }
}

const generateDiffPatch = (currentState: any, sourceOfTruth: any, editorContentJson: string) => {
    const patch: Record<string, any> = {};
    const normalize = (val: any, defaultVal: any) => val ?? defaultVal;
    const compareIds = (arr1: any[], arr2: any[]) => JSON.stringify(normalize(arr1, []).map(i => i._id).sort()) === JSON.stringify(normalize(arr2, []).map(i => i._id).sort());

    if (normalize(currentState.title) !== normalize(sourceOfTruth.title)) patch.title = currentState.title;
    if (normalize(currentState.slug) !== normalize(sourceOfTruth.slug?.current)) patch.slug = { _type: 'slug', current: currentState.slug };
    if (normalize(currentState.score, 0) !== normalize(sourceOfTruth.score, 0)) patch.score = currentState.score;
    if (normalize(currentState.verdict) !== normalize(sourceOfTruth.verdict)) patch.verdict = currentState.verdict;
    if (normalize(currentState.releaseDate) !== normalize(sourceOfTruth.releaseDate)) patch.releaseDate = currentState.releaseDate;
    if (normalize(currentState.synopsis) !== normalize(sourceOfTruth.synopsis)) patch.synopsis = currentState.synopsis;

    if (JSON.stringify(normalize(currentState.pros, [])) !== JSON.stringify(normalize(sourceOfTruth.pros, []))) patch.pros = currentState.pros;
    if (JSON.stringify(normalize(currentState.cons, [])) !== JSON.stringify(normalize(sourceOfTruth.cons, []))) patch.cons = currentState.cons;
    if (JSON.stringify(normalize(currentState.platforms, [])) !== JSON.stringify(normalize(sourceOfTruth.platforms, []))) patch.platforms = currentState.platforms;

    if (normalize(currentState.game?._id) !== normalize(sourceOfTruth.game?._id)) patch.game = currentState.game ? { _type: 'reference', _ref: currentState.game._id } : undefined;
    if (normalize(currentState.mainImage.assetId) !== normalize(sourceOfTruth.mainImage?._ref)) patch.mainImage = currentState.mainImage.assetId ? { _type: 'image', asset: { _type: 'reference', _ref: currentState.mainImage.assetId } } : undefined;
    
    if (!compareIds(currentState.tags, sourceOfTruth.tags)) patch.tags = normalize(currentState.tags, []).map((t: any) => ({ _type: 'reference', _ref: t._id, _key: t._id }));
    if (!compareIds(currentState.authors, sourceOfTruth.authors)) patch.authors = normalize(currentState.authors, []).map((a: any) => ({ _type: 'reference', _ref: a._id, _key: a._id }));
    if (!compareIds(currentState.reporters, sourceOfTruth.reporters)) patch.reporters = normalize(currentState.reporters, []).map((r: any) => ({ _type: 'reference', _ref: r._id, _key: r._id }));
    if (!compareIds(currentState.designers, sourceOfTruth.designers)) patch.designers = normalize(currentState.designers, []).map((d: any) => ({ _type: 'reference', _ref: d._id, _key: d._id }));

    const sourceContentJson = JSON.stringify(sourceOfTruth.tiptapContent || {});
    if (sourceOfTruth._type !== 'gameRelease' && editorContentJson !== sourceContentJson) {
        patch.content = tiptapToPortableText(JSON.parse(editorContentJson));
    }

    return patch;
};


export function EditorClient({ document: initialDocument }: { document: any }) {
    const [sourceOfTruth, setSourceOfTruth] = useState(initialDocument);
    const [state, dispatch] = useReducer(editorReducer, initialState);
    const { title, slug, isSlugManual } = state;
    const toast = useToast();
    const [isSidebarOpen, setIsSidebarOpen] = useState(true);
    const [editorInstance, setEditorInstance] = useState<Editor | null>(null);
    const [mainImageUploadQuality, setMainImageUploadQuality] = useState<UploadQuality>('1080p');
    const [blockUploadQuality, setBlockUploadQuality] = useState<UploadQuality>('1080p');
    const [slugValidationStatus, setSlugValidationStatus] = useState<'pending' | 'valid' | 'invalid'>('pending');
    const [slugValidationMessage, setSlugValidationMessage] = useState('جارٍ التحقق...');
    const debouncedSlug = useDebounce(slug, 500);
    const [editorContentJson, setEditorContentJson] = useState(JSON.stringify(initialDocument.tiptapContent || {}));
    
    const patch = useMemo(() => generateDiffPatch(state, sourceOfTruth, editorContentJson), [state, sourceOfTruth, editorContentJson]);
    const hasChanges = Object.keys(patch).length > 0;
    
    useEffect(() => {
        if (editorInstance) editorInstance.storage.uploadQuality = blockUploadQuality;
    }, [blockUploadQuality, editorInstance]);
    
    useEffect(() => {
        dispatch({ 
            type: 'INITIALIZE_STATE', 
            payload: { 
                _id: sourceOfTruth._id,
                _type: sourceOfTruth._type,
                title: sourceOfTruth.title ?? '', 
                slug: sourceOfTruth.slug?.current ?? '', 
                score: sourceOfTruth.score ?? 0, 
                verdict: sourceOfTruth.verdict ?? '', 
                pros: sourceOfTruth.pros ?? [], 
                cons: sourceOfTruth.cons ?? [], 
                game: sourceOfTruth.game || null, 
                publishedAt: sourceOfTruth.publishedAt || null, 
                mainImage: { assetId: sourceOfTruth.mainImage?._ref || null, assetUrl: sourceOfTruth.mainImage?.url || null }, 
                authors: (sourceOfTruth.authors || []).filter(Boolean), 
                reporters: (sourceOfTruth.reporters || []).filter(Boolean), 
                designers: (sourceOfTruth.designers || []).filter(Boolean), 
                tags: (sourceOfTruth.tags || []).filter(Boolean), 
                releaseDate: sourceOfTruth.releaseDate || '', 
                platforms: sourceOfTruth.platforms || [], 
                synopsis: sourceOfTruth.synopsis || '', 
            } 
        });

        if (editorInstance) {
            const editorJSON = JSON.stringify(editorInstance.getJSON());
            const sourceJSON = JSON.stringify(sourceOfTruth.tiptapContent || {});
            if (editorJSON !== sourceJSON) {
                editorInstance.commands.setContent(sourceOfTruth.tiptapContent, false);
            }
        }
    }, [sourceOfTruth, editorInstance]);
    
    useEffect(() => { if (editorInstance) { const updateJson = () => setEditorContentJson(JSON.stringify(editorInstance.getJSON())); editorInstance.on('update', updateJson); return () => { editorInstance.off('update', updateJson); }; } }, [editorInstance]);
    
    useEffect(() => { if (!isSlugManual && title !== sourceOfTruth.title) { dispatch({ type: 'UPDATE_SLUG', payload: { slug: clientSlugify(title), isManual: false } }); } }, [title, isSlugManual, sourceOfTruth.title]);
    
    useEffect(() => { 
        if (!state._id || !debouncedSlug) { 
            setSlugValidationStatus('invalid'); 
            setSlugValidationMessage(!state._id ? 'Waiting for document ID...' : 'المُعرِّف لا يمكن أن يكون فارغًا.'); 
            return; 
        } 
        setSlugValidationStatus('pending'); 
        setSlugValidationMessage('جارٍ التحقق...'); 
        const checkSlug = async () => { 
            const result = await validateSlugAction(debouncedSlug, state._id); 
            setSlugValidationStatus(result.isValid ? 'valid' : 'invalid'); 
            setSlugValidationMessage(result.message); 
        }; 
        checkSlug(); 
    }, [debouncedSlug, state._id]);
    
    const isDocumentValid = useMemo(() => { const { title, slug, mainImage, game, score, verdict, authors, reporters, releaseDate, platforms, synopsis } = state; const baseValid = title.trim() && slug.trim() && mainImage.assetId; if (!baseValid) return false; const type = sourceOfTruth._type; if (type === 'review') return game?._id && (authors || []).length > 0 && score > 0 && verdict.trim(); if (type === 'article') return game?._id && (authors || []).length > 0; if (type === 'news') return (reporters || []).length > 0; if (type === 'gameRelease') return releaseDate.trim() && synopsis.trim() && (platforms || []).length > 0; return false; }, [state, sourceOfTruth._type]);
    
    const saveWorkingCopy = async (): Promise<boolean> => {
        if (!hasChanges) return true;
        if (slugValidationStatus !== 'valid') { toast.error('لا يمكن الحفظ بمُعرِّف غير صالح.', 'left'); return false; }
    
        const result = await updateDocumentAction(sourceOfTruth._id, patch);
    
        if (result.success) {
            const newTiptapContent = editorInstance ? editorInstance.getJSON() : sourceOfTruth.tiptapContent;
            // --- THE DEFINITIVE FIX: STATE PROMOTION ---
            // Construct the new sourceOfTruth by merging the old with the new,
            // and explicitly re-formatting the mainImage to match Sanity's structure.
            setSourceOfTruth(prevState => {
                const newState = {
                    ...prevState,
                    ...state,
                    mainImage: state.mainImage.assetId 
                        ? { _ref: state.mainImage.assetId, url: state.mainImage.assetUrl } 
                        : null,
                    slug: { current: state.slug },
                    tiptapContent: newTiptapContent,
                };
                return newState;
            });
            return true;
        } else {
            toast.error(result.message || 'فشل حفظ التغييرات.', 'left');
            return false;
        }
    };
    
    const handlePublish = async (publishTime?: string | null): Promise<boolean> => {
        if (hasChanges) {
            const didSave = await saveWorkingCopy();
            if (!didSave) {
                toast.error('يرجى حفظ التغييرات أولاً.', 'left');
                return false;
            }
        }
        
        const result = await publishDocumentAction(sourceOfTruth._id, publishTime);
        if (result.success && result.updatedDocument) {
            setSourceOfTruth(result.updatedDocument);
            toast.success(result.message || 'تم تحديث حالة النشر بنجاح!', 'left');
            return true;
        } else {
            toast.error(result.message || 'فشل تحديث حالة النشر.', 'left');
            return false;
        }
    };
    
    useEffect(() => { if (hasChanges) { document.title = `*غير محفوظ* ${title || 'غير معنون'}`; window.onbeforeunload = () => "You have unsaved changes. Are you sure you want to leave?"; } else { document.title = title || "EternalGames الديوان"; window.onbeforeunload = null; } return () => { window.onbeforeunload = null; }; }, [hasChanges, title]);
    useEffect(() => { document.body.classList.add('editor-active'); return () => { document.body.classList.remove('editor-active'); } }, []);
    const getStatusInfo = () => { if (sourceOfTruth._type === 'gameRelease') return { text: 'إصدار', className: styles.statusPublished }; if (!state.publishedAt) return { text: 'مسودة', className: styles.statusDraft }; const date = new Date(state.publishedAt); if (date > new Date()) return { text: 'مجدولة', className: styles.statusScheduled }; return { text: 'منشورة', className: styles.statusPublished }; };
    const statusInfo = getStatusInfo();
    const isRelease = initialDocument._type === 'gameRelease';

    return (
        <div className={styles.sanctumContainer}>
            <header className={styles.editorHeader}>
                <div className={styles.headerLeft}>
                    <button className={styles.sanctumSidebarToggle} onClick={() => setIsSidebarOpen(!isSidebarOpen)}><SidebarToggleIcon /></button>
                    <a href="/studio" className={`${styles.exitButton} no-underline`}><ExitIcon />عودة للديوان</a>
                    <div style={{ width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.5rem' }} />
                    <Link href="/" className="no-underline" title="Return to Homepage" style={{ color: 'var(--text-secondary)', display: 'flex' }}>
                       <span style={{ fontFamily: 'var(--font-heading), sans-serif', fontSize: '2rem', fontWeight: 800 }}>∞</span>
                    </Link>
                </div>
                <div className={styles.headerRight}>
                    <div className={`${styles.documentStatus} ${statusInfo.className}`}>{statusInfo.text}</div>
                </div>
            </header>
            <motion.div className={styles.sanctumMain} layout transition={{ type: 'spring', stiffness: 400, damping: 40 }}>
                <EditorSidebar document={sourceOfTruth} isOpen={isSidebarOpen} documentState={state} dispatch={dispatch} onSave={saveWorkingCopy} hasChanges={hasChanges} onPublish={handlePublish} slugValidationStatus={slugValidationStatus} slugValidationMessage={slugValidationMessage} isDocumentValid={isDocumentValid} uploadQuality={mainImageUploadQuality} onUploadQualityChange={setMainImageUploadQuality} />
                <EditorCanvas document={sourceOfTruth} title={title} onTitleChange={(newTitle) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'title', value: newTitle } })} onEditorCreated={setEditorInstance} editor={editorInstance} />
            </motion.div>
            
            <AnimatePresence>
                {!isRelease && (
                    <BlockToolbar 
                        editor={editorInstance}
                        onFileUpload={(file) => {
                            if (editorInstance) {
                                uploadFile(file, editorInstance, toast, blockUploadQuality);
                            }
                        }}
                        uploadQuality={blockUploadQuality}
                        onUploadQualityChange={setBlockUploadQuality}
                    />
                )}
            </AnimatePresence>
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

// app/studio/[contentType]/[id/EditorSidebar.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { useState, useMemo, useTransition } from 'react';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { StatefulSaveButton } from './StatefulSaveButton';
import { ProsConsInput } from './metadata/ProsConsInput';
import { GameInput } from './metadata/GameInput';
import { TagInput } from './metadata/TagInput';
import { MainImageInput } from './metadata/MainImageInput';
import { CreatorInput } from './metadata/CreatorInput';
import { PlatformInput } from './metadata/PlatformInput';
import { UploadQuality } from '@/lib/image-optimizer';
import styles from './Editor.module.css';

const sidebarVariants = { hidden: { width: 0, opacity: 0, x: 50 }, visible: { width: '380px', opacity: 1, x: 0, transition: { type: 'spring', stiffness: 400, damping: 40 } }, exit: { width: 0, opacity: 0, x: 50, transition: { duration: 0.2, ease: 'easeInOut' } } };
const itemVariants = { hidden: { opacity: 0, y: 10 }, visible: { opacity: 1, y: 0 } };
const AlertIcon = () => <svg width="18" height="18" viewBox="0 0 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
const CheckIcon = () => <svg width="18" height="18" viewBox="0 0 24" fill="none" stroke="#16A34A" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ClockIcon = () => <svg width="18" height="18" viewBox="0 0 24" fill="none" stroke="var(--text-secondary)" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;
const SaveIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
const SuccessIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ToggleSwitch = ({ checked, onChange }: { checked: boolean, onChange: (checked: boolean) => void }) => ( <button type="button" role="switch" aria-checked={checked} onClick={() => onChange(!checked)} className={`toggle ${checked ? 'active' : ''}`}> <motion.div className="toggle-handle" layout transition={{ type: 'spring', stiffness: 700, damping: 30 }} /> </button> );

export function EditorSidebar({ document, isOpen, documentState, dispatch, onSave, hasChanges, onPublish, slugValidationStatus, slugValidationMessage, isDocumentValid, uploadQuality, onUploadQualityChange }: any) {
    const { title, slug, score, verdict, pros, cons, game, tags, publishedAt, mainImage, authors, reporters, designers, releaseDate, platforms, synopsis } = documentState;
    const [scheduledDateTime, setScheduledDateTime] = useState('');
    const [isSaving, startSaveTransition] = useTransition();
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success'>('idle');

    const isReview = document._type === 'review';
    const isArticle = document._type === 'article';
    const isNews = document._type === 'news';
    const isRelease = document._type === 'gameRelease';

    const primaryCreatorConfig = useMemo(() => {
        if (isReview) return { label: 'المراجعون', role: 'REVIEWER', field: 'authors' };
        if (isArticle) return { label: 'الكتّاب', role: 'AUTHOR', field: 'authors' };
        if (isNews) return { label: 'المراسلون', role: 'REPORTER', field: 'reporters' };
        return { label: 'المنشئون', role: 'AUTHOR', field: 'authors' };
    }, [isReview, isArticle, isNews]);

    const handleSave = () => { startSaveTransition(async () => { setSaveStatus('saving'); const success = await onSave(); setSaveStatus(success ? 'success' : 'idle'); if(success) setTimeout(() => setSaveStatus('idle'), 2000); }); };

    const isSaveDisabled = isSaving || !hasChanges || slugValidationStatus !== 'valid';
    const isSlugValid = slugValidationStatus === 'valid'; const isSlugPending = slugValidationStatus === 'pending'; const isPublished = publishedAt && new Date(publishedAt) <= new Date(); const isScheduled = publishedAt && new Date(publishedAt) > new Date();
    const isPublishDisabled = !isSlugValid || isSlugPending || hasChanges || !isDocumentValid; const isUnpublishDisabled = !isSlugValid || isSlugPending;
    const getSlugIcon = () => { if (isSlugPending) return <ClockIcon />; if (isSlugValid) return <CheckIcon />; return <AlertIcon />; };
    const handleFieldChange = (field: string, value: any) => { dispatch({ type: 'UPDATE_FIELD', payload: { field, value } }); };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.aside className={styles.sanctumSidebar} variants={sidebarVariants} initial="hidden" animate="visible" exit="exit">
                    <motion.div variants={itemVariants} className={styles.sidebarContent}><h2 className={styles.sidebarTitle}>منصة التحرير</h2><p className={styles.sidebarSubtitle}>تحرير: {title}</p></motion.div>
                    
                    {!isRelease && (
                        <motion.div className={styles.sidebarSection} variants={itemVariants}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                <label className={styles.sidebarLabel} style={{ marginBottom: 0 }}>جدولة (اختياري)</label>
                                <motion.button onClick={handleSave} disabled={isSaveDisabled} className={styles.sanctumSidebarToggle} title={isSaveDisabled ? 'لا تغييرات للحفظ' : 'حفظ التغييرات'} whileHover={{ scale: hasChanges && !isSaving ? 1.15 : 1 }} style={{ color: hasChanges && !isSaving ? 'var(--accent)' : 'var(--text-secondary)', cursor: isSaveDisabled ? 'not-allowed' : 'pointer' }}>
                                    <AnimatePresence mode="wait">
                                        {saveStatus === 'saving' && <motion.div key="loader" initial={{scale:0}} animate={{scale:1}} exit={{scale:0}}><ButtonLoader /></motion.div>}
                                        {saveStatus === 'success' && <motion.div key="success" initial={{scale:0}} animate={{scale:1}} exit={{scale:0}} style={{color: '#16A34A'}}><SuccessIcon /></motion.div>}
                                        {saveStatus === 'idle' && <motion.div key="icon" initial={{scale:0}} animate={{scale:1}} exit={{scale:0}}><SaveIcon /></motion.div>}
                                    </AnimatePresence>
                                </motion.button>
                            </div>
                            <input type="datetime-local" value={scheduledDateTime} onChange={(e) => setScheduledDateTime(e.target.value)} className={styles.sidebarInput} />
                            <motion.button onClick={() => onPublish(scheduledDateTime || '')} className="primary-button" style={{ width: '100%', marginTop: '1rem' }} disabled={isPublishDisabled}>{scheduledDateTime ? 'جدولة' : 'انشر الآن'}</motion.button>
                            {(isPublished || isScheduled) && (<motion.button onClick={() => onPublish(null)} className="outline-button" style={{ width: '100%', marginTop: '0.5rem', color: '#DC2626', borderColor: '#DC2626' }} disabled={isUnpublishDisabled}>إلغاء النشر</motion.button>)}
                            <p style={{ marginTop: '0.5rem', color: 'var(--text-secondary)', fontSize: '1.4rem', textAlign: 'right' }}> {!isDocumentValid && <span style={{ color: '#DC2626' }}>الحقول الإلزامية ناقصة.</span>} {hasChanges && isDocumentValid && "احفظ التغييرات قبل النشر."} </p>
                        </motion.div>
                    )}

                    <motion.div className={styles.sidebarSection} variants={itemVariants}>
                        <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem'}}>
                            <label className={styles.sidebarLabel} style={{marginBottom: 0}}>جودة الرفع</label>
                            <div style={{display: 'flex', alignItems: 'center', gap: '1rem', fontFamily: 'var(--font-main)', fontSize: '1.4rem'}}>
                                <span>1080p</span>
                                <ToggleSwitch checked={uploadQuality === '4k'} onChange={(isChecked) => onUploadQualityChange(isChecked ? '4k' : '1080p')} />
                                <span>4K</span>
                            </div>
                        </div>
                        <MainImageInput currentAssetId={mainImage.assetId} currentAssetUrl={mainImage.assetUrl} onImageChange={(assetId, assetUrl) => handleFieldChange('mainImage', { assetId, assetUrl })} uploadQuality={uploadQuality} />
                    </motion.div>
                    
                    <motion.div className={styles.sidebarSection} variants={itemVariants}>
                        <label className={styles.sidebarLabel}>المُعرِّف {!isSlugValid && <AlertIcon />}</label>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <motion.div key={slugValidationStatus} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }}>{getSlugIcon()}</motion.div>
                            <input type="text" value={slug} onChange={(e) => dispatch({ type: 'UPDATE_SLUG', payload: { slug: e.target.value, isManual: true } })} className={styles.sidebarInput} style={{ flexGrow: 1, borderColor: isSlugValid && !isSlugPending ? '#16A34A' : isSlugPending ? 'var(--border-color)' : '#DC2626' }} />
                        </div>
                        <AnimatePresence> {!isSlugValid && !isSlugPending && <motion.p initial={{height:0, opacity:0}} animate={{height:'auto', opacity:1}} exit={{height:0, opacity:0}} style={{ color: '#DC2626', fontSize: '1.2rem', marginTop: '0.5rem', textAlign: 'right' }}>{slugValidationMessage}</motion.p>} </AnimatePresence>
                    </motion.div>
                    
                    {isRelease ? ( <> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>تاريخ الإصدار</label> <input type="date" value={releaseDate} onChange={(e) => handleFieldChange('releaseDate', e.target.value)} className={styles.sidebarInput} /> </motion.div> <motion.div variants={itemVariants}><PlatformInput selectedPlatforms={platforms} onPlatformsChange={(p: any) => handleFieldChange('platforms', p)} /></motion.div> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>نبذة</label> <textarea value={synopsis} onChange={(e) => handleFieldChange('synopsis', e.target.value)} className={styles.sidebarInput} rows={5} /> </motion.div> </> ) : ( <> <div><CreatorInput label={primaryCreatorConfig.label} roleToSearch={primaryCreatorConfig.role} selectedCreators={documentState[primaryCreatorConfig.field]} onCreatorsChange={(c: any) => handleFieldChange(primaryCreatorConfig.field, c)} /></div> <div><GameInput selectedGame={game} onGameSelect={(g: any) => handleFieldChange('game', g)} /></div> <div><TagInput selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} /></div> </> )}
                    <div><CreatorInput label="المصممون (اختياري)" roleToSearch="DESIGNER" selectedCreators={designers} onCreatorsChange={(c: any) => handleFieldChange('designers', c)} /></div>
                    {isReview && (<> <motion.hr variants={itemVariants} style={{ border: 'none', borderTop: '1px solid var(--border-color)', margin: '1rem 0' }} /> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>التقييم (0-10) {score <= 0 && <AlertIcon />}</label> <input type="number" value={score} onChange={(e) => handleFieldChange('score', parseFloat(e.target.value) || 0)} className={styles.sidebarInput} min="0" max="10" step="0.1" /> </motion.div> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>الخلاصة {!verdict.trim() && <AlertIcon />}</label> <textarea value={verdict} onChange={(e) => handleFieldChange('verdict', e.target.value)} className={styles.sidebarInput} rows={3} /> </motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المحاسن" items={pros} setItems={(p: any) => handleFieldChange('pros', p)} /></motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المآخذ" items={cons} setItems={(c: any) => handleFieldChange('cons', c)} /></motion.div> </>)}
                    
                    <motion.div className={styles.sidebarFooter} variants={itemVariants}> <StatefulSaveButton onSave={onSave} hasChanges={hasChanges && isSlugValid && !isSlugPending} /> </motion.div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

// app/studio/[contentType]/[id]/FormattingToolbar.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion } from 'framer-motion';
import styles from './Editor.module.css';
import { TwoImageIcon, FourImageIcon, CompareIcon } from '../../StudioIcons';

const BoldIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>;
const ItalicIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>;
const LinkIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>;
const H2Icon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M4 12h8m-8 6h8M4 6h8m4 0v12m4-12v12"/></svg>;
const ListIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;


interface FormattingToolbarProps { editor: Editor; onLinkClick: () => void; }

export function FormattingToolbar({ editor, onLinkClick }: FormattingToolbarProps) {
    return (
        <div className={styles.formattingToolbar} onMouseDown={(e) => e.preventDefault()}>
            <motion.button onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()} className={`${styles.bubbleMenuButton} ${editor.isActive('heading', { level: 2 }) ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><H2Icon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBold().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bold') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><BoldIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleItalic().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('italic') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ItalicIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBulletList().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bulletList') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ListIcon /></motion.button>
            <motion.button onClick={onLinkClick} className={`${styles.bubbleMenuButton} ${editor.isActive('link') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><LinkIcon /></motion.button>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

// app/studio/[contentType]/[id]/ImageCompareComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { useState, useRef, useCallback } from 'react';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { clientAssetUploader } from '@/lib/sanity.client';
import { useToast } from '@/lib/toastStore';
import styles from '@/components/ImageCompare.module.css';
import editorStyles from './Editor.module.css';
import Image from 'next/image';

const UploadIcon = () => <svg className={styles.uploadIcon} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg>;
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const SizeSmallIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="6" rx="1"/><rect x="3" y="15" width="18" height="6" rx="1"/></svg>;
const SizeMediumIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="10" rx="1"/><rect x="3" y="17" width="18" height="4" rx="1"/></svg>;
const SizeLargeIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="1"/></svg>;

const Dropzone = ({ side, src, onUpload }: { side: 'left' | 'right', src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) { onUpload(file); } }; 
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); }; 
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); }; 
    return ( <div className={`${styles.dropzone} ${isDragging ? styles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}> <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} /> {src && <Image src={src} alt={`Image ${side}`} fill className={styles.imagePreview} />} <div className={styles.dropzoneContent}> <UploadIcon /> <span>{src ? `تغيير الصورة ${side === 'left' ? 1 : 2}` : `أفلت صورة أو انقر للرفع`}</span> </div> </div> ); 
};

export const ImageCompareComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, side: 'left' | 'right') => {
        try {
            toast.info('جار تحسين الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const optimizedFile = await optimizeImageForUpload(file, quality);
            
            const asset = await clientAssetUploader.assets.upload('image', optimizedFile, {
                filename: optimizedFile.name,
                contentType: optimizedFile.type,
            });

            if (asset?._id && asset?.url) {
                updateAttributes({
                    [side === 'left' ? 'src1' : 'src2']: asset.url,
                    [side === 'left' ? 'assetId1' : 'assetId2']: asset._id,
                });
                toast.success('تم رفع الصورة بنجاح.', 'left');
            } else {
                throw new Error('فشل رفع أصل الصورة إلى Sanity.');
            }
        } catch (error: any) {
            toast.error(error.message || 'فشل معالجة الصورة.', 'left');
        }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();
    const handleSizeChange = (size: 'small' | 'medium' | 'large') => updateAttributes({ 'data-size': size });
    const currentSize = node.attrs['data-size'] || 'large';

    return (
        <NodeViewWrapper as="div" className={editorStyles.imageCompareContainer} data-size={currentSize} data-drag-handle>
            {(node.attrs.src1 && node.attrs.src2) ? (
                <div className={styles.compareWrapper}>
                    <ReactCompareSlider itemOne={<ReactCompareSliderImage src={node.attrs.src1} alt="Image 1" />} itemTwo={<ReactCompareSliderImage src={node.attrs.src2} alt="Image 2" />} />
                </div>
            ) : (
                <div className={styles.compareWrapper}>
                    <div className={styles.placeholder}>
                        <Dropzone side="left" src={node.attrs.src1} onUpload={(file) => handleUpload(file, 'left')} />
                        <Dropzone side="right" src={node.attrs.src2} onUpload={(file) => handleUpload(file, 'right')} />
                    </div>
                </div>
            )}
             <div className={editorStyles.imageNodeMenu} contentEditable={false}>
                <button onClick={() => handleSizeChange('small')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'small' ? editorStyles.active : ''}`}><SizeSmallIcon /></button>
                <button onClick={() => handleSizeChange('medium')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'medium' ? editorStyles.active : ''}`}><SizeMediumIcon /></button>
                <button onClick={() => handleSizeChange('large')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'large' ? editorStyles.active : ''}`}><SizeLargeIcon /></button>
                <div style={{width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.4rem'}} />
                <button onClick={handleDelete} className={`${editorStyles.bubbleMenuButton} ${editorStyles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

// app/studio/[contentType]/[id]/ImageResizeComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import styles from './Editor.module.css';

const SizeSmallIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="6" rx="1"/><rect x="3" y="15" width="18" height="6" rx="1"/></svg>;
const SizeMediumIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="10" rx="1"/><rect x="3" y="17" width="18" height="4" rx="1"/></svg>;
const SizeLargeIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="1"/></svg>;
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export const ImageResizeComponent = ({ editor, node, updateAttributes, getPos }: NodeViewProps) => {
    
    const handleSizeChange = (size: 'small' | 'medium' | 'large') => {
        updateAttributes({ 'data-size': size });
    };

    const handleDelete = () => {
        editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run()
    }

    const currentSize = node.attrs['data-size'] || 'large';
    const { assetId, 'data-size': dataSize, ...imgAttributes } = node.attrs;

    return (
        <NodeViewWrapper 
            className={styles.imageNodeContainer} 
            data-size={currentSize}
            data-drag-handle
        >
            <img {...imgAttributes} alt={imgAttributes.alt || ''} />

            {/* THE FIX: The menu is no longer conditional */}
            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={() => handleSizeChange('small')} className={`${styles.bubbleMenuButton} ${currentSize === 'small' ? styles.active : ''}`}><SizeSmallIcon /></button>
                <button onClick={() => handleSizeChange('medium')} className={`${styles.bubbleMenuButton} ${currentSize === 'medium' ? styles.active : ''}`}><SizeMediumIcon /></button>
                <button onClick={() => handleSizeChange('large')} className={`${styles.bubbleMenuButton} ${currentSize === 'large' ? styles.active : ''}`}><SizeLargeIcon /></button>
                <div style={{width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.4rem'}} />
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

// app/studio/[contentType]/[id]/LinkEditorModal.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import editorStyles from './Editor.module.css'; // <-- IMPORTED for input styles
import modalStyles from '@/components/modals/Modals.module.css'; // <-- IMPORTED for modal layout

interface LinkEditorModalProps { isOpen: boolean; onClose: () => void; onSubmit: (url: string) => void; onRemove: () => void; initialUrl?: string; }
const modalVariants = { hidden: { opacity: 0, scale: 0.9, y: 20 }, visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 20, stiffness: 250 } }, exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } }, };

export function LinkEditorModal({ isOpen, onClose, onSubmit, onRemove, initialUrl }: LinkEditorModalProps) {
    const [url, setUrl] = useState('');

    useEffect(() => { if (isOpen) { setUrl(initialUrl || ''); } }, [isOpen, initialUrl]);
    const handleSubmit = (e: React.FormEvent) => { e.preventDefault(); if (url.trim()) { onSubmit(url); } };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div onMouseDown={(e) => e.preventDefault()} className={modalStyles.modalOverlay} style={{ zIndex: 5001, backgroundColor: 'transparent', backdropFilter: 'none' }} onClick={onClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={modalStyles.modalContent} style={{ padding: '2rem', maxWidth: '400px' }} variants={modalVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
                        <form onSubmit={handleSubmit}>
                            <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-ui)' }}>تعديل الرابط</h3>
                            <input type="url" value={url} onChange={(e) => setUrl(e.target.value)} placeholder="https://example.com" className={editorStyles.sidebarInput} autoFocus style={{ marginBottom: '1.5rem' }} />
                            <div className={modalStyles.modalActions} style={{ justifyContent: 'space-between' }}>
                                {initialUrl && (<button type="button" onClick={onRemove} className="outline-button" style={{ borderColor: '#DC2626', color: '#DC2626' }}>إزالة الرابط</button>)}
                                <div style={{ display: 'flex', gap: '1rem', marginLeft: 'auto' }}>
                                    <button type="button" onClick={onClose} className="outline-button">إلغاء</button>
                                    <button type="submit" className="primary-button">تطبيق</button>
                                </div>
                            </div>
                        </form>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

// app/studio/[contentType]/[id]/RichTextEditor.tsx
'use client';

// ... (imports remain the same)
import { useEditor, EditorContent, Editor, ReactNodeViewRenderer, BubbleMenu, FloatingMenu } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Placeholder from '@tiptap/extension-placeholder';
import Link from '@tiptap/extension-link';
import Heading from '@tiptap/extension-heading';
import BulletList from '@tiptap/extension-bullet-list';
import ListItem from '@tiptap/extension-list-item';
import Bold from '@tiptap/extension-bold';
import { InputRule, Node, mergeAttributes } from '@tiptap/core';
import { slugify } from 'transliteration';
import { useState, useEffect, useCallback } from 'react';
import { AnimatePresence } from 'framer-motion';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload, UploadQuality } from '@/lib/image-optimizer';
import { clientAssetUploader } from '@/lib/sanity.client';
import { FormattingToolbar } from './FormattingToolbar';
import { BlockToolbar } from './BlockToolbar';
import { LinkEditorModal } from './LinkEditorModal';
import { ImageResizeComponent } from './ImageResizeComponent';
import { ImageCompareComponent } from './ImageCompareComponent';
import { TwoImageGridComponent } from './editor-components/TwoImageGridComponent';
import { FourImageGridComponent } from './editor-components/FourImageGridComponent';
import styles from './Editor.module.css';


const formatFileSize = (bytes: number): string => { // Helper function for toast
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

export const uploadFile = async (file: File, editor: Editor, toast: ReturnType<typeof useToast>, quality: UploadQuality) => {
    try {
        toast.info('جار تحسين الصورة للرفع...', 'left');
        // THE FIX: Get file and final quality from optimizer
        const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);
        
        const reader = new FileReader();
        reader.readAsDataURL(optimizedFile);
        reader.onload = async () => {
            const { tr } = editor.state;
            const node = editor.state.schema.nodes.image.create({ src: reader.result as string });
            const transaction = tr.replaceSelectionWith(node);
            editor.view.dispatch(transaction);
            
            // THE FIX: Use final size and quality in the toast
            toast.info(`جار رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
            
            const asset = await clientAssetUploader.assets.upload('image', optimizedFile, {
                filename: optimizedFile.name,
                contentType: optimizedFile.type,
            });

            let imagePos: number | null = null;
            editor.state.doc.descendants((node, pos) => {
                if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
                    imagePos = pos;
                    return false;
                }
                return true;
            });
            
            if (imagePos !== null) {
                if (asset?._id && asset?.url) {
                    const finalTransaction = editor.state.tr.setNodeMarkup(imagePos, undefined, {
                        ...editor.state.doc.nodeAt(imagePos)?.attrs,
                        src: asset.url,
                        assetId: asset._id,
                    });
                    editor.view.dispatch(finalTransaction);
                    toast.success('تم رفع الصورة بنجاح.', 'left');
                } else {
                    throw new Error('فشل رفع أصل الصورة إلى Sanity.');
                }
            }
        };
    } catch (error: any) {
        toast.error(error.message || 'فشل رفع الصورة.', 'left');
        let imagePos: number | null = null;
        editor.state.doc.descendants((node, pos) => {
            if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
                imagePos = pos; return false;
            } return true;
        });
        if(imagePos !== null) {
            const failedTransaction = editor.state.tr.delete(imagePos, imagePos + 1);
            editor.view.dispatch(failedTransaction);
        }
    }
};

// ... (rest of the file remains the same)
const ImageCompareNode = Node.create({ name: 'imageCompare', group: 'block', atom: true, addAttributes() { return { src1: { default: null }, assetId1: { default: null }, src2: { default: null }, assetId2: { default: null }, 'data-size': { default: 'large' } }; }, parseHTML() { return [{ tag: 'div[data-type="image-compare"]' }]; }, renderHTML({ HTMLAttributes }) { return ['div', mergeAttributes({ 'data-type': 'image-compare' }, HTMLAttributes)]; }, addNodeView() { return ReactNodeViewRenderer(ImageCompareComponent); }, });
const CustomImage = Node.create({ name: 'image', group: 'block', atom: true, draggable: true, addAttributes() { return { src: { default: null }, alt: { default: null }, title: { default: null }, assetId: { default: null }, 'data-size': { default: 'large' }, }; }, parseHTML() { return [{ tag: 'img[src]' }]; }, renderHTML({ HTMLAttributes }) { return ['div', { 'data-type': 'custom-image' }, ['img', HTMLAttributes]]; }, addNodeView() { return ReactNodeViewRenderer(ImageResizeComponent); }, });
const TwoImageGridNode = Node.create({ name: 'twoImageGrid', group: 'block', atom: true, addAttributes() { return { src1: null, assetId1: null, src2: null, assetId2: null }; }, parseHTML() { return [{ tag: 'div[data-type="two-image-grid"]' }]; }, renderHTML({ HTMLAttributes }) { return ['div', mergeAttributes({ 'data-type': 'two-image-grid' }, HTMLAttributes)]; }, addNodeView() { return ReactNodeViewRenderer(TwoImageGridComponent); }, });
const FourImageGridNode = Node.create({ name: 'fourImageGrid', group: 'block', atom: true, addAttributes() { return { src1: null, assetId1: null, src2: null, assetId2: null, src3: null, assetId3: null, src4: null, assetId4: null }; }, parseHTML() { return [{ tag: 'div[data-type="four-image-grid"]' }]; }, renderHTML({ HTMLAttributes }) { return ['div', mergeAttributes({ 'data-type': 'four-image-grid' }, HTMLAttributes)]; }, addNodeView() { return ReactNodeViewRenderer(FourImageGridComponent); }, });

interface RichTextEditorProps { onEditorCreated: (editor: Editor) => void; initialContent?: any; }

export default function RichTextEditor({ onEditorCreated, initialContent }: RichTextEditorProps) {
    const toast = useToast();
    const [isLinkModalOpen, setIsLinkModalOpen] = useState(false);
    const [currentLinkUrl, setCurrentLinkUrl] = useState<string | undefined>(undefined);

    const editor = useEditor({
        extensions: [
            StarterKit.configure({ heading: false, bulletList: false, listItem: false, bold: false, image: false }),
            Bold.extend({ addInputRules() { return [ new InputRule({ find: /(?:^|\s)(\*\*(?!\s+\*\*).+\*\*(?!\s+\*\*))$/, handler: ({ state, range, match }) => { const { tr } = state; const text = match[1]; const start = range.from; const end = range.to; tr.delete(start, end); tr.insertText(text.slice(2, -2), start); tr.addMark(start, start + text.length - 4, this.type.create()); }, }), ]; }, }),
            Heading.configure({ levels: [2] }).extend({ onCreate({ editor }) { const transaction = editor.state.tr; editor.state.doc.descendants((node, pos) => { if (node.type.name === 'heading' && !node.attrs.id) { const id = slugify(node.textContent); transaction.setNodeMarkup(pos, undefined, { ...node.attrs, id }); } }); transaction.setMeta('addToHistory', false); editor.view.dispatch(transaction); }, addAttributes() { return { ...this.parent?.(), id: { default: null, parseHTML: element => element.getAttribute('id'), renderHTML: attributes => { if (!attributes.id) { return {}; } return { id: attributes.id }; }, }, }; }, }),
            Link.configure({ openOnClick: false, autolink: true, inclusive: false, HTMLAttributes: { class: 'editor-link' }, }),
            Placeholder.configure({ placeholder: 'اكتب محتواك هنا...' }),
            CustomImage, BulletList, ListItem, ImageCompareNode, TwoImageGridNode, FourImageGridNode,
        ],
        editorProps: {
            attributes: { class: styles.tiptap },
            handlePaste(view, event, slice) { if (!editor) return false; const items = Array.from(event.clipboardData?.items || []); const imageItem = items.find(item => item.type.startsWith('image/')); if (imageItem) { const file = imageItem.getAsFile(); if (file) { uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p'); return true; } } return false; },
            handleDrop(view, event, slice, moved) { if (!editor || moved) return false; const file = event.dataTransfer?.files[0]; if (file && file.type.startsWith('image/')) { uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p'); return true; } return false; },
        },
        immediatelyRender: false,
        content: initialContent || '',
        onSelectionUpdate: ({ editor }) => {
            if (editor.isActive('link')) { setCurrentLinkUrl(editor.getAttributes('link').href); } 
            else { setCurrentLinkUrl(undefined); }
        },
    });

    const handleOpenLinkModal = useCallback(() => { setIsLinkModalOpen(true); }, []);
    const handleCloseLinkModal = useCallback(() => { setIsLinkModalOpen(false); setCurrentLinkUrl(undefined); editor?.chain().focus().run(); }, [editor]);
    const handleSetLink = useCallback((url: string) => { if (editor) { editor.chain().focus().extendMarkRange('link').setLink({ href: url }).run(); } handleCloseLinkModal(); }, [editor, handleCloseLinkModal]);
    const handleRemoveLink = useCallback(() => { if (editor) { editor.chain().focus().extendMarkRange('link').unsetLink().run(); } handleCloseLinkModal(); }, [editor, handleCloseLinkModal]);
    useEffect(() => { if (editor) { onEditorCreated(editor); } }, [editor, onEditorCreated]);
    if (!editor) { return null; }

    return (
        <div onClick={(e) => { const target = e.target as HTMLElement; if (target.tagName === 'A' && target.classList.contains('editor-link')) { e.preventDefault(); } }}>
            <style jsx global>{`.tiptap a.editor-link { color: var(--accent); text-decoration: underline; text-decoration-color: color-mix(in srgb, var(--accent) 50%, transparent); cursor: default; }`}</style>
            
            <BubbleMenu editor={editor} tippyOptions={{ duration: 100, placement: 'top-start', offset: [0, 8] }} shouldShow={({ editor, state }) => { const { from, to } = state.selection; const isTextSelection = from !== to; const isBlockNodeSelection = editor.isActive('image') || editor.isActive('imageCompare') || editor.isActive('twoImageGrid') || editor.isActive('fourImageGrid'); return isTextSelection && !isBlockNodeSelection; }}>
                 <FormattingToolbar editor={editor} onLinkClick={handleOpenLinkModal} />
            </BubbleMenu>

            <LinkEditorModal isOpen={isLinkModalOpen} onClose={handleCloseLinkModal} onSubmit={handleSetLink} onRemove={handleRemoveLink} initialUrl={currentLinkUrl} />
            <EditorContent editor={editor} />
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

// app/studio/[contentType]/[id]/StatefulSaveButton.tsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from '@/components/ui/StatefulButton.module.css';

const SaveIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
const CheckIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>;

type SaveStatus = 'idle' | 'saving' | 'success' | 'error';

export function StatefulSaveButton({ onSave, hasChanges }: { onSave: () => Promise<boolean>; hasChanges: boolean }) {
    const [saveStatus, setSaveStatus] = useState<SaveStatus>('idle');
    const toast = useToast();

    const handleSave = async () => {
        if (saveStatus === 'saving') return;
        setSaveStatus('saving');
        const success = await onSave();
        if (success) {
            setSaveStatus('success');
            toast.success('حُفظت التغييرات بنجاح!', 'left'); // Position toast on the left for studio
            setTimeout(() => setSaveStatus('idle'), 2000);
        } else {
            setSaveStatus('error');
            toast.error('فشل حفظ التغييرات.', 'left');
            setTimeout(() => setSaveStatus('idle'), 3000);
        }
    };

    const isSaving = saveStatus === 'saving';

    return (
        <motion.button
            onClick={handleSave}
            className={`primary-button ${styles.statefulButton} ${styles.saveButton} ${styles[saveStatus]}`}
            disabled={isSaving || !hasChanges}
            animate={{
                width: isSaving || saveStatus === 'success' ? '48px' : '100%',
                height: '48px',
                borderRadius: isSaving || saveStatus === 'success' ? '50%' : '5px',
            }}
            transition={{ type: 'spring', stiffness: 300, damping: 20 }}
        >
            <AnimatePresence mode="wait">
                {saveStatus === 'saving' && <ButtonLoader key="loader" />}
                {saveStatus === 'success' && <motion.div key="success" initial={{ scale: 0 }} animate={{ scale: 1 }} exit={{ scale: 0 }}><CheckIcon /></motion.div>}
                {saveStatus === 'idle' && <motion.span key="idle" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
                {saveStatus === 'error' && <motion.span key="error" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
            </AnimatePresence>
        </motion.button>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/page.tsx ---

// app/studio/[contentType]/[id]/page.tsx

import { createClient } from 'next-sanity';
import { projectId, dataset, apiVersion } from '@/lib/sanity.client';
import { editorDocumentQuery } from '@/lib/sanity.queries'; // Use the master query
import { notFound } from "next/navigation";
import { EditorClient } from "./EditorClient";
import { unstable_noStore as noStore } from 'next/cache';
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';

const studioClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN,
    fetch: {
        cache: 'no-store',
    },
});

export default async function EditorPage({ params }: { params: { contentType: string; id: string } }) {
    noStore();
    
    const { id } = await params;
    
    // Use the comprehensive query from sanity.queries.ts
    const document = await studioClient.fetch(editorDocumentQuery, { id });
    if (!document) notFound();
    
    const tiptapContent = portableTextToTiptap(document.content ?? []);
    
    const documentWithTiptapContent = {
        ...document,
        tiptapContent: tiptapContent,
    };
    
    return <EditorClient document={documentWithTiptapContent} />;
}

--- END OF FILE app/studio/[contentType]/[id]/page.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { clientAssetUploader } from '@/lib/sanity.client';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };
    
    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && <Image src={src} alt={`Image ${side}`} fill className={compareStyles.imagePreview} />}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة ${side}` : `أفلت صورة أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const FourImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2 | 3 | 4) => {
        try {
            toast.info('جار تحسين الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            // --- THE FIX IS HERE (PART 1) ---
            // Correctly destructure the object returned by the optimizer.
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            // --- THE FIX IS HERE (PART 2) ---
            // Use the final size and quality percentage in the toast.
            toast.info(`جار رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const asset = await clientAssetUploader.assets.upload('image', optimizedFile, {
                filename: optimizedFile.name,
                contentType: optimizedFile.type,
            });

            if (asset?._id && asset?.url) {
                updateAttributes({ [`src${slot}`]: asset.url, [`assetId${slot}`]: asset._id });
                toast.success('تم رفع الصورة بنجاح.', 'left');
            } else { throw new Error('فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);
    
    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.fourImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
                <Dropzone side={3} src={node.attrs.src3} onUpload={(file) => handleUpload(file, 3)} />
                <Dropzone side={4} src={node.attrs.src4} onUpload={(file) => handleUpload(file, 4)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                 <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="Delete Grid"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

// app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx
'use client';

import { UploadQuality } from '@/lib/image-optimizer';
import styles from '../BlockToolbar.module.css';
import bubbleStyles from '../Editor.module.css';

interface QualityToggleProps {
    currentQuality: UploadQuality;
    onQualityChange: (quality: UploadQuality) => void;
}

const qualityCycle: UploadQuality[] = ['1080p', '4k', '8k'];
const qualityLabels: Record<UploadQuality, string> = {
    '1080p': 'FHD',
    '4k': '4K',
    '8k': '8K'
};
const qualityTooltips: Record<UploadQuality, string> = {
    '1080p': 'Full HD (1080p)',
    '4k': 'Ultra HD (4K)',
    '8k': 'Full Ultra HD (8K)'
};

export function QualityToggle({ currentQuality, onQualityChange }: QualityToggleProps) {
    
    const cycleQuality = () => {
        const currentIndex = qualityCycle.indexOf(currentQuality);
        const nextIndex = (currentIndex + 1) % qualityCycle.length;
        onQualityChange(qualityCycle[nextIndex]);
    };

    return (
        <div className={styles.optionButtonWrapper}>
            <button
                onClick={cycleQuality}
                className={bubbleStyles.bubbleMenuButton}
                title={`Cycle upload quality`}
            >
                <span style={{ fontSize: '13px', fontWeight: 700, color: 'var(--accent)' }}>
                    {qualityLabels[currentQuality]}
                </span>
            </button>
            <div className={styles.optionTooltip}>
                جودة الرفع: {qualityTooltips[currentQuality]}
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { clientAssetUploader } from '@/lib/sanity.client';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };

    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && <Image src={src} alt={`Image ${side}`} fill className={compareStyles.imagePreview} />}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة` : `أفلت صورة أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const TwoImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2) => {
        try {
            toast.info('جار تحسين الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            // --- THE FIX IS HERE (PART 1) ---
            // Correctly destructure the object returned by the optimizer.
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            // --- THE FIX IS HERE (PART 2) ---
            // Use the final size and quality percentage in the toast.
            toast.info(`جار رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const asset = await clientAssetUploader.assets.upload('image', optimizedFile, {
                filename: optimizedFile.name,
                contentType: optimizedFile.type,
            });

            if (asset?._id && asset?.url) {
                updateAttributes({ [`src${slot}`]: asset.url, [`assetId${slot}`]: asset._id });
                toast.success('تم رفع الصورة بنجاح.', 'left');
            } else { throw new Error('فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.twoImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="Delete Grid"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};

--- END OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddGameModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import modalStyles from '@/components/modals/Modals.module.css';

interface AddGameModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string; // <-- NEW PROP
}

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export function AddGameModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddGameModalProps) {
    const [gameTitle, setGameTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setGameTitle(initialValue); // Pre-fill on open
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (gameTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(gameTitle);
            });
        }
    };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    onMouseDown={(e) => e.preventDefault()}
                    className={modalStyles.modalOverlay}
                    style={{ zIndex: 5002 }}
                    onClick={onClose}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                >
                    <motion.div
                        className={modalStyles.modalContent}
                        style={{ padding: '2rem', maxWidth: '400px' }}
                        variants={modalVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <form onSubmit={handleSubmit}>
                            <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-ui)' }}>إنشاء لعبة جديدة</h3>
                            <input
                                type="text"
                                value={gameTitle}
                                onChange={(e) => setGameTitle(e.target.value)}
                                placeholder="مثال: Elden Ring"
                                className="profile-input"
                                autoFocus
                                style={{ marginBottom: '1.5rem' }}
                                disabled={isPending}
                            />
                            <div className={modalStyles.modalActions}>
                                <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                                <button type="submit" className="primary-button" disabled={isPending || !gameTitle.trim()}>
                                    {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                                </button>
                            </div>
                        </form>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddTagModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import modalStyles from '@/components/modals/Modals.module.css';

interface AddTagModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring', damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export function AddTagModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddTagModalProps) {
    const [tagTitle, setTagTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setTagTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (tagTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(tagTitle);
            });
        }
    };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    onMouseDown={(e) => e.preventDefault()}
                    className={modalStyles.modalOverlay}
                    style={{ zIndex: 5002 }}
                    onClick={onClose}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                >
                    <motion.div
                        className={modalStyles.modalContent}
                        style={{ padding: '2rem', maxWidth: '400px' }}
                        variants={modalVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <form onSubmit={handleSubmit}>
                            <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-ui)' }}>إضافة وسم جديد</h3>
                            <input
                                type="text"
                                value={tagTitle}
                                onChange={(e) => setTagTitle(e.target.value)}
                                placeholder="مثال: RPG"
                                className="profile-input"
                                autoFocus
                                style={{ marginBottom: '1.5rem' }}
                                disabled={isPending}
                            />
                            <div className={modalStyles.modalActions}>
                                <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                                <button type="submit" className="primary-button" disabled={isPending || !tagTitle.trim()}>
                                    {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                                </button>
                            </div>
                        </form>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

// app/studio/[contentType]/[id]/metadata/CreatorInput.tsx
'use client';

import { useState, useEffect, useRef, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useDebounce } from '@/hooks/useDebounce';
import { searchCreatorsAction } from '../../../actions';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Creator = { _id: string; name: string };
interface CreatorInputProps { label: string; roleToSearch: 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER'; selectedCreators: Creator[]; onCreatorsChange: (creators: Creator[]) => void; }

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};

const CreatorChip = ({ creator, onRemove }: { creator: Creator, onRemove: (creatorId: string) => void }) => {
    return (
        <motion.div onClick={(e) => { e.stopPropagation(); onRemove(creator._id); }} layout variants={{ initial: { opacity: 0, scale: 0.5 }, visible: { opacity: 1, scale: 1 }, exiting: { opacity: 0, scale: 0.6 } }} initial="initial" animate="visible" exit="exiting" style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 1, cursor: 'pointer' }} title={`Click to remove "${creator.name}"`} whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}>
            <span>{creator.name}</span>
            <svg width="12" height="12" viewBox="0 0 24 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function CreatorInput({ label, roleToSearch, selectedCreators = [], onCreatorsChange }: CreatorInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [results, setResults] = useState<Creator[]>([]);
    const [isPending, startTransition] = useTransition();
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const validSelectedCreators = (selectedCreators || []).filter(Boolean);

    useEffect(() => { const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; document.addEventListener('mousedown', handleClickOutside); return () => document.removeEventListener('mousedown', handleClickOutside); }, []);
    
    useEffect(() => { 
        if (isPopoverOpen) { 
            startTransition(() => { 
                searchCreatorsAction(debouncedSearchTerm, roleToSearch).then(setResults); 
            }); 
        } 
    }, [debouncedSearchTerm, roleToSearch, isPopoverOpen]);

    useEffect(() => { 
        if (isPopoverOpen) { 
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else { 
            setSearchTerm(''); 
        } 
    }, [isPopoverOpen]);

    const addCreator = (creator: Creator) => {
        if (!validSelectedCreators.some(c => c._id === creator._id)) {
            onCreatorsChange([...validSelectedCreators, creator]);
        }
        setSearchTerm('');
        inputRef.current?.focus();
    };
    
    const removeCreator = (creatorIdToRemove: string) => {
        onCreatorsChange(validSelectedCreators.filter(c => c._id !== creatorIdToRemove));
    };

    const availableResults = results.filter(res => !validSelectedCreators.some(sel => sel._id === res._id));

    return (
        <div className={styles.sidebarSection} ref={wrapperRef}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                <div 
                    className={styles.sidebarInput} 
                    style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text' }} 
                    onClick={() => setIsPopoverOpen(true)}
                >
                    <AnimatePresence>
                        {validSelectedCreators.map(creator => (<CreatorChip key={creator._id} creator={creator} onRemove={removeCreator} />))}
                    </AnimatePresence>
                    
                    {validSelectedCreators.length === 0 && !isPopoverOpen && (
                        <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>{`انقر لإضافة ${label.toLowerCase()}`}</span>
                    )}
                </div>
                
                <AnimatePresence>
                    {isPopoverOpen && (
                        <motion.div 
                            onClick={(e) => e.stopPropagation()} 
                            variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                            style={{ 
                                position: 'absolute', top: '100%', left: 0, 
                                width: '100%',
                                background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                borderRadius: '6px', zIndex: 10, 
                                padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)', marginTop: '0.5rem'
                            }}
                        >
                            <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder={`ابحث بالاسم...`} className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                            <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                {isPending ? <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>جار البحث...</div> : (
                                    <>
                                        {availableResults.map(creator => ( <button type="button" key={creator._id} onClick={() => addCreator(creator)} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} className={styles.popoverItemButton}> {creator.name} </button> ))}
                                        {!isPending && availableResults.length === 0 && <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>لا يوجد نتائج.</div>}
                                    </>
                                )}
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

// app/studio/[contentType]/[id]/metadata/GameInput.tsx
'use client';

import { useState, useEffect, useRef, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useDebounce } from '@/hooks/useDebounce';
import { searchGamesAction, createGameAction } from '../../../actions';
import { AddGameModal } from './AddGameModal';
import ActionButton from '@/components/ActionButton';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Game = { _id: string; title: string };
interface GameInputProps { selectedGame: Game | null; onGameSelect: (game: Game | null) => void; }
// THE FIX: Removed staggerChildren from the transition
const popoverVariants = { hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, };
const itemVariants = { hidden: { opacity: 0, x: -10 }, visible: { opacity: 1, x: 0 }, };

export function GameInput({ selectedGame, onGameSelect }: GameInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddGameModalOpen, setIsAddGameModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [results, setResults] = useState<Game[]>([]);
    const [initialGames, setInitialGames] = useState<Game[]>([]);
    const [isPending, startTransition] = useTransition();
    const debouncedSearchTerm = useDebounce(searchTerm, 300);
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => { 
        if (isPopoverOpen) { 
            if (initialGames.length === 0) {
                searchGamesAction('').then(games => {
                    setInitialGames(games);
                    setResults(games);
                });
            }
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else {
            setSearchTerm('');
        }
    }, [isPopoverOpen, initialGames.length]);

    useEffect(() => { 
        if (debouncedSearchTerm.length > 1) { 
            startTransition(() => { searchGamesAction(debouncedSearchTerm).then(setResults); });
        } else if (isPopoverOpen) {
            setResults(initialGames);
        } else {
            setResults([]);
        }
    }, [debouncedSearchTerm, isPopoverOpen, initialGames]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const handleSelect = (game: Game) => { onGameSelect(game); setIsPopoverOpen(false); };
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddGameModalOpen(true); };
    const handleCreateGame = async (title: string) => { const newGame = await createGameAction(title); if (newGame) { onGameSelect(newGame); } setIsAddGameModalOpen(false); setSearchTerm(''); };
    
    const showCreateOption = searchTerm.trim().length > 1 && !results.some(r => r.title.toLowerCase() === searchTerm.toLowerCase()) && !isPending;
    
    const displayResults = !isPending ? results : [];

    return (
        <>
            <AddGameModal isOpen={isAddGameModalOpen} onClose={() => setIsAddGameModalOpen(false)} onSubmit={handleCreateGame} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>اللعبة</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', justifyContent: 'space-between', 
                            cursor: selectedGame ? 'default' : 'text',
                            paddingRight: '0.5rem',
                        }} 
                        onClick={() => {if (!selectedGame) setIsPopoverOpen(true)}}
                    >
                        <span>{selectedGame ? selectedGame.title : 'ابحث عن لعبة أو أنشئها...'}</span>
                    </div>
                    
                    {selectedGame ? (
                        <ActionButton type="button" onClick={() => onGameSelect(null)} aria-label="Remove selected game">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </ActionButton>
                    ) : (
                        <ActionButton type="button" onClick={handleOpenModal} aria-label="إضافة لعبة جديدة">
                             <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </ActionButton>
                    )}
                    
                    <AnimatePresence>
                        {isPopoverOpen && !selectedGame && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()} 
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, right: 0,
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 10, marginTop: '0.5rem',
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search for a game..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {isPending ? <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>Searching...</div> : (
                                        <>
                                            {displayResults.map(game => (<motion.button type="button" key={game._id} variants={itemVariants} onClick={() => handleSelect(game)} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)' }} whileHover={{ backgroundColor: 'var(--bg-primary)' }}>{game.title}</motion.button>))}
                                            {showCreateOption && (
                                                <motion.button type="button" variants={itemVariants} onClick={handleOpenModal} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic' }} whileHover={{ backgroundColor: 'var(--bg-primary)' }}>
                                                    + Create new game: "{searchTerm.trim()}"
                                                </motion.button>
                                            )}
                                        </>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

// app/studio/[contentType]/[id]/metadata/MainImageInput.tsx
'use client';

import { useState, useRef, useTransition, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload, UploadQuality } from '@/lib/image-optimizer';
import { clientAssetUploader } from '@/lib/sanity.client';
import avatarStyles from '../../../../components/ProfileEditForm.module.css';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

export function MainImageInput({ currentAssetId, currentAssetUrl, onImageChange, uploadQuality }: {
    currentAssetId: string | null;
    currentAssetUrl: string | null;
    onImageChange: (assetId: string | null, url: string | null) => void;
    uploadQuality: UploadQuality;
}) {
    const [isDragging, setIsDragging] = useState(false);
    const [previewUrl, setPreviewUrl] = useState<string | null>(currentAssetUrl);
    const [isUploading, startUpload] = useTransition();
    const fileInputRef = useRef<HTMLInputElement>(null);
    const toast = useToast();

    useEffect(() => {
        setPreviewUrl(currentAssetUrl);
    }, [currentAssetUrl]);

    const handleFile = useCallback(async (file: File) => {
        if (!file.type.startsWith('image/')) {
            toast.error('نوع الملف غير صالح. يرجى رفع صورة.', 'left');
            return;
        }

        startUpload(async () => {
            try {
                toast.info('جار تحسين الصورة...', 'left');
                // THE FIX: Get file and final quality from optimizer
                const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, uploadQuality);
                const localUrl = URL.createObjectURL(optimizedFile);
                setPreviewUrl(localUrl);

                // THE FIX: Use final size and quality in the toast
                toast.info(`جار رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
                
                const asset = await clientAssetUploader.assets.upload('image', optimizedFile, {
                    filename: optimizedFile.name,
                    contentType: optimizedFile.type,
                });
                
                if (asset?._id && asset?.url) {
                    onImageChange(asset._id, asset.url);
                    toast.success('تم رفع الصورة الرئيسية بنجاح.', 'left');
                } else {
                    throw new Error('فشل رفع الصورة إلى Sanity.');
                }
            } catch (error: any) {
                setPreviewUrl(currentAssetUrl);
                onImageChange(currentAssetId, currentAssetUrl);
                toast.error(error.message || 'فشل تحسين الصورة.', 'left');
            }
        });
    }, [onImageChange, toast, currentAssetUrl, currentAssetId, uploadQuality]);
    
    // ... (rest of the component is the same)
    const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        setIsDragging(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            handleFile(e.dataTransfer.files[0]);
        }
    }, [handleFile]);

    const handleClear = () => {
        setPreviewUrl(null);
        onImageChange(null, null);
        if (fileInputRef.current) fileInputRef.current.value = '';
        toast.info('تمت إزالة الصورة الرئيسية.', 'left');
    };

    return (
        <>
            <input type="file" ref={fileInputRef} onChange={(e) => e.target.files && handleFile(e.target.files[0])} accept="image/*" style={{ display: 'none' }} disabled={isUploading} />
            <motion.div
                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                onDragLeave={() => setIsDragging(false)}
                onDrop={handleDrop}
                onClick={() => !isUploading && fileInputRef.current?.click()}
                style={{
                    aspectRatio: '16/9',
                    border: `2px dashed ${isDragging ? 'var(--accent)' : 'var(--border-color)'}`,
                    backgroundColor: isDragging ? 'color-mix(in srgb, var(--accent) 10%, transparent)' : 'var(--bg-primary)',
                    borderRadius: '8px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: isUploading ? 'progress' : 'pointer',
                    position: 'relative',
                    overflow: 'hidden',
                    transition: 'all 0.2s ease',
                }}
            >
                <AnimatePresence>
                    {previewUrl ? (
                        <motion.div key="image" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ width: '100%', height: '100%' }}>
                            <Image src={previewUrl} alt="معاينة الصورة المصغرة" fill sizes="300px" style={{ objectFit: 'cover' }} />
                            {isUploading && <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}><div className="spinner" style={{ width: '30px', height: '30px' }}/></div>}
                        </motion.div>
                    ) : (
                        <motion.div key="placeholder" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                            {isUploading ? ( <div className="spinner" /> ) : (
                                <>
                                    <p style={{ margin: 0 }}>اسحب وأفلت أو انقر للرفع</p>
                                    <p style={{ fontSize: '1.2rem', margin: '0.5rem 0 0 0' }}>سيتم تحسين الصور الكبيرة تلقائيًا</p>
                                </>
                            )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </motion.div>

            {previewUrl && (
                <button type="button" onClick={handleClear} className="outline-button" style={{ width: '100%', marginTop: '1rem', color: '#DC2626', borderColor: '#DC2626' }}>
                    إزالة الصورة
                </button>
            )}
        </>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

/* app/studio/[contentType]/[id]/metadata/Metadata.module.css */

.inputWrapper {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.inputWrapper > input,
.inputWrapper > div[class*="sidebarInput"] {
    flex-grow: 1;
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

// app/studio/[contentType]/[id]/metadata/PlatformInput.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Editor.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

const PLATFORMS = ['PC', 'PS5', 'Xbox', 'Switch'];

interface PlatformInputProps {
    selectedPlatforms: string[];
    onPlatformsChange: (platforms: string[]) => void;
}

export function PlatformInput({ selectedPlatforms = [], onPlatformsChange }: PlatformInputProps) {
    
    const handleToggle = (platform: string) => {
        const newSelection = selectedPlatforms.includes(platform)
            ? selectedPlatforms.filter(p => p !== platform)
            : [...selectedPlatforms, platform];
        onPlatformsChange(newSelection);
    };

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>المنصات</label>
            <div className={filterStyles.filterButtonsGroup}>
                {PLATFORMS.map(platform => {
                    const isActive = selectedPlatforms.includes(platform);
                    return (
                        <motion.button
                            key={platform}
                            type="button"
                            onClick={() => handleToggle(platform)}
                            className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`}
                        >
                            {platform}
                            {isActive && <motion.div layoutId="platform-highlight" className={filterStyles.filterHighlight} />}
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

// app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from '@/components/ActionButton';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

interface ProsConsInputProps { label: 'المحاسن' | 'المآخذ'; items: string[]; setItems: (newItems: string[]) => void; }
const itemVariants = { hidden: { opacity: 0, x: 20 }, visible: { opacity: 1, x: 0 }, exit: { opacity: 0, x: -20, transition: { duration: 0.2 } }, };
const RemoveIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

export function ProsConsInput({ label, items, setItems }: ProsConsInputProps) {
    const handleAddItem = () => { setItems([...items, '']); };
    const handleRemoveItem = (index: number) => { setItems(items.filter((_, i) => i !== index)); };
    const handleItemChange = (index: number, value: string) => { const newItems = [...items]; newItems[index] = value; setItems(newItems); };

    const buttonText = label === 'المحاسن' ? '+ إضافة محسن' : '+ إضافة مأخذ';
    const ariaLabel = label === 'المحاسن' ? 'إزالة المحسن' : 'إزالة المأخذ';

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                <AnimatePresence>
                    {items.map((item, index) => (
                        <motion.div key={index} layout variants={itemVariants} initial="hidden" animate="visible" exit="exit" transition={{ type: 'spring', stiffness: 400, damping: 25 }} className={metadataStyles.inputWrapper}>
                            <ActionButton type="button" onClick={() => handleRemoveItem(index)} aria-label={ariaLabel}>
                                <RemoveIcon />
                            </ActionButton>
                            <input type="text" value={item} onChange={(e) => handleItemChange(index, e.target.value)} className={styles.sidebarInput} />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </div>
            <button type="button" onClick={handleAddItem} className="outline-button" style={{ width: '100%', marginTop: '1rem' }}>
                {buttonText}
            </button>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

// app/studio/[contentType]/[id]/metadata/TagInput.tsx
'use client';

import { useState, useEffect, useRef, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useDebounce } from '@/hooks/useDebounce';
import { searchTagsAction, createTagAction, getRecentTagsAction } from '../../../actions';
import { AddTagModal } from './AddTagModal';
import ActionButton from '@/components/ActionButton';
import { translateTag } from '@/lib/translations';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Tag = { _id: string; title: string };

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};

const AnimatedTag = ({ tag, onRemove }: { tag: Tag, onRemove: (tagId: string) => void }) => {
    const [isDeleting, setIsDeleting] = useState(false);
    const tagVariants = { initial: { opacity: 0, scale: 0.5 }, visible: { opacity: 1, scale: 1 }, exiting: { opacity: 0, scale: 0.6, transition: { duration: 0.2, ease: 'easeOut' } }, };
    const handleRemove = (e: React.MouseEvent) => { e.stopPropagation(); setIsDeleting(true); };
    return (
        <motion.div onClick={handleRemove} layout variants={tagVariants} initial="initial" animate={isDeleting ? "exiting" : "visible"} exit="exiting" onAnimationComplete={() => { if (isDeleting) { onRemove(tag._id); } }} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 1, cursor: 'pointer' }} title={`Click to remove "${translateTag(tag.title)}"`} whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}>
            <span>{translateTag(tag.title)}</span>
            <svg width="12" height="12" viewBox="0 0 24 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function TagInput({ selectedTags, onTagsChange }: { selectedTags: Tag[], onTagsChange: (tags: Tag[]) => void }) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddTagModalOpen, setIsAddTagModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [results, setResults] = useState<Tag[]>([]);
    const [initialTags, setInitialTags] = useState<Tag[]>([]);
    const [isPending, startTransition] = useTransition();
    const debouncedSearchTerm = useDebounce(searchTerm, 200);
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => { 
        if (isPopoverOpen) { 
            if (initialTags.length === 0) { 
                getRecentTagsAction().then(tags => {
                    setInitialTags(tags);
                    setResults(tags);
                }); 
            }
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else { 
            setSearchTerm(''); 
        } 
    }, [isPopoverOpen, initialTags.length]);
    
    useEffect(() => { 
        if (debouncedSearchTerm.length > 0) { 
            startTransition(() => { 
                searchTagsAction(debouncedSearchTerm).then(setResults); 
            }); 
        } else if (isPopoverOpen) {
            setResults(initialTags);
        } else {
            setResults([]);
        }
    }, [debouncedSearchTerm, isPopoverOpen, initialTags]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { 
            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { 
                setIsPopoverOpen(false); 
            } 
        }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const addTag = (tag: Tag) => { if (!selectedTags.some(t => t._id === tag._id)) { onTagsChange([...selectedTags, tag]); } setSearchTerm(''); inputRef.current?.focus(); };
    const removeTag = (tagIdToRemove: string) => { onTagsChange(selectedTags.filter(tag => tag._id !== tagIdToRemove)); };
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddTagModalOpen(true); };
    const handleCreateTag = async (title: string) => { const newTag = await createTagAction(title); if (newTag) { addTag(newTag); } setIsAddTagModalOpen(false); setSearchTerm(''); };
    
    const showCreateOption = searchTerm.trim().length > 1 && !results.some(r => r.title.toLowerCase() === searchTerm.toLowerCase()) && !isPending;
    
    const filteredResults = !isPending ? results.filter(tag => !selectedTags.some(st => st._id === tag._id)) : [];

    return (
        <>
            <AddTagModal isOpen={isAddTagModalOpen} onClose={() => setIsAddTagModalOpen(false)} onSubmit={handleCreateTag} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>الوسوم</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', 
                            minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text',
                        }} 
                        onClick={() => setIsPopoverOpen(true)}
                    >
                        <AnimatePresence>{selectedTags.map(tag => (<AnimatedTag key={tag._id} tag={tag} onRemove={removeTag} />))}</AnimatePresence>
                        {selectedTags.length === 0 && !isPopoverOpen && (
                            // THE DEFINITIVE FIX: Use `right` for RTL positioning.
                            <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>انقر لإضافة الوسوم...</span>
                        )}
                    </div>
                     <ActionButton type="button" onClick={handleOpenModal} aria-label="إضافة وسم جديد">
                        <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </ActionButton>
                    
                    <AnimatePresence>
                        {isPopoverOpen && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()} 
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, 
                                    width: '100%',
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 10, 
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.1)', marginTop: '0.5rem'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="Search or create a tag..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {isPending ? <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>Searching...</div> : (
                                        <>
                                            {filteredResults.map(tag => ( <button type="button" key={tag._id} onClick={() => addTag(tag)} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} className={styles.popoverItemButton}> {translateTag(tag.title)} </button> ))}
                                            {showCreateOption && (
                                                <button type="button" onClick={handleOpenModal} style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic' }} className={styles.popoverItemButton}>
                                                    + Create new tag: "{searchTerm.trim()}"
                                                </button>
                                            )}
                                        </>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

================================================================================

--- START OF FILE app/tags/[tag]/page.tsx ---

// app/tags/[tag]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByTagListQuery } from '@/lib/sanity.queries'; // Use LEAN query
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import { translateTag } from '@/lib/translations';

export default async function TagPage({ params }: { params: { tag: string } }) {
    const tagSlug = decodeURIComponent(params.tag);

    const tagMeta = await client.fetch(
        `*[_type == "tag" && slug.current == $slug][0]{title}`,
        { slug: tagSlug }
    );

    if (!tagMeta) {
        notFound();
    }

    // MODIFIED: Using lean query for initial content load
    const allItems = await client.fetch(allContentByTagListQuery, { slug: tagSlug });

    if (!allItems || allItems.length === 0) {
        return (
            <div className="container page-container">
                <h1 className="page-title">وسم: &quot;{translateTag(tagMeta.title)}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يتم نشر أي محتوى بهذا الوسم بعد.</p>
            </div>
        );
    }
    
    return (
         <HubPageClient
            initialItems={allItems}
            hubTitle={translateTag(tagMeta.title)}
            hubType="وسم"
        />
    );
}




--- END OF FILE app/tags/[tag]/page.tsx ---

================================================================================

--- START OF FILE app/welcome/page.tsx ---

// app/welcome/page.tsx
'use client';

import { useState, useTransition, useEffect, useMemo } from 'react';
import { completeOnboardingAction, checkUsernameAvailability } from '@/app/actions/userActions';
import { useSession } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useDebounce } from '@/hooks/useDebounce';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useToast } from '@/lib/toastStore';
import { countries } from '@/lib/countries';
import Link from 'next/link';

const InfoTooltip = ({ text }: { text: string }) => (
    <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', marginLeft: '0.5rem', cursor: 'pointer' }} className="info-tooltip-container">
        <svg width="16" height="16" viewBox="0 0 20 20" fill="var(--text-secondary)"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" /></svg>
        <div className="info-tooltip-text">{text}</div>
    </div>
);

export default function WelcomePage() {
    const { data: session, status: sessionStatus, update } = useSession();
    const router = useRouter();
    const searchParams = useSearchParams();
    const toast = useToast();

    const [fullName, setFullName] = useState('');
    const [username, setUsername] = useState('');
    const [age, setAge] = useState('');
    const [country, setCountry] = useState('');
    const [countrySearch, setCountrySearch] = useState('');
    const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);
    const [termsAccepted, setTermsAccepted] = useState(false);

    const [usernameStatus, setUsernameStatus] = useState<{ type: 'idle' | 'checking' | 'valid' | 'invalid', message: string }>({ type: 'idle', message: '' });
    const [isPending, startTransition] = useTransition();
    const debouncedUsername = useDebounce(username, 500);

    const hasInitialUsername = !!session?.user?.username;

    const filteredCountries = useMemo(() => 
        countries.filter(c => c.toLowerCase().includes(countrySearch.toLowerCase())),
    [countrySearch]);
    
    useEffect(() => {
        if (sessionStatus === 'authenticated') {
            if (!(session as any)?.needsOnboarding) {
                const callbackUrl = searchParams.get('callbackUrl') || '/';
                router.replace(callbackUrl);
                return;
            }
            setFullName(session.user?.name ?? '');
            if (session.user?.username) {
                setUsername(session.user.username);
            }
        }
    }, [sessionStatus, session, router, searchParams]);


    useEffect(() => {
        if (!hasInitialUsername && debouncedUsername) {
            setUsernameStatus({ type: 'checking', message: 'جارٍ التحقق...' });
            checkUsernameAvailability(debouncedUsername).then(result => {
                setUsernameStatus({ type: result.available ? 'valid' : 'invalid', message: result.message });
            });
        } else if (!hasInitialUsername) {
            setUsernameStatus({ type: 'idle', message: '' });
        }
    }, [debouncedUsername, hasInitialUsername]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (isButtonDisabled) return;

        const formData = new FormData(e.target as HTMLFormElement);
        startTransition(async () => {
            const result = await completeOnboardingAction(formData);
            if (result.success) {
                toast.success('اكتمل ملفك. أهلاً بك في EternalGames.');
                await update(); 
                const callbackUrl = searchParams.get('callbackUrl') || '/';
                router.push(callbackUrl);
            } else {
                toast.error(result.message || 'فشل إكمال الملف الشخصي.');
            }
        });
    };

    if (sessionStatus === 'loading' || !session || (sessionStatus === 'authenticated' && !(session as any)?.needsOnboarding)) {
        return (
            <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
                <div className="spinner" />
            </div>
        );
    }
    
    const isButtonDisabled = isPending || (!hasInitialUsername && usernameStatus.type !== 'valid') || !fullName || !termsAccepted;

    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'flex-start', paddingTop: '15vh' }}>
            <motion.div 
                style={{ maxWidth: '500px', width: '100%', textAlign: 'center' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <h1 className="page-title">أهلاً بك في رحاب EternalGames!</h1>
                <p style={{ color: 'var(--text-secondary)', fontSize: '1.8rem', marginTop: '-2rem', marginBottom: '3rem' }}>بقيت خطوة أخيرة. أكمل ملفك الشخصي لتدخل مجتمعنا.</p>
                <form onSubmit={handleSubmit} style={{ textAlign: 'left' }}>
                    <div className="profile-form-group">
                        <input id="fullName" name="fullName" type="text" value={fullName} onChange={(e) => setFullName(e.target.value)} className="profile-input" placeholder=" " required />
                        <label htmlFor="fullName" className="profile-form-label">الاسم الكامل</label>
                    </div>

                    {!hasInitialUsername && (
                        <div className="profile-form-group">
                            <input id="username" name="username" type="text" value={username} onChange={(e) => setUsername(e.target.value.toLowerCase())} className="profile-input" placeholder=" " autoFocus required />
                            <label htmlFor="username" className="profile-form-label">اختر اسمًا للمستخدم</label>
                            <AnimatePresence>
                                {usernameStatus.message && <motion.p initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} style={{ fontSize: '1.4rem', margin: '0.5rem 0 0 0', color: usernameStatus.type === 'invalid' ? '#DC2626' : (usernameStatus.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameStatus.message}</motion.p>}
                            </AnimatePresence>
                        </div>
                    )}
                    
                    {hasInitialUsername && (
                        <input type="hidden" name="username" value={username} />
                    )}

                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem' }}>
                        <div className="profile-form-group">
                            <input 
                                id="age" 
                                name="age" 
                                type="text"
                                inputMode="numeric"
                                pattern="[0-9]*"
                                value={age} 
                                onChange={(e) => {
                                    if (e.target.value === '' || /^[0-9]+$/.test(e.target.value)) {
                                        setAge(e.target.value);
                                    }
                                }} 
                                className="profile-input" 
                                placeholder=" " 
                            />
                            <label htmlFor="age" className="profile-form-label">العمر (اختياري)<InfoTooltip text="عمرك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                        </div>
                        <div className="profile-form-group" style={{ position: 'relative' }}>
                            <input id="country" name="country" type="text" value={country} onFocus={() => setIsCountryDropdownOpen(true)} onBlur={() => setTimeout(() => setIsCountryDropdownOpen(false), 150)} onChange={(e) => { setCountry(e.target.value); setCountrySearch(e.target.value); }} className="profile-input" placeholder=" " autoComplete="off" />
                            <label htmlFor="country" className="profile-form-label">البلد (اختياري)<InfoTooltip text="بلدك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                            {isCountryDropdownOpen && (
                                <div style={{ position: 'absolute', top: '100%', left: 0, right: 0, maxHeight: '200px', overflowY: 'auto', background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '8px', zIndex: 10, marginTop: '0.5rem' }}>
                                    {filteredCountries.map(c => 
                                        <button type="button" key={c} onMouseDown={() => { setCountry(c); setIsCountryDropdownOpen(false); }} 
                                        className="country-picker-button">
                                            {c}
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="profile-form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                        <input type="checkbox" id="terms" name="terms" checked={termsAccepted} onChange={(e) => setTermsAccepted(e.target.checked)} style={{ width: '1.6rem', height: '1.6rem' }}/>
                        <label htmlFor="terms" style={{ fontSize: '1.4rem', color: 'var(--text-secondary)' }}>أوافق على<Link href="/terms-of-service" target="_blank">شروط الخدمة</Link>.
                        </label>
                    </div>

                    {/* --- THE FIX IS HERE --- */}
                    <motion.button type="submit" className="primary-button" style={{ width: '100%', marginTop: '1rem', height: '48px' }} disabled={isButtonDisabled} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '5px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                        <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إكمال الملف الشخصي</motion.span>}</AnimatePresence>
                    </motion.button>
                </form>
            </motion.div>
        </div>
    );
}




--- END OF FILE app/welcome/page.tsx ---

================================================================================

--- START OF FILE components/ActionButton.module.css ---

/* components/ActionButton.module.css */

.actionButton {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    /* --- THE FIX IS HERE --- */
    width: 36px;
    height: 36px;
    aspect-ratio: 1 / 1;
    flex-shrink: 0;
    /* --- END FIX --- */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.2s ease;
    z-index: 10;
}

.actionButton:hover:not(:disabled) {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
    /* NEW: Explicitly transition transform and box-shadow quickly */
    transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.2s ease-out, box-shadow 0.2s ease-out;
}

[data-theme="dark"] .actionButton:hover:not(:disabled) {
    color: var(--bg-primary);
}




--- END OF FILE components/ActionButton.module.css ---

================================================================================

--- START OF FILE components/ActionButton.tsx ---

// components/ActionButton.tsx
'use client';

import { motion } from 'framer-motion';
import React from 'react';
import styles from './ActionButton.module.css';

interface ActionButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    children: React.ReactNode;
    'aria-label': string;
}

const ActionButton = React.forwardRef<HTMLButtonElement, ActionButtonProps>(
    ({ children, ...props }, ref) => {
        return (
            <motion.button
                ref={ref}
                className={styles.actionButton}
                whileTap={{ scale: 0.9, y: 0 }}
                whileHover={{ scale: 1.15, y: 0 }}
                // --- THE FIX: Use an instantaneous tween/duration for immediate feel ---
                transition={{ duration: 0.05, ease: "easeInOut" }}
                {...props}
            >
                {children}
            </motion.button>
        );
    }
);

ActionButton.displayName = 'ActionButton';
export default ActionButton;




--- END OF FILE components/ActionButton.tsx ---

================================================================================

--- START OF FILE components/AnimatedGridBackground.tsx ---

// components/AnimatedGridBackground.tsx

'use client';

import { motion } from 'framer-motion';

export default function AnimatedGridBackground() {
  return (
    <motion.div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        width: '100vw',
        height: '100vh',
        zIndex: -1,
        '--grid-size': '60px',
        '--grid-color': 'rgba(125, 128, 140, 0.1)',
        backgroundImage:
          'linear-gradient(to right, var(--grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px)',
        backgroundSize: 'var(--grid-size) var(--grid-size)',
      }}
      animate={{
        backgroundPosition: ['0px 0px', 'var(--grid-size) var(--grid-size)'],
      }}
      transition={{
        duration: 10,
        repeat: Infinity,
        ease: 'linear',
      }}
    />
  );
}

























--- END OF FILE components/AnimatedGridBackground.tsx ---

================================================================================

--- START OF FILE components/AnimatedNumber.tsx ---

// components/AnimatedNumber.tsx
'use client';

import { motion, useAnimate } from 'framer-motion';
import { useEffect } from 'react';

const DIGIT_MAP: { [key: string]: number } = { '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, };

const Digit = ({ digit, isInView }: { digit: string; isInView: boolean }) => {
    const [scope, animate] = useAnimate();
    const digitHeight = 90;

    useEffect(() => {
        if (isInView) {
            animate(scope.current, { y: -DIGIT_MAP[digit] * digitHeight }, { duration: 1.5, ease: [0.22, 1, 0.36, 1] });
        }
    }, [digit, isInView, animate, scope, digitHeight]);

    return (
        <div style={{ height: `${digitHeight}px`, overflow: 'hidden' }}>
            <motion.div ref={scope} style={{ y: 0 }}>
                {Object.keys(DIGIT_MAP).map(d => <div key={d} style={{ height: `${digitHeight}px` }}>{d}</div>)}
            </motion.div>
        </div>
    );
};

export const AnimatedNumber = ({ value, isInView, className }: { value: number; isInView: boolean; className: string; }) => {
    const [scope, animate] = useAnimate();

    useEffect(() => {
        if (isInView) {
            const popAnimation = animate(scope.current, { scale: [1, 1.15, 1], }, { duration: 0.4, delay: 1.5, ease: "easeOut", });
            return () => { popAnimation.stop(); };
        }
    }, [isInView, animate, scope]);

    const stringValue = value.toFixed(1);
    const [integerPart, decimalPart] = stringValue.split('.');
    const integerDigits = Array.from(integerPart);

    return (
        <div ref={scope} className={className} style={{ display: 'flex', justifyContent: 'center' }}>
            {/* THE DEFINITIVE FIX:
                Render decimal part FIRST in the code, so RTL layout places it on the LEFT.
                Render integer part LAST in the code, so RTL layout places it on the RIGHT.
                Removed `flexDirection: 'row-reverse'`.
            */}
            <Digit digit={decimalPart} isInView={isInView} />
            <div style={{ lineHeight: '8rem' }}>.</div>
            {integerDigits.map((digit, i) => <Digit key={i} digit={digit} isInView={isInView} />)}
        </div>
    );
};




--- END OF FILE components/AnimatedNumber.tsx ---

================================================================================

--- START OF FILE components/AnimatedReleases.tsx ---

'use client';

import { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import { ContentBlock } from '@/components/ContentBlock';
import KineticReleaseTimeline from '@/components/KineticReleaseTimeline';

export default function AnimatedReleases({ releases }: { releases: any[] }) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.4 });
    const variants = { hidden: { opacity: 0, y: 50 }, visible: { opacity: 1, y: 0 } };

    return (
        <motion.div 
            ref={ref} 
            variants={variants} 
            initial="hidden" 
            animate={isInView ? "visible" : "hidden"} 
            transition={{ duration: 0.8, ease: "easeOut" }}
        >
            <ContentBlock title="إصدارات هذا الشهر">
                <p style={{textAlign: 'center', maxWidth: '600px', margin: '-2rem auto 4rem auto', color: 'var(--text-secondary)'}}>نظرة على الألعاب التي ترى النور هذا الشهر. ما صدر منها قد وُسِمَ بعلامة.</p>
                <KineticReleaseTimeline releases={releases} />
            </ContentBlock>
        </motion.div>
    );
}




--- END OF FILE components/AnimatedReleases.tsx ---

================================================================================

--- START OF FILE components/ArticleCard.module.css ---

/* components/ArticleCard.module.css */

.livingCardWrapper {
    transform-style: preserve-3d;
    height: 100%;
}

.cardLink {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
}

.articleCard {
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    height: 100%;
    border: 1px solid var(--border-color);
    transform-style: preserve-3d;
    will-change: transform;
    transition: box-shadow 0.4s ease-out, border-color 0.4s ease-out;
}

.livingCardWrapper:hover .articleCard {
    border-color: color-mix(in srgb, var(--text-primary) 20%, transparent);
}

.imageContainer {
    overflow: hidden;
    position: relative;
    width: 100%;
    height: 200px;
    flex-shrink: 0;
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.score {
    position: absolute;
    top: 1rem;
    left: 1rem; /* RTL FIX */
    right: auto;
    background-color: var(--accent);
    color: #FFFFFF;
    font-family: var(--font-main), sans-serif;
    font-weight: 800;
    font-size: 1.6rem;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    box-shadow: 0 0 10px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 2;
    opacity: 0;
    transform: translateY(10px) translateZ(50px);
    transition: opacity 0.3s ease, transform 0.3s ease;
}

[data-theme="dark"] .score {
    color: var(--bg-primary);
}

.livingCardWrapper:hover .score {
    opacity: 1;
    transform: translateY(0) translateZ(50px);
}

.cardContent {
    padding: 2rem;
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    min-height: 0;
    transform: translateZ(20px);
    text-align: right; /* RTL FIX */
}

.cardTitleLink {
    color: var(--text-primary);
    transition: color 0.2s ease;
    text-decoration: none;
}

.cardTitleLink:hover {
    color: var(--accent);
}

.cardTitleLink h3 {
    font-size: 2rem;
    margin-bottom: 1rem;
    margin-top: 0;
}

.cardMetadata {
    font-family: var(--font-main), sans-serif;
    font-size: 1.4rem;
    color: var(--text-secondary);
}

.authorLink {
    color: var(--text-secondary);
    font-weight: 500;
    cursor: pointer;
    text-decoration: none;
}

.authorLink:hover {
    color: var(--text-primary);
    text-decoration: underline;
}

.tagContainer {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}




--- END OF FILE components/ArticleCard.module.css ---

================================================================================

--- START OF FILE components/ArticleCard.tsx ---

// components/ArticleCard.tsx
'use client';

import React, { memo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import TagLinks from './TagLinks';
import { motion } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import CreatorCredit from './CreatorCredit';
import { CardProps } from '@/types';
import styles from './ArticleCard.module.css';

type ArticleCardProps = {
    article: CardProps & { width?: number; height?: number; mainImageRef?: any; };
    layoutIdPrefix: string;
    isPriority?: boolean;
    isArticle?: boolean;
};

const ArticleCardComponent = ({ article, layoutIdPrefix, isPriority = false, isArticle = false }: ArticleCardProps) => {
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix); 
    const { livingCardRef, livingCardAnimation } = useLivingCard();

    const type = article.type;
    const isReview = type === 'review';

    const getLinkBasePath = () => {
        switch (type) {
            case 'review': return '/reviews/';
            case 'article': return '/articles/';
            case 'news': return '/news/';
            default: return '/';
        }
    };

    const linkPath = `${getLinkBasePath()}${article.slug}`;
    
    // This handler is now used by the individual Link components inside
    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    const handleMouseEnter = () => {
        router.prefetch(linkPath);
    };

    const hasScore = isReview && typeof article.score === 'number';
    const authorLabel = isReview ? 'مراجعة' : (type === 'news' ? 'خبر' : 'مقالة');

    const imageSource = article.imageUrl;
    if (!imageSource) return null;
    
    const baseUrl = imageSource.split('?')[0];
    const imageUrl = `${baseUrl}?w=600&auto=format&q=80`;

    // --- THE DEFINITIVE FIX: START ---
    // The outermost element is now a motion.div, not an <a> tag.
    return (
        <motion.div
            ref={livingCardRef}
            onMouseMove={livingCardAnimation.onMouseMove}
            onMouseEnter={() => { livingCardAnimation.onHoverStart(); handleMouseEnter(); }}
            onMouseLeave={livingCardAnimation.onHoverEnd}
            className={styles.livingCardWrapper}
            style={livingCardAnimation.style}
        >
            <motion.div
                layoutId={`${layoutIdPrefix}-card-container-${article.id}`}
                className={styles.articleCard}
            >
                {/* Link is now on the image */}
                <Link href={linkPath} onClick={handleClick} className="no-underline">
                    <motion.div className={styles.imageContainer} layoutId={`${layoutIdPrefix}-card-image-${article.id}`}>
                        {hasScore && ( <motion.div className={styles.score}>{article.score.toFixed(1)}</motion.div> )}
                        <Image 
                            src={imageUrl}
                            alt={article.title}
                            width={article.width || 1600}
                            height={article.height || 900}
                            sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 350px"
                            className={styles.cardImage}
                            style={{ objectFit: 'cover' }}
                            placeholder="blur" 
                            blurDataURL={article.blurDataURL}
                            priority={isPriority}
                            unoptimized
                        />
                    </motion.div>
                </Link>
                <motion.div className={styles.cardContent}>
                    <div>
                        {/* Link is now on the title */}
                        <Link href={linkPath} onClick={handleClick} className={`${styles.cardTitleLink} no-underline`}>
                            <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${article.id}`}>{article.title}</motion.h3>
                        </Link>
                        <div className={styles.cardMetadata}>
                            {/* CreatorCredit can now render a real link without nesting issues */}
                            <CreatorCredit label={authorLabel} creators={article.authors} />
                            {article.date && <p style={{margin: '0.25rem 0 0 0', fontSize: '1.3rem'}}>{article.date}</p>}
                        </div>
                    </div>
                    <div className={styles.tagContainer}>
                        <TagLinks tags={article.tags} small={true} />
                    </div>
                </motion.div>
            </motion.div>
        </motion.div>
        // --- THE DEFINITIVE FIX: END ---
    );
};

const ArticleCard = memo(ArticleCardComponent);
export default ArticleCard;

--- END OF FILE components/ArticleCard.tsx ---

================================================================================

--- START OF FILE components/ArticleGrid.tsx ---

// components/ArticleGrid.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import { CardProps } from '@/types';

export default function ArticleGrid({ articles }: { articles: CardProps[] }) {
  return (
    <motion.div layout className="content-grid">
      <AnimatePresence>
        {articles.map((article, index) => ( // <-- ADD INDEX
          <motion.div
            key={article.id}
            layout
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.8 }}
            transition={{ type: 'spring', stiffness: 250, damping: 25 }}
            style={{ height: '100%' }}
          >
            <ArticleCard
              article={article}
              layoutIdPrefix="articles-grid"
              isPriority={index < 3} // <-- PASS PROP TO FIRST 3 CARDS
            />
          </motion.div>
        ))}
      </AnimatePresence>
    </motion.div>
  );
}




--- END OF FILE components/ArticleGrid.tsx ---

================================================================================

--- START OF FILE components/AuthOrb.module.css ---

.authOrb {
  position: relative;
  width: 80px;
  height: 80px;
  background-color: var(--bg-secondary);
  border: 2px solid var(--border-color);
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.3s cubic-bezier(0.22,1,0.36,1), border-color 0.3s ease;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--text-primary) 10%, transparent);
}
.large {
  width: 120px;
  height: 120px;
}
.authOrb:hover:not(:disabled) {
  border-color: var(--accent);
}
.iconWrapper {
  width: 50%;
  height: 50%;
}
.large .iconWrapper {
  width: 45%;
  height: 45%;
}
.icon {
  width: 100%;
  height: 100%;
  color: var(--text-primary);
  filter: grayscale(1) opacity(0.7);
  transition: filter 0.3s ease, color 0.3s ease;
}
.authOrb:hover:not(:disabled) .icon {
  filter: grayscale(0) opacity(1);
  color: var(--accent);
}
.loaderExternal {
  position: absolute;
  width: 130%;
  height: 130%;
  top: 50%;
  right: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}







--- END OF FILE components/AuthOrb.module.css ---

================================================================================

--- START OF FILE components/AuthOrb.tsx ---

// components/AuthOrb.tsx

import { motion, AnimatePresence } from 'framer-motion';
import styles from './AuthOrb.module.css';

const OrbLoader = () => (
    <motion.svg
        className={styles.loaderExternal}
        viewBox="0 0 60 60"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.3 }}
    >
        <motion.circle
            cx="30"
            cy="30"
            r="28"
            fill="none"
            stroke="var(--accent)"
            strokeWidth="2.5"
            strokeLinecap="round"
            pathLength="1"
            strokeDasharray="1"
            strokeDashoffset="0.75"
            initial={{ rotate: -90 }}
            animate={{ rotate: 270 }}
            transition={{ duration: 1.2, repeat: Infinity, ease: "linear" }}
        />
    </motion.svg>
);

interface AuthOrbProps {
    Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
    onClick: () => void;
    ariaLabel: string;
    isLarge?: boolean;
    isLoading?: boolean;
    isDisabled?: boolean;
}

export const AuthOrb = ({ Icon, onClick, ariaLabel, isLarge = false, isLoading = false, isDisabled = false }: AuthOrbProps) => {
    return (
        <motion.button
            onClick={onClick}
            aria-label={ariaLabel}
            disabled={isDisabled}
            className={`${styles.authOrb} ${isLarge ? styles.large : ''}`}
            animate={{
                scale: isLoading ? 1.2 : (isDisabled ? 0.8 : 1),
                opacity: isLoading ? 1 : (isDisabled ? 0.4 : 1),
            }}
            whileHover={!isDisabled ? { scale: 1.1, y: -5 } : {}}
            whileTap={!isDisabled ? { scale: 0.95 } : {}}
            transition={{ type: 'spring', stiffness: 400, damping: 20 }}
            style={{ cursor: isDisabled ? 'default' : 'pointer' }}
        >
            <motion.div
                className={styles.iconWrapper}
                animate={{ opacity: isLoading ? 0.5 : 1 }}
            >
                <Icon className={styles.icon} />
            </motion.div>

            <AnimatePresence>
                {isLoading && <OrbLoader key="loader" />}
            </AnimatePresence>
        </motion.button>
    );
};







--- END OF FILE components/AuthOrb.tsx ---

================================================================================

--- START OF FILE components/AvatarCropperModal.tsx ---

'use client';

import { useState, useRef } from 'react';
import ReactCrop, { type Crop, type PixelCrop } from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import { AnimatePresence, motion } from 'framer-motion';

interface AvatarCropperModalProps {
isOpen: boolean;
onClose: () => void;
imageSrc: string;
onCropComplete: (file: File) => void;
}

// Function to convert canvas data to a file
function canvasToFile(canvas: HTMLCanvasElement, fileName: string): Promise<File> {
return new Promise((resolve, reject) => {
canvas.toBlob((blob) => {
if (!blob) {
reject(new Error('Canvas is empty'));
return;
}
resolve(new File([blob], fileName, { type: 'image/png' }));
}, 'image/png');
});
}

export default function AvatarCropperModal({
isOpen,
onClose,
imageSrc,
onCropComplete,
}: AvatarCropperModalProps) {
const imgRef = useRef<HTMLImageElement>(null);
const [crop, setCrop] = useState<Crop>({
unit: '%',
width: 50,
height: 50,
x: 25,
y: 25,
});
const [completedCrop, setCompletedCrop] = useState<PixelCrop>();

const handleCrop = async () => {
if (!completedCrop || !imgRef.current) {
console.error('Crop or image reference not available.');
return;
}

const image = imgRef.current;
const canvas = document.createElement('canvas');
const scaleX = image.naturalWidth / image.width;
const scaleY = image.naturalHeight / image.height;

canvas.width = completedCrop.width;
canvas.height = completedCrop.height;
const ctx = canvas.getContext('2d');

if (!ctx) {
console.error('Could not get canvas context.');
return;
}

ctx.drawImage(
image,
completedCrop.x * scaleX,
completedCrop.y * scaleY,
completedCrop.width * scaleX,
completedCrop.height * scaleY,
0,
0,
completedCrop.width,
completedCrop.height
);

try {
const croppedFile = await canvasToFile(canvas, 'avatar.png');
onCropComplete(croppedFile);
} catch (error) {
console.error("Error creating cropped file:", error);
}
};

return (
<AnimatePresence>
{isOpen && (
<motion.div
className="modal-overlay"
initial={{ opacity: 0 }}
animate={{ opacity: 1 }}
exit={{ opacity: 0 }}
onClick={onClose}
>
<motion.div
className="modal-content"
initial={{ opacity: 0, scale: 0.95 }}
animate={{ opacity: 1, scale: 1 }}
exit={{ opacity: 0, scale: 0.95 }}
transition={{ duration: 0.2, ease: 'easeOut' }}
onClick={(e) => e.stopPropagation()}
style={{ maxWidth: '600px', width: '100%' }}
>
<h3 style={{ marginTop: 0, marginBottom: '2rem' }}>Crop Your Avatar</h3>
<div style={{ display: 'flex', justifyContent: 'center', marginBottom: '2rem' }}>
<ReactCrop
crop={crop}
onChange={(_, percentCrop) => setCrop(percentCrop)}
onComplete={(c) => setCompletedCrop(c)}
aspect={1}
circularCrop
>
{/* eslint-disable-next-line @next/next/no-img-element */}
<img
ref={imgRef}
alt="Crop me"
src={imageSrc}
style={{ maxHeight: '70vh' }}
/>
</ReactCrop>
</div>
<div className="modal-actions">
<button onClick={onClose} className="outline-button">إلغاء</button>
<button onClick={handleCrop} className="primary-button">تأكيد</button>
</div>
</motion.div>
</motion.div>
)}
</AnimatePresence>
);
}





























--- END OF FILE components/AvatarCropperModal.tsx ---

================================================================================

--- START OF FILE components/BookmarkButton.tsx ---

// components/BookmarkButton.tsx
'use client';

import React from 'react';
import { useUserStore } from '@/lib/store';
import { motion } from 'framer-motion';
import { useSession } from 'next-auth/react';
import ActionButton from './ActionButton';

const iconVariants = {
    unmarked: { scale: 1, rotate: 0 },
    marked: {
        rotate: [0, -5, 5, -2, 2, 0],
        scale: 1,
        transition: { rotate: { duration: 0.5, ease: 'easeInOut' } }
    },
};

const fillVariants = {
    unmarked: { opacity: 0, transition: { duration: 0.2 } },
    marked: { opacity: 1, transition: { duration: 0.3, ease: 'easeIn' } },
};

const BookmarkIcon = () => (
    <div style={{ position: 'relative', display: 'flex' }}>
        <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </svg>
        <motion.svg
            width="24" height="24" viewBox="0 0 24"
            fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
            style={{ position: 'absolute' }}
            variants={fillVariants}
        >
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </motion.svg>
    </div>
);

const BookmarkButton = ({ contentId, contentType }: { contentId: number; contentType: string; }) => {
    const { status } = useSession();
    const { bookmarks, toggleBookmark, setSignInModalOpen } = useUserStore();
    
    const contentKey = `${contentType}-${contentId}`;
    const isBookmarked = bookmarks.includes(contentKey);

    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        if (status !== 'authenticated') {
            setSignInModalOpen(true);
            return;
        }
        toggleBookmark(contentId, contentType);
    };

    return (
        <ActionButton
            onClick={handleClick}
            aria-label="Bookmark article"
        >
            <motion.div
                initial={false}
                animate={isBookmarked ? "marked" : "unmarked"}
                variants={iconVariants}
            >
                <BookmarkIcon />
            </motion.div>
        </ActionButton>
    );
};

export default BookmarkButton;




--- END OF FILE components/BookmarkButton.tsx ---

================================================================================

--- START OF FILE components/BookmarksGrid.tsx ---

// components/BookmarksGrid.tsx

'use client';

import { useUserStore } from '@/lib/store';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import { adaptToCardProps } from '@/lib/adapters';

export default function BookmarksGrid({ initialItems }: { initialItems: any[] }) {
    // We still subscribe to the store to get real-time updates when a user bookmarks/unbookmarks.
    const bookmarksFromStore = useUserStore(state => state.bookmarks);
    
    // The initial state is now server-rendered, providing a fast first paint.
    const [bookmarkedItems, setBookmarkedItems] = useState(() => 
        initialItems.map(adaptToCardProps).filter(Boolean)
    );

    useEffect(() => {
        // This effect ensures the grid visually updates when the store changes,
        // without needing a full page refresh.
        const currentIdsInGrid = new Set(bookmarkedItems.map(item => item.id));
        
        if (bookmarksFromStore.length < currentIdsInGrid.size) {
            // An item was removed
            setBookmarkedItems(prev => prev.filter(item => bookmarksFromStore.includes(item.id)));
        }
        // Note: Adding items in real-time is more complex and would require a re-fetch.
        // This implementation prioritizes correct removal, which is the more common action on this page.

    }, [bookmarksFromStore, bookmarkedItems]);

    if (initialItems.length === 0 && bookmarkedItems.length === 0) {
        return <p>You haven&apos;t bookmarked any content yet.</p>;
    }

    return (
        <motion.div layout className="content-grid">
            <AnimatePresence>
                {bookmarkedItems.map(item => (
                    <motion.div
                        key={`bookmark-${item.id}`}
                        layout
                        initial={{ opacity: 0, scale: 0.8 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.8 }}
                        transition={{ type: 'spring', stiffness: 250, damping: 25 }}
                        style={{ height: '100%' }}
                    >
                        <ArticleCard
                            article={item}
                            layoutIdPrefix="bookmark"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </motion.div>
    );
}




--- END OF FILE components/BookmarksGrid.tsx ---

================================================================================

--- START OF FILE components/ChronoCard.tsx ---

// components/ChronoCard.tsx
'use client';

import Link from 'next/link';
import Image from 'next/image';
import type { SanityGameRelease } from '@/types/sanity';
import { motion, useMotionValue, useTransform, useSpring } from 'framer-motion';
import { memo } from 'react';
import { useLivingCard } from '@/hooks/useLivingCard';

// --- DEFINITIVE FIX: ADDED imports for centralized icons ---
import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

// --- DEFINITIVE FIX: Replaced inline SVGs with imported components ---
const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
  'PC': PCIcon,
  'PS5': PS5Icon,
  'Xbox': XboxIcon,
  'Switch': SwitchIcon,
};

const ChronoCardComponent = ({ release }: { release: SanityGameRelease }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);
    const smoothMouseX = useSpring(mouseX, { damping: 20, stiffness: 150, mass: 0.7 });
    const smoothMouseY = useSpring(mouseY, { damping: 20, stiffness: 150, mass: 0.7 });
    const glareX = useTransform(smoothMouseX, [0, 1], ['0%', '100%']);
    const glareY = useTransform(smoothMouseY, [0, 1], ['0%', '100%']);
    const glareOpacity = useTransform(smoothMouseX, [0, 0.5, 1], [0.3, 0.6, 0.3]);
    
    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        livingCardAnimation.onMouseMove(e);
        if (!livingCardRef.current) return;
        const { left, top, width, height } = livingCardRef.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const handleMouseLeave = () => {
        livingCardAnimation.onHoverEnd();
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    const formattedDate = new Date(release.releaseDate).toLocaleDateString('en-US', {
        month: 'numeric',
        day: 'numeric',
        timeZone: 'UTC',
    }'numeric');
  
    const layoutIdPrefix = "releases-grid";
    const contentId = release.legacyId || release._id;

    return (
        <motion.div
            ref={livingCardRef}
            onMouseMove={handleMouseMove}
            onMouseEnter={livingCardAnimation.onHoverStart}
            onMouseLeave={handleMouseLeave}
            className="living-card-wrapper"
            style={livingCardAnimation.style}
        >
            <Link href={`/games/${release.slug}`} className="chrono-card-link no-underline" scroll={false}>
                <motion.div
                    layoutId={`${layoutIdPrefix}-card-container-${contentId}`}
                    className="chrono-card living-card"
                    style={{
                        transformStyle: 'preserve-3d',
                        transform: 'translateZ(0px)',
                    }}
                >
                    <motion.div
                        className="living-card-glare"
                        style={{
                            opacity: glareOpacity,
                            '--mouse-x': glareX,
                            '--mouse-y': glareY,
                            borderRadius: '12px',
                        }}
                    />
          
                    <motion.div 
                        className="chrono-card-image-container"
                        layoutId={`${layoutIdPrefix}-card-image-${contentId}`}
                        style={{ transform: 'translateZ(20px)' }}
                    >
                        <Image
                            src={release.mainImage.url}
                            alt={release.title}
                            fill
                            sizes="(max-width: 768px) 90vw, 320px"
                            className="chrono-card-image"
                            placeholder="blur"
                            blurDataURL={release.mainImage.blurDataURL}
                        />
                        <div className="chrono-card-synopsis">
                            <p>{release.synopsis}</p>
                        </div>
                    </motion.div>
          
                    <motion.div className="chrono-card-content" style={{ transform: 'translateZ(20px)' }}>
                        <div className="chrono-card-header">
                            <motion.h3 
                                className="chrono-card-title"
                                layoutId={`${layoutIdPrefix}-card-title-${contentId}`}
                            >
                                {release.title}
                            </motion.h3>
                            <p className="chrono-card-date">{formattedDate}</p>
                        </div>
                        <div className="chrono-card-platforms">
                            {(release.platforms || []).map(p => {
                                const Icon = PlatformIcons[p];
                                return Icon ? <Icon key={p} className="platform-icon" title={p} /> : null;
                            })}
                        </div>
                    </motion.div>
                </motion.div>
            </Link>
        </motion.div>
    );
}

export default memo(ChronoCardComponent);




--- END OF FILE components/ChronoCard.tsx ---

================================================================================

--- START OF FILE components/ConfirmationModal.tsx ---

'use client';

import { AnimatePresence, motion } from 'framer-motion';

export default function ConfirmationModal({ isOpen, onClose, onConfirm, title, message }: { isOpen: boolean; onClose: () => void; onConfirm: () => void; title: string; message: string; }) {
return (
<AnimatePresence>
{isOpen && (
<motion.div className="modal-overlay" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} onClick={onClose}>
<motion.div className="modal-content" initial={{ opacity: 0, scale: 0.95 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.95 }} transition={{ duration: 0.2, ease: 'easeOut' }} onClick={(e) => e.stopPropagation()}>
<h3>{title}</h3><p>{message}</p>
<div className="modal-actions">
<button onClick={onClose} className="outline-button">إلغاء</button>
<button onClick={onConfirm} className="primary-button">تأكيد</button>
</div>
</motion.div>
</motion.div>
)}
</AnimatePresence>
);
}





























--- END OF FILE components/ConfirmationModal.tsx ---

================================================================================

--- START OF FILE components/ContentActionBar.tsx ---

// components/ContentActionBar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import BookmarkButton from './BookmarkButton';
import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from './ActionButton';

const iconVariants = { unliked: { scale: 1 }, liked: { scale: [1, 1.4, 1.1], transition: { duration: 0.4, ease: "easeOut" } }, };
const fillVariants = { unliked: { fill: 'rgba(0,0,0,0)', transition: { duration: 0.2 } }, liked: { fill: 'currentColor', transition: { duration: 0.25, delay: 0.1 } }, };
const shockwaveVariants = { unliked: { scale: 0, opacity: 0 }, liked: { scale: 1, opacity: [1, 0], transition: { duration: 0.5, ease: "easeOut" } } };
const HeartIcon = ({ isLiked }: { isLiked: boolean }) => ( <motion.div initial={false} animate={isLiked ? "liked" : "unliked"} variants={iconVariants} style={{ position: 'relative', display: 'flex' }}> <motion.div variants={shockwaveVariants} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, border: '2px solid var(--accent)', borderRadius: '50%' }} /> <svg width="24" height="24" viewBox="0 0 24" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <motion.path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" variants={fillVariants} /> </svg> </motion.div> );
const ShareIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>);
const CheckIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>);

interface ContentActionBarProps { contentId: number; contentType: 'review' | 'article' | 'news'; contentSlug: string; }

export default function ContentActionBar({ contentId, contentType, contentSlug }: ContentActionBarProps) {
    const { status } = useSession();
    const { setSignInModalOpen, likes, toggleLike, addShare } = useUserStore();
    const [justCopied, setJustCopied] = useState(false);
    const [hasMounted, setHasMounted] = useState(false);
    
    useEffect(() => { setHasMounted(true); }, []);

    const contentKey = `${contentType}-${contentId}`;
    const isLiked = hasMounted && likes.includes(contentKey);

    const handleLike = () => { if (status !== 'authenticated') { setSignInModalOpen(true); return; } toggleLike(contentId, contentType, contentSlug); };
    const handleShare = async () => { const shareData = { title: `EternalGames: ${document.title}`, text: `Check out this ${contentType} on EternalGames!`, url: window.location.href }; if (navigator.share) { try { await navigator.share(shareData); if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } } catch (error) { console.log('Web Share API canceled or failed.', error); } } else { await navigator.clipboard.writeText(window.location.href); setJustCopied(true); if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } setTimeout(() => setJustCopied(false), 2000); } };

    if (!hasMounted) { return <div style={{display: 'flex', gap: '1rem', height: '44px'}}><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div></div>; }

    return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <ActionButton onClick={handleLike} aria-label={isLiked ? 'Unlike' : 'Like'}><HeartIcon isLiked={isLiked} /></ActionButton>
            <ActionButton onClick={handleShare} aria-label="Share"><AnimatePresence mode="wait" initial={false}><motion.div key={justCopied ? 'check' : 'share'} initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }} transition={{ duration: 0.2 }}>{justCopied ? <CheckIcon /> : <ShareIcon />}</motion.div></AnimatePresence></ActionButton>
            <BookmarkButton contentId={contentId} contentType={contentType} />
        </div>
    );
}




--- END OF FILE components/ContentActionBar.tsx ---

================================================================================

--- START OF FILE components/ContentBlock.module.css ---

/* components/ContentBlock.module.css */
.contentBlock {
    margin-bottom: 6rem;
}

.contentBlockTitle {
    font-size: clamp(2.8rem, 4vw, 3.6rem);
    margin-bottom: 3rem;
    font-weight: 700;
    text-align: right;
    border-right: 4px solid var(--accent);
    padding-right: 1.5rem;
}

.contentBlockBody {
    /* Default body styles */
}

/* --- THE DEFINITIVE FIX --- */
.variantFullbleed {
    width: 100vw;
    position: relative;
    left: 50%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    padding-top: 4rem; /* Add padding to the top of the block itself */
    padding-bottom: 4rem;
    background-color: var(--bg-secondary);
}

.variantFullbleed .contentBlockTitle {
    /* Keep the title aligned with the main site container */
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
    padding-right: 3.5rem; /* Adjust for container padding */
    padding-left: 2rem;
}

.variantFullbleed .contentBlockBody {
    padding: 0;
    max-width: none;
}

--- END OF FILE components/ContentBlock.module.css ---

================================================================================

--- START OF FILE components/ContentBlock.tsx ---

// components/ContentBlock.tsx
import React from 'react';
import styles from './ContentBlock.module.css';

type ContentBlockProps = {
    title: string;
    children?: React.ReactNode;
    variant?: 'default' | 'fullbleed';
};

export function ContentBlock({ title, children, variant = 'default' }: ContentBlockProps) {
    const blockClasses = `${styles.contentBlock} ${variant === 'fullbleed' ? styles.variantFullbleed : ''}`;

    return (
        <section className={blockClasses}>
            <h2 className={styles.contentBlockTitle}>{title}</h2>
            {children && (
                <div className={styles.contentBlockBody}>
                    {children}
                </div>
            )}
        </section>
    );
}

--- END OF FILE components/ContentBlock.tsx ---

================================================================================

--- START OF FILE components/CreatorCredit.module.css ---

/* components/CreatorCredit.module.css */

.creatorCredit {
    line-height: 1.6;
    color: var(--text-primary);
    display: block; /* Changed from inline to block */
    margin-bottom: 0.25rem; /* Add some space between lines */
}

.label {
    font-weight: 500;
    color: var(--text-secondary);
    margin-left: 0.5rem;
}

.creatorLinkContainer {
    position: relative;
    display: inline-block;
}

.hoverCard {
    position: absolute;
    bottom: calc(100% + 10px);
    right: 50%; /* Center relative to the link */
    transform: translateX(50%);
    width: 280px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
    padding: 1.5rem;
    z-index: 10;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    transform-origin: bottom center;
}

.cardHeader {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.cardAvatar {
    border-radius: 50%;
}

.cardName {
    font-size: 1.6rem;
    font-weight: 700;
    color: var(--text-primary);
}

.cardUsername {
    font-size: 1.4rem;
    color: var(--text-secondary);
}

.cardBio {
    font-size: 1.4rem;
    color: var(--text-secondary);
    line-height: 1.5;
    margin: 0;
    /* Clamp to 3 lines */
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;  
    overflow: hidden;
}




--- END OF FILE components/CreatorCredit.module.css ---

================================================================================

--- START OF FILE components/CreatorCredit.tsx ---

// components/CreatorCredit.tsx
'use client';

import Link from 'next/link';
import React, { useState, useRef, useEffect } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { getCreatorUsernames } from '@/app/actions/creatorActions';
import type { SanityAuthor } from '@/types/sanity';
import styles from './CreatorCredit.module.css';

const hoverCardVariants = {
    hidden: { opacity: 0, y: 10, scale: 0.95 },
    visible: { opacity: 1, y: 0, scale: 1, transition: { duration: 0.2, ease: 'easeOut' } },
    exit: { opacity: 0, y: 10, scale: 0.95, transition: { duration: 0.15, ease: 'easeIn' } }
};

const CreatorHoverCard = ({ creator }: { creator: SanityAuthor }) => (
    <motion.div className={styles.hoverCard} variants={hoverCardVariants} initial="hidden" animate="visible" exit="exit">
        <div className={styles.cardHeader}>
            <Image 
                src={creator.image || '/default-avatar.svg'} 
                alt={creator.name}
                width={48}
                height={48}
                className={styles.cardAvatar}
            />
            <div>
                <p className={styles.cardName}>{creator.name}</p>
                {creator.username && <p className={styles.cardUsername}>@{creator.username}</p>}
            </div>
        </div>
        {creator.bio && <p className={styles.cardBio}>{creator.bio}</p>}
    </motion.div>
);

// --- THE DEFINITIVE FIX: SIMPLIFIED COMPONENT THAT ALWAYS RENDERS A REAL LINK ---
const CreatorLink = ({ creator }: { creator: SanityAuthor }) => {
    const [isHovered, setIsHovered] = useState(false);

    return (
        <div 
            className={styles.creatorLinkContainer}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
        >
            <AnimatePresence>
                {isHovered && <CreatorHoverCard creator={creator} />}
            </AnimatePresence>

            {creator.username ? (
                <Link 
                    href={`/creators/${creator.username}`} 
                    className="creator-credit-link no-underline"
                    onClick={(e) => e.stopPropagation()} // Stop propagation to prevent parent link navigation
                >
                    {creator.name}
                </Link>
            ) : (
                <span>{creator.name}</span>
            )}
        </div>
    );
};


export default function CreatorCredit({ label, creators }: { 
    label: string; 
    creators: SanityAuthor[] | null | undefined;
}) {
    const [enrichedCreators, setEnrichedCreators] = useState(creators || []);

    useEffect(() => {
        const creatorsWithoutUsername = (creators || []).filter(c => c && c.prismaUserId && !c.username);

        if (creatorsWithoutUsername.length > 0) {
            const idsToFetch = creatorsWithoutUsername.map(c => c.prismaUserId);
            getCreatorUsernames(idsToFetch).then(usernameMap => {
                setEnrichedCreators(prevCreators => 
                    prevCreators.map(creator => {
                        if (creator.prismaUserId && usernameMap[creator.prismaUserId]) {
                            return { ...creator, username: usernameMap[creator.prismaUserId] };
                        }
                        return creator;
                    })
                );
            });
        } else {
            setEnrichedCreators(creators || []);
        }
    }, [creators]);

    if (!enrichedCreators || enrichedCreators.length === 0) return null;

    const formattedNames = enrichedCreators.map((creator, i) => (
        <React.Fragment key={`${creator._id}-${i}`}>
            {i > 0 && (i === enrichedCreators.length - 1 ? ' و ' : '، ')}
            <CreatorLink creator={creator} />
        </React.Fragment>
    ));

    return (
        <div className={styles.creatorCredit}>
            <span className={styles.label}>{label}:</span>
            {formattedNames}
        </div>
    );
}

--- END OF FILE components/CreatorCredit.tsx ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.module.css ---

/* components/DigitalAtriumHomePage.module.css */
.atriumPageContainer {
  position: relative;
  width: 100%;
}

/* This style is no longer needed and has been removed. */
/* .stickyHeroWrapper { ... } */

.atriumMainContent {
  /* Reduced top padding as the hero section now provides its own. */
  padding-top: 4rem;
  padding-bottom: 8rem;
}

.atriumGrid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
  margin-top: 5rem;
}
@media (min-width:1024px) {
  .atriumGrid {
    grid-template-columns: 2.5fr 1fr;
  }
}
.atriumMainColumn {
  min-width: 0;
}

/* This is for the VanguardReviews full-bleed section */
.vanguardSection {
  margin-bottom: 5rem;
}

.horizontalScrollContainer {
  display: flex;
  overflow-x: auto;
  gap: 3rem;
  padding: 1rem 0 2rem 1rem;
  margin-right: -1rem;
  scrollbar-color: var(--accent) transparent;
}
.horizontalScrollContainer::-webkit-scrollbar {
  height: 8px;
}
.horizontalScrollContainer::-webkit-scrollbar-track {
  background: transparent;
}
.horizontalScrollContainer::-webkit-scrollbar-thumb {
  background-color: var(--accent);
  border-radius: 4px;
  border: 2px solid var(--bg-secondary);
}
.horizontalScrollItem {
  flex: 0 0 320px;
  min-width: 320px;
}
@media (min-width:768px) {
  .horizontalScrollItem {
    flex: 0 0 350px;
    min-width: 350px;
  }
}

--- END OF FILE components/DigitalAtriumHomePage.module.css ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.tsx ---

// components/DigitalAtriumHomePage.tsx
'use client';

import { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import TriptychHero from './TriptychHero';
import { ContentBlock } from './ContentBlock';
import NewsTicker from './NewsTicker';
import VanguardReviews from './VanguardReviews/VanguardReviews';
import PaginatedCarousel from './PaginatedCarousel';
import { adaptToCardProps } from '@/lib/adapters';
import styles from './DigitalAtriumHomePage.module.css';

// This sub-component is perfect for the sections below the hero. No changes needed here.
const AnimatedContentBlock = ({ title, children, direction = 'right', variant = 'default' }: { title: string, children?: React.ReactNode, direction?: 'left' | 'right' | 'bottom', variant?: 'default' | 'fullbleed' }) => {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.2 }); 
    const variants = { 
        right: { hidden: { opacity: 0, x: 100 }, visible: { opacity: 1, x: 0 } },
        left: { hidden: { opacity: 0, x: -100 }, visible: { opacity: 1, x: 0 } },
        bottom: { hidden: { opacity: 0, y: 50 }, visible: { opacity: 1, y: 0 } } 
    };
    return ( 
        <motion.div ref={ref} variants={variants[direction]} initial="hidden" animate={isInView ? "visible" : "hidden"} transition={{ duration: 0.8, ease: "easeOut" }}> 
            <ContentBlock title={title} variant={variant}>{children}</ContentBlock> 
        </motion.div> 
    );
};

export default function DigitalAtriumHomePage({ heroContent, reviews, articles, latestNews, children }: {
    heroContent: any;
    reviews: any[];
    articles: any[];
    latestNews: any[];
    children: React.ReactNode;
}) {
  const adaptedReviews = (reviews || []).map(adaptToCardProps).filter(Boolean);
  const adaptedArticles = (articles || []).map(adaptToCardProps).filter(Boolean);
  const adaptedLatestNews = (latestNews || []).map(adaptToCardProps).filter(Boolean);
  
  return (
    <div className={styles.atriumPageContainer}>
      
      {/* --- THE FIX: Reduced minHeight to pull the hero section higher --- */}
      <motion.div 
        style={{ paddingTop: 'var(--nav-height-scrolled)', minHeight: '80vh', display: 'flex', alignItems: 'center' }}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.75, ease: 'easeOut' }}
      >
        <TriptychHero heroContent={heroContent} panelStyles={{}} />
      </motion.div>
      
      <div className={styles.atriumMainContent}>
          <AnimatedContentBlock title="مراجعات الطليعة" direction="bottom" variant="fullbleed">
              <VanguardReviews reviews={adaptedReviews} />
          </AnimatedContentBlock>
          
          <div className="container">
              <div className={styles.atriumGrid}>
                  <main className={styles.atriumMainColumn}>
                      <AnimatedContentBlock title="مقالات مختارة" direction="right"><PaginatedCarousel items={adaptedArticles} itemsPerPage={2} layoutIdPrefix="atrium-articles" /></AnimatedContentBlock>
                  </main>
                  <aside className="atrium-sidebar-column">
                      <motion.div initial={{ opacity: 0, x: -100 }} whileInView={{ opacity: 1, x: 0 }} transition={{ duration: 0.8, ease: "easeOut" }} viewport={{ once: true, amount: 0.7 }}>
                          <NewsTicker latestNews={adaptedLatestNews} />
                      </motion.div>
                  </aside>
              </div>
              {children}
          </div>
      </div>
    </div>
  );
}

--- END OF FILE components/DigitalAtriumHomePage.tsx ---

================================================================================

--- START OF FILE components/FeaturedReviewHero.module.css ---

/* components/FeaturedReviewHero.module.css */

.featuredHeroContainer {
  position: relative;
  width: 100%;
  height: 70vh;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  color: #fff;
  overflow: hidden;
  padding-top: var(--nav-height-scrolled);
}

.featuredHeroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
  transform: scale(1.1);
}

.featuredHeroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.8) 100%);
  z-index: -1;
}

.featuredHeroContent {
  position: relative;
  max-width: 800px;
}

.featuredHeroLabel {
  font-family: var(--font-ui);
  font-size: 1.6rem;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--accent);
  margin-bottom: 1rem;
}

.featuredHeroTitle {
  font-family: var(--font-heading);
  font-size: 6rem;
  font-weight: 800;
  line-height: 1.1;
  margin: 0 0 2rem 0;
  text-shadow: 0 5px 20px rgba(0,0,0,0.5);
}

.featuredHeroMeta {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  margin-bottom: 3rem;
  font-family: var(--font-heading);
  font-size: 2.4rem;
}

.featuredHeroScore {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background-color: var(--accent);
  color: var(--bg-primary);
  font-weight: 800;
  font-size: 2.8rem;
  box-shadow: 0 0 20px 0 color-mix(in srgb, var(--accent) 80%, transparent);
}

.featuredHeroGame {
  color: #fff;
  font-weight: 700;
}

@media (max-width: 768px) {
  .featuredHeroTitle {
    font-size: 4.8rem;
  }
  .featuredHeroMeta {
    flex-direction: column;
    gap: 1rem;
  }
}







--- END OF FILE components/FeaturedReviewHero.module.css ---

================================================================================

--- START OF FILE components/FeaturedReviewHero.tsx ---

// components/FeaturedReviewHero.tsx

'use client';

import type { SanityReview } from '@/types/sanity';
import Image from 'next/image';
import Link from 'next/link';
import { motion, useScroll, useTransform, useMotionValue, useSpring } from 'framer-motion';
import { useRef } from 'react';
import styles from './FeaturedReviewHero.module.css'; // <-- CORRECTED IMPORT

const containerVariants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1, transition: { staggerChildren: 0.15, delayChildren: 0.3 } }
};

const itemVariants = {
  hidden: { opacity: 0, y: 20 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: 'easeOut' } }
};

export default function FeaturedReviewHero({ review }: { review: SanityReview }) {
  const containerRef = useRef<HTMLDivElement>(null);
  
  const { scrollYProgress } = useScroll({ target: containerRef, offset: ["start start", "end start"] });
  const parallaxY = useTransform(scrollYProgress, [0, 1], ["0%", "-20%"]);
  const mouseX = useMotionValue(0.5);
  const mouseY = useMotionValue(0.5);
  const springConfig = { damping: 25, stiffness: 200 };
  const smoothMouseX = useSpring(mouseX, springConfig);
  const smoothMouseY = useSpring(mouseY, springConfig);
  
  const bgMouseX = useTransform(smoothMouseX, [0, 1], ["-2.5%", "2.5%"]);
  const bgMouseY = useTransform(smoothMouseY, [0, 1], ["-2.5%", "2.5%"]);
  const contentMouseX = useTransform(smoothMouseX, [0, 1], ["2%", "-2%"]);
  const contentMouseY = useTransform(smoothMouseY, [0, 1], ["2%", "-2%"]);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!containerRef.current) return;
    const { left, top, width, height } = containerRef.current.getBoundingClientRect();
    mouseX.set((e.clientX - left) / width);
    mouseY.set((e.clientY - top) / height);
  };
  const handleMouseLeave = () => { mouseX.set(0.5); mouseY.set(0.5); };

  return (
    <div ref={containerRef} className={styles.featuredHeroContainer} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave}>
      <motion.div className={styles.featuredHeroBg} style={{ y: parallaxY, x: bgMouseX, y: bgMouseY }}>
        <Image src={review.mainImage.url} alt={`Background for ${review.title}`} fill style={{ objectFit: 'cover' }} priority placeholder="blur" blurDataURL={review.mainImage.blurDataURL} />
      </motion.div>
      <div className={styles.featuredHeroOverlay} />
      
      <motion.div 
        className={`container ${styles.featuredHeroContent}`}
        style={{ x: contentMouseX, y: contentMouseY }}
        variants={containerVariants}
        initial="hidden"
        animate="visible"
      >
        <motion.p variants={itemVariants} className={styles.featuredHeroLabel}>الأعلى تقييمًا</motion.p>
        <motion.h1 variants={itemVariants} className={styles.featuredHeroTitle}>{review.title}</motion.h1>
        <motion.div variants={itemVariants} className={styles.featuredHeroMeta}>
          <span className={styles.featuredHeroScore}>{review.score?.toFixed(1)}</span>
          {/* THE FIX: Only render the game title if it exists */}
          {review.game?.title && (
            <span className={styles.featuredHeroGame}>{review.game.title}</span>
          )}
        </motion.div>
        <motion.div variants={itemVariants}>
          <Link href={`/reviews/${review.slug}`} className="primary-button no-underline" style={{padding: '1.2rem 3rem', fontSize: '1.8rem'}}>اقرأ المراجعة كاملة</Link>
        </motion.div>
      </motion.div>
    </div>
  );
}




--- END OF FILE components/FeaturedReviewHero.tsx ---

================================================================================

--- START OF FILE components/FilteredReviewsGrid.tsx ---

// components/FilteredReviewsGrid.tsx

'use client';

import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import type { CardProps } from '@/types'; 

export default function FilteredReviewsGrid({ reviews }: { reviews: CardProps[] }) {
  return (
    <motion.div layout className="content-grid">
      <AnimatePresence>
        {reviews.map((review, index) => ( // <-- ADD INDEX
          <motion.div
            key={review.id}
            layout
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.8 }}
            transition={{ type: 'spring', stiffness: 250, damping: 25 }}
            style={{ height: '100%' }}
          >
            <ArticleCard
              article={review}
              layoutIdPrefix="reviews"
              isPriority={index < 3} // <-- PASS PROP TO FIRST 3 CARDS
            />
          </motion.div>
        ))}
      </AnimatePresence>
    </motion.div>
  );
}




--- END OF FILE components/FilteredReviewsGrid.tsx ---

================================================================================

--- START OF FILE components/Footer.module.css ---

/* components/Footer.module.css */

.footer {
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--border-color);
}
.newFooterLayout {
  padding: 4rem 0;
}
.footerContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2.5rem;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem;
}
.footerSocials {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
}
.footerDivider {
  width: 60px;
  height: 1px;
  background-color: var(--border-color);
  margin: 0 auto;
}
.footerInfo {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem;
  font-size: 1.4rem;
  color: var(--text-secondary);
}
.footerCopyright, .footerInfo a {
  margin: 0;
}
.designerCredit {
  display: inline-flex;
  align-items: center;
  gap: 0.7rem;
  color: var(--text-secondary);
  transition: color 0.3s ease, transform 0.3s ease;
}
.designerCredit:hover {
  color: var(--accent);
  transform: translateY(-2px);
}
.designerIcon {
  width: 14px;
  height: 14px;
}
.infoSeparator {
  font-weight: 300;
}
.footerControls a {
  transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}
.footerControls a:hover {
  filter: none !important;
  transform: translateY(-4px); 
}
.socialLinkFrame {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  background-color: transparent;
  transition: all 0.2s ease-out;
}
.footerControls a:hover .socialLinkFrame {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  color: var(--accent);
}
.socialIconSvg {
  width: 20px;
  height: 20px;
}




--- END OF FILE components/Footer.module.css ---

================================================================================

--- START OF FILE components/Footer.tsx ---

'use client';

import React from 'react';
import styles from './Footer.module.css'; // <-- IMPORTED MODULE

//  Dedicated, Correctly Scaled Icon Components
const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 1200 1227" fill="currentColor" {...props}>
<g transform="scale(0.8) translate(150, 150)">
<path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
</g>
</svg>
);
const TikTokIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="80 80 320 320" fill="currentColor" {...props}>
<path d="M207.26,200.54c3.77,0,7.48.28,11.1.81v43.65c-3.47-1.22-7.21-1.88-11.1-1.88-18.55,0-33.59,15.04-33.59,33.59s15.04,33.59,33.59,33.59,33.59-15.04,33.59-33.59V113.28h42.83c-.06,1.09-.1,2.19-.1,3.3,0,30.64,24.84,55.48,55.48,55.48v40.79c-20.73,0-39.92-6.55-55.63-17.7v81.57c0,42.07-34.11,76.17-76.17,76.17s-76.17-34.11-76.17-76.17,34.1-76.17,76.17-76.17"/>
</svg>
);
const YouTubeIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M21.58 7.19a2.5 2.5 0 0 0-1.76-1.77C18.25 5 12 5 12 5s-6.25 0-7.82.42a2.5 2.5 0 0 0-1.76 1.77A26.12 26.12 0 0 0 2 12s0 4.25.42 5.81a2.5 2.5 0 0 0 1.76 1.77C5.75 20 12 20 12 20s6.25 0 7.82-.42a2.5 2.5 0 0 0 1.76-1.77A26.12 26.12 0 0 0 22 12s0-4.25-.42-4.81zM9.75 15.5v-7l6 3.5-6 3.5z"/>
</svg>
);
const InstagramIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M7.8 2h8.4C19.4 2 22 4.6 22 7.8v8.4a5.8 5.8 0 0 1-5.8 5.8H7.8C4.6 22 2 19.4 2 16.2V7.8A5.8 5.8 0 0 1 7.8 2m-.2 2A3.6 3.6 0 0 0 4 7.6v8.8C4 18.39 5.61 20 7.6 20h8.8a3.6 3.6 0 0 0 3.6-3.6V7.6C20 5.61 18.39 4 16.4 4H7.6m9.65 1.5a1.25 1.25 0 0 1 1.25 1.25A1.25 1.25 0 0 1 17.25 8 1.25 1.25 0 0 1 16 6.75a1.25 1.25 0 0 1 1.25-1.25M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z"/>
</svg>
);
const FacebookIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
</svg>
);

const Footer = () => {
return (
<footer className={`${styles.footer} ${styles.newFooterLayout}`}>
<div className={`container ${styles.footerContainer}`}>
<div className={`${styles.footerSocials} ${styles.footerControls}`}>
<a href="https://x.com/1EternalGames" target="_blank" rel="noopener noreferrer" aria-label="X / Twitter" className="no-underline">
<div className={styles.socialLinkFrame}><XIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.tiktok.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="TikTok" className="no-underline">
<div className={styles.socialLinkFrame}><TikTokIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.youtube.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="YouTube" className="no-underline">
<div className={styles.socialLinkFrame}><YouTubeIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.instagram.com/1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="Instagram" className="no-underline">
<div className={styles.socialLinkFrame}><InstagramIcon className={styles.socialIconSvg} /></div>
</a>
<a href="https://www.facebook.com/people/Eternal-Games/61574132488834/" target="_blank" rel="noopener noreferrer" aria-label="Facebook" className="no-underline">
<div className={styles.socialLinkFrame}><FacebookIcon className={styles.socialIconSvg} /></div>
</a>
</div>

<div className={styles.footerDivider}></div>

<div className={styles.footerInfo}>
<p className={styles.footerCopyright}>&copy; {new Date().getFullYear()} EternalGames</p>
<span className={styles.infoSeparator}>•</span>
<a href="https://x.com/MoVisionX" target="_blank" rel="noopener noreferrer" className={`${styles.designerCredit} no-underline`}>
<span>صاغه محمد السعد - @MoVisionX</span>
<XIcon className={styles.designerIcon} />
</a>
</div>
</div>
</footer>
);
};

export default Footer;




--- END OF FILE components/Footer.tsx ---

================================================================================

--- START OF FILE components/GameLink.module.css ---

/* components/GameLink.module.css */

.kineticGameTag {
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.6rem 1.4rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 600;
    border: 1px solid var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
    color: var(--accent);
    transition: all 0.25s ease-out;
    white-space: nowrap; /* <-- THE FIX */
    flex-direction: row-reverse; /* FIX: Flip content order */
}
  
.kineticGameTag:hover {
    transform: translateY(-2px);
    background-color: var(--accent);
    border-color: var(--accent);
    color: #FFFFFF;
    box-shadow: 0 4px 15px color-mix(in srgb, var(--accent) 20%, transparent);
}
  
[data-theme="dark"] .kineticGameTag:hover {
    color: var(--bg-primary);
}
  
.gameTagArrow {
    display: inline-block;
    opacity: 0;
    transform: translateX(8px);
    transition: opacity 0.25s ease-out, transform 0.25s ease-out;
}
  
.kineticGameTag:hover .gameTagArrow {
    opacity: 1;
    transform: translateX(-0);
}




--- END OF FILE components/GameLink.module.css ---

================================================================================

--- START OF FILE components/GameLink.tsx ---

// components/GameLink.tsx
import Link from 'next/link';
import React from 'react';
import styles from './GameLink.module.css';

type GameLinkProps = {
    gameName?: string | null; // <-- Make gameName optional to prevent errors
    className?: string;
};

const GameLink = ({ gameName, className = '' }: GameLinkProps) => {
    // --- DEFINITIVE FIX IS HERE: Part 1 ---
    // Safely handle cases where gameName might be null or undefined.
    if (!gameName) {
        return null;
    }
    const slug = gameName.replace(/\s+/g, '-').toLowerCase();

    // --- DEFINITIVE FIX IS HERE: Part 2 ---
    // Correctly combine the default module class with any passed className.
    // The default style from the module will always be applied.
    const finalClassName = `${styles.kineticGameTag} ${className} no-underline`;

    return (
        <Link href={`/games/${slug}`} className={finalClassName}>
            <span>{gameName}</span>
            <span className={styles.gameTagArrow}>→</span>
        </Link>
    );
};

export default GameLink;







--- END OF FILE components/GameLink.tsx ---

================================================================================

--- START OF FILE components/HorizontalShowcase.module.css ---

/* components/HorizontalShowcase.module.css */

.horizontalShowcaseWrapper {
  position: relative;
  height: 450px;
  display: flex;
  align-items: center;
  overflow: hidden;
  cursor: grab;
}
.horizontalShowcaseWrapper:active {
  cursor: grabbing;
}

.horizontalShowcaseList {
  display: flex;
  align-items: center;
}

.horizontalShowcaseList {
  --showcase-card-width: 50vw;
  --showcase-card-max-width: 600px;
  --showcase-card-gap: 2rem;
}
@media (max-width: 768px) {
  .horizontalShowcaseList {
    --showcase-card-width: 80vw;
  }
}

.showcaseItemWrapper {
  flex-shrink: 0;
  width: var(--showcase-card-width);
  max-width: var(--showcase-card-max-width);
  margin-right: var(--showcase-card-gap);
}
.showcaseItemWrapper:first-child {
  margin-left: var(--showcase-card-gap);
}

.showcaseCardContainer {
  width: 100%;
  perspective: 1000px;
  flex-shrink: 0;
  padding: 0 1.5rem;
}
@media (max-width: 768px) {
  .showcaseCardContainer {
    width: 80%;
  }
}

.showcaseCardLink {
  display: block;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  aspect-ratio: 16 / 9;
  box-shadow: 0 20px 40px -15px color-mix(in srgb, var(--text-primary) 20%, transparent);
  background-color: var(--bg-secondary);
  border: 1px solid color-mix(in srgb, var(--border-color) 50%, transparent);
}

.showcaseCardImageWrapper {
  position: absolute;
  inset: 0;
}
.showcaseCardImage {
  transition: transform 0.4s ease;
}
.showcaseCardLink:hover .showcaseCardImage {
  transform: scale(1.05);
}

.showcaseCardContent {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 2.5rem;
  color: #fff;
  background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
  text-align: right;
}
.showcaseCardTitle {
  font-family: var(--font-main);
  font-size: 2.8rem;
  line-height: 1.2;
}
.showcaseCardGame {
  font-family: var(--font-main);
  color: var(--text-secondary);
  font-weight: 500;
  margin-top: 0.75rem;
}
[data-theme="dark"] .showcaseCardGame {
  color: color-mix(in srgb, var(--text-secondary) 80%, #fff);
}

.showcaseArrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 10;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(8px);
}
.showcaseArrow.left {
  left: 3rem;
  right: auto;
}
.showcaseArrow.right {
  right: 3rem;
  left: auto;
}




--- END OF FILE components/HorizontalShowcase.module.css ---

================================================================================

--- START OF FILE components/HorizontalShowcase.tsx ---

// components/HorizontalShowcase.tsx

'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import styles from './HorizontalShowcase.module.css';

const ArrowIcon = ({ direction = 'right' }: { direction?: 'left' | 'right' }) => (
  <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
    <polyline points={direction === 'right' ? "9 18 15 12 9 6" : "15 18 9 12 15 6"} />
  </svg>
);

const ShowcaseCard = ({ article, isActive }: { article: any, isActive: boolean }) => {
  
  // --- THE DEFINITIVE FIX: ---
  // The source URL from the adapter might already have query params. We must strip them
  // before appending our own desired params to avoid conflicts and errors.
  const imageSource = article.imageUrl;
  if (!imageSource) return null;

  const baseUrl = imageSource.split('?')[0];
  const imageUrl = `${baseUrl}?w=1200&auto=format&q=80`;

  return (
    <motion.div
      className={styles.showcaseCardContainer}
      animate={{ 
        scale: isActive ? 1 : 0.85, 
        opacity: isActive ? 1 : 0.7,
      }}
      transition={{ type: 'spring', stiffness: 300, damping: 30 }}
    >
      <Link href={`/articles/${article.slug}`} className={`no-underline ${styles.showcaseCardLink}`} tabIndex={isActive ? 0 : -1} draggable="false">
        <div className={styles.showcaseCardImageWrapper}>
          <Image 
            src={imageUrl} 
            alt={article.title} 
            fill 
            sizes="60vw"
            style={{ objectFit: 'cover' }}
            className={styles.showcaseCardImage}
            draggable="false"
            unoptimized
          />
        </div>
        <div className={styles.showcaseCardContent}>
          <h3 className={styles.showcaseCardTitle}>{article.title}</h3>
          <p className={styles.showcaseCardGame}>{article.game}</p>
        </div>
      </Link>
    </motion.div>
  );
};

export default function HorizontalShowcase({ articles, onActiveIndexChange }: { articles: any[], onActiveIndexChange: (index: number) => void }) {
  const [activeIndex, setActiveIndex] = useState(0);
  const [xOffset, setXOffset] = useState(0);
  const [isCalculated, setIsCalculated] = useState(false);
  
  const wrapperRef = useRef<HTMLDivElement>(null);
  const cardRefs = useRef<(HTMLDivElement | null)[]>([]);

  const calculateAndGoToIndex = useCallback((index: number) => {
    if (!wrapperRef.current || !cardRefs.current[index]) return;

    const wrapperWidth = wrapperRef.current.offsetWidth;
    const targetCard = cardRefs.current[index]!;
    const targetOffsetLeft = targetCard.offsetLeft;
    const targetWidth = targetCard.offsetWidth;
    
    const newXOffset = (wrapperWidth / 2) - targetOffsetLeft - (targetWidth / 2);
    
    setXOffset(newXOffset);
    setActiveIndex(index);
    onActiveIndexChange(index);
    setIsCalculated(true);
  }, [onActiveIndexChange]);

  // Recalculate on resize
  useEffect(() => {
    const handleResize = () => calculateAndGoToIndex(activeIndex);
    window.addEventListener('resize', handleResize);
    // Initial calculation after a short delay to ensure layout is stable
    const timeoutId = setTimeout(() => handleResize(), 100); 
    
    return () => {
      window.removeEventListener('resize', handleResize);
      clearTimeout(timeoutId);
    };
  }, [activeIndex, calculateAndGoToIndex]);
  
  const handleNext = useCallback(() => {
    const nextIndex = Math.min(activeIndex + 1, articles.length - 1);
    calculateAndGoToIndex(nextIndex);
  }, [activeIndex, articles.length, calculateAndGoToIndex]);

  const handlePrev = useCallback(() => {
    const prevIndex = Math.max(activeIndex - 1, 0);
    calculateAndGoToIndex(prevIndex);
  }, [activeIndex, calculateAndGoToIndex]);
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'ArrowRight') handleNext();
      if (event.key === 'ArrowLeft') handlePrev();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleNext, handlePrev]);

  const onDragEnd = (event: any, { offset, velocity }: any) => {
    const swipeConfidenceThreshold = 10000;
    const swipePower = Math.abs(offset.x) * velocity.x;

    if (swipePower < -swipeConfidenceThreshold) {
      handleNext();
    } else if (swipePower > swipeConfidenceThreshold) {
      handlePrev();
    } else {
      // Snap back to the current active index if not a strong swipe
      calculateAndGoToIndex(activeIndex);
    }
  };

  return (
    <div ref={wrapperRef} className={styles.horizontalShowcaseWrapper} dir="ltr">
      <AnimatePresence>
        {isCalculated && activeIndex > 0 && (
          <motion.button className={`${styles.showcaseArrow} ${styles.left}`} onClick={handlePrev} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
            <ArrowIcon direction="left" />
          </motion.button>
        )}
      </AnimatePresence>
      <AnimatePresence>
        {isCalculated && activeIndex < articles.length - 1 && (
          <motion.button className={`${styles.showcaseArrow} ${styles.right}`} onClick={handleNext} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
            <ArrowIcon direction="right" />
          </motion.button>
        )}
      </AnimatePresence>

      <motion.div
        className={styles.horizontalShowcaseList}
        drag="x"
        dragConstraints={{ left: 0, right: 0 }}
        dragElastic={0.1}
        onDragEnd={onDragEnd}
        initial={{ opacity: 0 }}
        animate={{ 
          x: xOffset,
          opacity: isCalculated ? 1 : 0
        }}
        transition={{ 
          x: { type: 'spring', stiffness: 300, damping: 50 },
          opacity: { duration: 0.5 }
        }}
      >
        {articles.map((article, index) => (
          <div 
            key={article.id} 
            ref={el => cardRefs.current[index] = el}
            className={styles.showcaseItemWrapper}
          >
            <ShowcaseCard
              article={{...article, isLeft: index < activeIndex}}
              isActive={activeIndex === index}
            />
          </div>
        ))}
      </motion.div>
    </div>
  );
}

--- END OF FILE components/HorizontalShowcase.tsx ---

================================================================================

--- START OF FILE components/HubFilters.tsx ---

// components/HubFilters.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './filters/Filters.module.css';

export type HubTypeFilter = 'all' | 'review' | 'article' | 'news';
export type HubSortOrder = 'latest' | 'viral';

const typeFilters: { label: string, value: HubTypeFilter }[] = [
    { label: 'الكل', value: 'all' },
    { label: 'مراجعات', value: 'review' },
    { label: 'مقالات', value: 'article' },
    { label: 'أخبار', value: 'news' },
];

const sortOrders: { label: string, value: HubSortOrder }[] = [
    { label: 'الأحدث', value: 'latest' },
    { label: 'الأكثر رواجًا', value: 'viral' },
];

interface HubFiltersProps {
    activeTypeFilter: HubTypeFilter;
    onTypeFilterChange: (filter: HubTypeFilter) => void;
    activeSort: HubSortOrder;
    onSortChange: (sort: HubSortOrder) => void;
}

export default function HubFilters({
    activeTypeFilter,
    onTypeFilterChange,
    activeSort,
    onSortChange
}: HubFiltersProps) {
    return (
        <div className={styles.filtersContainer} style={{ marginBottom: '3rem' }}>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>نوع المحتوى:</span>
                <div className={styles.filterButtonsGroup}>
                    {typeFilters.map(filter => (
                        <motion.button
                            key={filter.value}
                            onClick={() => onTypeFilterChange(filter.value)}
                            className={`${styles.filterButton} ${activeTypeFilter === filter.value ? styles.active : ''}`}
                        >
                            {filter.label}
                            {activeTypeFilter === filter.value && <motion.div layoutId="hub-type-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>الفرز حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    {sortOrders.map(sort => (
                        <motion.button
                            key={sort.value}
                            onClick={() => onSortChange(sort.value)}
                            className={`${styles.filterButton} ${activeSort === sort.value ? styles.active : ''}`}
                        >
                            {sort.label}
                            {activeSort === sort.value && <motion.div layoutId="hub-sort-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
        </div>
    );
}




--- END OF FILE components/HubFilters.tsx ---

================================================================================

--- START OF FILE components/HubPage.module.css ---

/* components/HubPage.module.css */
.hubPageContainer {
  /* padding-top: var(--nav-height-scrolled); <-- REMOVED */
}

.hubHero {
  height: 40vh; /* <-- REDUCED HEIGHT */
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  margin-bottom: -8rem; /* <-- PULLS CONTENT UP */
}

.heroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
}

.heroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 100%); /* Adjusted gradient */
  z-index: -1;
}

.heroTitle {
  font-size: 6.4rem;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
}




--- END OF FILE components/HubPage.module.css ---

================================================================================

--- START OF FILE components/HubPageClient.tsx ---

// components/HubPageClient.tsx
'use client';

import { useState, useMemo, useRef } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import HubFilters, { HubTypeFilter, HubSortOrder } from './HubFilters';
import ArticleCard from './ArticleCard';
import { useEngagementScores } from '@/hooks/useEngagementScores';
import Image from 'next/image';
import { adaptToCardProps } from '@/lib/adapters';
import { urlFor } from '@/sanity/lib/image';
import styles from './HubPage.module.css';

interface HubPageClientProps {
    initialItems: any[];
    hubTitle: string;
    hubType: 'اللعبة' | 'وسم' | 'أعمال';
    headerAction?: React.ReactNode;
}

export default function HubPageClient({ initialItems, hubTitle, hubType, headerAction }: HubPageClientProps) {
    const [activeTypeFilter, setActiveTypeFilter] = useState<HubTypeFilter>('all');
    const [activeSort, setActiveSort] = useState<HubSortOrder>('latest');
    const engagementScores = useEngagementScores();
    const contentRef = useRef(null);
    const isInView = useInView(contentRef, { once: true, amount: 0.1 });

    const latestItem = useMemo(() => {
        if (initialItems && initialItems.length > 0) {
            return initialItems[0];
        }
        return null;
    }, [initialItems]);

    const heroImageUrl = latestItem?.mainImageRef 
        ? urlFor(latestItem.mainImageRef).width(1920).quality(80).auto('format').url() 
        : null;
    const heroBlurDataURL = latestItem?.mainImageRef 
        ? urlFor(latestItem.mainImageRef).width(20).blur(10).quality(30).auto('format').url()
        : null;

    const filteredAndSortedItems = useMemo(() => {
        const scoresMap = new Map(engagementScores.map(s => [s.id, s.engagementScore]));
        let items = initialItems;
        if (activeTypeFilter !== 'all') {
            items = items.filter(item => item._type === activeTypeFilter);
        }
        if (activeSort === 'viral') {
            items.sort((a, b) => {
                const scoreA = scoresMap.get(a.legacyId) || 0;
                const scoreB = scoresMap.get(b.legacyId) || 0;
                return scoreB - scoreA;
            });
        }
        return items.map(adaptToCardProps).filter(Boolean);
    }, [initialItems, activeTypeFilter, activeSort, engagementScores]);
    
    const heroContent = (
        <div className={styles.hubHero} style={{ height: heroImageUrl ? '40vh' : 'auto', marginBottom: heroImageUrl ? '-8rem' : '0', paddingTop: heroImageUrl ? '0' : `calc(var(--nav-height-scrolled) + 4rem)`}}>
            {heroImageUrl && (
                <>
                    <Image 
                        src={heroImageUrl} 
                        alt={`Background for ${hubTitle}`} 
                        fill 
                        className={styles.heroBg}
                        style={{ objectFit: 'cover' }} 
                        priority 
                        placeholder={heroBlurDataURL ? 'blur' : 'empty'}
                        blurDataURL={heroBlurDataURL || ''}
                    />
                    <div className={styles.heroOverlay} />
                </>
            )}
            <motion.div 
                className="container"
                style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1.5rem', zIndex: 5 }}
                initial={{opacity: 0, y: 20}} animate={{opacity: 1, y: 0}} transition={{duration: 0.5, delay: 0.2}}
            >
                {headerAction}
                <h1 className={`${styles.heroTitle} page-title`} style={{margin: 0}}>
                    {hubType}<span>: &quot;{hubTitle}&quot;</span>
                </h1>
            </motion.div>
        </div>
    );

    return (
        <div className={styles.hubPageContainer}>
            {heroContent}
            <div ref={contentRef} className="container" style={{paddingTop: '4rem'}}>
                 <motion.div
                    initial={{ opacity: 0, y: 50 }}
                    animate={isInView ? { opacity: 1, y: 0 } : {}}
                    transition={{ duration: 0.7, ease: "easeOut" }}
                >
                    <HubFilters
                        activeTypeFilter={activeTypeFilter}
                        onTypeFilterChange={setActiveTypeFilter}
                        activeSort={activeSort}
                        onSortChange={setActiveSort}
                    />
                </motion.div>
                
                <motion.div layout className="content-grid" style={{ paddingBottom: '6rem' }}>
                    <AnimatePresence>
                        {filteredAndSortedItems.length > 0 ? (
                            filteredAndSortedItems.map(item => (
                                <motion.div
                                    key={item.id}
                                    layout
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ type: 'spring', stiffness: 250, damping: 25 }}
                                    style={{ height: '100%' }}
                                >
                                    <ArticleCard
                                        article={item}
                                        isArticle={item.type === 'article'}
                                        layoutIdPrefix={`${hubType}-${hubTitle}`}
                                    />
                                </motion.div>
                            ))
                        ) : (
                             <motion.div 
                                initial={{ opacity: 0 }} animate={{ opacity: 1 }}
                                style={{gridColumn: '1 / -1', textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}}
                            >
                                No content found matching your filters.
                            </motion.div>
                        )}
                    </AnimatePresence>
                </motion.div>
            </div>
        </div>
    );
}




--- END OF FILE components/HubPageClient.tsx ---

================================================================================

--- START OF FILE components/ImageCompare.module.css ---

/* components/ImageCompare.module.css */
.compareWrapper {
  margin: 2rem 0;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  box-shadow: 0 10px 30px -10px rgba(0,0,0,0.2);
  line-height: 0; 
}

.placeholder {
  width: 100%;
  aspect-ratio: 16/9;
  background-color: var(--bg-primary);
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  padding: 1rem;
}

.dropzone {
  aspect-ratio: 16 / 9;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  font-family: var(--font-main);
  font-size: 1.4rem;
  transition: border-color 0.2s, background-color 0.2s;
  position: relative; /* For image positioning */
  overflow: hidden; /* To contain the image */
  cursor: pointer; /* For click-to-upload */
}

.dropzone.active {
  border-color: var(--accent);
  background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.uploadIcon {
  width: 2.4rem;
  height: 2.4rem;
  margin-bottom: 0.5rem;
  opacity: 0.6;
}

.imagePreview {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
}

.dropzoneContent {
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(0,0,0,0.5);
  color: white;
  padding: 1rem;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.2s ease-out;
}
.dropzone:hover .dropzoneContent {
  opacity: 1;
}

.imageCompareContainer {
  margin: 2rem 0;
}

.imageCompareContainer[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="large"] { max-width: 100%; }

.twoImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

.fourImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

--- END OF FILE components/ImageCompare.module.css ---

================================================================================

--- START OF FILE components/ImageCompare.tsx ---

// components/ImageCompare.tsx
'use client';

import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { urlFor } from '@/sanity/lib/image'; // Import urlFor
import styles from './ImageCompare.module.css';

export default function ImageCompare({ value }: { value: any }) {
    const { image1, image2, size } = value;

    if (!image1?.asset || !image2?.asset) {
        return <div className={styles.placeholder}>Could not load image comparison.</div>;
    }

    // --- THE DEFINITIVE FIX ---
    const imageUrl1 = urlFor(image1).auto('format').quality(85).url();
    const imageUrl2 = urlFor(image2).auto('format').quality(85).url();

    return (
        <div className={styles.imageCompareContainer} data-size={size || 'large'}>
            <div className={styles.compareWrapper}>
                <ReactCompareSlider
                    itemOne={<ReactCompareSliderImage src={imageUrl1} alt={image1.alt || 'Before'} />}
                    itemTwo={<ReactCompareSliderImage src={imageUrl2} alt={image2.alt || 'After'} />}
                />
            </div>
        </div>
    );
}

--- END OF FILE components/ImageCompare.tsx ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.module.css ---

/* components/KineticReleaseTimeline.module.css */
.timelineContainer {
  position: relative;
  max-width: 760px;
  margin: 0 auto;
  padding: 4rem 2rem;
}
.timelineSpine {
  position: absolute;
  top: 0;
  right: 50%;
  transform: translateX(50%);
  width: 2px;
  height: 100%;
  z-index: 1;
}
.timelineSpineTrack {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
  border-radius: 2px;
}
.timelineSpineProgress {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  transform-origin: top;
  box-shadow: 0 0 10px 0 var(--accent);
}
.timelineItemsWrapper {
  display: flex;
  flex-direction: column;
}
.timelineItemWrapper {
  position: relative;
  width: calc(50% - 40px);
  margin-bottom: 4rem;
  z-index: 2;
}
.timelineItemWrapper.left {
  align-self: flex-end;
}
.timelineItemWrapper.right {
  align-self: flex-start;
}
.dotsContainer {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  z-index: 4;
}
.dot {
  position: absolute;
  right: -220%;
  width: 12px;
  height: 12px;
  background-color: var(--border-color);
  border-radius: 50%;
  /* FIX: Only translate vertically (-50% Y), horizontal centering relies on right: 50% */
  transform: translateY(-50%); 
  transition: background-color 0.2s ease-in-out, box-shadow 0.3s ease-in-out;
}
.releasedIndicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background-color: color-mix(in srgb,var(--accent) 90%,transparent);
  backdrop-filter: blur(4px);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-size: 1.3rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  border: 1px solid rgba(255,255,255,0.2);
}
.checkIcon {
  width: 16px;
  height: 16px;
}




--- END OF FILE components/KineticReleaseTimeline.module.css ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.tsx ---

// components/KineticReleaseTimeline.tsx
'use client';

import React, { useMemo, useRef, useState, useLayoutEffect } from 'react';
import { motion, useScroll, useInView, useTransform, MotionValue } from 'framer-motion';
import TimelineCard from './TimelineCard'; // <-- IMPORT THE NEW CARD
import styles from './KineticReleaseTimeline.module.css';

const TimelineItem = ({ release, index }: { release: any, index: number }) => {
    const itemRef = useRef(null);
    const cardIsInView = useInView(itemRef, { once: true, amount: 0.5 });
    const isLeft = index % 2 === 0;
    const variants = {
        hidden: { opacity: 0, x: isLeft ? -50 : 50, scale: 0.9 },
        visible: { opacity: 1, x: 0, scale: 1, transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] } }
    };

    return (
        <div ref={itemRef} className={`${styles.timelineItemWrapper} ${isLeft ? styles.left : styles.right}`}>
            <motion.div variants={variants} initial="hidden" animate={cardIsInView ? "visible" : "hidden"}>
                <TimelineCard release={release} />
            </motion.div>
        </div>
    );
};

const TimelineDot = ({ position, scrollYProgress }: { position: number, scrollYProgress: MotionValue<number> }) => {
    const backgroundColor = useTransform( scrollYProgress, [position - 0.01, position], ['var(--border-color)', 'var(--accent)'] );
    const boxShadow = useTransform( scrollYProgress, [position - 0.01, position], ['0 0 0px 0 rgba(0,0,0,0)', '0 0 8px 0 var(--accent)'] );
    return ( <motion.div className={styles.dot} style={{ top: `${position * 100}%`, backgroundColor: backgroundColor, boxShadow: boxShadow, }} /> );
};

export default function KineticReleaseTimeline({ releases: allReleases }: { releases: any[] }) {
    const timelineRef = useRef<HTMLDivElement>(null);
    const [dotPositions, setDotPositions] = useState<number[]>([]);
    const { scrollYProgress } = useScroll({ target: timelineRef, offset: ["start 50%", "end 50%"], });
    const releasesForThisMonth = useMemo(() => {
        if (!allReleases) return [];
        const now = new Date(); const currentMonth = now.getMonth(); const currentYear = now.getFullYear();
        return allReleases.filter(release => { const releaseDate = new Date(release.releaseDate); return releaseDate.getUTCMonth() === currentMonth && releaseDate.getUTCFullYear() === currentYear; }).sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    }, [allReleases]);

    useLayoutEffect(() => {
        if (timelineRef.current && releasesForThisMonth.length > 0) {
            const timeoutId = setTimeout(() => {
                const containerEl = timelineRef.current; if (!containerEl) return;
                const containerHeight = containerEl.scrollHeight;
                const itemElements = Array.from(containerEl.querySelectorAll(`.${styles.timelineItemWrapper}`));
                const positions = itemElements.map(el => { const item = el as HTMLElement; const top = item.offsetTop + (item.offsetHeight / 2); return top / containerHeight; });
                setDotPositions(positions);
            }, 100);
            return () => clearTimeout(timeoutId);
        }
    }, [releasesForThisMonth]);

    return (
        <div ref={timelineRef} className={styles.timelineContainer}>
            <div className={styles.timelineSpine}>
                <div className={styles.timelineSpineTrack} />
                <motion.div className={styles.timelineSpineProgress} style={{ scaleY: scrollYProgress }} />
                <div className={styles.dotsContainer}>
                    {dotPositions.map((pos, index) => ( <TimelineDot key={index} position={pos} scrollYProgress={scrollYProgress} /> ))}
                </div>
            </div>
            <div className={styles.timelineItemsWrapper}>
                {releasesForThisMonth.length > 0 ? (
                    releasesForThisMonth.map((release, index) => ( <TimelineItem key={release._id} release={release} index={index} /> ))
                ) : (
                    <motion.div style={{ paddingTop: '20vh', textAlign: 'center', color: 'var(--text-secondary)', width: '100%' }} initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.8, delay: 0.8, ease: 'easeOut' }}>يجري تحديث جدول الإصدارات. عد قريبًا.</motion.div>
                )}
            </div>
        </div>
    );
}







--- END OF FILE components/KineticReleaseTimeline.tsx ---

================================================================================

--- START OF FILE components/Lightbox.module.css ---

/* components/Lightbox.module.css */
.lightboxOverlay {
    position: fixed;
    inset: 0;
    background-color: color-mix(in srgb, var(--bg-primary) 70%, transparent);
    backdrop-filter: blur(10px) saturate(120%);
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 15vh 20vw;
    cursor: zoom-out;
}

@media (max-width: 1024px) {
    .lightboxOverlay {
        padding: 10vh 5vw;
    }
}

.imageContainer {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0,0,0,0.6);
    background-color: var(--border-color); /* Fallback for loading */
}

.lightboxImage {
    max-width: none;
    max-height: none;
    width: 100%;
    height: 100%;
    object-fit: contain; /* THE FIX: Ensures the whole image is visible */
    cursor: grab;
    will-change: transform;
}
.lightboxImage:active {
    cursor: grabbing;
}

.controls {
    position: absolute;
    top: 2rem;
    left: 2rem; /* RTL */
    right: auto;
    z-index: 9999;
    display: flex;
    gap: 0.75rem;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    padding: 0.5rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.controlButton {
    width: 44px;
    height: 44px;
    border-radius: 6px;
    background-color: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
}
.controlButton:hover {
    background-color: var(--bg-primary);
    color: var(--accent);
}
.controlButton svg {
    width: 22px;
    height: 22px;
}

/* --- THE DEFINITIVE FIX: Navigation Button Styles --- */
.navButton {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(4px);
    z-index: 9999;
    transition: all 0.2s ease-out;
}
.navButton:hover {
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-50%) scale(1.1);
}
.navButton.prev {
    left: 2rem; /* RTL */
    right: auto;
}
.navButton.next {
    right: 2rem; /* RTL */
    left: auto;
}

--- END OF FILE components/Lightbox.module.css ---

================================================================================

--- START OF FILE components/Lightbox.tsx ---

// components/Lightbox.tsx
'use client';

import { createPortal } from 'react-dom';
import { AnimatePresence, motion, useMotionValue, useSpring } from 'framer-motion';
import { useLightboxStore } from '@/lib/lightboxStore';
import { useEffect, useState, useRef, useCallback } from 'react';
import styles from './Lightbox.module.css';

const ZoomInIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ZoomOutIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ResetIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>;
const DownloadIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const CloseIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const ArrowIcon = ({ dir }: { dir: 'left' | 'right' }) => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points={dir === 'left' ? "15 18 9 12 15 6" : "9 18 15 12 9 6"} /></svg>;

const clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max);
const springConfig = { type: 'spring', damping: 30, stiffness: 400 };

export default function Lightbox() {
    const { isOpen, imageUrls, currentIndex, closeLightbox, goToNext, goToPrevious } = useLightboxStore();
    const [isMounted, setIsMounted] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const imageRef = useRef<HTMLImageElement>(null);
    const imageUrl = imageUrls[currentIndex];

    const scale = useMotionValue(1);
    const x = useMotionValue(0);
    const y = useMotionValue(0);

    const animatedScale = useSpring(scale, springConfig);
    const animatedX = useSpring(x, springConfig);
    const animatedY = useSpring(y, springConfig);
    
    const [dragConstraints, setDragConstraints] = useState({ left: 0, right: 0, top: 0, bottom: 0 });

    useEffect(() => {
        setIsMounted(true);
        const handleKeyDown = (e: KeyboardEvent) => { 
            if (e.key === 'Escape') closeLightbox();
            if (isOpen && imageUrls.length > 1) {
                if (e.key === 'ArrowRight') goToPrevious();
                if (e.key === 'ArrowLeft') goToNext();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [closeLightbox, isOpen, imageUrls, goToNext, goToPrevious]);

    useEffect(() => {
        if (isOpen) document.body.classList.add('lightbox-active');
        else document.body.classList.remove('lightbox-active');
        return () => { document.body.classList.remove('lightbox-active'); };
    }, [isOpen]);

    const resetTransform = useCallback(() => {
        scale.set(1);
        x.set(0);
        y.set(0);
    }, [scale, x, y]);

    useEffect(() => { if (isOpen) resetTransform(); }, [isOpen, resetTransform, currentIndex]);
    
    const updateConstraints = useCallback((currentScale: number) => {
        const currentX = x.get();
        const currentY = y.get();

        if (currentScale <= 1) {
            setDragConstraints({ left: 0, right: 0, top: 0, bottom: 0 });
            resetTransform();
            return;
        }

        if (containerRef.current && imageRef.current && imageRef.current.naturalWidth > 0) {
            const container = containerRef.current.getBoundingClientRect();
            const imageAspectRatio = imageRef.current.naturalWidth / imageRef.current.naturalHeight;
            const containerAspectRatio = container.width / container.height;
            
            let renderedWidth, renderedHeight;
            if (imageAspectRatio > containerAspectRatio) {
                renderedWidth = container.width;
                renderedHeight = container.width / imageAspectRatio;
            } else {
                renderedHeight = container.height;
                renderedWidth = container.height * imageAspectRatio;
            }

            const overhangX = Math.max(0, (renderedWidth * currentScale - container.width) / 2);
            const overhangY = Math.max(0, (renderedHeight * currentScale - container.height) / 2);

            setDragConstraints({ left: -overhangX, right: overhangX, top: -overhangY, bottom: overhangY });
            
            x.set(clamp(currentX, -overhangX, overhangX));
            y.set(clamp(currentY, -overhangY, overhangY));
        }
    }, [x, y, resetTransform, scale]);

    useEffect(() => {
        const unsubscribe = scale.onChange(updateConstraints);
        return () => unsubscribe();
    }, [scale, updateConstraints]);
    
    const handleZoom = useCallback((delta: number, clientX?: number, clientY?: number) => {
        const currentScale = scale.get();
        const newScale = clamp(currentScale + delta, 1, 8);
        const scaleRatio = newScale / currentScale;

        const currentX = x.get();
        const currentY = y.get();
        
        if (containerRef.current && clientX && clientY) {
            const rect = containerRef.current.getBoundingClientRect();
            const pointerX = clientX - rect.left - rect.width / 2;
            const pointerY = clientY - rect.top - rect.height / 2;
            
            const newX = pointerX + (currentX - pointerX) * scaleRatio;
            const newY = pointerY + (currentY - pointerY) * scaleRatio;
            
            x.set(newX);
            y.set(newY);
        }
        scale.set(newScale);
    }, [scale, x, y]);

    const handleWheel = useCallback((e: React.WheelEvent) => {
        e.preventDefault();
        e.stopPropagation();
        handleZoom(e.deltaY * -0.01, e.clientX, e.clientY);
    }, [handleZoom]);

    const isZoomed = scale.get() > 1.001;

    const lightboxContent = (
        <AnimatePresence>
            {isOpen && imageUrl && (
                <motion.div className={styles.lightboxOverlay} onWheel={handleWheel} onClick={closeLightbox} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div ref={containerRef} className={styles.imageContainer} onClick={(e) => e.stopPropagation()} initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} transition={{type: 'spring', damping: 25, stiffness: 250}}>
                        <AnimatePresence mode="wait">
                            <motion.img
                                key={currentIndex}
                                ref={imageRef}
                                drag={isZoomed}
                                dragConstraints={dragConstraints}
                                dragElastic={0}
                                dragMomentum={false}
                                src={imageUrl}
                                alt="Full resolution view"
                                className={styles.lightboxImage}
                                style={{ 
                                    scale: animatedScale, 
                                    x: animatedX, 
                                    y: animatedY 
                                }}
                                initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}
                            />
                        </AnimatePresence>
                    </motion.div>
                    
                    <div className={styles.controls} onClick={(e) => e.stopPropagation()}>
                        <button className={styles.controlButton} onClick={() => handleZoom(0.5)} title="Zoom In"><ZoomInIcon /></button>
                        <button className={styles.controlButton} onClick={() => handleZoom(-0.5)} title="Zoom Out"><ZoomOutIcon /></button>
                        <button className={styles.controlButton} onClick={resetTransform} title="Reset Zoom"><ResetIcon /></button>
                        <a href={`${imageUrl}?dl=`} download className={styles.controlButton} title="Download Image"><DownloadIcon /></a>
                        <button className={styles.controlButton} onClick={closeLightbox} title="Close"><CloseIcon /></button>
                    </div>

                    {imageUrls.length > 1 && (
                        <>
                            <button className={`${styles.navButton} ${styles.prev}`} onClick={(e) => { e.stopPropagation(); goToPrevious(); }}><ArrowIcon dir="left" /></button>
                            <button className={`${styles.navButton} ${styles.next}`} onClick={(e) => { e.stopPropagation(); goToNext(); }}><ArrowIcon dir="right" /></button>
                        </>
                    )}
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) return null;
    return createPortal(lightboxContent, document.body);
}

--- END OF FILE components/Lightbox.tsx ---

================================================================================

--- START OF FILE components/Navbar.module.css ---

/* components/Navbar.module.css */

.navbar {
  position: fixed;
  top: 0;
  right: 0;
  width: 100%;
  z-index: 1070;
  height: var(--nav-height);
  display: flex;
  align-items: center;
  transition: height 0.3s ease, background-color 0.3s ease, backdrop-filter 0.3s ease, border-bottom 0.3s ease;
  border-bottom: 1px solid transparent;
}

.navbar.scrolled {
  height: var(--nav-height-scrolled);
  background-color: color-mix(in srgb,var(--bg-primary) 80%,transparent);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border-color);
}

.navContainer {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  width: 100%;
}

.navLogo {
  font-family: var(--font-heading), sans-serif;
  font-size: 3rem;
  font-weight: 800;
  color: var(--text-primary);
  justify-self: start;
}

.navLinks {
  display: flex;
  gap: 3rem;
  list-style: none;
}

.navLinks a {
  font-family: var(--font-ui), sans-serif;
  font-weight: 500;
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: color 0.3s ease, transform 0.3s ease, text-shadow 0.3s ease;
}

.navLinks a:hover {
  color: var(--accent);
  transform: translateY(-2px);
  text-shadow: 0 4px 8px color-mix(in srgb,var(--accent) 40%,transparent);
}

.navControls {
  display: flex;
  align-items: center;
  gap: 2rem;
  justify-self: end;
}

.navSearch {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  position: relative;
  width: 2.4rem;
  height: 2.4rem;
}

.navSearch svg {
  width: 2.4rem;
  height: 2.4rem;
  stroke: var(--text-primary);
  transition: stroke 0.3s ease, transform 0.3s ease;
}

.navSearch:hover svg {
  stroke: var(--accent);
  transform: rotate(-15deg) scale(1.1);
}




--- END OF FILE components/Navbar.module.css ---

================================================================================

--- START OF FILE components/Navbar.tsx ---

// components/Navbar.tsx
'use client';

import React, from 'react';
import Link from 'next/link';
import { ThemeToggle } from './ThemeToggle';
import UserProfile from './UserProfile';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './Navbar.module.css'; // <-- IMPORTED MODULE

// Lazy load search to optimize initial load
const Search = React.lazy(() => import('./Search'));

const SearchIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
);

const Navbar = () => {
    const [scrolled, setScrolled] = React.useState(false);
    const [isSearchOpen, setIsSearchOpen] = React.useState(false);
    const [loadSearch, setLoadSearch] = React.useState(false);

    React.useEffect(() => {
        const handleScroll = () => { setScrolled(window.scrollY > 50); };
        window.addEventListener('scroll', handleScroll);
        return () => window.removeEventListener('scroll', handleScroll);
    }, []);

    const openSearch = () => {
        setLoadSearch(true);
        setIsSearchOpen(true);
    };

    return (
        <>
            <header className={`${styles.navbar} ${scrolled ? styles.scrolled : ''}`}>
                <div className={`container ${styles.navContainer}`}>
                    <Link href="/" className={`${styles.navLogo} no-underline`}>∞</Link>
                    <nav>
                        <ul className={styles.navLinks}>
                            <li><Link href="/reviews">المراجعات</Link></li>
                            <li><Link href="/news">الأخبار</Link></li>
                            <li><Link href="/articles">المقالات</Link></li>
                            <li><Link href="/releases">الإصدارات</Link></li>
                            <li><Link href="/celestial-almanac">التقويم</Link></li>
                            <li><Link href="/constellation">الكوكبة</Link></li>
                        </ul>
                    </nav>
                    <div className={styles.navControls}>
                        <ThemeToggle />
                        <UserProfile />
                        <button className={styles.navSearch} onClick={openSearch} aria-label="فتح البحث">
                            <AnimatePresence>
                                {!isSearchOpen && (
                                    <motion.div
                                        key="search-icon"
                                        initial={{ scale: 0.5, opacity: 0 }}
                                        animate={{ scale: 1, opacity: 1 }}
                                        exit={{ scale: 0, rotate: -360, opacity: 0 }}
                                        transition={{ type: 'spring', stiffness: 500, damping: 25 }}
                                    >
                                        <SearchIcon />
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </button>
                    </div>
                </div>
            </header>
            {loadSearch && (
                <React.Suspense fallback={null}>
                    <Search isOpen={isSearchOpen} onClose={() => setIsSearchOpen(false)} />
                </React.Suspense>
            )}
        </>
    );
};

export default Navbar;




--- END OF FILE components/Navbar.tsx ---

================================================================================

--- START OF FILE components/NewsCard.module.css ---

/* components/NewsCard.module.css */

.newsCardLink {
    display: block;
    height: 100%;
    text-decoration: none;
}

.newsCard {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    overflow: hidden;
    height: 100%;
    display: flex;
    flex-direction: column;
    transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1), box-shadow 0.3s cubic-bezier(0.22, 1, 0.36, 1), border-color 0.3s ease;
}

/* This is the wrapper for the 3D hover effect */
.livingCardWrapper {
    transform-style: preserve-3d;
    height: 100%;
}

.livingCardWrapper:hover .newsCard {
    border-color: color-mix(in srgb, var(--text-primary) 20%, transparent);
}

.imageContainer {
    position: relative;
    width: 100%;
    height: 200px;
    overflow: hidden;
    flex-shrink: 0;
}

.cardImage {
    transition: transform 0.4s ease;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.cardContent {
    padding: 2rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}

.category {
    font-family: var(--font-ui), sans-serif;
    font-size: 1.3rem;
    font-weight: 500;
    color: var(--accent);
    margin-bottom: 0.5rem;
}

.cardContent h3 {
    font-size: 1.8rem;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0;
}

/* Lead Card specific styles for News Page */
.leadNewsCard {
    border-radius: 12px;
}

.leadNewsCard .imageContainer {
    height: 220px;
}

.leadNewsCard .cardContent {
    padding: 1.5rem 2.5rem;
}

.leadNewsCard h3 {
    font-size: 2.5rem;
    line-height: 1.2;
}







--- END OF FILE components/NewsCard.module.css ---

================================================================================

--- START OF FILE components/NewsCard.tsx ---

// components/NewsCard.tsx
'use client';

import { NewsItem } from '@/lib/data';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { memo } from 'react';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useLivingCard } from '@/hooks/useLivingCard';
import styles from './NewsCard.module.css';

const NewsCardComponent = ({ item, isLead = false }: { item: any, isLead?: boolean }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard({ isLead });
    const router = useRouter();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const layoutIdPrefix = 'news-grid';

    const linkPath = `/news/${item.slug}`;

    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        setPrefix(layoutIdPrefix);
        router.push(linkPath, { scroll: false });
    };

    const handleMouseEnter = () => {
        router.prefetch(linkPath);
    };

    // --- THE DEFINITIVE FIX: ---
    // The source URL from the adapter might already have query params. We must strip them
    // before appending our own desired params to avoid conflicts and errors.
    const imageSource = item.imageUrl;
    if (!imageSource) return null;

    const baseUrl = imageSource.split('?')[0];
    const imageUrl = `${baseUrl}?w=600&auto=format&q=80`;

    return (
        <motion.div 
            ref={livingCardRef} 
            onMouseMove={livingCardAnimation.onMouseMove}
            onMouseEnter={() => { livingCardAnimation.onHoverStart(); handleMouseEnter(); }}
            onMouseLeave={livingCardAnimation.onHoverEnd}
            className={styles.livingCardWrapper}
            style={livingCardAnimation.style}
        >
            <a href={linkPath} onClick={handleClick} className={`${styles.newsCardLink} no-underline`}>
                <motion.div
                    className={`${styles.newsCard} ${isLead ? styles.leadNewsCard : ''}`}
                    layoutId={`${layoutIdPrefix}-card-container-${item.id}`}
                >
                    <motion.div
                        className={styles.imageContainer}
                        style={{ transform: 'translateZ(20px)' }}
                        layoutId={`${layoutIdPrefix}-card-image-${item.id}`}
                    >
                        <Image 
                            src={imageUrl} 
                            alt={item.title} 
                            width={item.width || 1600}
                            height={item.height || 900}
                            sizes={isLead ? '100vw' : '30vw'}
                            className={styles.cardImage} 
                            placeholder="blur" 
                            blurDataURL={item.blurDataURL}
                            unoptimized
                        />
                    </motion.div>
                    <div className={styles.cardContent} style={{ transform: 'translateZ(40px)' }}>
                        <p className={styles.category}>{item.category}</p>
                        <motion.h3 layoutId={`${layoutIdPrefix}-card-title-${item.id}`}>{item.title}</motion.h3>
                    </div>
                </motion.div>
            </a>
        </motion.div>
    );
};

export default memo(NewsCardComponent);

--- END OF FILE components/NewsCard.tsx ---

================================================================================

--- START OF FILE components/NewsTicker.module.css ---

/* components/NewsTicker.module.css */

.newsTickerContainer {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 2.5rem;
}

.newsTickerTitle {
    font-family: var(--font-ui);
    font-size: 1.6rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin: 0 0 2rem 0;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.newsTickerList {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.newsTickerItem {
    display: flex;
    align-items: flex-start;
    gap: 1.5rem;
}

.newsTickerImageContainer {
    flex-shrink: 0;
    width: 50px;
    height: 50px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
}

.newsTickerImage {
    transition: transform 0.3s ease;
}

.newsTickerItem:hover .newsTickerImage {
    transform: scale(1.1);
}

.newsTickerTextContent {
    flex-grow: 1;
}

.newsTickerCategory {
    font-family: var(--font-ui);
    font-size: 1.3rem;
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 0.2rem;
}

.newsTickerItemTitle {
    margin: 0;
    font-size: 1.5rem;
    line-height: 1.5;
    color: var(--text-primary);
    transition: color 0.2s ease;
}

.newsTickerItem:hover .newsTickerItemTitle {
    color: var(--accent);
}

.newsTickerArchiveLink {
    display: inline-block;
    margin-top: 2rem;
    font-family: var(--font-ui);
    font-size: 1.4rem;
    font-weight: 500;
    color: var(--text-secondary);
}

/* Styles for the Vertical Slider variant */
.verticalNewsSliderContainer {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 2.5rem;
    height: 450px;
    display: flex;
    flex-direction: column;
}

.verticalNewsSliderTitle {
    font-family: var(--font-ui);
    font-size: 1.6rem;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-secondary);
    margin: 0 0 1.5rem 0;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.verticalNewsSliderLink {
    flex-grow: 1;
    position: relative;
    display: block;
    overflow: hidden;
    border-radius: 8px;
}

.verticalNewsSliderItem {
    position: absolute;
    inset: 0;
    color: #fff;
}

.verticalNewsImageContainer {
    position: absolute;
    inset: 0;
}

.verticalNewsContent {
    position: relative;
    z-index: 2;
    height: 100%;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    background: linear-gradient(to top,rgba(0,0,0,0.8) 0%,transparent 60%);
}

.verticalNewsContent .newsTickerCategory {
    color: var(--accent);
    margin-bottom: 0.5rem;
}

.verticalNewsContent .newsTickerItemTitle {
    color: #fff;
    font-size: 1.6rem;
    line-height: 1.4;
    font-weight: 700;
}

.verticalNewsPagination {
    display: flex;
    justify-content: center;
    gap: 6px;
    padding: 1.5rem 0;
    flex-shrink: 0;
}

.vPaginationDot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--border-color);
    transition: background-color 0.3s ease;
}

.vPaginationDot.active {
    background-color: var(--accent);
}

.newsTickerArchiveLinkCentered {
    text-align: center;
    flex-shrink: 0;
}







--- END OF FILE components/NewsTicker.module.css ---

================================================================================

--- START OF FILE components/NewsTicker.tsx ---

// components/NewsTicker.tsx
'use client';
import Link from "next/link";
import { motion, useInView } from 'framer-motion';
import { useRef } from "react";
import Image from "next/image";
import styles from './NewsTicker.module.css';

const containerVariants = { hidden: { opacity: 0, x: 100 }, visible: { opacity: 1, x: 0, transition: { duration: 0.8, ease: "easeOut", staggerChildren: 0.1, delayChildren: 0.3 } } };
const itemVariants = { hidden: { opacity: 0, x: 20 }, visible: { opacity: 1, x: 0, transition: { duration: 0.5, ease: 'easeOut' } } };

export default function NewsTicker({ latestNews }: { latestNews: any[] }) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.2 });
    if (!latestNews || latestNews.length === 0) return null;

    return (
        <motion.div ref={ref} className={styles.newsTickerContainer} variants={containerVariants} initial="hidden" animate={isInView ? "visible" : "hidden"}>
            <h3 className={styles.newsTickerTitle}>نبض الأحداث</h3>
            <div className={styles.newsTickerList}>
                {latestNews.map(item => {
                    const imageSource = item.imageUrl;
                    if (!imageSource) return null;

                    // --- THE DEFINITIVE FIX: ---
                    const baseUrl = imageSource.split('?')[0];
                    const imageUrl = `${baseUrl}?w=100&h=100&auto=format&q=75`;

                    return (
                        <motion.div key={item.id} variants={itemVariants}>
                            <Link href={`/news/${item.slug}`} className={`${styles.newsTickerItem} no-underline`}>
                                <div className={styles.newsTickerImageContainer}>
                                    <Image 
                                        src={imageUrl} 
                                        alt={item.title} 
                                        width={50}
                                        height={50}
                                        className={styles.newsTickerImage}
                                        unoptimized
                                    />
                                </div>
                                <div className={styles.newsTickerTextContent}>
                                    <p className={styles.newsTickerCategory}>{item.category}</p>
                                    <p className={styles.newsTickerItemTitle}>{item.title}</p>
                                </div>
                            </Link>
                        </motion.div>
                    );
                })}
            </div>
            <Link href="/news" className={styles.newsTickerArchiveLink}>عرض كل الأخبار ←</Link>
        </motion.div>
    );
}

--- END OF FILE components/NewsTicker.tsx ---

================================================================================

--- START OF FILE components/PaginatedCarousel.module.css ---

/* components/PaginatedCarousel.module.css */
.paginatedCarouselContainer {
  position: relative;
}
.paginatedCarouselContent {
  margin-bottom: 2rem;
  min-height: 420px;
}
/* New CSS to enforce 2-column grid inside the carousel */
.twoColumnGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 3rem;
  grid-auto-rows: 1fr;
}
@media (max-width: 768px) {
  .twoColumnGrid {
    grid-template-columns: 1fr;
  }
}
/* End New CSS */
.paginationControls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
}
.paginationDot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: var(--border-color);
  border: none;
  cursor: pointer;
  padding: 0;
  transition: all 0.3s ease;
}
.paginationDot:hover {
  background-color: var(--text-secondary);
}
.paginationDot.active {
  background-color: var(--accent);
  transform: scale(1.2);
}




--- END OF FILE components/PaginatedCarousel.module.css ---

================================================================================

--- START OF FILE components/PaginatedCarousel.tsx ---

// components/PaginatedCarousel.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import styles from './PaginatedCarousel.module.css'; // <-- IMPORT MODULE

type PaginatedCarouselProps = {
    items: any[];
    itemsPerPage: number;
    layoutIdPrefix: string;
};

export default function PaginatedCarousel({ items, itemsPerPage, layoutIdPrefix }: PaginatedCarouselProps) {
    const [currentPage, setCurrentPage] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    const totalPages = Math.ceil(items.length / itemsPerPage);

    const resetTimeout = () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } };

    useEffect(() => {
        resetTimeout();
        if (!isHovered) {
            timeoutRef.current = setTimeout( () => setCurrentPage((prevPage) => (prevPage + 1) % totalPages), 5000 );
        }
        return () => resetTimeout();
    }, [currentPage, isHovered, totalPages]);

    const startIndex = currentPage * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = items.slice(startIndex, endIndex);

    return (
        <div className={styles.paginatedCarouselContainer} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)}>
            <div className={styles.paginatedCarouselContent}>
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentPage}
                        className={styles.twoColumnGrid} // <-- APPLIED NEW CLASS
                        initial={{ opacity: 0, x: 50 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: -50 }}
                        transition={{ duration: 0.35, ease: 'easeInOut' }}
                        style={{ transformStyle: 'preserve-3d' }}
                    >
                        {currentItems.map((item) => (
                            <ArticleCard key={item.id} article={item} isArticle={item.type === 'article'} layoutIdPrefix={layoutIdPrefix} />
                        ))}
                    </motion.div>
                </AnimatePresence>
            </div>
            <div className={styles.paginationControls}>
                {Array.from({ length: totalPages }).map((_, index) => (
                    <motion.button
                        key={index}
                        className={`${styles.paginationDot} ${currentPage === index ? styles.active : ''}`}
                        onClick={() => setCurrentPage(index)}
                        aria-label={`Go to page ${index + 1}`}
                        whileHover={{ scale: 1.2 }}
                        whileTap={{ scale: 0.9 }}
                    />
                ))}
            </div>
        </div>
    );
}




--- END OF FILE components/PaginatedCarousel.tsx ---

================================================================================

--- START OF FILE components/PasswordChangeForm.tsx ---

// components/PasswordChangeForm.tsx
'use client';

import { useState, useTransition } from 'react';
import { changePasswordAction } from '@/app/actions/userActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from './ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function PasswordChangeForm() {
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    
    // --- DEFINITIVE FIX: Comment is now correctly formatted ---
    // State to manage form fields for floating labels
    const [currentPassword, setCurrentPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');

    const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const formData = new FormData(event.currentTarget);
        const form = event.currentTarget;

        startTransition(async () => {
            const result = await changePasswordAction(formData);
            if (result.success) {
                toast.success(result.message || 'تم تغيير كلمة السر بنجاح!');
                // Clear state on success
                setCurrentPassword('');
                setNewPassword('');
                setConfirmPassword('');
                form.reset();
            } else {
                toast.error(result.message || 'Failed to change password.');
            }
        });
    };

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <form onSubmit={handleSubmit} style={{ maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
            <div className={`profile-form-group ${hasContent(currentPassword)}`}>
                <input 
                    id="currentPassword" 
                    name="currentPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={currentPassword}
                    onChange={(e) => setCurrentPassword(e.target.value)}
                    placeholder=" "
                />
                 <label className="profile-form-label" htmlFor="currentPassword">كلمة السر الحالية</label>
            </div>
            <div className={`profile-form-group ${hasContent(newPassword)}`}>
                <input 
                    id="newPassword" 
                    name="newPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={newPassword}
                    onChange={(e) => setNewPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="newPassword">كلمة السر الجديدة</label>
            </div>
            <div className={`profile-form-group ${hasContent(confirmPassword)}`}>
                <input 
                    id="confirmPassword" 
                    name="confirmPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="confirmPassword">تأكيد كلمة السر الجديدة</label>
            </div>
            <motion.button 
                type="submit" 
                className="primary-button" 
                disabled={isPending}
                animate={{
                    width: isPending ? '48px' : 'auto',
                    height: '48px',
                    borderRadius: isPending ? '50%' : '5px',
                }}
                transition={{ type: 'spring', stiffness: 400, damping: 25 }}
            >
                <AnimatePresence mode="wait">
                    {isPending ? (
                        <ButtonLoader key="loader" />
                    ) : (
                        <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>تحديث كلمة السر</motion.span>
                    )}
                </AnimatePresence>
            </motion.button>
        </form>
    );
}







--- END OF FILE components/PasswordChangeForm.tsx ---

================================================================================

--- START OF FILE components/PortableTextComponent.tsx ---

// components/PortableTextComponent.tsx
'use client'

import React from 'react'
import { PortableText, PortableTextComponents } from '@portabletext/react'
import { urlFor } from '@/sanity/lib/image'
import ImageCompare from './ImageCompare';
import TwoImageGrid from './custom/TwoImageGrid';
import FourImageGrid from './custom/FourImageGrid';
import { slugify } from 'transliteration';
import NextImage from 'next/image';
import { useLightboxStore } from '@/lib/lightboxStore';

const SanityImageComponent = ({ value }: { value: any }) => {
    const { asset, alt } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);
    if (!asset?._id || !asset?.url) return null;

    const { width, height } = asset.metadata?.dimensions || { width: 1920, height: 1080 };
    const blurDataURL = asset.metadata?.lqip;

    const optimizedSrc = urlFor(asset)
        .width(1920)
        .auto('format')
        .quality(85)
        .url();

    const fullResSrc = urlFor(asset).auto('format').quality(100).url();

    return (
        <div style={{ margin: '4rem 0' }}>
            <div
              onClick={() => openLightbox([fullResSrc], 0)}
              className="image-lightbox-trigger"
            >
                <NextImage
                    src={optimizedSrc}
                    alt={alt || 'Content Image'}
                    width={width}
                    height={height}
                    sizes="(max-width: 960px) 90vw, 850px"
                    placeholder={blurDataURL ? 'blur' : 'empty'}
                    blurDataURL={blurDataURL}
                    loading="lazy"
                    draggable={false}
                    style={{
                        width: '100%',
                        height: 'auto',
                    }}
                />
            </div>
        </div>
    );
};

const H2Component = ({ children }: { children: React.ReactNode }) => {
    const textContent = Array.isArray(children) ? children.join('') : (children as string) || '';
    const id = slugify(textContent);
    return <h2 id={id} style={{ margin: '5rem 0 2rem 0', paddingBottom: '1rem', borderBottom: '1px solid var(--border-color)' }}>{children}</h2>
}

const components: PortableTextComponents = {
    types: { 
        image: SanityImageComponent,
        imageCompare: ({ value }) => <ImageCompare value={value} />,
        twoImageGrid: ({ value }) => <TwoImageGrid value={value} />,
        fourImageGrid: ({ value }) => <FourImageGrid value={value} />,
    },
    block: { h2: H2Component, blockquote: ({ children }) => <blockquote style={{ margin: '4rem 0', paddingLeft: '2rem', borderLeft: '4px solid var(--accent)', fontSize: '2.4rem', fontStyle: 'italic', color: 'var(--text-primary)' }}>{children}</blockquote>, },
}

export default function PortableTextComponent({ content }: { content: any[] }) {
    if (!content) return null
    return (
        <div className="portable-text-content" style={{ fontSize: '1.8rem', lineHeight: 1.8 }}>
            <PortableText value={content} components={components} />
        </div>
    )
}

--- END OF FILE components/PortableTextComponent.tsx ---

================================================================================

--- START OF FILE components/ProfileEditForm.module.css ---

/* components/ProfileEditForm.module.css */
.avatarFormGroup{margin-bottom:2rem}
.avatarInputContainer{display:flex;align-items:center;gap:1.5rem}
.avatarPreviewButton{position:relative;border-radius:50%;overflow:hidden;padding:0;border:none;background:none;cursor:pointer;width:80px;height:80px;flex-shrink:0}
.profileAvatarPreview{border-radius:50%;transition:all .3s ease-out}
.avatarUploadPrompt{position:absolute;inset:0;background-color:color-mix(in srgb,var(--bg-primary) 70%,transparent);color:var(--text-primary);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem;font-size:1.2rem;font-weight:500;font-family:var(--font-ui);opacity:0;transition:opacity .3s ease-out;z-index:2}
.avatarPreviewButton:hover .avatarUploadPrompt{opacity:1}
.avatarPreviewButton:hover .profileAvatarPreview{transform:scale(1.1);filter:blur(2px) brightness(.8)}
.formDescription{font-size:1.4rem;color:var(--text-secondary);margin:0}







--- END OF FILE components/ProfileEditForm.module.css ---

================================================================================

--- START OF FILE components/ProfileEditForm.tsx ---

// components/ProfileEditForm.tsx
'use client';

import { updateUserAvatar, updateUserProfile, checkUsernameAvailability } from '@/app/actions/userActions';
import {المستخدم} from '@prisma/client';
import { useRef, useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import { useSession } from 'next-auth/react';
import AvatarCropperModal from './AvatarCropperModal';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useDebounce } from '@/hooks/useDebounce';
import { useToast } from '@/lib/toastStore';
import avatarStyles from './ProfileEditForm.module.css';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const ToggleSwitch = ({ checked, onChange, name }: { checked: boolean, onChange: (checked: boolean) => void, name: string }) => (
    <button
        type="button"
        role="switch"
        aria-checked={checked}
        onClick={() => onChange(!checked)}
        className={`toggle ${checked ? 'active' : ''}`}
    >
        <motion.div className="toggle-handle" layout transition={{ type: 'spring', stiffness: 700, damping: 30 }} />
        <input type="checkbox" name={name} checked={checked} readOnly style={{ display: 'none' }} />
    </button>
);


export default function ProfileEditForm({ user }: { user: المستخدم}) {
    const inputFileRef = useRef<HTMLInputElement>(null);
    const { update: updateSession } = useSession();
    const toast = useToast();
    const [isSaving, startSaveTransition] = useTransition();
    const [isCheckingUsername, startUsernameCheckTransition] = useTransition();
    
    // THE FIX: Use nullish coalescing `?? ''` for robust state initialization.
    // This guarantees the state is always a string, never null or undefined.
    const [avatarPreview, setAvatarPreview] = useState(user.image ?? '/default-avatar.svg');
    const [avatarFile, setAvatarFile] = useState<File | null>(null);
    const [name, setName] = useState(user.name ?? '');
    const [username, setUsername] = useState(user.username ?? '');
    const [bio, setBio] = useState(user.bio ?? '');
    const [twitterHandle, setTwitterHandle] = useState(user.twitterHandle ?? '');
    const [instagramHandle, setInstagramHandle] = useState(user.instagramHandle ?? '');
    const [agePublic, setAgePublic] = useState(user.agePublic);
    const [countryPublic, setCountryPublic] = useState(user.countryPublic);

    const [usernameStatus, setUsernameStatus] = useState<{ type: 'idle' | 'checking' | 'valid' | 'invalid', message: string }>({ type: 'idle', message: '' });
    const debouncedUsername = useDebounce(username, 500);
    const [isCropperOpen, setIsCropperOpen] = useState(false);
    const [cropperImageSrc, setCropperImageSrc] = useState<string | null>(null);
    
    const hasTextChanged = 
        name !== (user.name ?? '') ||
        username !== (user.username ?? '') ||
        bio !== (user.bio ?? '') ||
        twitterHandle !== (user.twitterHandle ?? '') ||
        instagramHandle !== (user.instagramHandle ?? '') ||
        agePublic !== user.agePublic ||
        countryPublic !== user.countryPublic;

    const hasChanges = !!avatarFile || hasTextChanged;
    const isSaveDisabled = isSaving || !hasChanges || usernameStatus.type === 'invalid' || usernameStatus.type === 'checking';

    useEffect(() => {
        if (debouncedUsername && debouncedUsername !== user.username) {
            setUsernameStatus({ type: 'checking', message: 'Checking...' });
            startUsernameCheckTransition(async () => {
                const result = await checkUsernameAvailability(debouncedUsername);
                setUsernameStatus({ type: result.available ? 'valid' : 'invalid', message: result.message });
            });
        } else {
            setUsernameStatus({ type: 'idle', message: '' });
        }
    }, [debouncedUsername, user.username]);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => { setCropperImageSrc(reader.result as string); setIsCropperOpen(true); };
        reader.readAsDataURL(file);
        if(inputFileRef.current) inputFileRef.current.value = "";
    };
    const handleCropComplete = (croppedFile: File) => {
        setAvatarFile(croppedFile);
        setAvatarPreview(URL.createObjectURL(croppedFile));
        setIsCropperOpen(false);
    };
    async function handleProfileSave(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault();
        if (isSaveDisabled) return;
        startSaveTransition(async () => {
            try {
                if (avatarFile) {
                    const avatarFormData = new FormData();
                    avatarFormData.append('avatar', avatarFile);
                    const avatarResult = await updateUserAvatar(avatarFormData);
                    if (!avatarResult.success) throw new Error(avatarResult.message);
                }
                if (hasTextChanged) {
                    const profileFormData = new FormData(event.currentTarget);
                    const profileResult = await updateUserProfile(profileFormData);
                    if (!profileResult.success) throw new Error(profileResult.message);
                }
                await updateSession();
                toast.success('تم تحديث الملف الشخصي بنجاح!');
                setAvatarFile(null);
            } catch (error: any) {
                toast.error(error.message || 'Failed to update profile.');
            }
        });
    }

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <>
            <AvatarCropperModal isOpen={isCropperOpen} onClose={() => setIsCropperOpen(false)} imageSrc={cropperImageSrc || ''} onCropComplete={handleCropComplete} />
            <form onSubmit={handleProfileSave} style={{ maxWidth: '600px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                <div className={avatarStyles.avatarFormGroup}>
                    <label className="profile-form-label" style={{position: 'static', transform: 'none', marginBottom: '0.5rem', fontSize: '1.4rem', color: 'var(--text-primary)', fontWeight: '600'}}>صورتك الرمزية</label>
                    <div className={avatarStyles.avatarInputContainer}>
                        <button type="button" className={avatarStyles.avatarPreviewButton} onClick={() => inputFileRef.current?.click()}>
                            <div className={avatarStyles.avatarUploadPrompt}><UploadIcon /><span>تغيير</span></div>
                            <Image src={avatarPreview} alt="Avatar preview" width={80} height={80} className={avatarStyles.profileAvatarPreview} />
                        </button>
                        <p className={avatarStyles.formDescription}>انقر لرفع صورة جديدة (الحد الأقصى 4.5 ميجابايت).</p>
                        <input ref={inputFileRef} type="file" name="avatar_source" onChange={handleFileChange} accept="image/png, image/jpeg, image/webp" style={{ display: 'none' }} disabled={isSaving} />
                    </div>
                </div>
                <div className={`profile-form-group ${hasContent(name)}`}>
                    <input id="name" name="name" value={name} onChange={(e) => setName(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="name" className="profile-form-label">الاسم المعروض</label>
                </div>
                <div className={`profile-form-group ${hasContent(username)}`}>
                    <input id="username" name="username" value={username} onChange={(e) => setUsername(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="username" className="profile-form-label">اسم المستخدم</label>
                    <AnimatePresence>
                        {usernameStatus.message && ( <motion.p initial={{opacity: 0, height: 0}} animate={{opacity: 1, height: 'auto'}} exit={{opacity: 0, height: 0}} style={{ fontSize: '1.3rem', margin: '0.5rem 0 0 0', color: usernameStatus.type === 'invalid' ? '#DC2626' : (usernameStatus.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameStatus.message}</motion.p> )}
                    </AnimatePresence>
                </div>
                <div className={`profile-form-group ${hasContent(bio)}`}>
                    <textarea id="bio" name="bio" value={bio} onChange={(e) => setBio(e.target.value)} rows={4} className="profile-input" maxLength={500} placeholder=" " />
                    <label htmlFor="bio" className="profile-form-label">النبذة التعريفية</label>
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                    <div className={`profile-form-group ${hasContent(twitterHandle)}`}>
                        <input id="twitterHandle" name="twitterHandle" value={twitterHandle} onChange={(e) => setTwitterHandle(e.target.value)} className="profile-input" placeholder=" " />
                         <label htmlFor="twitterHandle" className="profile-form-label">حساب تويتر</label>
                    </div>
                    <div className={`profile-form-group ${hasContent(instagramHandle)}`}>
                        <input id="instagramHandle" name="instagramHandle" value={instagramHandle} onChange={(e) => setInstagramHandle(e.target.value)} className="profile-input" placeholder=" "/>
                        <label htmlFor="instagramHandle" className="profile-form-label">حساب انستغرام</label>
                    </div>
                </div>

                <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem', background: 'var(--bg-primary)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border-color)'}}>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="agePublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار العمر للعامة</label>
                        <ToggleSwitch name="agePublic" checked={agePublic} onChange={setAgePublic} />
                    </div>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="countryPublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار البلد للعامة</label>
                        <ToggleSwitch name="countryPublic" checked={countryPublic} onChange={setCountryPublic} />
                    </div>
                </div>

                <motion.button type="submit" className="primary-button" disabled={isSaveDisabled} animate={{ width: isSaving ? '48px' : '100%', height: '48px', borderRadius: isSaving ? '50%' : '5px', }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">
                        {isSaving ? ( <ButtonLoader key="loader" /> ) : ( <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>حفظ التغييرات</motion.span> )}
                    </AnimatePresence>
                </motion.button>
            </form>
        </>
    );
}




--- END OF FILE components/ProfileEditForm.tsx ---

================================================================================

--- START OF FILE components/ReadingHud.module.css ---

/* components/ReadingHud.module.css */

.readingHud {
  position: fixed;
  top: 50%;
  left: 2rem;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  height: 300px;
  z-index: 100;
}
@media (max-width: 1200px) {
  .readingHud {
    display: none;
  }
}

.track {
  width: 2px;
  height: 100%;
  background-color: var(--border-color);
  position: relative;
  border-radius: 2px;
}

.progress {
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  transform-origin: top;
  border-radius: 2px;
  box-shadow: 0 0 8px 0 color-mix(in srgb, var(--accent) 70%, transparent);
}

.markers {
  position: absolute;
  top: 0;
  right: 50%;
  width: 1px;
  height: 100%;
  transform: translateX(50%);
}

.marker {
  position: absolute;
  right: 50%;
  transform: translateX(50%);
  width: 10px;
  height: 10px;
  background-color: var(--border-color);
  border: 2px solid var(--bg-primary);
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
}
.marker:hover {
  background-color: var(--accent);
  transform: translateX(50%) scale(1.5);
}
.marker.active {
  background-color: var(--accent);
  transform: translateX(50%) scale(1.8);
  box-shadow: 0 0 12px 2px color-mix(in srgb, var(--accent) 70%, transparent);
}
.marker::after {
  content: attr(data-title);
  position: absolute;
  top: 50%;
  left: 18px;
  transform: translateY(-50%) scale(0.9);
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  font-family: var(--font-ui);
  font-size: 1.4rem;
  font-weight: 500;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease, transform 0.3s ease, right 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  border: 1px solid var(--border-color);
}
.marker:hover::after {
  opacity: 1;
  transform: translateY(-50%) scale(1);
  left: 25px;
}







--- END OF FILE components/ReadingHud.module.css ---

================================================================================

--- START OF FILE components/ReadingHud.tsx ---

// components/ReadingHud.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, useScroll, useSpring, AnimatePresence } from 'framer-motion';
import styles from './ReadingHud.module.css'; // <-- IMPORTED

type Heading = {
    id: string;
    title: string;
    top: number;
};

export default function ReadingHud({ contentContainerRef, headings }: { contentContainerRef: React.RefObject<HTMLElement>, headings: Heading[] }) {
    const [activeHeadings, setActiveHeadings] = useState<Set<string>>(new Set());
    const [isVisible, setIsVisible] = useState(false);
    const scrollableHeightRef = useRef(0);
    const { scrollYProgress } = useScroll({ target: contentContainerRef, offset: ['start start', 'end end'] });
    const springyProgress = useSpring(scrollYProgress, { stiffness: 200, damping: 40, restDelta: 0.001 });

    useEffect(() => {
        const contentElement = contentContainerRef.current;
        if (!contentElement || headings.length === 0) {
            setIsVisible(false);
            return;
        }

        const newScrollableHeight = contentElement.scrollHeight - window.innerHeight;
        scrollableHeightRef.current = Math.max(1, newScrollableHeight);

        const visibilityObserver = new IntersectionObserver(([entry]) => setIsVisible(entry.isIntersecting), { rootMargin: "0px 0px -40% 0px" });
        visibilityObserver.observe(contentElement);

        const unsubscribeFromScroll = scrollYProgress.on("change", (latestProgress) => {
            const currentlyActive = new Set<string>();
            headings.forEach(heading => {
                const headingProgressPosition = heading.top / scrollableHeightRef.current;
                if (latestProgress >= headingProgressPosition) {
                    currentlyActive.add(heading.id);
                }
            });
            setActiveHeadings(currentlyActive);
        });

        return () => {
            visibilityObserver.disconnect();
            unsubscribeFromScroll();
        };
    }, [contentContainerRef, headings, scrollYProgress]);

    const handleMarkerClick = (headingId: string) => {
        const headingElement = document.getElementById(headingId);
        if (!headingElement) return;
        const navbarOffset = 80;
        const elementTop = headingElement.getBoundingClientRect().top + window.scrollY;
        const targetScrollPosition = elementTop - navbarOffset;
        window.scrollTo({ top: targetScrollPosition, behavior: 'smooth' });
    };

    return (
        <AnimatePresence>
            {isVisible && headings.length > 0 && (
                <motion.aside
                    className={styles.readingHud}
                    initial={{ opacity: 0, x: 20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: 20 }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                >
                    <div className={styles.track}>
                        <motion.div className={styles.progress} style={{ scaleY: springyProgress }} />
                    </div>
                    <div className={styles.markers}>
                        {headings.map((h) => {
                            const isActive = activeHeadings.has(h.id);
                            return (
                                <button
                                    key={h.id}
                                    className={`${styles.marker} ${isActive ? styles.active : ''}`}
                                    style={{ top: `${(h.top / scrollableHeightRef.current) * 100}%` }}
                                    onClick={() => handleMarkerClick(h.id)}
                                    data-title={h.title}
                                    aria-label={`Scroll to ${h.title}`}
                                />
                            )
                        })}
                    </div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
};







--- END OF FILE components/ReadingHud.tsx ---

================================================================================

--- START OF FILE components/ScoreBox.tsx ---

// components/ScoreBox.tsx
'use client';

import React, { useRef, memo } from 'react';
import { motion, useInView } from 'framer-motion';
import { AnimatedNumber } from './AnimatedNumber';
import styles from '../app/reviews/[slug]/ReviewPage.module.css';

const CheckIcon = () => ( <svg style={{flexShrink:0,width:'1.8rem',height:'1.8rem',marginTop:'0.2rem',color:'#16A34A'}} fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd"></path></svg> );
const CrossIcon = () => ( <svg style={{flexShrink:0,width:'1.8rem',height:'1.8rem',marginTop:'0.2rem',color:'#DC2626'}} fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd"></path></svg> );

const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.25, delayChildren: 0.2 }, }, };
const itemVariants = { hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: 'easeOut' } }, };

const ScoreBoxComponent = ({ review }: { review: any }) => {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.5 });

    return (
        <motion.div ref={ref} className={styles.reviewScoreBox} initial="hidden" animate={isInView ? "visible" : "hidden"} variants={containerVariants}>
            <svg className={styles.scoreBoxBorder} width="100%" height="100%">
                <motion.rect x="1" y="1" width="calc(100% - 2px)" height="calc(100% - 2px)" rx="12" stroke="var(--accent)" strokeWidth="2" fill="transparent" initial={{ pathLength: 0 }} animate={{ pathLength: isInView ? 1 : 0 }} transition={{ duration: 1, ease: 'easeInOut' }} />
            </svg>
            <AnimatedNumber value={review.score} isInView={isInView} className={styles.scoreBoxScore} />
            <motion.div variants={itemVariants} className={styles.scoreBoxVerdictLabel}>الخلاصة</motion.div>
            <motion.p variants={itemVariants} className={styles.scoreBoxVerdictText}>{review.verdict}</motion.p>
            <motion.div variants={itemVariants} className={styles.scoreBoxDivider} />
            <div className={styles.scoreBoxProsCons}>
                <motion.div variants={itemVariants}>
                    <h4>المحاسن</h4>
                    {/* THE FIX: Use a more robust key */}
                    <ul>{review.pros.map((pro: string, index: number) => (<li key={`pro-${index}`}>{pro} <CheckIcon /></li>))}</ul>
                </motion.div>
                <motion.div variants={itemVariants}>
                    <h4>المآخذ</h4>
                    {/* THE FIX: Use a more robust key */}
                    <ul>{review.cons.map((con: string, index: number) => (<li key={`con-${index}`}>{con} <CrossIcon /></li>))}</ul>
                </motion.div>
            </div>
        </motion.div>
    );
};

export default memo(ScoreBoxComponent);




--- END OF FILE components/ScoreBox.tsx ---

================================================================================

--- START OF FILE components/Search.module.css ---

/* components/Search.module.css */

.searchOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: color-mix(in srgb, var(--bg-primary) 85%, transparent);
  backdrop-filter: blur(10px);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding-top: 15vh;
  z-index: 2000;
}

.searchContainer {
  position: relative;
  width: 100%;
  max-width: 700px;
  padding: 0 2rem;
}

.searchCloseButton {
  position: absolute;
  top: -60px;
  left: 2rem; /* RTL */
  right: auto;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  padding: 1rem;
  width: 40px;
  height: 40px;
  transition: color 0.3s ease, transform 0.3s ease;
}

.searchCloseButton:hover {
  transform: scale(1.1) rotate(90deg);
  color: var(--accent);
}

.searchInput {
  width: 100%;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  color: var(--text-primary);
  font-family: var(--font-main), sans-serif;
  font-size: 2.2rem;
  padding: 1.5rem 2rem;
  outline: none;
  text-align: right; /* RTL */
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
  box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

.searchInput:focus {
  border-color: var(--accent);
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.searchResultsList {
  margin-top: 2rem;
  max-height: 65vh;
  overflow-y: auto;
  list-style: none;
  padding: 1rem 1rem 0 1rem;
}

.searchResultLink {
  display: flex;
  align-items: center;
  gap: 2.5rem;
  padding: 1.5rem;
  margin: 0 0 1.5rem 0;
  border-radius: 10px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  transition: all 0.2s ease-out;
  box-shadow: none;
  position: relative;
  overflow: hidden;
  text-align: right; /* RTL */
}

.searchResultLink:hover {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  transform: translateY(-3px) scale(1.005);
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent), 0 5px 20px rgba(0,0,0,0.2);
}

.searchResultThumbnail {
  flex-shrink: 0;
  width: 100px;
  height: 60px;
  border-radius: 6px;
  overflow: hidden;
  border: 1px solid var(--border-color);
}

.searchResultImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.searchResultDetails h4 {
  font-family: var(--font-main), sans-serif;
  font-size: 2rem;
  font-weight: 700;
  line-height: 1.3;
  margin: 0;
  color: var(--text-primary);
  transition: color 0.2s ease;
}

.searchResultLink:hover h4 {
  color: var(--accent);
}

.searchResultDetails p {
  font-family: var(--font-main), sans-serif;
  font-size: 1.4rem;
  color: var(--text-secondary);
  margin: 0.5rem 0 0 0;
}

.searchInitialPrompt {
  font-family: var(--font-main), sans-serif;
  font-size: 2.8rem;
  text-align: center;
  color: var(--text-secondary);
  margin-top: 5rem;
}

.searchResultImageFallback {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
}




--- END OF FILE components/Search.module.css ---

================================================================================

--- START OF FILE components/Search.tsx ---

// components/Search.tsx

'use client';

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import type { SanitySearchResult } from '@/types/sanity';
import { useDebounce } from '@/hooks/useDebounce';
import styles from './Search.module.css'; // <-- IMPORT ADDED

const CrossIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

const overlayVariants = {
    hidden: { opacity: 0, backdropFilter: 'blur(0px)' },
    visible: { opacity: 1, backdropFilter: 'blur(12px)' }
};

const containerVariants = {
    hidden: { y: '-10vh', opacity: 0, scale: 0.98, transition: { type: 'spring', stiffness: 200, damping: 25 } },
    visible: { y: 0, opacity: 1, scale: 1, transition: { type: 'spring', stiffness: 200, damping: 25 } }
};

const listVariants = {
    visible: { transition: { staggerChildren: 0.03, delayChildren: 0.05 } }
};

const resultItemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 }
};

export default function Search({ isOpen, onClose }: { isOpen: boolean, onClose: () => void }) {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState<SanitySearchResult[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    const debouncedQuery = useDebounce(query, 250);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (isOpen) {
            inputRef.current?.focus();
            const handleKeyDown = (event: KeyboardEvent) => {
                if (event.key === 'Escape') onClose();
            };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
        } else {
            setQuery('');
            setResults([]);
        }
    }, [isOpen, onClose]);

    const performSearch = useCallback(async (searchQuery: string) => {
        if (searchQuery.length < 3) { setResults([]); return; }
        setIsSearching(true);
        try {
            const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) throw new Error('Search failed');
            const data: SanitySearchResult[] = await response.json();
            setResults(data);
        } catch (error) {
            console.error('Search error:', error);
            setResults([]);
        } finally {
            setIsSearching(false);
        }
    }, []);

    useEffect(() => { performSearch(debouncedQuery); }, [debouncedQuery, performSearch]);

    const getLinkPath = (item: SanitySearchResult) => {
        switch (item._type) {
            case 'review': return `/reviews/${item.slug}`;
            case 'article': return `/articles/${item.slug}`;
            case 'news': return `/news/${item.slug}`;
            default: return '/';
        }
    };

    const hasContent = useMemo(() => query.length >= 3 && results.length > 0, [query, results]);
    const isInitialPrompt = query.length < 3;

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    className={styles.searchOverlay} // Updated
                    onClick={onClose}
                    variants={overlayVariants}
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    style={{ zIndex: 2000 }}
                >
                    <motion.div
                        className={styles.searchContainer} // Updated
                        onClick={(e) => e.stopPropagation()}
                        variants={containerVariants}
                        initial="hidden"
                        animate="visible"
                        exit="hidden"
                    >
                        <button className={styles.searchCloseButton} onClick={onClose} aria-label="Close search">
                            <CrossIcon />
                        </button>
                        <input
                            ref={inputRef}
                            type="search"
                            className={styles.searchInput} // Updated
                            placeholder="استنطاق الأرشيف"
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                        />
                        <div className={styles.searchResultsList}>
                            <AnimatePresence mode="wait">
                                {isInitialPrompt && (
                                    <motion.p
                                        key="prompt"
                                        initial={{ opacity: 0 }}
                                        animate={{ opacity: 1 }}
                                        exit={{ opacity: 0 }}
                                        className={styles.searchInitialPrompt} // Updated
                                    >خُطَّ حروفك لاستنطاق السجلات.</motion.p>
                                )}
                                {isSearching && (
                                    <motion.div key="loading" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ display: 'flex', justifyContent: 'center', padding: '4rem' }}>
                                        <div className="spinner" style={{ width: '50px', height: '50px', borderTopColor: 'var(--accent)' }} />
                                    </motion.div>
                                )}
                                {hasContent && (
                                    <motion.ul
                                        key="results"
                                        variants={listVariants}
                                        initial="hidden"
                                        animate="visible"
                                        exit="hidden"
                                    >
                                        {results.map(result => (
                                            <motion.li key={result._id} variants={resultItemVariants}>
                                                <Link href={getLinkPath(result)} onClick={onClose} className={`${styles.searchResultLink} no-underline`}>
                                                    <motion.div className={styles.searchResultThumbnail}>
                                                        {result.imageUrl ? (
                                                            <Image src={result.imageUrl} alt={result.title} width={100} height={60} className={styles.searchResultImage} sizes="100px" />
                                                        ) : (
                                                            <div className={styles.searchResultImageFallback} />
                                                        )}
                                                    </motion.div>
                                                    <div className={styles.searchResultDetails}>
                                                        <h4>{result.title}</h4>
                                                        <p style={{ textTransform: 'capitalize' }}>
                                                            {result._type === 'review' && `Review by ${result.authorName || 'فريق العمل'}`}
                                                            {result._type === 'article' && `Article | اللعبة: ${result.gameTitle || 'غير متوفر'}`}
                                                            {result._type === 'news' && `News | Category: ${result.category || 'تحديث'}`}
                                                        </p>
                                                    </div>
                                                </Link>
                                            </motion.li>
                                        ))}
                                    </motion.ul>
                                )}
                                {!isSearching && query.length >= 3 && results.length === 0 && (
                                    <motion.div key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ color: 'var(--text-secondary)', marginTop: '3rem', textAlign: 'center', fontSize: '2.4rem' }}>
                                        <p>لا أثر في السجلات لـ &quot;{query}&quot;.</p>
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}







--- END OF FILE components/Search.tsx ---

================================================================================

--- START OF FILE components/SessionProvider.tsx ---

'use client';
import { SessionProvider } from 'next-auth/react';
import React from 'react';

type Props = {
children: React.ReactNode;
};

export default function NextAuthProvider({ children }: Props) {
return <SessionProvider>{children}</SessionProvider>;
}





























--- END OF FILE components/SessionProvider.tsx ---

================================================================================

--- START OF FILE components/SignInModal.module.css ---

.authOverlay {
  position: fixed;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
  backdrop-filter: blur(8px) saturate(120%);
  z-index: 5000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
}
.authModalPanelContainer {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 420px;
  min-height: 450px;
}
.authSatelliteContainer {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
}
.authOrbRowTop {
  display: flex;
  justify-content: center;
  gap: 3rem;
  width: 100%;
}
.authFooterText {
  font-family: var(--font-ui);
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-align: center;
}
.authMorphWrapper {
  position: relative;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}
.authCredentialsPanel {
  width: 420px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  box-shadow: 0 25px 50px -12px rgba(0,0,0,0.35);
  padding: 3rem;
  overflow: hidden;
}
.authCredentialsContent {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.authBackButton {
  position: absolute;
  top: 1.5rem;
  right: 1.5rem;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  width: 24px;
  height: 24px;
  z-index: 20;
}
.authBackButton:hover {
  color: var(--text-primary);
}
.formHeader {
  text-align: center;
  margin-bottom: 2rem;
}
.formTitle {
  font-size: 2.8rem;
  margin: 0;
  font-family: var(--font-heading);
}
.credentialsForm {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  width: 100%;
}
.authInput {
  width: 100%;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
  font-size: 1.5rem;
  color: var(--text-primary);
}
.authInput:focus {
  outline: none;
  border-color: var(--accent);
}
.authSubmitButton {
  background-color: var(--accent);
  color: #fff;
  border: none;
  padding: 1.2rem 2.4rem;
  border-radius: 8px;
  font-weight: 700;
  font-size: 1.6rem;
  cursor: pointer;
  margin-top: 0.5rem;
}
[data-theme="dark"] .authSubmitButton {
  color: var(--bg-primary);
}
.authViewSwitcher {
  margin-top: 2rem;
  text-align: center;
  font-size: 1.4rem;
  color: var(--text-secondary);
}
.authViewSwitcher a {
  color: var(--accent);
  font-weight: 600;
  cursor: pointer;
  text-decoration: underline;
}
.authMessage {
  margin-top: 1rem;
  font-size: 1.4rem;
  text-align: center;
}
.authMessage.error {
  color: #DC2626;
}
.authMessage.success {
  color: #16A34A;
}







--- END OF FILE components/SignInModal.module.css ---

================================================================================

--- START OF FILE components/SignInModal.tsx ---

// components/SignInModal.tsx
'use client';

import React, { useState, useEffect, useTransition } from 'react';
import { createPortal } from 'react-dom';
import { signIn } from 'next-auth/react';
import { motion, AnimatePresence } from 'framer-motion';
import dynamic from 'next/dynamic';
import { useUserStore } from '@/lib/store';
import { useRouter, usePathname } from 'next/navigation';
import { AuthOrb } from './AuthOrb';
import { requestPasswordReset } from '@/app/actions/authActions';
import ButtonLoader from './ui/ButtonLoader';
import { useDebounce } from '@/hooks/useDebounce';
import { checkUsernameAvailability } from '@/app/actions/userActions';
import styles from './SignInModal.module.css';

const GitHubIcon = dynamic(() => import('@/components/icons/GitHubIcon'));
const GoogleIcon = dynamic(() => import('@/components/icons/GoogleIcon'));
const XIcon = dynamic(() => import('@/components/icons/XIcon'));
const EternalGamesIcon = dynamic(() => import('@/components/icons/EternalGamesIcon'));

const CredentialsForm = ({ onBack, onAuthSuccess, onForgotPassword, callbackUrl }: { onBack: () => void, onAuthSuccess: () => void, onForgotPassword: () => void, callbackUrl: string }) => {
    const [view, setView] = useState<'signin' | 'signup'>('signin');
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);
    const router = useRouter();

    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    
    const handleSignIn = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        const formData = new FormData(event.currentTarget);
        
        startTransition(async () => {
            const result = await signIn('credentials', {
                redirect: false,
                ...Object.fromEntries(formData),
            });

            if (result?.error) {
                setMessage({ type: 'error', text: result.error });
            } else if (result?.url) {
                router.push(result.url);
                onAuthSuccess();
            } else {
                 setMessage({ type: 'error', text: 'طرأ خطأ غير متوقع.' });
            }
        });
    };
    
    const handleSignUp = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        
        const formData = new FormData(event.currentTarget);

        startTransition(async () => {
            const result = await signIn('signup', {
                redirect: false,
                ...Object.fromEntries(formData),
            });

            if (result?.error) {
                setMessage({ type: 'error', text: result.error });
            } else if (result?.url) {
                router.push(result.url);
                onAuthSuccess();
            } else {
                setMessage({ type: 'error', text: 'An unexpected error occurred during sign up.' });
            }
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} initial={{ opacity: 0 }} animate={{ opacity: 1, transition: { delay: 0.25, duration: 0.3 } }} exit={{ opacity: 0, transition: { duration: 0.15 } }}>
            <motion.button onClick={onBack} className={styles.authBackButton} whileHover={{ x: 2 }} >
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg>
            </motion.button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>{view === 'signup' ? 'إنشاء حساب' : 'Sign In with Email'}</h2></div>
            
            {view === 'signin' ? (
                <form onSubmit={handleSignIn} className={styles.credentialsForm}>
                    <input type="hidden" name="returnTo" value={callbackUrl} />
                    <input type="email" name="email" placeholder="البريد الإلكتروني" required className={styles.authInput} autoFocus value={email} onChange={e => setEmail(e.target.value)} />
                    <input type="password" name="password" placeholder="كلمة السر" required className={styles.authInput} value={password} onChange={e => setPassword(e.target.value)} />
                    {/* --- THE FIX IS HERE --- */}
                    <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                        <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>ولوج</motion.span>}</AnimatePresence>
                    </motion.button>
                </form>
            ) : (
                <form onSubmit={handleSignUp} className={styles.credentialsForm}>
                    <input type="hidden" name="returnTo" value={callbackUrl} />
                    <input type="email" name="email" placeholder="البريد الإلكتروني" required value={email} onChange={e => setEmail(e.target.value)} className={styles.authInput} />
                    <input type="password" name="password" placeholder="كلمة السر (8 أحرف على الأقل)" required value={password} onChange={e => setPassword(e.target.value)} className={styles.authInput} />
                    {/* --- THE FIX IS HERE --- */}
                    <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                        <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>أنشئ حسابًا</motion.span>}</AnimatePresence>
                    </motion.button>
                </form>
            )}

            {message && <p className={`${styles.authMessage} ${message.type === 'error' ? styles.error : styles.success}`}>{message.text}</p>}
            <p className={styles.authViewSwitcher}>
                {view === 'signup' ? (
                    <>لديك حساب بالفعل؟<a onClick={() => {setView('signin'); setMessage(null);}} className="no-underline">ولوج</a></>
                ) : (
                    <>جديدٌ في EternalGames؟<a onClick={() => {setView('signup'); setMessage(null);}} className="no-underline">أنشئ حسابًا</a></>
                )}
            </p>
            {view === 'signin' && <a onClick={onForgotPassword} className="no-underline" style={{textAlign: 'center', fontSize: '1.4rem', color: 'var(--text-secondary)', cursor: 'pointer', display: 'block', marginTop: '1rem'}}>هل نسيت كلمة السر؟</a>}
        </motion.div>
    );
};

const ForgotPasswordForm = ({ onBack }: { onBack: () => void }) => {
    const [email, setEmail] = useState('');
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);
        startTransition(async () => {
            const result = await requestPasswordReset(email);
            setMessage(result);
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} initial={{ opacity: 0 }} animate={{ opacity: 1, transition: { delay: 0.25, duration: 0.3 } }} exit={{ opacity: 0, transition: { duration: 0.15 } }}>
            <motion.button onClick={onBack} className={styles.authBackButton} whileHover={{ x: 2 }}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></motion.button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>إعادة تعيين كلمة السر</h2><p style={{color: 'var(--text-secondary)', fontSize: '1.5rem'}}>أدخل بريدك لتلقي رابط إعادة التعيين.</p></div>
            <form onSubmit={handleSubmit} className={styles.credentialsForm}>
                <input type="email" name="email" placeholder="البريد الإلكتروني" required className={styles.authInput} autoFocus value={email} onChange={(e) => setEmail(e.target.value)} />
                {/* --- THE FIX IS HERE --- */}
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} animate={{ width: isPending ? '48px' : '100%', height: '48px', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إرسال الرابط</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${message.type === 'error' ? styles.error : styles.success}`}>{message.text}</p>}
        </motion.div>
    );
};

export default function SignInModal() {
    const { isSignInModalOpen, setSignInModalOpen } = useUserStore();
    const [view, setView] = useState<'orbs' | 'credentials' | 'forgotPassword'>('orbs');
    const [isMounted, setIsMounted] = useState(false);
    const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
    const pathname = usePathname();

    useEffect(() => { setIsMounted(true); }, []);

    const handleClose = () => {
        if (loadingProvider) return;
        setSignInModalOpen(false);
        setTimeout(() => { setView('orbs'); setLoadingProvider(null); }, 350);
    };

    const handleProviderSignIn = (provider: string) => {
        setLoadingProvider(provider);
        signIn(provider, { callbackUrl: pathname });
    };

    const renderContent = () => {
        switch(view) {
            case 'credentials':
                return <CredentialsForm onBack={() => setView('orbs')} onAuthSuccess={handleClose} onForgotPassword={() => setView('forgotPassword')} callbackUrl={pathname} />;
            case 'forgotPassword':
                return <ForgotPasswordForm onBack={() => setView('credentials')} />;
            case 'orbs':
            default:
                return (
                    <motion.div key="center-orb" style={{ zIndex: loadingProvider ? 0 : 'auto' }}>
                        <AuthOrb Icon={EternalGamesIcon} onClick={() => setView('credentials')} ariaLabel="الولوج بالبريد" isLarge isDisabled={!!loadingProvider} />
                    </motion.div>
                );
        }
    }

    const modalContent = (
        <AnimatePresence>
            {isSignInModalOpen && (
                <motion.div className={styles.authOverlay} onClick={handleClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={styles.authModalPanelContainer} onClick={(e) => e.stopPropagation()} initial="hidden" animate="visible" >
                        <AnimatePresence>
                            {view === 'orbs' && (
                                <div className={styles.authSatelliteContainer}>
                                    <motion.div className={styles.authOrbRowTop}>
                                        <AuthOrb Icon={GitHubIcon} onClick={() => handleProviderSignIn('github')} ariaLabel="الولوج عبر GitHub" isLoading={loadingProvider === 'github'} isDisabled={!!loadingProvider} />
                                        <AuthOrb Icon={GoogleIcon} onClick={() => handleProviderSignIn('google')} ariaLabel="الولوج عبر Google" isLoading={loadingProvider === 'google'} isDisabled={!!loadingProvider} />
                                        <AuthOrb Icon={XIcon} onClick={() => handleProviderSignIn('twitter')} ariaLabel="الولوج عبر X/Twitter" isLoading={loadingProvider === 'twitter'} isDisabled={!!loadingProvider} />
                                    </motion.div>
                                    <motion.p className={styles.authFooterText}>انضم إلى EternalGames عبر مزود خدمة أو تابع بالبريد.</motion.p>
                                </div>
                            )}
                        </AnimatePresence>
                        <motion.div layoutId="auth-panel" className={styles.authMorphWrapper} transition={{ type: 'spring', stiffness: 500, damping: 30, mass: 0.7 }}>
                            <AnimatePresence mode="wait" initial={false}>
                                <div key={view} className={view !== 'orbs' ? styles.authCredentialsPanel : ''}>
                                    {renderContent()}
                                </div>
                            </AnimatePresence>
                        </motion.div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) { return null; }
    return createPortal(modalContent, document.body);
}




--- END OF FILE components/SignInModal.tsx ---

================================================================================

--- START OF FILE components/StudioBar.module.css ---

/* components/StudioBar.module.css */

.studioBar {
  position: fixed;
  bottom: 2rem;
  right: 0;
  left: 0;
  width: max-content;
  margin-right: auto;
  margin-left: auto;
  z-index: 1080;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 20%, transparent);
  backdrop-filter: blur(10px);
  padding: 0.5rem;
}

.studioBarContent {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.studioBarButton {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1.25rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.5rem;
  color: var(--text-primary);
  background-color: transparent;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s ease-out, color 0.2s ease-out;
}

.studioBarButton:hover {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}

.brand {
  color: var(--accent);
}

.brand:hover {
  color: var(--accent); /* Ensure hover doesn't change color from accent */
}







--- END OF FILE components/StudioBar.module.css ---

================================================================================

--- START OF FILE components/StudioBar.tsx ---

// components/StudioBar.tsx
'use client';

import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './StudioBar.module.css'; // <-- IMPORTED

const StudioIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M12 2l-5.5 9h11zM12 21.8l-5.5-9h11z"/> </svg> );
const EditIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /> </svg> );

export default function StudioBar() {
    const { data: session } = useSession();
    const pathname = usePathname();
    
    const userRoles = session?.user?.roles || [];
    const isCreatorOrAdmin = userRoles.some(role => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
    let editPath = null;
    const pathSegments = pathname.split('/').filter(Boolean);
    
    if (['reviews', 'articles', 'news'].includes(pathSegments[0]) && pathSegments.length === 2) {
        // Future feature placeholder
    }

    if (!isCreatorOrAdmin || pathname.startsWith('/studio')) {
        return null;
    }

    return (
        <AnimatePresence>
            <motion.div
                className={styles.studioBar}
                initial={{ y: '100%' }}
                animate={{ y: '0%' }}
                exit={{ y: '100%' }}
                transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            >
                <div className={styles.studioBarContent}>
                    <Link href="/studio" className={`${styles.studioBarButton} ${styles.brand}`}>
                        <StudioIcon />
                        <span>الديوان</span>
                    </Link>

                    {editPath && (
                        <Link href={editPath} className={styles.studioBarButton}>
                            <EditIcon />
                            <span>Edit Page</span>
                        </Link>
                    )}
                </div>
            </motion.div>
        </AnimatePresence>
    );
}







--- END OF FILE components/StudioBar.tsx ---

================================================================================

--- START OF FILE components/TagLinks.module.css ---

/* components/TagLinks.module.css */

.tagLinksContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

.tagLinksContainer.small {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}
  
.tagLink {
    display: inline-block; /* motion.div wrapper handles block display */
    background-color: color-mix(in srgb,var(--accent) 15%,transparent);
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 500;
    transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    cursor: pointer;
}
  
.tagLink:hover {
    background-color: var(--accent);
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px -3px color-mix(in srgb, var(--accent) 40%, transparent), 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}
  
[data-theme="dark"] .tagLink:hover {
    color: var(--bg-primary);
}







--- END OF FILE components/TagLinks.module.css ---

================================================================================

--- START OF FILE components/TagLinks.tsx ---

// components/TagLinks.tsx
'use client';

import { useRouter } from 'next/navigation';
import { translateTag } from '@/lib/translations';
import styles from './TagLinks.module.css';

export default function TagLinks({ tags, small = false }: { tags: string[], small?: boolean }) {
  const router = useRouter();

  if (!tags || tags.length === 0) return null;

  const handleTagClick = (e: React.MouseEvent, tag: string) => {
    e.preventDefault();
    e.stopPropagation(); // Stop the click from bubbling up to the card's main link
    const slug = tag.toLowerCase().replace(/ /g, '-');
    router.push(`/tags/${slug}`);
  };

  return (
    <div className={`${styles.tagLinksContainer} ${small ? styles.small : ''}`}>
      {tags.map((tag) => (
        <span 
          key={tag} 
          className={styles.tagLink}
          onClick={(e) => handleTagClick(e, tag)}
        >
          {translateTag(tag)}
        </span>
      ))}
    </div>
  );
}




--- END OF FILE components/TagLinks.tsx ---

================================================================================

--- START OF FILE components/TerminalTicker.tsx ---

// components/TerminalTicker.tsx
'use client';

import { useState, useEffect } from 'react';
import type { SanityNews } from '@/types/sanity';
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../app/news/NewsPage.module.css'; // <-- IMPORTED

const ScrambledText = ({ text }: { text: string }) => {
  const [displayText, setDisplayText] = useState('');
  const chars = '!<>-_\\/[]{}—=+*^?#________';

  useEffect(() => {
    let frame = 0;
    const frameRate = 2;
    const scrambleDuration = 30;

    const intervalId = setInterval(() => {
      let newText = '';
      let isComplete = true;

      for (let i = 0; i < text.length; i++) {
        const progress = (frame - i * frameRate) / scrambleDuration;
        if (progress < 1 && progress > 0) {
          const randomChar = chars[Math.floor(Math.random() * chars.length)];
          newText += randomChar;
          isComplete = false;
        } else {
          newText += text[i];
        }
      }

      setDisplayText(newText);
      frame++;

      if (isComplete) {
        clearInterval(intervalId);
      }
    }, 40);

    return () => clearInterval(intervalId);
  }, [text]);

  return <>{displayText}</>;
};

export default function TerminalTicker({ headlines }: { headlines: SanityNews[] }) {
  const [index, setIndex] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setIndex((prevIndex) => (prevIndex + 1) % headlines.length);
    }, 6000);
    return () => clearInterval(timer);
  }, [headlines.length]);

  return (
    <div className={styles.terminalTickerContainer}>
      <h3 className={styles.terminalTickerTitle}>
        <motion.span
          animate={{ opacity: [0.5, 1, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity }}
          style={{ display: 'inline-block', width: '8px', height: '8px', borderRadius: '50%', backgroundColor: '#ff4d4d', marginRight: '1rem' }}
        />
        LIVE FEED
      </h3>
      <div className={styles.terminalTickerContent}>
        <AnimatePresence mode="wait">
          <motion.div
            key={index}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Link href={`/news/${headlines[index].slug}`} className="no-underline">
              <p className={styles.terminalTickerCategory}>{headlines[index].category}</p>
              <h4 className={styles.terminalTickerHeadline}>
                <ScrambledText text={headlines[index].title} />
              </h4>
            </Link>
          </motion.div>
        </AnimatePresence>
      </div>
    </div>
  );
}







--- END OF FILE components/TerminalTicker.tsx ---

================================================================================

--- START OF FILE components/ThemeProvider.tsx ---

'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
// CORRECTED: The 'ThemeProviderProps' type is now imported directly from the main package.
// The old '/dist/types' path no longer exists in the newer version of the library.
import { type ThemeProviderProps } from 'next-themes';

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}





























--- END OF FILE components/ThemeProvider.tsx ---

================================================================================

--- START OF FILE components/ThemeToggle.module.css ---

/* components/ThemeToggle.module.css */

.themeToggleButton {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    transition: color 0.3s ease;
}
  
.themeToggleButton:hover {
    color: var(--accent);
}







--- END OF FILE components/ThemeToggle.module.css ---

================================================================================

--- START OF FILE components/ThemeToggle.tsx ---

// components/ThemeToggle.tsx
'use client';

import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './ThemeToggle.module.css'; // <-- IMPORTED MODULE

const SunIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
const MoonIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;

export const ThemeToggle = () => {
    const [mounted, setMounted] = useState(false);
    const { theme, setTheme } = useTheme();
    useEffect(() => { setMounted(true); }, []);

    if (!mounted) { return <div style={{ width: '24px', height: '24px' }} />; }

    const isDark = theme === 'dark';

    return (
        <motion.button
            className={styles.themeToggleButton} // <-- UPDATED CLASS
            onClick={() => setTheme(isDark ? 'light' : 'dark')}
            aria-label={isDark ? 'Activate light mode' : 'Activate dark mode'}
            title={isDark ? 'Activate light mode' : 'Activate dark mode'}
            whileHover={{ scale: 1.2, rotate: 90 }}
            whileTap={{ scale: 0.9, rotate: -90 }}
            transition={{ type: "spring", stiffness: 400, damping: 15 }}
        >
            <AnimatePresence mode="wait" initial={false}>
                <motion.div
                    key={isDark ? "moon" : "sun"}
                    initial={{ y: -20, opacity: 0, rotate: -90 }}
                    animate={{ y: 0, opacity: 1, rotate: 0 }}
                    exit={{ y: 20, opacity: 0, rotate: 90 }}
                    transition={{ duration: 0.3, ease: 'easeInOut' }}
                >
                    {isDark ? <SunIcon /> : <MoonIcon />}
                </motion.div>
            </AnimatePresence>
        </motion.button>
    );
};







--- END OF FILE components/ThemeToggle.tsx ---

================================================================================

--- START OF FILE components/TimelineCard.module.css ---

/* components/TimelineCard.module.css */
.livingCardWrapper {
    transform-style: preserve-3d;
    height: 100%;
}

.timelineCard {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    will-change: transform;
    transform-style: preserve-3d;
}

.imageContainer {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    overflow: hidden;
    flex-shrink: 0;
}

.image {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.4s ease-out;
}

.livingCardWrapper:hover .image {
    transform: scale(1.05);
}

.synopsisOverlay {
    position: absolute;
    inset: 0;
    padding: 1.5rem;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 40%, transparent 100%);
    color: #fff;
    display: flex;
    align-items: flex-end;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
    font-size: 1.4rem;
    line-height: 1.5;
}

.livingCardWrapper:hover .synopsisOverlay {
    opacity: 1;
}

@keyframes pulse-glow {
    0%, 100% {
        box-shadow: 0 0 10px 0px color-mix(in srgb, var(--accent) 50%, transparent);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 16px 2px color-mix(in srgb, var(--accent) 70%, transparent);
        transform: scale(1.03);
    }
}

/* --- THE SIZE FIX IS HERE --- */
.releasedBadge {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    background-color: color-mix(in srgb, var(--accent) 95%, black 20%);
    backdrop-filter: blur(5px);
    color: #fff;
    padding: 0.4rem 1rem; /* Reduced padding */
    border-radius: 999px;
    font-family: var(--font-ui);
    font-size: 1.2rem; /* Reduced font size */
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 0.5rem; /* Reduced gap */
    border: 1px solid color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 2;
    animation: pulse-glow 3s infinite ease-in-out;
}

.checkIcon {
    width: 14px; /* Reduced icon size */
    height: 14px; /* Reduced icon size */
    filter: drop-shadow(0 0 5px #fff);
}
/* --- END OF FIX --- */

.cardContent {
    padding: 1.5rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    background-color: var(--bg-secondary);
}

.cardHeader h4 {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    line-height: 1.3;
    color: var(--text-primary);
    margin: 0 0 0.4rem 0;
}

.cardHeader p {
    font-family: var(--font-ui);
    font-size: 1.4rem;
    color: var(--text-secondary);
    margin: 0;
}

.platformIcons {
    display: flex;
    gap: 1.2rem;
    align-items: center;
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.platformIcon {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
}







--- END OF FILE components/TimelineCard.module.css ---

================================================================================

--- START OF FILE components/TimelineCard.tsx ---

// components/TimelineCard.tsx
'use client';

import Link from 'next/link';
import Image from 'next/image';
import type { SanityGameRelease } from '@/types/sanity';
import { motion } from 'framer-motion';
import { memo } from 'react';
import { useLivingCard } from '@/hooks/useLivingCard';
import styles from './TimelineCard.module.css';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    'PC': PCIcon,
    'PS5': PS5Icon,
    'Xbox': XboxIcon,
    'Switch': SwitchIcon,
};

const CheckIcon = (props: React.SVGProps<SVGSVGElement>) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props}><path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.052-.143z" clipRule="evenodd" /></svg> );

const TimelineCardComponent = ({ release }: { release: SanityGameRelease }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const date = new Date(release.releaseDate);
    const day = date.getUTCDate();
    const monthIndex = date.getUTCMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;

    // --- THE DEFINITIVE FIX: ---
    const baseUrl = release.mainImage.url.split('?')[0];
    const imageUrl = `${baseUrl}?w=600&auto=format&q=80`;

    return (
        <motion.div 
            ref={livingCardRef} 
            onMouseMove={livingCardAnimation.onMouseMove} 
            onMouseEnter={livingCardAnimation.onHoverStart} 
            onMouseLeave={livingCardAnimation.onHoverEnd}
            className={styles.livingCardWrapper} 
            style={livingCardAnimation.style}
        >
            <Link href={`/games/${release.slug}`} className={`${styles.timelineCard} no-underline`} style={{transformStyle: 'preserve-3d'}}>
                <div className={styles.imageContainer} style={{ transform: 'translateZ(20px)' }}>
                    <Image
                        src={imageUrl}
                        alt={release.title}
                        fill
                        sizes="30vw"
                        className={styles.image}
                        placeholder="blur"
                        blurDataURL={release.mainImage.blurDataURL}
                        unoptimized
                    />
                    {new Date(release.releaseDate) < new Date() && <div className={styles.releasedBadge}><CheckIcon className={styles.checkIcon} /> صدرت</div>}
                    <div className={styles.synopsisOverlay}><p>{release.synopsis}</p></div>
                </div>
                <div className={styles.cardContent} style={{ transform: 'translateZ(40px)' }}>
                    <div className={styles.cardHeader}>
                        <h4>{release.title}</h4>
                        <p>{formattedDate}</p>
                    </div>
                    <div className={styles.platformIcons}>
                        {(release.platforms || []).map(p => { const Icon = PlatformIcons[p]; return Icon ? <Icon key={p} className={styles.platformIcon} title={p} /> : null; })}
                    </div>
                </div>
            </Link>
        </motion.div>
    );
}

export default memo(TimelineCardComponent);

--- END OF FILE components/TimelineCard.tsx ---

================================================================================

--- START OF FILE components/ToastProvider.tsx ---

// components/ToastProvider.tsx

'use client';

import { useState, useEffect, useMemo } from 'react';
import { AnimatePresence } from 'framer-motion';
import { createPortal } from 'react-dom';
import useToastStore from '@/lib/toastStore';
import { Toast } from './ui/Toast';

const ToastContainer = ({ toasts, dismissToast, position }: { toasts: any[], dismissToast: (id: string) => void, position: 'left' | 'right' }) => (
<div
className="toast-container-global"
style={{
position: 'fixed',
bottom: '2rem',
[position]: '2rem',
zIndex: 9999,
display: 'flex',
flexDirection: 'column',
gap: '1rem',
[position === 'right' ? 'left' : 'right']: 'auto',
}}
>
<AnimatePresence>
{toasts.map((toast) => (
<Toast
key={toast.id}
id={toast.id}
message={toast.message}
type={toast.type}
onDismiss={dismissToast}
/>
))}
</AnimatePresence>
</div>
);

export default function ToastProvider() {
const { toasts, dismissToast } = useToastStore();
const [isMounted, setIsMounted] = useState(false); // Must be top-level hook

//  DEFINITIVE FIX FOR HOOKS ORDER
// Hooks must be executed unconditionally at the top level.
const { leftToasts, rightToasts } = useMemo(() => {
return {
leftToasts: toasts.filter(t => t.position === 'left'),
rightToasts: toasts.filter(t => t.position === 'right'),
};
}, [toasts]); // Unconditional hook execution

// Effect to set mount status runs only on client
useEffect(() => {
setIsMounted(true);
}, []);

//  Conditionally return null only if mounting fails or on server
if (!isMounted) {
// We return null here. The internal useToastStore hooks (and useMemo above)
// are still executed, preserving the hooks order between renders.
return null;
}

// After mounting, create the portal into document.body.
return createPortal(
<>
<ToastContainer toasts={rightToasts} dismissToast={dismissToast} position="right" />
<ToastContainer toasts={leftToasts} dismissToast={dismissToast} position="left" />
</>,
document.body
);
}





























--- END OF FILE components/ToastProvider.tsx ---

================================================================================

--- START OF FILE components/TriptychHero.module.css ---

/* components/TriptychHero.module.css */

.stickyHeroWrapper {
  top: 0;
  height: 100vh;
  width: 100%;
}

.triptychHeroContainer {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem;
  height: 100%;
  width: 100%;
  padding: 2rem;
  padding-top: var(--nav-height);
  perspective: 1500px;
  background-color: var(--bg-primary);
}

.triptychPanel {
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  height: 70vh;
  box-shadow: 0 25px 50px -12px rgba(0,0,0,0.4);
  will-change: transform;
  transform-style: preserve-3d;
  border: 1px solid var(--border-color);
}

/* MODIFIER CLASSES */
.center {
  width: 45%;
  height: 80vh;
  z-index: 2;
}

.left,
.right {
  width: 22%;
  z-index: 1;
  transform: scale(0.95);
}

.triptychPanelLink {
  display: block;
  width: 100%;
  height: 100%;
  color: #fff;
}

.triptychPanelBgContainer {
  position: absolute;
  inset: 0;
}

.triptychPanelBg {
  /* THE FIX: Added filter to the transition property */
  transition: transform 0.4s cubic-bezier(0.22,1,0.36,1), filter 0.4s ease-out;
  filter: saturate(100%) contrast(100%); /* Base state for smooth transition */
}

.triptychPanelLink:hover .triptychPanelBg {
  transform: scale(1.05);
  /* THE FIX: Apply saturation and contrast filters on hover */
  filter: saturate(120%) contrast(110%);
}

.triptychPanelOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top,rgba(0,0,0,0.85) 0%,rgba(0,0,0,0.1) 50%,rgba(0,0,0,0.6) 100%);
  transition: background-color 0.3s ease;
}

/* THE FIX: Removed the overlay color change on hover */
.triptychPanelContent {
  position: absolute;
  bottom: 0;
  right: 0;
  padding: 2rem;
  width: 100%;
  transform: translateZ(30px);
}

.triptychPanelCategory {
  font-family: var(--font-ui);
  font-size: 1.4rem;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--accent);
}

.triptychPanelContent h3 {
  font-size: 2.4rem;
  line-height: 1.3;
}

.center .triptychPanelContent h3 {
  font-size: 3.2rem;
}

.scrollPrompt {
  position: absolute;
  bottom: 4rem;
  right: 50%;
  transform: translateX(50%);
  color: #fff;
  font-family: var(--font-ui);
  font-size: 1.4rem;
  text-align: center;
  opacity: 0.7;
  z-index: 5;
}

.scrollPromptLine {
  width: 1px;
  height: 40px;
  background: #fff;
  margin: 0.5rem auto 0;
  animation: scroll-down 2s infinite;
}

@keyframes scroll-down {
  0%{transform:scaleY(0);transform-origin:top;}
  50%{transform:scaleY(1);transform-origin:top;}
  51%{transform:scaleY(1);transform-origin:bottom;}
  100%{transform:scaleY(0);transform-origin:bottom;}
}

--- END OF FILE components/TriptychHero.module.css ---

================================================================================

--- START OF FILE components/TriptychHero.tsx ---

// components/TriptychHero.tsx
'use client';
import { useRef } from 'react';
import { motion, useMotionValue, useSpring, useTransform, MotionStyle } from 'framer-motion';
import Link from 'next/link';
import Image from 'next/image';
import styles from './TriptychHero.module.css';

const springConfig = { damping: 20, stiffness: 150, mass: 0.5 };

const TriptychPanel = ({ item, isCenter, defaultCategory }: { item: any, isCenter?: boolean, defaultCategory: string }) => {
    if (!item?.mainImage?.url) {
        return (
            <div className={styles.triptychPanelBgContainer} style={{backgroundColor: 'var(--border-color)'}}>
                <div className={styles.triptychPanelOverlay} />
            </div>
        );
    }

    const getLink = () => {
        switch(item._type) {
            case 'review': return `/reviews/${item.slug}`;
            case 'news': return `/news/${item.slug}`;
            case 'article': return `/articles/${item.slug}`;
            default: return '/';
        }
    };

    const baseUrl = item.mainImage.url.split('?')[0];
    const imageUrl = `${baseUrl}?w=1200&auto=format&q=80`;

    return (
        <Link href={getLink()} className={`${styles.triptychPanelLink} no-underline`}>
            <div className={styles.triptychPanelBgContainer}>
                <Image
                    src={imageUrl}
                    alt={item.title}
                    fill
                    sizes="50vw"
                    style={{ objectFit: 'cover' }}
                    className={styles.triptychPanelBg}
                    priority
                    placeholder="blur"
                    blurDataURL={item.mainImage.blurDataURL}
                    unoptimized
                />
            </div>
            <div className={styles.triptychPanelOverlay} />
            <div className={styles.triptychPanelContent}>
                <p className={styles.triptychPanelCategory}>{defaultCategory}</p>
                <h3>{item.title}</h3>
            </div>
        </Link>
    );
};

interface TriptychHeroProps {
    heroContent: any;
    panelStyles: {
        left: MotionStyle;
        center: MotionStyle;
        right: MotionStyle;
    };
}

export default function TriptychHero({ heroContent, panelStyles }: TriptychHeroProps) {
    const ref = useRef<HTMLDivElement>(null);
    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);
    const { featuredReview, latestNews, featuredArticle } = heroContent || {};

    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);
    
    // --- THE DEFINITIVE TILT SETTINGS ---
    const rotateX = useTransform(smoothMouseY, [0, 1], [12, -12]);
    const centerRotateX = useTransform(smoothMouseY, [0, 1], [8, -8]);
    const rotateY = useTransform(smoothMouseX, [0, 1], [-12, 12]);
    const centerRotateY = useTransform(smoothMouseX, [0, 1], [-8, 8]);

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        if (!ref.current) return;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };
    const handleMouseLeave = () => { mouseX.set(0.5); mouseY.set(0.5); };

    return (
        <div ref={ref} onMouseMove={handleMouseMove} onMouseLeave={handleMouseLeave} className={styles.triptychHeroContainer}>
            <motion.div className={`${styles.triptychPanel} ${styles.left}`} style={{ ...panelStyles.left, rotateX, rotateY }}>
                <TriptychPanel item={latestNews} defaultCategory="آخر الأخبار" />
            </motion.div>
            <motion.div className={`${styles.triptychPanel} ${styles.center}`} style={{ ...panelStyles.center, rotateX: centerRotateX, rotateY: centerRotateY }}>
                <TriptychPanel item={featuredReview} isCenter defaultCategory="مراجعة مميزة" />
            </motion.div>
            <motion.div className={`${styles.triptychPanel} ${styles.right}`} style={{ ...panelStyles.right, rotateX, rotateY }}>
                <TriptychPanel item={featuredArticle} defaultCategory="من المقالات" />
            </motion.div>
            <div className={styles.scrollPrompt}>
                <span>مرر لاستكشاف الديوان</span>
                <div className={styles.scrollPromptLine}></div>
            </div>
        </div>
    );
}

--- END OF FILE components/TriptychHero.tsx ---

================================================================================

--- START OF FILE components/UserProfile.module.css ---

/* components/UserProfile.module.css */

.userProfileContainer {
  position: relative;
}

.userAvatarButton {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  border-radius: 50%;
}

.userAvatar {
  border-radius: 50%;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}

.userAvatarButton:hover .userAvatar {
  border-color: var(--accent);
}

.userAvatarFallback {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-main);
  font-weight: 700;
  font-size: 1.6rem;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}

.userAvatarButton:hover .userAvatarFallback {
  border-color: var(--accent);
}

.userAvatarSkeleton {
  width: 99px; /* Matches Sign In button */
  height: 39px; /* Matches Sign In button */
  background-color: var(--border-color);
  border-radius: 5px;
  animation: pulse 1.5s infinite ease-in-out;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.userDropdown {
  position: absolute;
  top: calc(100% + 15px);
  left: 0; /* RTL */
  right: auto;
  width: 240px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 15%, transparent);
  z-index: 1100;
  overflow: hidden;
  padding: 0.5rem 0;
  transform-origin: top left; /* RTL */
}

.dropdownUserInfo {
  padding: 0.75rem 1.25rem;
  text-align: right; /* RTL */
}

.dropdownUserName {
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dropdownUserEmail {
  font-family: var(--font-main);
  font-size: 1.4rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.userDropdownDivider {
  height: 1px;
  background-color: var(--border-color);
  margin: 0.5rem 0;
}

.userDropdownItem {
  display: block;
  width: 100%;
  text-align: right; /* RTL */
  padding: 0.75rem 1.25rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: background-color 0.2s ease, color 0.2s ease;
  background: none;
  border: none;
  cursor: pointer;
}

.userDropdownItem:hover {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}

.userDropdownItem.signout {
  color: #DC2626;
}

.userDropdownItem.signout:hover {
  background-color: color-mix(in srgb, #DC2626 15%, transparent);
  color: #DC2626;
}

.signInButton {
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 1rem 2.4rem;
  border-radius: 5px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s ease, transform 0.2s ease;
}

[data-theme="dark"] .signInButton {
  color: var(--bg-primary);
}

.signInButton:hover {
  opacity: 0.85;
}




--- END OF FILE components/UserProfile.module.css ---

================================================================================

--- START OF FILE components/UserProfile.tsx ---

// components/UserProfile.tsx
'use client';

import { useSession, signOut } from 'next-auth/react';
import Image from 'next/image';
import Link from 'next/link';
import { useState, useEffect, useRef, lazy, Suspense } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import styles from './UserProfile.module.css';

const SignInModal = lazy(() => import('./SignInModal'));

const UserProfile = () => {
    const { data: session, status } = useSession();
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const dropdownRef = useRef<HTMLDivElement>(null);
    const { setSignInModalOpen } = useUserStore();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsDropdownOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    if (status === 'loading') {
        return <div className={styles.userAvatarSkeleton} />;
    }

    if (session && session.user) {
        const userInitial = session.user.name ? session.user.name.charAt(0).toUpperCase() : '?';

        return (
            <div className={styles.userProfileContainer} ref={dropdownRef}>
                <motion.button
                    className={styles.userAvatarButton}
                    onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                    aria-label="فتح قائمة المستخدم"
                    animate={{ scale: isDropdownOpen ? 1.1 : 1, rotate: isDropdownOpen ? -15 : 0 }}
                    transition={{ type: 'spring', stiffness: 400, damping: 15 }}
                >
                    {session.user.image ? (
                        <Image
                            src={session.user.image}
                            alt={session.user.name || 'User Avatar'}
                            width={36}
                            height={36}
                            className={styles.userAvatar}
                            unoptimized // THE FIX
                        />
                    ) : (
                        <div className={styles.userAvatarFallback}><span>{userInitial}</span></div>
                    )}
                </motion.button>

                <AnimatePresence>
                    {isDropdownOpen && (
                        <motion.div
                            className={styles.userDropdown}
                            initial={{ opacity: 0, scale: 0.95, y: -10 }}
                            animate={{ opacity: 1, scale: 1, y: 0 }}
                            exit={{ opacity: 0, scale: 0.95, y: -10 }}
                            transition={{ duration: 0.2, ease: 'easeOut' }}
                        >
                            <div className={styles.dropdownUserInfo}>
                                <p className={styles.dropdownUserName}>{session.user.name}</p>
                                <p className={styles.dropdownUserEmail}>{session.user.email}</p>
                            </div>
                            <div className={styles.userDropdownDivider} />
                            
                            {session.user.username && (
                                <Link href={`/profile/${session.user.username}`} className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>ملفك الشخصي</Link>
                            )}

                            <Link href="/profile" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>الإعدادات</Link>
                            <Link href="/profile/bookmarks" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)}>المحفوظات</Link>
                            
                            <div className={styles.userDropdownDivider} />
                            <button onClick={() => signOut()} className={`${styles.userDropdownItem} ${styles.signout}`}>خروج</button>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        );
    }

    return (
        <>
            <motion.button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton}
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 700, damping: 30 }}
            >ولوج</motion.button>
            <Suspense fallback={null}>
                <SignInModal />
            </Suspense>
        </>
    );
};

export default UserProfile;

--- END OF FILE components/UserProfile.tsx ---

================================================================================

--- START OF FILE components/UserStoreHydration.tsx ---

// components/UserStoreHydration.tsx
'use client';

import { useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import { getUserState } from '@/app/actions/userActions';
import { useRouter, usePathname } from 'next/navigation'; // <-- Import useRouter and usePathname

function UserStoreHydration() {
    const { data: session, status } = useSession();
    const router = useRouter();
    const pathname = usePathname();
    const { syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb } = useUserStore();

    useEffect(() => {
        // THE DEFINITIVE FIX (Part 2):
        // This component, which runs on every page, now checks for the onboarding flag.
        // If the flag is present and the user isn't already on the welcome page,
        // it performs a client-side redirect, preserving the session.
        if (status === 'authenticated' && (session as any)?.needsOnboarding && pathname !== '/welcome') {
            const callbackUrl = pathname !== '/' ? `?callbackUrl=${encodeURIComponent(pathname)}` : '';
            router.push(`/welcome${callbackUrl}`);
            return; // Stop further execution in this effect
        }

        if (status === 'loading') {
            if (_hasHydrated) {
                reset();
            }
            return;
        }

        if (status === 'authenticated') {
            if (!isSyncedWithDb) {
                getUserState().then(result => {
                    if (result.success && result.data) {
                        syncWithDb(result.data);
                        setIsSyncedWithDb(true);
                    }
                });
            }
        } 
        else if (status === 'unauthenticated') {
            reset();
        }

    }, [status, session, pathname, router, syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb]);

    return null;
}

export default UserStoreHydration;




--- END OF FILE components/UserStoreHydration.tsx ---

================================================================================

--- START OF FILE components/comments/CommentForm.tsx ---

// components/comments/CommentForm.tsx
'use client';
import { useState, useTransition, FormEvent } from 'react';
import { Session } from 'next-auth';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from './Comments.module.css';

export default function CommentForm({
    slug,
    session,
    parentId,
    onPostComment,
    onReplySuccess,
}: {
    slug: string;
    session: Session | null;
    parentId?: string;
    onPostComment: (content: string, parentId?: string) => Promise<void>;
    onReplySuccess?: () => void;
}) {
    const [commentText, setCommentText] = useState('');
    const [isPending, startTransition] = useTransition();
    const isButtonDisabled = isPending || commentText.trim().length === 0;

    const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const content = commentText;
        if (content.trim().length === 0) return;

        startTransition(async () => {
            await onPostComment(content, parentId);
            setCommentText('');
            if (parentId && onReplySuccess) {
                onReplySuccess();
            }
        });
    };

    return (
        <div className={styles.commentFormWrapper}>
            <div className={styles.commentFormAvatar}>
                <Image src={session!.user.image || '/default-avatar.svg'} alt={session!.user.name || 'User Avatar'} width={40} height={40} className="user-avatar" />
            </div>
            <div className={styles.commentFormMain}>
                <form onSubmit={handleSubmit}>
                    <textarea
                        name="comment"
                        placeholder="أدلِ برأيك..."
                        required
                        className="profile-input" // This global class is okay here
                        disabled={isPending}
                        value={commentText}
                        onChange={(e) => setCommentText(e.target.value)}
                    />
                    <div className={styles.commentEditActions}>
                        <motion.button type="submit" className={`${isButtonDisabled ? 'outline-button' : 'primary-button'}`} disabled={isButtonDisabled} animate={{ width: isPending ? '44px' : 'auto', height: '44px', borderRadius: isPending ? '50%' : '5px' }}>
                            <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{parentId ? 'أضف ردًا' : 'انشر التعليق'}</motion.span>}</AnimatePresence>
                        </motion.button>
                        {parentId && (<button type="button" onClick={onReplySuccess} className="outline-button">إلغاء</button>)}
                    </div>
                </form>
            </div>
        </div>
    );
}







--- END OF FILE components/comments/CommentForm.tsx ---

================================================================================

--- START OF FILE components/comments/CommentItem.tsx ---

// components/comments/CommentItem.tsx
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import { Session } from 'next-auth';
import { useState, useTransition, useMemo } from 'react';
import { deleteComment, updateComment, getReplies } from '@/app/actions/commentActions';
import ConfirmationModal from '../ConfirmationModal';
import CommentVoteButtons from './CommentVoteButtons';
import CommentForm from './CommentForm';
import Link from 'next/link';
import Image from 'next/image';
import TimeStamp from './TimeStamp';
import styles from './Comments.module.css';

const ReplyIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path> </svg> );
const animationVariants = { initial: { opacity: 0, y: -10 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 10 } };

export default function CommentItem({ comment, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comment: any;
    session: Session | null;
    slug: string;
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
    onPostReply: (content: string, parentId?: string) => Promise<void>;
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    const [isPending, startTransition] = useTransition();
    const [isEditing, setIsEditing] = useState(false);
    const [editText, setEditText] = useState(comment.content);
    const [showDeleteModal, setShowDeleteModal] = useState(false);
    const [isReplying, setIsReplying] = useState(false);
    const [replies, setReplies] = useState<any[]>(comment.replies || []);
    const [areRepliesVisible, setAreRepliesVisible] = useState(true);
    const [isLoadingReplies, setIsLoadingReplies] = useState(false);
    const replyCount = comment._count?.replies || 0;
    const isAuthor = useMemo(() => session?.user?.id === comment.author.id, [session, comment.author.id]);

    const handleToggleReplies = async () => { if (areRepliesVisible) { setAreRepliesVisible(false); return; } setIsLoadingReplies(true); setAreRepliesVisible(true); if (replies.length < replyCount) { const result = await getReplies(comment.id); if (result.success) { setReplies(result.replies as any[]); } } setIsLoadingReplies(false); };
    
    const handleDeleteConfirm = () => {
        startTransition(async () => {
            const result = await deleteComment(comment.id);
            if (result.success) {
                onDeleteSuccess(result.deletedId || comment.id, result.wasDeleted, result.updatedComment);
            }
            setShowDeleteModal(false);
        });
    };

    const handleUpdate = () => {
        startTransition(async () => {
            const result = await updateComment(comment.id, editText);
            if(result.success && result.updatedComment) {
                onUpdateSuccess(result.updatedComment);
            }
            setIsEditing(false);
        });
    };
    
    const DeletedState = () => ( <div className={`${styles.commentItem} ${styles.deleted}`}> <div className={styles.commentAuthorInfo}> <div className={styles.deletedAvatar} /> <div> <p className={`${styles.commentAuthorLink} ${styles.deleted}`}>حُذِفَ التعليق</p> <TimeStamp date={comment.createdAt} /> </div> </div> </div> );

    if (comment.isDeleted) { return ( <> <DeletedState /> {replyCount > 0 && ( <div className={styles.commentRepliesList}> {(replies || []).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </> ); }

    return ( <> <motion.div className={styles.commentItem} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}> <div className={styles.commentHeader}> <div className={styles.commentAuthorInfo}>
        <Link href={`/profile/${comment.author.username}`}><Image src={comment.author.image || '/default-avatar.svg'} alt={comment.author.name || 'User Avatar'} width={40} height={40} className="user-avatar" /></Link>
        <div className={styles.authorAndTimestamp}>
            <Link 
                href={`/profile/${comment.author.username}`} 
                className={`${styles.commentAuthorLink} no-underline ${comment.isOptimistic ? styles.pulsingText : ''}`}
            >
                {comment.author.name}
            </Link>
            {!comment.isOptimistic && <TimeStamp date={comment.createdAt} />}
        </div>
    </div> 
    {session?.user && !comment.isOptimistic && ( <button onClick={() => setIsReplying(!isReplying)} className={styles.commentReplyButton} disabled={isPending}> <ReplyIcon /> </button> )} 
    </div> <AnimatePresence mode="wait"> {!isEditing ? ( <motion.div key="display" variants={animationVariants} initial="initial" animate="animate" exit="exit"> 
    <div className={styles.commentBody}>
        <p className={comment.isOptimistic ? styles.pulsingText : ''}>{comment.content}</p>
    </div> 
    <div className={styles.commentFooter}> 
    {!comment.isOptimistic && (
        <>
            <CommentVoteButtons commentId={comment.id} initialVotes={comment.votes} onVoteUpdate={onVoteUpdate} /> 
            {replyCount > 0 && (<button onClick={handleToggleReplies} className={`${styles.commentActionButton} ${styles.viewRepliesButton}`} disabled={isLoadingReplies}>{isLoadingReplies ? 'جار التحميل...' : areRepliesVisible ? 'إخفاء الردود' : `View ${replyCount} ${replyCount > 1 ? 'ردود' : 'رد'}`}</button>)} 
            {isAuthor && ( <div className={styles.commentAuthorActions}> <button onClick={() => setIsEditing(true)} className={styles.commentActionButton} disabled={isPending}>تحرير</button> <button onClick={() => setShowDeleteModal(true)} className={styles.commentActionButton} disabled={isPending}>حذف</button> </div> )}
        </>
    )}
    </div> </motion.div> ) : ( <motion.div key="edit" variants={animationVariants} initial="initial" animate="animate" exit="exit" className={styles.commentEditForm}> <textarea defaultValue={comment.content} onChange={(e) => setEditText(e.target.value)} className="profile-input" disabled={isPending} autoFocus /> <div className={styles.commentEditActions}> <button onClick={handleUpdate} className="primary-button" disabled={isPending || editText.trim() === ''}>حفظ</button> <button onClick={() => setIsEditing(false)} className="outline-button" disabled={isPending}>إلغاء</button> </div> </motion.div> )} </AnimatePresence> <AnimatePresence> {isReplying && ( <motion.div className={styles.commentReplyFormContainer} variants={animationVariants} initial="initial" animate="animate" exit="exit"> <CommentForm slug={slug} session={session} parentId={comment.id} onPostComment={onPostReply} onReplySuccess={() => setIsReplying(false)} /> </motion.div> )} </AnimatePresence> {areRepliesVisible && ( <div className={styles.commentRepliesList}> {isLoadingReplies && <div className="spinner" />} {!isLoadingReplies && (replies).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </motion.div> <ConfirmationModal isOpen={showDeleteModal} onClose={() => setShowDeleteModal(false)} onConfirm={handleDeleteConfirm} title="حذف التعليق" message="هل أنت متيقن؟" /> </> );
}




--- END OF FILE components/comments/CommentItem.tsx ---

================================================================================

--- START OF FILE components/comments/CommentList.tsx ---

// components/comments/CommentList.tsx
'use client';
import CommentItem from './CommentItem';
import type { Session } from 'next-auth';
import styles from './Comments.module.css';

export default function CommentList({ comments, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comments: any[],
    session: Session | null,
    slug: string,
    onVoteUpdate: (commentId: string, newVotes: any[]) => void,
    onPostReply: (content: string, parentId?: string) => Promise<void>,
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    if (comments.length === 0) {
        return <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginTop: '4rem' }}>كن أول من يخط حرفًا هنا.</p>
    }
    return (
        <div className={styles.commentList}>
            {comments.map(comment => (
                <CommentItem
                    key={comment.id}
                    comment={comment}
                    session={session}
                    slug={slug}
                    onVoteUpdate={onVoteUpdate}
                    onPostReply={onPostReply}
                    onDeleteSuccess={onDeleteSuccess} // Pass down callback
                    onUpdateSuccess={onUpdateSuccess} // Pass down callback
                />
            ))}
        </div>
    )
}




--- END OF FILE components/comments/CommentList.tsx ---

================================================================================

--- START OF FILE components/comments/CommentSection.tsx ---

// components/comments/CommentSection.tsx
'use client';

import { useState, useOptimistic } from 'react';
import type { Session } from 'next-auth';
import { postReplyOrComment } from '@/app/actions/commentActions';
import CommentForm from './CommentForm';
import SignInPrompt from './SignInPrompt';
import CommentList from './CommentList';
import styles from './Comments.module.css';

const addReplyToState = (comments: any[], parentId: string, reply: any): any[] => {
    return comments.map(comment => {
        if (comment.id === parentId) {
            const updatedReplies = comment.replies ? [...comment.replies, reply] : [reply]; // Append to end
            return { ...comment, replies: updatedReplies, _count: { replies: (comment._count?.replies || 0) + 1 } };
        }
        if (comment.replies && comment.replies.length > 0) {
            return { ...comment, replies: addReplyToState(comment.replies, parentId, reply) };
        }
        return comment;
    });
};

export default function CommentSection({ slug, initialComments, session }: {
    slug: string;
    initialComments: any[];
    session: Session | null;
}) {
    const [comments, setComments] = useState(initialComments);

    const [optimisticComments, addOptimisticComment] = useOptimistic(
        comments,
        (state, { newComment, parentId }) => {
            if (parentId) {
                return addReplyToState(state, parentId, newComment);
            }
            return [newComment, ...state];
        }
    );

    const handlePostComment = async (content: string, parentId?: string) => {
        if (!session?.user) return;

        const optimisticComment = {
            id: crypto.randomUUID(),
            content,
            parentId,
            createdAt: new Date().toISOString(),
            author: session.user,
            authorId: session.user.id,
            votes: [],
            replies: [],
            _count: { replies: 0 },
            isOptimistic: true,
        };

        addOptimisticComment({ newComment: optimisticComment, parentId });

        const result = await postReplyOrComment(slug, content, parentId);

        if (result.success && result.comment) {
            setComments(currentComments => {
                const updateWithNewComment = (commentsList: any[]): any[] => {
                    return commentsList.map(c => {
                        if (c.id === optimisticComment.id) return result.comment;
                        if (c.replies) return { ...c, replies: updateWithNewComment(c.replies) };
                        return c;
                    });
                };

                if (parentId) {
                     return addReplyToState(currentComments, parentId, result.comment)
                        .filter(c => c.id !== optimisticComment.id);
                }
                
                return [result.comment, ...currentComments.filter(c => c.id !== optimisticComment.id)];
            });
        }
    };
    
    const handleVoteUpdate = (commentId: string, newVotes: any[]) => {
        const updateVotesRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(comment => {
                if (comment.id === commentId) return { ...comment, votes: newVotes };
                if (comment.replies) return { ...comment, replies: updateVotesRecursive(comment.replies) };
                return comment;
            });
        };
        setComments(prevComments => updateVotesRecursive(prevComments));
    };

    // --- THE FIX: START ---
    const handleDeleteSuccess = (deletedId: string, wasDeleted: boolean, updatedComment?: any) => {
        const removeOrUpdateRecursive = (commentsList: any[]): any[] => {
            if (wasDeleted) {
                return commentsList.filter(c => {
                    if (c.replies) c.replies = removeOrUpdateRecursive(c.replies);
                    return c.id !== deletedId;
                });
            } else {
                return commentsList.map(c => {
                    if (c.id === deletedId) return updatedComment;
                    if (c.replies) return { ...c, replies: removeOrUpdateRecursive(c.replies) };
                    return c;
                });
            }
        };
        setComments(prevComments => removeOrUpdateRecursive(prevComments));
    };

    const handleUpdateSuccess = (updatedComment: any) => {
        const updateRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(c => {
                if (c.id === updatedComment.id) return updatedComment;
                if (c.replies) return { ...c, replies: updateRecursive(c.replies) };
                return c;
            });
        };
        setComments(prevComments => updateRecursive(prevComments));
    };
    // --- THE FIX: END ---


    return (
        <div className={styles.commentsSection}>
            {session?.user ? (
                <CommentForm slug={slug} session={session} onPostComment={handlePostComment} />
            ) : (
                <SignInPrompt />
            )}
            
            <div> 
                <CommentList
                    comments={optimisticComments}
                    session={session}
                    slug={slug}
                    onVoteUpdate={handleVoteUpdate}
                    onPostReply={handlePostComment}
                    onDeleteSuccess={handleDeleteSuccess} // Pass down callback
                    onUpdateSuccess={handleUpdateSuccess} // Pass down callback
                />
            </div>
        </div>
    );
}




--- END OF FILE components/comments/CommentSection.tsx ---

================================================================================

--- START OF FILE components/comments/CommentVoteButtons.tsx ---

// components/comments/CommentVoteButtons.tsx
'use client';
import { useTransition, useOptimistic, useRef } from 'react';
import { voteOnComment } from '@/app/actions/commentActions';
import { VoteType } from '@prisma/client';
import { useUserStore } from '@/lib/store';
import { useSession } from 'next-auth/react';
import { motion, useAnimationControls } from 'framer-motion'; // <-- Ensure useAnimationControls is imported
import styles from './Comments.module.css';

const ThumbsUpIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/0000/svg"> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
const ThumbsDownIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/0000/svg" style={{ transform: 'scaleY(-1)' }}> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
type Vote = { userId: string; type: VoteType; };
const buttonVariants = { inactive: { scale: 1 }, active: { scale: [1, 1.3, 1.1], transition: { duration: 0.4, ease: "easeOut" } } }
const countVariants = { initial: { y: 10, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: -10, opacity: 0 }, transition: { type: 'spring', stiffness: 400, damping: 20 } };


export default function CommentVoteButtons({ commentId, initialVotes, onVoteUpdate }: { 
    commentId: string; 
    initialVotes: Vote[];
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
}) {
    const { data: session } = useSession();
    const setSignInModalOpen = useUserStore((s) => s.setSignInModalOpen);
    const [_, startTransition] = useTransition(); 
    const latestRequestRef = useRef(0);
    const likeControls = useAnimationControls();
    const dislikeControls = useAnimationControls();

    const [optimisticVotes, setOptimisticVotes] = useOptimistic(initialVotes, (state, newVote: { voteType: VoteType; userId: string }) => {
        const existingVoteIndex = state.findIndex(v => v.userId === newVote.userId);
        if (existingVoteIndex > -1) {
            const existingVote = state[existingVoteIndex];
            if (existingVote.type === newVote.voteType) { return state.filter(v => v.userId !== newVote.userId); } 
            else { return state.map(v => v.userId === newVote.userId ? { ...v, type: newVote.voteType } : v); }
        } else { return [...state, { userId: newVote.userId, type: newVote.voteType }]; }
    });

    const likes = optimisticVotes.filter(v => v.type === 'LIKE').length;
    const dislikes = optimisticVotes.filter(v => v.type === 'DISLIKE').length;
    const currentUserVote = optimisticVotes.find(v => v.userId === session?.user?.id)?.type;

    const handleVote = (voteType: VoteType) => {
        if (!session?.user?.id) { setSignInModalOpen(true); return; }
        const requestId = ++latestRequestRef.current;
        
        if (voteType === 'LIKE') {
            likeControls.start("active");
        } else {
            dislikeControls.start("active");
        }
        
        startTransition(() => {
            setOptimisticVotes({ voteType, userId: session.user.id! });
        });

        voteOnComment(commentId, voteType).then(result => {
            if (requestId === latestRequestRef.current && result.success && result.updatedVotes) {
                onVoteUpdate(commentId, result.updatedVotes);
            }
        });
    };

    return (
        <div className={styles.commentVoteActions}>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'LIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.LIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants} 
                initial={currentUserVote === 'LIKE' ? 'active' : 'inactive'}
                animate={likeControls}
            >
                <ThumbsUpIcon isActive={currentUserVote === 'LIKE'} />
                <motion.span key={likes} variants={countVariants} initial="initial" animate="animate" exit="exit">{likes}</motion.span>
            </motion.button>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'DISLIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.DISLIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants}
                initial={currentUserVote === 'DISLIKE' ? 'active' : 'inactive'}
                animate={dislikeControls}
            >
                <ThumbsDownIcon isActive={currentUserVote === 'DISLIKE'} />
                <motion.span key={dislikes} variants={countVariants} initial="initial" animate="animate" exit="exit">{dislikes}</motion.span>
            </motion.button>
        </div>
    );
}







--- END OF FILE components/comments/CommentVoteButtons.tsx ---

================================================================================

--- START OF FILE components/comments/Comments.module.css ---

/* components/comments/Comments.module.css */
@keyframes pulse-text {
    0%, 100% {
        color: var(--text-primary);
    }
    50% {
        color: var(--text-secondary);
    }
}

.pulsingText {
    animation: pulse-text 2s ease-in-out infinite;
}

.commentsSection { margin-top: 8rem; padding-top: 4rem; border-top: 1px solid var(--border-color); }
.commentsBlock .commentsSection { margin-top: 0; padding-top: 0; border-top: none; }
.commentsBlock { margin-top: 8rem; background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 3rem; }
.commentSigninPrompt { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 4rem; text-align: center; margin-top: 2rem; }
.commentFormWrapper { display: flex; align-items: flex-start; gap: 1.5rem; margin-bottom: 5rem; max-width: 700px; }
.commentFormAvatar { flex-shrink: 0; margin-top: 0.5rem; }
.commentFormMain { flex-grow: 1; }
.commentFormMain .profileInput { min-height: 120px; margin-bottom: 1rem; }
.commentList { position: relative; max-width: 700px; display: flex; flex-direction: column; gap: 4rem; border-right: 2px solid var(--border-color); padding-right: 3rem; border-left: none; padding-left: 0; }
.commentItem { position: relative; }
.commentItem::before { content: ''; position: absolute; right: -3.9rem; left: auto; top: 10px; width: 14px; height: 14px; border-radius: 50%; background-color: var(--bg-secondary); border: 3px solid var(--accent); }
.commentHeader { display: flex; align-items: flex-start; justify-content: space-between; gap: 1.2rem; margin-bottom: 1rem; }
.commentAuthorInfo { display: flex; align-items: center; gap: 1.2rem; flex-grow: 1; }
.commentAuthorLink { font-family: var(--font-main), sans-serif; font-weight: 700; font-size: 1.8rem; color: var(--text-primary); transition: color 0.2s ease; }
.commentAuthorLink:hover { color: var(--accent); }

.authorAndTimestamp {
    display: flex;
    align-items: baseline; 
    gap: 0.8rem;
}
.commentTimestamp {
    font-size: 1.3rem;
    color: var(--text-secondary);
    font-family: var(--font-main), sans-serif;
    margin: 0;
}
.commentReplyButton { flex-shrink: 0; background: none; border: none; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: var(--text-secondary); transition: all 0.2s ease; }
.commentReplyButton:hover { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); transform: scale(1.1); }
.commentBody { padding-right: 52px; padding-left: 0; }
.commentFooter { display: flex; justify-content: space-between; align-items: center; margin-top: 1.5rem; padding-right: 52px; padding-left: 0; }
.commentVoteActions { display: flex; align-items: center; gap: 1.5rem; }
.commentAuthorActions { display: flex; align-items: center; gap: 1.5rem; }
.commentActionButton { background: none; border: none; padding: 0.2rem 0.6rem; margin: 0 -0.6rem; border-radius: 4px; cursor: pointer; font-family: var(--font-main), sans-serif; font-size: 1.3rem; font-weight: 500; color: var(--text-secondary); transition: color 0.2s ease, background-color 0.2s ease; }
.commentActionButton:hover { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }
.voteButton { display: flex; align-items: center; gap: 0.6rem; background: none; border: none; cursor: pointer; color: var(--text-secondary); padding: 0.4rem 0.8rem; margin: 0 -0.8rem; border-radius: 999px; transition: color 0.2s ease, background-color 0.2s ease; }
.voteButton:hover:not(:disabled) { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }
.voteButton.active { color: var(--accent); font-weight: 700; }
.viewRepliesButton { margin-left: auto; margin-right: 1.5rem; }
.commentEditForm { margin-top: 1rem; padding-right: 52px; padding-left: 0; }
.commentEditActions { display: flex; gap: 1rem; }
.commentReplyFormContainer { padding-right: 52px; padding-left: 0; margin-top: 1.5rem; }
.commentReplyFormContainer .commentFormWrapper { margin: 0; padding: 0; }
.commentRepliesList { position: relative; display: flex; flex-direction: column; gap: 3rem; margin-top: 3rem; padding-right: 52px; padding-left: 0; }
.commentRepliesList::before { content: ''; position: absolute; top: 0; right: 20px; left: auto; bottom: 0; width: 2px; background-color: var(--border-color); }
.commentRepliesList .commentItem { padding-right: 0; border-right: none; }
.commentRepliesList .commentItem::before { display: none; }
.commentItem.deleted .commentAuthorInfo { opacity: 0.7; }
.deletedAvatar { width: 40px; height: 40px; border-radius: 50%; background-color: var(--border-color); }
.commentAuthorLink.deleted { color: var(--text-secondary); font-style: italic; }




--- END OF FILE components/comments/Comments.module.css ---

================================================================================

--- START OF FILE components/comments/LazyCommentSection.tsx ---

'use client';

import { useState, useRef, useEffect } from 'react';
import dynamic from 'next/dynamic';
import type { Session } from 'next-auth';

// A placeholder to prevent layout shift while the component loads.
const CommentsPlaceholder = () => (
<div style={{ minHeight: '250px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
<div className="spinner" />
</div>
);

// Dynamically import the interactive CommentList component.
const CommentList = dynamic(() => import('./CommentList'), {
loading: () => <CommentsPlaceholder />,
ssr: false // This is a purely client-side interactive component.
});

export default function LazyCommentSection({ comments, session, slug }: { comments: any[]; session: Session | null, slug: string }) {
const [isIntersecting, setIntersecting] = useState(false);
const ref = useRef<HTMLDivElement>(null);

useEffect(() => {
if (!ref.current) return;
const observer = new IntersectionObserver(
([entry]) => {
// Trigger when the placeholder is 250px from the viewport edge
if (entry.isIntersecting) {
setIntersecting(true);
observer.unobserve(entry.target);
}
},
{ rootMargin: "250px" }
);
observer.observe(ref.current);
return () => observer.disconnect();
}, []);

// Render a static placeholder div until it's time to load the interactive component.
return (
<div ref={ref} style={{ minHeight: '250px' }}>
{isIntersecting ? <CommentList comments={comments} session={session} slug={slug} /> : null}
</div>
);
}





























--- END OF FILE components/comments/LazyCommentSection.tsx ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.module.css ---

/* components/comments/SignInPrompt.module.css */

.signInPrompt {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 4rem;
    text-align: center;
    margin-top: 2rem;
}

.signInButton {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 1rem 2.4rem;
    border-radius: 5px;
    font-family: var(--font-ui), sans-serif;
    font-weight: 500;
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

[data-theme="dark"] .signInButton {
    color: var(--bg-primary);
}

.signInButton:hover {
    opacity: 0.85;
}







--- END OF FILE components/comments/SignInPrompt.module.css ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.tsx ---

// components/comments/SignInPrompt.tsx
'use client';

import { useUserStore } from "@/lib/store";
import { motion } from "framer-motion";
import styles from './SignInPrompt.module.css'; // <-- IMPORTED MODULE

export default function SignInPrompt() {
    const { setSignInModalOpen } = useUserStore();

    return (
        <div className={styles.signInPrompt}>
            <h3>شارك في النقاش</h3>
            <p>لترك بصمتك في النقاش، قم بتسجيل الدخول.</p>
            <motion.button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton} // <-- UPDATED CLASS
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 400, damping: 15 }}
            >ولوج</motion.button>
        </div>
    );
}







--- END OF FILE components/comments/SignInPrompt.tsx ---

================================================================================

--- START OF FILE components/comments/TimeStamp.tsx ---

'use client';
import { useState, useEffect } from 'react';
export default function TimeStamp({ date }: { date: Date }) {
const [displayTime, setDisplayTime] = useState('');
useEffect(() => {
const updateDisplayTime = () => {
const seconds = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
if (seconds < 5) { setDisplayTime("للتو"); return; }
if (seconds < 60) { setDisplayTime(`${Math.floor(seconds)}s ago`); return; }
const minutes = seconds / 60;
if (minutes < 60) { setDisplayTime(`${Math.floor(minutes)}m ago`); return; }
const hours = minutes / 60;
if (hours < 24) { setDisplayTime(`${Math.floor(hours)}h ago`); return; }
setDisplayTime(new Date(date).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
};
updateDisplayTime();
const interval = setInterval(updateDisplayTime, 30000); // update every 30 seconds
return () => clearInterval(interval);
}, [date]);
return <p className="comment-timestamp">{displayTime}</p>;
}





























--- END OF FILE components/comments/TimeStamp.tsx ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.module.css ---

/* components/constellation/ConstellationControlPanel.module.css */

.settingsButton {
  position: absolute;
  bottom: 2rem;
  right: 2rem;
  left: auto;
  z-index: 2001;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background-color: color-mix(in srgb,var(--bg-secondary) 80%,transparent);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(4px);
  transition: all 0.3s ease;
}

.settingsButton:hover {
  border-color: var(--accent);
  color: var(--accent);
  box-shadow: 0 0 15px 0 color-mix(in srgb,var(--accent) 70%,transparent);
}

.panelOverlay {
  position: absolute;
  inset: 0;
  z-index: 2000;
  background-color: rgba(0,0,0,0.3);
}

.panel {
  position: absolute;
  top: 0;
  right: 0;
  left: auto;
  bottom: 0;
  width: 100%;
  max-width: 320px;
  background-color: color-mix(in srgb,var(--bg-secondary) 90%,transparent);
  backdrop-filter: blur(10px);
  border-left: 1px solid var(--border-color);
  border-right: none;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  font-family: var(--font-main);
}

.panelHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.panelHeader h3 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: 600;
}

.closeButton {
  background: none;
  border: none;
  padding: 0.5rem;
  color: var(--text-secondary);
  cursor: pointer;
  transition: color 0.2s;
}
.closeButton:hover {
  color: var(--text-primary);
}

.divider {
  height: 1px;
  background-color: var(--border-color);
  margin: -0.5rem 0;
}

.section {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.label {
  font-size: 1.4rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.presetButtons {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 1rem;
}

.presetButton {
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);padding: 0.8rem;border-radius: 6px;
  font-size: 1.3rem;font-weight: 500;text-transform: capitalize;
  cursor: pointer;transition: all 0.2s ease;
}

.presetButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.presetButton.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .presetButton.active {
  color: var(--bg-primary);
}

.rangeInput {
  -webkit-appearance: none;appearance: none;
  width: 100%;height: 4px;background: var(--border-color);
  border-radius: 2px;outline: none;transition: background-color 0.2s;
}
.rangeInput:disabled {
  background-color: color-mix(in srgb,var(--border-color) 50%,transparent);
}
.rangeInput::-webkit-slider-thumb {
  -webkit-appearance: none;appearance: none;
  width: 16px;height: 16px;background: var(--accent);
  border-radius: 50%;cursor: pointer;
  transition: filter 0.2s ease-out;
}
.rangeInput::-webkit-slider-thumb:hover {
  filter: drop-shadow(0 0 6px var(--accent));
}
.rangeInput:disabled::-webkit-slider-thumb {
  background: var(--text-secondary);cursor: not-allowed;filter: none;
}

.section > .label {
  display: block;
  width: 100%;
}

.toggle {
  width: 44px;height: 24px;background-color: var(--border-color);
  border-radius: 999px;padding: 2px;
  display: flex;cursor: pointer;justify-content: flex-start;
  border: none;
}
.toggle.active {
  background-color: var(--accent);justify-content: flex-end;
}
.toggleHandle {
  width: 20px;
  height: 20px;
  background-color: white;
  border-radius: 50%;
}

.note {
  font-size: 1.2rem;
  color: var(--text-secondary);
  margin: -0.5rem 0 0 0;
  font-style: italic;
}




--- END OF FILE components/constellation/ConstellationControlPanel.module.css ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.tsx ---

// components/constellation/ConstellationControlPanel.tsx
'use client';

import { motion } from 'framer-motion';
import { useTheme } from 'next-themes';
import styles from './ConstellationControlPanel.module.css';

export type Preset = 'أداء' | 'متوازن' | 'فائق';
export type ConstellationSettings = {
    activePreset: Preset | 'custom';
    starCountMultiplier: number;
    bloomIntensity: number;
    alwaysShowOrbits: boolean;
    flawlessPathThickness: number;
};

const CloseIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

const panelVariants = {
    hidden: { x: '-100%', opacity: 0 },
    visible: { x: 0, opacity: 1, transition: { type: 'spring', damping: 25, stiffness: 150, staggerChildren: 0.05, delayChildren: 0.1 } },
    exit: { x: '-100%', opacity: 0, transition: { duration: 0.2 } }
};
const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: -20, transition: { duration: 0.15 } }
};

interface ControlPanelProps {
    settings: ConstellationSettings;
    setSettings: (settings: ConstellationSettings) => void;
    onClose: () => void;
    onPresetChange: (preset: Preset) => void;
    isFullscreen: boolean;
    onToggleFullscreen: () => void;
}

export default function ConstellationControlPanel({ settings, setSettings, onClose, onPresetChange, isFullscreen, onToggleFullscreen }: ControlPanelProps) {
    const { resolvedTheme } = useTheme();
    const isLightMode = resolvedTheme === 'light';

    const handleValueChange = (key: keyof ConstellationSettings, value: number | boolean) => {
        setSettings({ ...settings, activePreset: 'custom', [key]: value });
    };

    return (
        <motion.div className={styles.panelOverlay} onClick={onClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
            <motion.div className={styles.panel} variants={panelVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
                <motion.div className={styles.panelHeader} variants={itemVariants}>
                    <h3>إعدادات الكوكبة</h3>
                    <motion.button onClick={onClose} className={styles.closeButton} whileHover={{ scale: 1.1, rotate: 90 }}><CloseIcon /></motion.button>
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>إعدادات الجودة</label>
                    <div className={styles.presetButtons}>
                        {(['أداء', 'متوازن', 'فائق'] as Preset[]).map(p => (
                            <motion.button key={p} className={`${styles.presetButton} ${settings.activePreset === p ? styles.active : ''}`} onClick={() => onPresetChange(p)} whileTap={{ scale: 0.95 }}>
                                {p}
                            </motion.button>
                        ))}
                    </div>
                </motion.div>

                <motion.div className={styles.divider} variants={itemVariants} />

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label} htmlFor="galaxy-density">كثافة المجرة</label>
                    <input id="galaxy-density" type="range" min="0.1" max="1.5" step="0.1" value={settings.starCountMultiplier} onChange={(e) => handleValueChange('starCountMultiplier', parseFloat(e.target.value))} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants} style={{ opacity: isLightMode ? 0.5 : 1 }}>
                    <label className={styles.label} htmlFor="bloom-intensity">Bloom Intensity {isLightMode && "(Disabled)"}</label>
                    <input id="bloom-intensity" type="range" min="0" max="2.5" step="0.1" value={settings.bloomIntensity} onChange={(e) => handleValueChange('bloomIntensity', parseFloat(e.target.value))} disabled={isLightMode} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.divider} variants={itemVariants} />

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label} htmlFor="path-thickness">سماكة المسار</label>
                    <input id="path-thickness" type="range" min="1" max="3" step="0.1" value={settings.flawlessPathThickness} onChange={(e) => handleValueChange('flawlessPathThickness', parseFloat(e.target.value))} className={styles.rangeInput} />
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>إظهار المدارات دائمًا</label>
                    <button className={`${styles.toggle} ${settings.alwaysShowOrbits ? styles.active : ''}`} onClick={() => handleValueChange('alwaysShowOrbits', !settings.alwaysShowOrbits)}>
                        <motion.div className={styles.toggleHandle} layout transition={{ type: 'spring', stiffness: 500, damping: 25 }} />
                    </button>
                </motion.div>

                <motion.div className={styles.section} variants={itemVariants}>
                    <label className={styles.label}>وضع ملء الشاشة</label>
                    <button className={`${styles.toggle} ${isFullscreen ? styles.active : ''}`} onClick={onToggleFullscreen}>
                        <motion.div className={styles.toggleHandle} layout transition={{ type: 'spring', stiffness: 500, damping: 25 }} />
                    </button>
                </motion.div>
            </motion.div>
        </motion.div>
    );
}




--- END OF FILE components/constellation/ConstellationControlPanel.tsx ---

================================================================================

--- START OF FILE components/constellation/ConstellationLoader.tsx ---

// components/constellation/ConstellationLoader.tsx
'use client';

import dynamic from 'next/dynamic';

// This is the correct location for the dynamic import with ssr: false.
const Constellation = dynamic(() => import('@/components/constellation'), {
    ssr: false,
    loading: () => (
        <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <div className="spinner" />
        </div>
    ),
});

// This simple wrapper component is safely imported by the Client Component.
export default function ConstellationLoader() {
    return <Constellation />;
}




--- END OF FILE components/constellation/ConstellationLoader.tsx ---

================================================================================

--- START OF FILE components/constellation/Scene.tsx ---

// components/constellation/Scene.tsx
import React, { useRef, useMemo, Suspense, useCallback, useState } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Tube, Line, Html } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, SIZES, StarData, ScreenPosition, Placement, getStarSize, StarActionType } from './config';
import { ConstellationSettings } from './ConstellationControlPanel';
import { motion, AnimatePresence } from 'framer-motion';

const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
    const positions = useMemo(() => {
        const pos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
            pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
        }
        return pos;
    }, [count, radius]);
    return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const InteractiveStar = ({ star, color, isHovered, onHover, onClick }: {
    star: StarData, color: string, isHovered: boolean,
    onHover: (star: StarData | null) => void,
    onClick: (star: StarData) => void
}) => {
    const ref = useRef<THREE.Mesh>(null!);
    const size = useMemo(() => getStarSize(star), [star]);
    useFrame(() => { ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.5 : 1), 0.2); });
    const handlePointerOver = (e: ThreeEvent<PointerEvent>) => { e.stopPropagation(); document.body.style.cursor = 'pointer'; onHover(star); };
    const handlePointerOut = () => { onHover(null); document.body.style.cursor = 'auto'; };
    return (
        <mesh ref={ref} onClick={(e) => { e.stopPropagation(); onClick(star); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
            <sphereGeometry args={[size, 16, 16]} />
            <meshBasicMaterial color={color} toneMapped={false} />
        </mesh>
    );
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
    const ref = useRef<THREE.Group>(null!);
    useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 45; });
    return (
        <group ref={ref}>
            <StarLayer count={Math.floor(1500 * countMultiplier)} radius={4} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(1000 * countMultiplier)} radius={6} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(500 * countMultiplier)} radius={8} size={0.008} opacity={0.3} color={themeColors.bgStarColor} />
        </group>
    );
};

const createUIShareIconGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const createCenteredShapeFromPoints = (points: {x: number, y: number}[]) => {
        const shape = new THREE.Shape();
        const vecs = points.map(p => new THREE.Vector2(p.x, p.y).sub(center).multiplyScalar(scale));
        shape.moveTo(vecs[0].x, -vecs[0].y);
        for (let i = 1; i < vecs.length; i++) shape.lineTo(vecs[i].x, -vecs[i].y);
        shape.closePath();
        return shape;
    };
    const createCircleShape = ({x, y, r}: {x: number, y: number, r: number}) => {
        const shape = new THREE.Shape();
        const centerVec = new THREE.Vector2(x, y).sub(center).multiplyScalar(scale);
        shape.absarc(centerVec.x, -centerVec.y, r * scale, 0, Math.PI * 2, false);
        return shape;
    };
    const circle1Shape = createCircleShape({ x: 18, y: 5, r: 3 });
    const circle2Shape = createCircleShape({ x: 6, y: 12, r: 3 });
    const circle3Shape = createCircleShape({ x: 18, y: 19, r: 3 });
    const line1Points = [{ x: 8.59, y: 13.51 }, { x: 15.42, y: 17.44 }, { x: 14.42, y: 19.18 }, { x: 7.59, y: 15.25 }];
    const line2Points = [{ x: 8.59, y: 10.49 }, { x: 9.59, y: 12.23 }, { x: 16.42, y: 8.30 }, { x: 15.42, y: 6.56 }];
    const line1Shape = createCenteredShapeFromPoints(line1Points);
    const line2Shape = createCenteredShapeFromPoints(line2Points);
    return new THREE.ShapeGeometry([circle1Shape, circle2Shape, circle3Shape, line1Shape, line2Shape]);
};

const createUIHeartGeometry = () => {
    const shape = new THREE.Shape();
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const transform = (x: number, y: number) => {
        const v = new THREE.Vector2(x, y).sub(center);
        return { x: v.x * scale, y: -v.y * scale };
    };
    let p0 = transform(12, 21); shape.moveTo(p0.x, p0.y);
    let p1 = transform(12, 21), p2 = transform(5.8, 16.4), p3 = transform(2.8, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(0.9, 9.7); p2 = transform(2.5, 5); p3 = transform(6.7, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(8.6, 4.3); p2 = transform(10.5, 5.2); p3 = transform(12, 6.7); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(13.5, 5.2); p2 = transform(15.4, 4.3); p3 = transform(17.3, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(21.5, 5); p2 = transform(23.1, 9.7); p3 = transform(21.2, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(18.2, 16.4); p2 = transform(12, 21); p3 = transform(12, 21); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    return new THREE.ShapeGeometry(shape);
};

const createUIBookmarkGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const points = [
        new THREE.Vector2(6, 2), new THREE.Vector2(4, 4), new THREE.Vector2(4, 22),
        new THREE.Vector2(12, 17), new THREE.Vector2(20, 22), new THREE.Vector2(20, 4),
        new THREE.Vector2(18, 2),
    ];
    const transformedPoints = points.map(p => {
        const v = p.clone().sub(center);
        return new THREE.Vector2(v.x * scale, -v.y * scale);
    });
    return new THREE.ShapeGeometry(new THREE.Shape().setFromPoints(transformedPoints));
};

const ICON_GEOMETRIES = {
    heart: createUIHeartGeometry(),
    bookmark: createUIBookmarkGeometry(),
    share: createUIShareIconGeometry(),
    comment: new THREE.ShapeGeometry(new THREE.Shape().setFromPoints([
        new THREE.Vector2(-0.6, 0.4), new THREE.Vector2(0.6, 0.4), new THREE.Vector2(0.6, -0.2),
        new THREE.Vector2(0.1, -0.2), new THREE.Vector2(0, -0.4), new THREE.Vector2(-0.1, -0.2),
        new THREE.Vector2(-0.6, -0.2),
    ]))
};

const ActionOrbit3D = ({ actions }: { actions: StarActionType[] }) => {
    const { camera } = useThree();
    const groupRef = useRef<THREE.Group>(null!);
    useFrame(() => { if (groupRef.current) groupRef.current.quaternion.copy(camera.quaternion); });
    const radius = 0.3;
    const iconScale = 0.085;

    return (
        <group ref={groupRef}>
            {actions.map((action, index) => {
                const angle = (index / actions.length) * Math.PI * 2;
                const iconPosition = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                const geometryKey = action === 'like' ? 'heart' : action;
                const geometry = ICON_GEOMETRIES[geometryKey];
                return (
                    <group key={action}>
                        <Tube renderOrder={0} args={[new THREE.LineCurve3(new THREE.Vector3(0,0,0), iconPosition), 16, 0.002, 8, false]}>
                            <meshBasicMaterial color="white" toneMapped={false} />
                        </Tube>
                        <mesh renderOrder={1} position={iconPosition} geometry={geometry} scale={iconScale}>
                            <meshBasicMaterial color={THEME_CONFIG.dark.reviewColor} toneMapped={false} />
                        </mesh>
                    </group>
                );
            })}
        </group>
    );
};

const UserStarPoints = ({ stars, themeColors, hoveredStar, setHoveredStar, setActiveStar, alwaysShowOrbits }: {
    stars: StarData[], themeColors: typeof THEME_CONFIG.dark, hoveredStar: StarData | null,
    setHoveredStar: (star: StarData | null) => void,
    setActiveStar: (star: StarData, position: ScreenPosition) => void,
    alwaysShowOrbits: boolean
}) => {
    const { camera, gl } = useThree();
    const handleStarClick = useCallback((star: StarData) => {
        const canvasRect = gl.domElement.getBoundingClientRect();
        const vec = new THREE.Vector3().copy(star.position);
        vec.project(camera);
        const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
        const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
        const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
        let finalX = x;
        const cardWidth = 300;
        const padding = 20;
        if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
        if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
        setActiveStar(star, { top: y, left: finalX, placement });
    }, [camera, gl.domElement, setActiveStar]);
    return (
        <group>
            {stars.map(star => {
                const colorKey = `${star.content._type}Color` as keyof typeof themeColors;
                const isHovered = hoveredStar?.id === star.id;
                return (
                    // --- DEFINITIVE FIX IS HERE: Use _id as a fallback for the key ---
                    <group key={star.id || star.content._id} position={star.position}>
                        <InteractiveStar star={star} color={themeColors[colorKey]} isHovered={isHovered} onHover={setHoveredStar} onClick={handleStarClick} />
                        {(alwaysShowOrbits || isHovered) && star.actions.length > 0 && (
                            <ActionOrbit3D actions={star.actions} />
                        )}
                    </group>
                );
            })}
        </group>
    );
};

const ConstellationPath = ({ pathPoints, color, thickness }: { pathPoints: THREE.Vector3[], color: string, thickness: number }) => {
    return <Line points={pathPoints} color={color} lineWidth={thickness} />;
};

const HoverContext = ({ hoveredStar, alwaysShowOrbits }: { hoveredStar: StarData, alwaysShowOrbits: boolean }) => {
    return (
        <Html position={hoveredStar.position}>
            <div style={{ position: 'relative', pointerEvents: 'none', transform: 'translate(-50%, -50%)' }}>
                {!alwaysShowOrbits && (
                    <motion.div
                        initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }}
                        transition={{ duration: 0.2, ease: 'easeOut' }}
                        style={{
                            position: 'absolute', bottom: '80px', left: '50%', transform: 'translateX(-50%)',
                            background: 'var(--bg-secondary)', color: 'var(--text-primary)', padding: '0.5rem 1rem',
                            borderRadius: '6px', border: '1px solid var(--border-color)', fontSize: '1.4rem',
                            fontFamily: 'var(--font-ui)', whiteSpace: 'nowrap', zIndex: 10000,
                            boxShadow: '0 4px 15px rgba(0,0,0,0.2)'
                        }}
                    >
                        <p style={{ margin: 0, fontWeight: 600 }}>{hoveredStar.content.title}</p>
                        <p style={{ margin: 0, textTransform: 'capitalize', color: 'var(--text-secondary)' }}>{hoveredStar.content.type}</p>
                    </motion.div>
                )}
            </div>
        </Html>
    );
};

function InteractiveLayer({ chronologicalStars, themeColors, setActiveStar, settings }: any) {
    const [hoveredStar, setHoveredStar] = useState<StarData | null>(null);
    const { bloomIntensity, alwaysShowOrbits, flawlessPathThickness } = settings;
    const isBloomEnabled = bloomIntensity > 0;

    const controlsRef = useRef<any>();
    useFrame(() => {
        if (controlsRef.current) {
            controlsRef.current.autoRotate = !hoveredStar;
            controlsRef.current.update();
        }
    });

    return (
        <>
            <AnimatePresence>{hoveredStar && <HoverContext hoveredStar={hoveredStar} alwaysShowOrbits={alwaysShowOrbits} />}</AnimatePresence>
            {isBloomEnabled ? (
                <Selection>
                    <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={0}>
                        <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
                    </EffectComposer>
                    {chronologicalStars.length > 0 && (
                        <Select enabled>
                            <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                            <ConstellationPath pathPoints={chronologicalStars.map(s => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                        </Select>
                    )}
                </Selection>
            ) : (
                chronologicalStars.length > 0 && (
                    <>
                        <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                        <ConstellationPath pathPoints={chronologicalStars.map(s => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                    </>
                )
            )}
            <OrbitControls
                ref={controlsRef}
                enableZoom
                autoRotate={true}
                autoRotateSpeed={0.15}
                minDistance={2.5}
                maxDistance={10}
                zoomSpeed={0.5}
            />
        </>
    );
}

interface SceneProps {
    chronologicalStars: StarData[];
    themeColors: typeof THEME_CONFIG.dark;
    setActiveStar: (star: StarData, position: ScreenPosition) => void;
    settings: ConstellationSettings;
}

export const Scene = ({ chronologicalStars, themeColors, setActiveStar, settings }: SceneProps) => {
    return (
        <Suspense fallback={null}>
            <color attach="background" args={[themeColors.bgColor]} />
            <ambientLight intensity={0.5} />
            <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
            <InteractiveLayer
                chronologicalStars={chronologicalStars}
                themeColors={themeColors}
                setActiveStar={setActiveStar}
                settings={settings}
            />
        </Suspense>
    );
};










--- END OF FILE components/constellation/Scene.tsx ---

================================================================================

--- START OF FILE components/constellation/ScreenshotButton.tsx1 ---

// components/constellation/ScreenshotButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './ConstellationControlPanel.module.css';

const CameraIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
        <circle cx="12" cy="13" r="4"></circle>
    </svg>
);

interface ScreenshotButtonProps {
    onClick: () => void;
    disabled: boolean;
}

export default function ScreenshotButton({ onClick, disabled }: ScreenshotButtonProps) {
    return (
        <motion.button
            className={styles.presetButton}
            style={{ gridColumn: '1 / -1', height: '44px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.75rem' }}
            onClick={onClick}
            disabled={disabled}
            whileTap={{ scale: 0.95 }}
        >
            <CameraIcon />
            <span>{disabled ? 'Capturing...' : 'Capture Screenshot'}</span>
        </motion.button>
    );
}




--- END OF FILE components/constellation/ScreenshotButton.tsx1 ---

================================================================================

--- START OF FILE components/constellation/StarPreviewCard.tsx ---

import React from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { SanityContentObject, StarData, ScreenPosition } from './config';

interface StarPreviewCardProps {
starData: StarData;
position: ScreenPosition;
onClose: () => void;
}

const typeMap = {
    review: 'مراجعة',
    article: 'مقالة',
    news: 'خبر'
}

export const StarPreviewCard = ({ starData, position, onClose }: StarPreviewCardProps) => {
const getLinkPath = (item: SanityContentObject) => {
switch (item._type) {
case 'review': return `/reviews/${item.slug}`;
case 'article': return `/articles/${item.slug}`;
case 'news': return `/news/${item.slug}`;
default: return '/';
}
};

const imageUrl = starData.content.mainImage?.url;
const contentType = typeMap[starData.content._type] || 'محتوى';

return (
<motion.div
onClick={(e) => e.stopPropagation()}
initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }}
transition={{ type: 'spring', damping: 25, stiffness: 300 }}
style={{
position: 'fixed', top: position.top, left: position.left,
width: '300px',
background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px',
boxShadow: '0 10px 30px rgba(0,0,0,0.3)', overflow: 'hidden', zIndex: 10001,
transform: position.placement === 'below'
? 'translate(-50%, 20px)'
: 'translate(-50%, calc(-100% - 20px))',
transformOrigin: position.placement === 'below' ? 'top center' : 'bottom center',
}}
>
<motion.button
onClick={onClose} whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
style={{
position: 'absolute', top: '10px', right: '10px', zIndex: 2, width: '32px', height: '32px',
borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.3)', color: 'white',
display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
}} aria-label="إغلاق المعاينة"
>
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
</motion.button>

<div style={{ position: 'relative', width: '100%', height: '150px' }}>
{imageUrl ? (
<Image
src={imageUrl}
alt={starData.content.title}
fill
style={{ objectFit: 'cover' }}
/>
) : (
<div style={{ width: '100%', height: '100%', backgroundColor: 'var(--border-color)' }} />
)}
</div>

<div style={{ padding: '1.5rem', textAlign: 'right' }}>
<p style={{ textTransform: 'capitalize', color: 'var(--accent)', fontFamily: 'var(--font-main)', fontSize: '1.3rem', margin: '0 0 0.5rem 0' }}>{contentType}</p>
<h3 style={{ margin: '0 0 1.5rem 0', fontSize: '1.7rem' }}>{starData.content.title}</h3>
<Link href={getLinkPath(starData.content)} onClick={onClose} className="primary-button no-underline" style={{ display: 'block', textAlign: 'center' }}>
عرض كامل الـ{contentType}
</Link>
</div>

</motion.div>
);
};




--- END OF FILE components/constellation/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE components/constellation/config.ts ---

import * as THREE from 'three';
// Import the new Sanity types instead of the old mock data types
import type { SanityReview, SanityArticle, SanityNews } from '@/types/sanity';

//  Type Definitions
// Create a new union type for any content object from Sanity
export type SanityContentObject = SanityReview | SanityArticle | SanityNews;

export type StarActionType = 'bookmark' | 'like' | 'comment' | 'share';
export type StarType = 'history' | 'like' | 'comment' | 'share';

export type StarData = {
id: number;
position: THREE.Vector3;
content: SanityContentObject;
// This determines the star's base size based on the most significant action
type: StarType;
// This contains ALL actions taken on the content, used to draw the orbit
actions: StarActionType[];
};

export type Placement = 'above' | 'below';
export type ScreenPosition = {
top: number;
left: number;
placement: Placement;
};

//  Theme-aware Color & Size Mapping
export const THEME_CONFIG = {
dark: {
reviewColor: '#00E5FF', articleColor: '#E1E1E6', newsColor: '#7D808C',
pathColor: '#FFFFFF', bgStarColor: '#FFFFFF', bgColor: '#0A0B0F',
},
light: {
reviewColor: '#0891B2', articleColor: '#1F2937', newsColor: '#6B7280',
pathColor: '#1F2937', bgStarColor: '#1F2937', bgColor: '#F0F2F5',
},
};

const BASE_SIZE = 0.035;
const BOOKMARK_MULTIPLIER = 1.6;

export const SIZES: Record<StarType, number> = {
history: BASE_SIZE,
like: BASE_SIZE * 1.3,
comment: BASE_SIZE * 1.6,
share: BASE_SIZE * 2.0,
};

// A bookmarked star is ALWAYS the largest version of its type
export const getStarSize = (star: StarData) => {
// legacyId is the correct property for the numeric ID
return star.actions.includes('bookmark') ? SIZES['share'] * BOOKMARK_MULTIPLIER : SIZES[star.type];
};





























--- END OF FILE components/constellation/config.ts ---

================================================================================

--- START OF FILE components/constellation/index.tsx ---

// components/constellation/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import * as THREE from 'three';
import { THEME_CONFIG, StarData, SanityContentObject, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from './ConstellationControlPanel';
import { getCommentedContentIds } from '@/app/actions/userActions';
import styles from './ConstellationControlPanel.module.css';

const CelestialGearIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="8"></circle>
        <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
    </svg>
);

export default function Constellation() {
    const [isHydrated, setIsHydrated] = useState(false);
    useEffect(() => { setIsHydrated(true); }, []);

    const [isFullscreen, setIsFullscreen] = useState(false);

    useEffect(() => {
        document.body.classList.add('constellation-active');
        if (isFullscreen) {
            document.body.classList.add('fullscreen-active');
        } else {
            document.body.classList.remove('fullscreen-active');
        }
        return () => {
            document.body.classList.remove('constellation-active');
            document.body.classList.remove('fullscreen-active');
        };
    }, [isFullscreen]);

    const { resolvedTheme } = useTheme();
    const { bookmarks, likes, shares } = useUserStore();
    const [userContent, setUserContent] = useState<SanityContentObject[]>([]);
    const [activeStar, setActiveStar] = useState<StarData | null>(null);
    const [activeStarPosition, setActiveStarPosition] = useState<ScreenPosition | null>(null);
    const [isPanelOpen, setIsPanelOpen] = useState(false);
    const [commentedContentSlugs, setCommentedContentSlugs] = useState<string[]>([]);

    useEffect(() => {
        if (!isHydrated) return;
        getCommentedContentIds().then(slugs => { setCommentedContentSlugs(slugs); });

        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));
        
        const allIds = [...new Set([...safeBookmarks, ...safeLikes, ...safeShares])];
        
        if (allIds.length === 0) { 
            setUserContent([]); 
            return; 
        }

        const fetchContent = async () => {
            const response = await fetch('/api/content-by-ids', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ ids: allIds }), 
            });
            if (response.ok) { 
                const data = await response.json(); 
                setUserContent(data); 
            } else {
                console.error("Failed to fetch content for Constellation:", response.statusText);
            }
        };
        fetchContent();
    }, [isHydrated, bookmarks, likes, shares]);

    const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
        'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
        'متوازن': { activePreset: 'متوازن', starCountMultiplier: 1.0, bloomIntensity: 0.9, alwaysShowOrbits: false, flawlessPathThickness: 2 },
        'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.5, alwaysShowOrbits: false, flawlessPathThickness: 2.5 },
    }), []);

    const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['متوازن']);
    const lastValidBloom = useRef(settings.bloomIntensity);

    useEffect(() => {
        if (settings.bloomIntensity > 0) {
            lastValidBloom.current = settings.bloomIntensity;
        }
    }, [settings.bloomIntensity]);
    
    useEffect(() => {
        if (resolvedTheme === 'light') {
            if (settings.bloomIntensity > 0) {
                setSettings(s => ({ ...s, bloomIntensity: 0, activePreset: 'custom' }));
            }
        } else {
            if (settings.bloomIntensity === 0 && lastValidBloom.current > 0) {
                 setSettings(s => ({ ...s, bloomIntensity: lastValidBloom.current, activePreset: 'custom' }));
            }
        }
    }, [resolvedTheme, settings.bloomIntensity]);

    const handlePresetChange = (preset: Preset) => {
        let newSettings = PRESETS[preset];
        if (resolvedTheme === 'light') newSettings.bloomIntensity = 0;
        setSettings(newSettings);
    };

    const isDark = resolvedTheme === 'dark';
    const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;

    const chronologicalStars = useMemo(() => {
        if (!isHydrated || userContent.length === 0) return [];
        
        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));

        const starMap = new Map<number, { type: "history" | "like" | "comment" | "share", actions: ("bookmark" | "like" | "comment" | "share")[], content: SanityContentObject }>();
        
        userContent.filter(content => content.legacyId != null).forEach(content => {
            const id = content.legacyId; 
            let type: "history" | "like" | "comment" | "share" = 'history'; 
            const actions: ("bookmark" | "like" | "comment" | "share")[] = [];

            if (safeLikes.includes(id)) { actions.push('like'); }
            if (safeShares.includes(id)) { actions.push('share'); }
            if (commentedContentSlugs.includes(content.slug)) { actions.push('comment'); }
            if (safeBookmarks.includes(id)) { actions.push('bookmark'); }

            if (actions.includes('like')) type = 'like';
            if (actions.includes('comment')) type = 'comment'; 
            if (actions.includes('share')) type = 'share';
            
            starMap.set(id, { type, actions: actions.sort(), content });
        });
        
        const allUserStars: StarData[] = [];
        starMap.forEach((data, id) => {
            const u=Math.random(), v=Math.random(), theta=2*Math.PI*u, phi=Math.acos(2*v-1);
            const r = 1.8 + Math.random() * 0.6;
            const position = new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            allUserStars.push({ id, position, content: data.content, type: data.type, actions: data.actions });
        });
        
        const sortedStars = allUserStars.sort((a, b) => 
            new Date(a.content.publishedAt).getTime() - new Date(b.content.publishedAt).getTime()
        );

        if (sortedStars.length > 1) {
            const curve = new THREE.CatmullRomCurve3( sortedStars.map(s => s.position) );
            const points = curve.getPoints(sortedStars.length - 1);
            return sortedStars.map((star, i) => ({ ...star, position: points[i] }));
        }
        return sortedStars;
    }, [isHydrated, userContent, bookmarks, likes, shares, commentedContentSlugs]);

    const handleSetActiveStar = useCallback((star: StarData, position: ScreenPosition) => { setActiveStar(star); setActiveStarPosition(position); }, []);
    const handleClosePreview = useCallback(() => { setActiveStar(null); setActiveStarPosition(null); }, []);

    if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

    return (
        <>
            <AnimatePresence>
                {activeStar && activeStarPosition && ( <motion.div style={{ position: 'fixed', inset: 0, zIndex: 10000 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}> <StarPreviewCard starData={activeStar} position={activeStarPosition} onClose={handleClosePreview} /> </motion.div> )}
                {isPanelOpen && <ConstellationControlPanel settings={settings} setSettings={setSettings} onClose={() => setIsPanelOpen(false)} onPresetChange={handlePresetChange} isFullscreen={isFullscreen} onToggleFullscreen={() => setIsFullscreen(!isFullscreen)} />}
            </AnimatePresence>
            <div style={{ position: 'relative', width: '100%', height: 'calc(100vh - var(--nav-height-scrolled))' }}>
                <motion.button className={styles.settingsButton} onClick={() => setIsPanelOpen(true)} title="فتح إعدادات الكوكبة" whileHover={{ scale: 1.1, rotate: 90 }} transition={{ type: 'spring', stiffness: 500, damping: 20 }} whileTap={{ scale: 0.9 }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.5 } }}>
                    <CelestialGearIcon />
                </motion.button>
                <Canvas camera={{ position: [0, 0, 5] }}>
                    <Scene settings={settings} chronologicalStars={chronologicalStars} themeColors={themeColors} setActiveStar={handleSetActiveStar} />
                </Canvas>
                {chronologicalStars.length === 0 && ( <div style={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', textAlign: 'center', pointerEvents: 'none', padding: '2rem' }}> <motion.h1 className="page-title" style={{ fontSize: '6rem' }} initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.2, ease: 'easeOut' }}> كوكبتك في انتظارك </motion.h1> <motion.p style={{ maxWidth: '600px', fontSize: '2rem', color: 'var(--text-secondary)' }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.4, ease: 'easeOut' }}> بينما تستكشف وتعجب وتشارك، ستبدأ خريطتك النجمية الشخصية في التكون هنا. </motion.p> </div> )}
            </div>
        </>
    );
}




--- END OF FILE components/constellation/index.tsx ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.module.css ---

/* components/custom/FourImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}

--- END OF FILE components/custom/FourImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.tsx ---

// components/custom/FourImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import styles from './FourImageGrid.module.css';

export default function FourImageGrid({ value }: { value: any }) {
    const { image1, image2, image3, image4 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2, image3, image4].filter(img => img?.asset);
    if (images.length === 0) return null;
    
    const imageUrls = images.map(img => urlFor(img.asset).auto('format').quality(100).url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={() => openLightbox(imageUrls, index)}
                >
                    <Image
                        src={urlFor(image.asset).width(800).auto('format').quality(85).url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}

--- END OF FILE components/custom/FourImageGrid.tsx ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.module.css ---

/* components/custom/TwoImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}

--- END OF FILE components/custom/TwoImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.tsx ---

// components/custom/TwoImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import styles from './TwoImageGrid.module.css';

export default function TwoImageGrid({ value }: { value: any }) {
    const { image1, image2 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2].filter(img => img?.asset);
    if (images.length === 0) return null;

    const imageUrls = images.map(img => urlFor(img.asset).auto('format').quality(100).url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div 
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={() => openLightbox(imageUrls, index)}
                >
                    <Image
                        src={urlFor(image.asset).width(800).auto('format').quality(85).url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}

--- END OF FILE components/custom/TwoImageGrid.tsx ---

================================================================================

--- START OF FILE components/filters/ArticleFilters.tsx ---

// components/filters/ArticleFilters.tsx
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import { translateTag } from '@/lib/translations';
import styles from './Filters.module.css';

export default function ArticleFilters({ 
    sortOrder, onSortChange, searchTerm, onSearchChange, 
    allGames, selectedGame, onGameSelect, 
    allGameTags, selectedGameTags, onGameTagToggle,
    allArticleTypeTags, selectedArticleType, onArticleTypeSelect,
    onClearAllFilters 
}: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    
    const hasActiveFilters = !!selectedGame || selectedGameTags.length > 0 || !!selectedArticleType || searchTerm;

    return (
        <div className={styles.filtersContainer} ref={popoverRef}>
            <input type="search" placeholder="ابحث في المقالات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
            
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>الفرز حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    {[{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر رواجًا', value: 'viral' }].map(option => (
                        <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${sortOrder === option.value ? styles.active : ''}`}>
                            {option.label}
                            {sortOrder === option.value && <motion.div layoutId="article-sort-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>

            {/* THE FIX: New, dedicated filter group for Article Types */}
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>نوع المقال:</span>
                <div className={styles.filterButtonsGroup}>
                    <motion.button onClick={() => onArticleTypeSelect(null)} className={`${styles.filterButton} ${!selectedArticleType ? styles.active : ''}`}>
                        الكل
                        {!selectedArticleType && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                    {allArticleTypeTags.map((tag: any) => (
                        <motion.button key={tag._id} onClick={() => onArticleTypeSelect(tag)} className={`${styles.filterButton} ${selectedArticleType?._id === tag._id ? styles.active : ''}`}>
                            {translateTag(tag.title)}
                            {selectedArticleType?._id === tag._id && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>

            <div className={styles.filterGroup}>
                 <span className={styles.filterLabel}>التصفية بـ:</span>
                 <div className={styles.filterButtonsGroup}>
                    <motion.div style={{ position: 'relative' }} layout>
                        <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                        <AnimatePresence>
                            {openPopover === 'game' && (<GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} />)}
                        </AnimatePresence>
                    </motion.div>
                    <div style={{ position: 'relative' }}>
                        <SelectedTagsButton selectedTags={selectedGameTags} onOpenPopover={() => togglePopover('tags')} />
                        <AnimatePresence>
                            {openPopover === 'tags' && (<TagFilterPopover allTags={allGameTags} selectedTags={selectedGameTags} onTagToggle={(tag) => { onGameTagToggle(tag); }} />)}
                        </AnimatePresence>
                    </div>
                    <AnimatePresence>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAllFilters} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}> مسح المرشحات </motion.button>)}
                    </AnimatePresence>
                </div>
            </div>
        </div>
    );
}




--- END OF FILE components/filters/ArticleFilters.tsx ---

================================================================================

--- START OF FILE components/filters/Filters.module.css ---

/* components/filters/Filters.module.css */

/* --- Main Filter Container --- */
.filtersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  position: relative;
  z-index: 2;
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-main);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
  margin-left: 1.5rem; /* RTL spacing */
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

/* --- THE DEFINITIVE, CENTRALIZED FILTER BUTTON STYLES --- */
.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative;
  overflow: hidden;
}
.filterButton:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.filterButton.active {
  color: var(--bg-secondary);
  z-index: 2;
}

.filterButton.clear {
  color: var(--text-secondary);
  border-color: var(--border-color);
}

.filterButton.clear:hover {
  background-color: var(--border-color);
  color: var(--text-primary);
}

.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

@media (max-width: 768px) {
  .filterGroup {
    flex-direction: column;
    align-items: flex-start;
  }
}

/* --- Search Input (used in both filter bars) --- */
.searchInput {
  flex-grow: 1;
  min-width: 250px;
  padding: 1rem 1.5rem;
  font-size: 1.6rem;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  text-align: right; /* RTL */
}
.searchInput:focus {
  outline: none;
  border-color: var(--accent);
}

/* --- Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0; /* RTL */
  left: auto;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
  text-align: right; /* RTL */
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
  text-align: right; /* RTL */
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: right; /* RTL */
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-main);
  transition: background-color 0.1s ease-out;
}
.popoverItemButton:hover {
  background-color: var(--bg-primary);
}
.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

/* --- Selected Game Button --- */
.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem; /* RTL */
  margin-left: 0;
  flex-shrink: 0;
  cursor: pointer;
  color: currentColor; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
  z-index: 2;
}
.gameClearButton:hover {
  opacity: 1;
}
.gameSelectedButton.active {
  background-color: transparent;
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}




--- END OF FILE components/filters/Filters.module.css ---

================================================================================

--- START OF FILE components/filters/GameFilterPopover.tsx ---

// components/filters/GameFilterPopover.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useDebounce } from '@/hooks/useDebounce';
import { searchGamesAction } from '@/app/studio/actions';
import type { SanityGame } from '@/types/sanity';
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: -10 }, visible: { opacity: 1, x: 0 } };

export default function GameFilterPopover({ allGames, selectedGame, onGameSelect, onClose }: { allGames: SanityGame[], selectedGame: SanityGame | null, onGameSelect: (game: SanityGame | null) => void, onClose: () => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState<SanityGame[]>(allGames);
  const debouncedSearchTerm = useDebounce(searchTerm, 200);

  useEffect(() => {
    if (debouncedSearchTerm.length > 1) {
      searchGamesAction(debouncedSearchTerm).then(setResults);
    } else {
      setResults(allGames);
    }
  }, [debouncedSearchTerm, allGames]);

  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="Search for a game..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {results.map(game => (
          <motion.button key={game._id} variants={itemVariants} className={`${styles.popoverItemButton} ${selectedGame?._id === game._id ? styles.selected : ''}`} onClick={() => { onGameSelect(game); onClose(); }}>
            {game.title}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}







--- END OF FILE components/filters/GameFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/NewsFilterBar.tsx ---

// components/filters/NewsFilterBar.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import PopoverTriggerButton from './ui/PopoverTriggerButton';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import { usePopoverManager } from '@/hooks/usePopoverManager'; // <-- NEW HOOK IMPORT
import styles from './Filters.module.css';
import newsStyles from '../../app/news/NewsPage.module.css';

const SortPopover = ({ activeSort, onSortChange, onClose }: any) => {
    const sortOptions = [{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر انتشاراً', value: 'viral' }];
    return (
      <motion.div className={styles.filterPopover} variants={{ hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 } }} initial="hidden" animate="visible" exit="hidden" onClick={e => e.stopPropagation()}>
        {sortOptions.map(opt => (
          <button key={opt.value} className={`${styles.popoverItemButton} ${activeSort === opt.value ? styles.selected : ''}`} onClick={() => { onSortChange(opt.value); onClose(); }}>{opt.label}</button>
        ))}
      </motion.div>
    );
};
  
const TypePopover = ({ activeType, onTypeChange, onClose }: any) => {
    const typeOptions = [{ label: 'كل المصادر', value: 'الكل' }, { label: 'داخلي (يخص لعبة)', value: 'Internal' }, { label: 'خارجي (صناعة/عام)', value: 'External' }];
    return (
      <motion.div className={styles.filterPopover} variants={{ hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 } }} initial="hidden" animate="visible" exit="hidden" onClick={e => e.stopPropagation()}>
        {typeOptions.map(opt => (
          <button key={opt.value} className={`${styles.popoverItemButton} ${activeType === opt.value ? styles.selected : ''}`} onClick={() => { onTypeChange(opt.value); onClose(); }}>{opt.label}</button>
        ))}
      </motion.div>
    );
};

export default function NewsFilterBar({
  allCategories, activeCategory, onCategoryChange,
  allGames, selectedGame, onGameSelect,
  allTags, selectedTags, onTagToggle, onClearAll,
  activeSort, onSortChange, newsTypeFilter, onNewsTypeChange
}: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();

    const hasActiveFilters = !!selectedGame || selectedTags.length > 0 || newsTypeFilter !== 'الكل';
    const sortLabel = `Sort: ${activeSort === 'latest' ? 'Recent' : 'الأكثر رواجًا'}`;
    const typeLabel = `Type: ${newsTypeFilter === 'الكل' ? 'الكل' : newsTypeFilter}`;

    return (
        <div className={newsStyles.newsFilterBar} ref={popoverRef}>
            <div className={newsStyles.categoryTabs}>
                {allCategories.map((category: string, index: number) => (
                    <button
                        key={`${category}-${index}`}
                        onClick={() => onCategoryChange(category)}
                        className={`${newsStyles.categoryTab} ${activeCategory === category ? newsStyles.active : ''}`}
                    >
                        {category}
                        {activeCategory === category && (
                        <motion.div layoutId="news-category-underline" className={newsStyles.categoryUnderline} />
                        )}
                    </button>
                ))}
            </div>
            <div className={newsStyles.filterControls}>
                <div style={{ position: 'relative' }}>
                    <PopoverTriggerButton label={sortLabel} isActive={activeSort !== 'latest'} onClick={() => togglePopover('sort')} layoutId="news-sort-highlight" />
                    <AnimatePresence>{openPopover === 'sort' && <SortPopover activeSort={activeSort} onSortChange={onSortChange} onClose={closePopover} />}</AnimatePresence>
                </div>
                
                <div style={{ position: 'relative' }}>
                    <PopoverTriggerButton label={typeLabel} isActive={newsTypeFilter !== 'الكل'} onClick={() => togglePopover('type')} layoutId="news-type-highlight" />
                    <AnimatePresence>{openPopover === 'type' && <TypePopover activeType={newsTypeFilter} onTypeChange={onNewsTypeChange} onClose={closePopover} />}</AnimatePresence>
                </div>

                <div style={{ position: 'relative' }}>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>
                        {openPopover === 'game' && <GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} />}
                    </AnimatePresence>
                </div>

                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>
                        {openPopover === 'tags' && <TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); closePopover(); }} />}
                    </AnimatePresence>
                </div>

                <AnimatePresence>
                    {hasActiveFilters && (
                        <motion.div initial={{ opacity: 0, width: 0 }} animate={{ opacity: 1, width: 'auto' }} exit={{ opacity: 0, width: 0 }}>
                        <PopoverTriggerButton label="مسح" isActive={false} onClick={onClearAll} className={styles.clear} />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}







--- END OF FILE components/filters/NewsFilterBar.tsx ---

================================================================================

--- START OF FILE components/filters/ReviewFilters.tsx ---

// components/filters/ReviewFilters.tsx
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import ScoreFilterPopover from './ScoreFilterPopover';
import PopoverTriggerButton from './ui/PopoverTriggerButton';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import styles from './Filters.module.css';

export type SortOption = 'latest' | 'score';
export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';

const sortOptions: { label: string; value: SortOption }[] = [ { label: 'الأحدث', value: 'latest' }, { label: 'الأعلى تقييمًا', value: 'score' }, ];
const scoreRangeMap: Record<ScoreFilter, string> = { 'All': 'الكل', '9-10': '9-10', '8-8.9': '8-8.9', '7-7.9': '7-7.9', '<7': '<7' };

export default function ReviewFilters({ activeSort, onSortChange, selectedScoreRange, onScoreSelect, allGames, selectedGame, onGameSelect, allTags, selectedTags, onTagToggle, onClearAll, searchTerm, onSearchChange }: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();

    const scoreButtonLabel = selectedScoreRange === 'All' ? 'التقييم' : `التقييم: ${scoreRangeMap[selectedScoreRange]}`;
    const hasActiveFilters = selectedScoreRange !== 'All' || !!selectedGame || selectedTags.length > 0 || searchTerm;

    return (
        <div className={styles.filtersContainer}>
            <input type="search" placeholder="ابحث في المراجعات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} style={{ width: '100%', marginBottom: '1.5rem', marginTop: '0.5rem' }} />
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>الفرز حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    {sortOptions.map(option => (
                        <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                            {option.label}
                            {activeSort === option.value && <motion.div layoutId="sort-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
            <div className={styles.filterGroup} ref={popoverRef}>
                <span className={styles.filterLabel}>التصفية حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    <div style={{ position: 'relative' }}>
                        <PopoverTriggerButton label={scoreButtonLabel} isActive={selectedScoreRange !== 'All'} onClick={() => togglePopover('score')} layoutId="review-score-highlight" />
                        <AnimatePresence>{openPopover === 'score' && (<ScoreFilterPopover selectedScoreRange={selectedScoreRange} onScoreSelect={(score) => { onScoreSelect(score); closePopover(); }} onClose={closePopover} />)}</AnimatePresence>
                    </div>
                    <motion.div style={{ position: 'relative' }} layout>
                        <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                        <AnimatePresence>{openPopover === 'game' && (<GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} />)}</AnimatePresence>
                    </motion.div>
                    <div style={{ position: 'relative' }}>
                        <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                        <AnimatePresence>{openPopover === 'tags' && (<TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); closePopover(); }} />)}</AnimatePresence>
                    </div>
                    <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}>مسح الكل</motion.button>)}</AnimatePresence>
                </div>
            </div>
        </div>
    );
}




--- END OF FILE components/filters/ReviewFilters.tsx ---

================================================================================

--- START OF FILE components/filters/ScoreFilterPopover.tsx ---

// components/filters/ScoreFilterPopover.tsx
'use client';
import { motion } from 'framer-motion';
import styles from './Filters.module.css';

export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';
const scoreFilters: { label: string; value: ScoreFilter }[] = [
    { label: 'كل التقييمات', value: 'All' },
    { label: 'تحفة فنية (9-10)', value: '9-10' },
    { label: 'رائعة (8-8.9)', value: '8-8.9' },
    { label: 'جيدة (7-7.9)', value: '7-7.9' },
    { label: 'متفاوتة (<7)', value: '<7' },
];
const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: 10 }, visible: { opacity: 1, x: 0 } }; // RTL: from right

export default function ScoreFilterPopover({ selectedScoreRange, onScoreSelect, onClose }: { selectedScoreRange: ScoreFilter, onScoreSelect: (score: ScoreFilter) => void, onClose: () => void }) {
  return (
    <motion.div className={styles.filterPopover} style={{ width: '220px' }} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <div className={styles.popoverResultsList}>
        {scoreFilters.map(filter => (
          <motion.button key={filter.value} variants={itemVariants} className={`${styles.popoverItemButton} ${selectedScoreRange === filter.value ? styles.selected : ''}`} onClick={() => { onScoreSelect(filter.value); onClose(); }}>
            {filter.label}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}




--- END OF FILE components/filters/ScoreFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/TagFilterPopover.tsx ---

// components/filters/TagFilterPopover.tsx
'use client';
import { useState } from 'react';
import { motion } from 'framer-motion';
import type { SanityTag } from '@/types/sanity';
import { translateTag } from '@/lib/translations'; // Import the translator
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: -10, scale: 0.95 }, };

export default function TagFilterPopover({ allTags, selectedTags, onTagToggle }: { allTags: SanityTag[], selectedTags: SanityTag[], onTagToggle: (tag: SanityTag) => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  const selectedTagIds = new Set(selectedTags.map(t => t._id));

  // DEFINITIVE FIX: Search both the original English title and the translated Arabic title.
  const filteredTags = allTags.filter(tag => 
    tag.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
    translateTag(tag.title).toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="ابحث عن وسم..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {filteredTags.map(tag => (
          <motion.button key={tag._id} className={`${styles.popoverItemButton} ${selectedTagIds.has(tag._id) ? styles.selected : ''}`} onClick={() => onTagToggle(tag)}>
            {translateTag(tag.title)}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}




--- END OF FILE components/filters/TagFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

// components/filters/ui/PopoverTriggerButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';

interface PopoverTriggerButtonProps {
    label: string;
    isActive: boolean;
    onClick: () => void;
    className?: string;
    layoutId?: string; // Prop is now used to pass a UNIQUE ID
}

export default function PopoverTriggerButton({ label, isActive, onClick, className = '', layoutId }: PopoverTriggerButtonProps) {
    return (
        <motion.button
            onClick={onClick}
            className={`${styles.filterButton} ${isActive ? styles.active : ''} ${className}`}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
        >
            {/* The highlight is only rendered if a layoutId is provided */}
            {isActive && layoutId && <motion.div layoutId={layoutId} className={styles.filterHighlight} />}
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.button>
    );
}







--- END OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedGameButton.tsx ---

// components/filters/ui/SelectedGameButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityGame } from '@/types/sanity';

interface SelectedGameButtonProps {
    selectedGame: SanityGame | null;
    onClearGame: (game: null) => void;
    onOpenPopover: () => void;
}

export default function SelectedGameButton({ selectedGame, onClearGame, onOpenPopover }: SelectedGameButtonProps) {
    if (!selectedGame) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>اللعبة</button>
        );
    }

    // The root element is now a simple motion.div with the layout prop to prevent flickering.
    return (
        <motion.div layout className={`${styles.filterButton} ${styles.gameSelectedButton} ${styles.active}`} onClick={onOpenPopover}>
            {/* The animated highlight is now self-contained for consistency */}
            <motion.div layoutId="game-highlight" className={styles.filterHighlight} />
            <span style={{ marginRight: '0.75rem', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', zIndex: 1, position: 'relative' }}>
                {selectedGame.title}
            </span>
            <motion.button
                className={styles.gameClearButton}
                onClick={(e) => {
                    e.stopPropagation();
                    onClearGame(null);
                }}
                whileTap={{ scale: 0.9 }}
            >
                {/* The SVG is now correctly styled to be visible against the cyan background */}
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </motion.button>
        </motion.div>
    );
}







--- END OF FILE components/filters/ui/SelectedGameButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedTagsButton.tsx ---

// components/filters/ui/SelectedTagsButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityTag } from '@/types/sanity';

interface SelectedTagsButtonProps {
    selectedTags: SanityTag[];
    onOpenPopover: () => void;
}

export default function SelectedTagsButton({ selectedTags, onOpenPopover }: SelectedTagsButtonProps) {
    const isActive = selectedTags.length > 0;
    const label = isActive ? `الوسوم (${selectedTags.length})` : "الوسوم";

    if (!isActive) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>
                {label}
            </button>
        );
    }
    
    return (
        <motion.button
            layout
            className={`${styles.filterButton} ${styles.active}`}
            onClick={onOpenPopover}
            whileHover={{ scale: 1.05 }}
        >
            <motion.div layoutId="tags-highlight" className={styles.filterHighlight} />
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.button>
    );
}




--- END OF FILE components/filters/ui/SelectedTagsButton.tsx ---

================================================================================

--- START OF FILE components/forms/Form.module.css ---

/* components/forms/Form.module.css */
.formGroup {
  position: relative;
  margin-bottom: 2.5rem;
}

.formLabel {
  position: absolute;
  right: 1.5rem;
  top: 1.3rem;
  font-family: var(--font-ui);
  font-size: 1.6rem;
  color: var(--text-secondary);
  pointer-events: none;
  transition: all 0.2s ease-out;
}

.input:focus ~ .formLabel,
.input:not(:placeholder-shown) ~ .formLabel,
.formGroup.hasContent .formLabel {
  top: -2rem;
  right: 0;
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--accent);
}

.input {
  width: 100%;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
  font-family: var(--font-ui);
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
}

.input::placeholder {
  color: transparent; /* Hide placeholder for floating label effect */
}







--- END OF FILE components/forms/Form.module.css ---

================================================================================

--- START OF FILE components/icons/EternalGamesIcon.tsx ---

export default function EternalGamesIcon(props: React.SVGProps<SVGSVGElement>) {
return (
<svg fill="currentColor" viewBox="0 0 512 512" aria-hidden="true" {...props}>
<path d="M365.3,160H298.6c-4.4,0-8,3.6-8,8v16c0,4.4,3.6,8,8,8h29.4c15.2,0,28.2,5.6,38.6,16.2c11.3,11.5,17.4,26.9,17.4,42.8c0,15.9-6.1,31.3-17.4,42.8c-10.4,10.6-23.4,16.2-38.6,16.2H298.6c-4.4,0-8,3.6-8,8v16c0,4.4,3.6,8,8,8h66.7c29.7,0,56.7-11.4,76.5-31.5c20.1-20.4,31.2-47.8,31.2-77.5c0-29.7-11.1-57.1-31.2-77.5C422,171.4,395,160,365.3,160z M146.7,160h-66.7c-4.4,0-8,3.6-8,8v16c0,4.4,3.6,8,8,8h29.4c15.2,0,28.2,5.6,38.6,16.2c11.3,11.5,17.4,26.9,17.4,42.8c0,15.9-6.1,31.3-17.4,42.8c-10.4,10.6-23.4,16.2-38.6,16.2H72c-4.4,0-8,3.6-8,8v16c0,4.4,3.6,8,8,8h74.7c29.7,0,56.7-11.4,76.5-31.5c20.1-20.4,31.2-47.8,31.2-77.5c0-29.7-11.1-57.1-31.2-77.5C203.3,171.4,176.4,160,146.7,160z" />
</svg>
);
}





























--- END OF FILE components/icons/EternalGamesIcon.tsx ---

================================================================================

--- START OF FILE components/icons/GitHubIcon.tsx ---

export default function GitHubIcon(props: React.SVGProps<SVGSVGElement>) {
return (
<svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" {...props}>
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
</svg>
);
}





























--- END OF FILE components/icons/GitHubIcon.tsx ---

================================================================================

--- START OF FILE components/icons/GoogleIcon.tsx ---

export default function GoogleIcon(props: React.SVGProps<SVGSVGElement>) {
return (
<svg viewBox="0 0 48 48" fill="currentColor" aria-hidden="true" {...props}>
<path d="M45.12 24.5c0-1.56-.14-3.06-.4-4.5H24v8.51h11.84c-.51 2.75-2.06 5.08-4.39 6.64v5.52h7.11c4.16-3.83 6.56-9.47 6.56-16.17z" />
<path d="M24 46c5.94 0 10.92-1.96 14.56-5.3l-7.11-5.52c-1.97 1.32-4.49 2.1-7.45 2.1-5.73 0-10.58-3.87-12.31-9.07H4.34v5.7C7.96 40.5 15.4 46 24 46z" />
<path d="M11.69 28.18c-.38-1.13-.6-2.33-.6-3.58s.22-2.45.6-3.58v-5.7H4.34C2.96 18.05 2 20.9 2 24.6c0 3.7.96 6.55 2.34 9.28l7.35-5.7z" />
<path d="M24 10.75c3.23 0 6.13 1.11 8.41 3.29l6.31-6.31C34.91 4.18 29.93 2 24 2 15.4 2 7.96 7.5 4.34 13.37l7.35 5.7c1.73-5.2 6.58-9.02 12.31-9.02z" />
</svg>
);
}





























--- END OF FILE components/icons/GoogleIcon.tsx ---

================================================================================

--- START OF FILE components/icons/XIcon.tsx ---

export default function XIcon(props: React.SVGProps<SVGSVGElement>) {
return (
<svg viewBox="0 0 1200 1227" fill="currentColor" aria-hidden="true" {...props}>
<path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
</svg>
);
}





























--- END OF FILE components/icons/XIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PCIcon.tsx ---

// components/icons/platforms/PCIcon.tsx
export default function PCIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 24 24" fill="currentColor" {...props}>
            <path d="M4 2H20C21.1 2 22 2.9 22 4V16C22 17.1 21.1 18 20 18H13V20H15V22H9V20H11V18H4C2.9 18 2 17.1 2 16V4C2 2.9 2.9 2 4 2M4 4V16H20V4H4Z" />
        </svg>
    );
}







--- END OF FILE components/icons/platforms/PCIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PS5Icon.tsx ---

// components/icons/platforms/PS5Icon.tsx
export default function PS5Icon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M3.262 24.248c-2.374-0.681-2.767-2.084-1.69-2.899 0.776-0.51 1.668-0.954 2.612-1.288l0.087-0.027 7.017-2.516v2.89l-5.030 1.839c-0.881 0.339-1.031 0.79-0.299 1.032 0.365 0.093 0.783 0.147 1.214 0.147 0.615 0 1.204-0.109 1.749-0.308l-0.035 0.011 2.422-0.882v2.592c-0.15 0.037-0.32 0.055-0.487 0.091-0.775 0.136-1.667 0.214-2.577 0.214-1.778 0-3.486-0.298-5.078-0.846l0.11 0.033zM18.049 24.544l7.868-2.843c0.893-0.322 1.032-0.781 0.307-1.022-0.363-0.089-0.779-0.14-1.208-0.14-0.622 0-1.22 0.108-1.774 0.305l0.037-0.011-5.255 1.874v-2.983l0.3-0.106c1.050-0.349 2.284-0.62 3.557-0.761l0.083-0.008c0.468-0.050 1.010-0.078 1.559-0.078 1.877 0 3.677 0.331 5.343 0.939l-0.108-0.035c2.309 0.751 2.549 1.839 1.969 2.589-0.559 0.557-1.235 0.998-1.988 1.282l-0.039 0.013-10.677 3.883v-2.869zM12.231 4.248v21.927l4.892 1.576v-18.39c0-0.862 0.38-1.438 0.992-1.238 0.795 0.225 0.95 1.017 0.95 1.881v7.342c3.050 1.491 5.451-0.003 5.451-3.939 0-4.045-1.407-5.842-5.546-7.282-1.785-0.648-4.040-1.294-6.347-1.805l-0.389-0.072z" />
        </svg>
    );
}







--- END OF FILE components/icons/platforms/PS5Icon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/SwitchIcon.tsx ---

// components/icons/platforms/SwitchIcon.tsx
export default function SwitchIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M18.901 32h4.901c4.5 0 8.198-3.698 8.198-8.198v-15.604c0-4.5-3.698-8.198-8.198-8.198h-5c-0.099 0-0.203 0.099-0.203 0.198v31.604c0 0.099 0.099 0.198 0.302 0.198zM25 14.401c1.802 0 3.198 1.5 3.198 3.198 0 1.802-1.5 3.198-3.198 3.198-1.802 0-3.198-1.396-3.198-3.198-0.104-1.797 1.396-3.198 3.198-3.198zM15.198 0h-7c-4.5 0-8.198 3.698-8.198 8.198v15.604c0 4.5 3.698 8.198 8.198 8.198h7c0.099 0 0.203-0.099 0.203-0.198v-31.604c0-0.099-0.099-0.198-0.203-0.198zM12.901 29.401h-4.703c-3.099 0-5.599-2.5-5.599-5.599v-15.604c0-3.099 2.5-5.599 5.599-5.599h4.604zM5 9.599c0 1.698 1.302 3 3 3s3-1.302 3-3c0-1.698-1.302-3-3-3s-3 1.302-3 3z"/>
        </svg>
    );
}







--- END OF FILE components/icons/platforms/SwitchIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/XboxIcon.tsx ---

// components/icons/platforms/XboxIcon.tsx
export default function XboxIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M16 5.425c-1.888-1.125-4.106-1.922-6.473-2.249l-0.092-0.010c-0.070-0.005-0.152-0.008-0.234-0.008-0.613 0-1.188 0.16-1.687 0.441l0.017-0.009c2.357-1.634 5.277-2.61 8.426-2.61 0.008 0 0.016 0 0.024 0h0.019c0.005 0 0.011 0 0.018 0 3.157 0 6.086 0.976 8.501 2.642l-0.050-0.033c-0.478-0.272-1.051-0.433-1.662-0.433-0.085 0-0.169 0.003-0.252 0.009l0.011-0.001c-2.459 0.336-4.677 1.13-6.648 2.297l0.082-0.045zM5.554 5.268c-0.041 0.014-0.077 0.032-0.11 0.054l0.002-0.001c-2.758 2.723-4.466 6.504-4.466 10.684 0 3.584 1.256 6.875 3.353 9.457l-0.022-0.028c-1.754-3.261 4.48-12.455 7.61-16.159-3.53-3.521-5.277-4.062-6.015-4.062-0.010-0-0.021-0.001-0.032-0.001-0.115 0-0.225 0.021-0.326 0.060l0.006-0.002zM20.083 9.275c3.129 3.706 9.367 12.908 7.605 16.161 2.075-2.554 3.332-5.845 3.332-9.43 0-4.181-1.709-7.962-4.467-10.684l-0.002-0.002c-0.029-0.021-0.063-0.039-0.1-0.052l-0.003-0.001c-0.1-0.036-0.216-0.056-0.336-0.056-0.005 0-0.011 0-0.016 0h0.001c-0.741-0-2.485 0.543-6.014 4.063zM6.114 27.306c2.627 2.306 6.093 3.714 9.888 3.714s7.261-1.407 9.905-3.728l-0.017 0.015c2.349-2.393-5.402-10.901-9.89-14.29-4.483 3.39-12.24 11.897-9.886 14.29z" />
        </svg>
    );
}







--- END OF FILE components/icons/platforms/XboxIcon.tsx ---

================================================================================

--- START OF FILE components/modals/Modals.module.css ---

/* components/modals/Modals.module.css */

.modalOverlay {
  position: fixed;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5000;
}

.modalContent {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 3rem;
  max-width: 450px;
  width: 100%;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

.modalActions {
  display: flex;
  justify-content: flex-start;
  gap: 1rem;
}







--- END OF FILE components/modals/Modals.module.css ---

================================================================================

--- START OF FILE components/ui/ButtonLoader.tsx ---

'use client';

import { motion } from 'framer-motion';

export default function ButtonLoader() {
return (
<motion.svg
className="stateful-button-loader"
viewBox="0 0 50 50"
initial={{ opacity: 0 }}
animate={{ opacity: 1 }}
exit={{ opacity: 0 }}
>
<motion.circle cx="25" cy="25" r="20" fill="none" strokeWidth="4" />
</motion.svg>
);
}





























--- END OF FILE components/ui/ButtonLoader.tsx ---

================================================================================

--- START OF FILE components/ui/StatefulButton.module.css ---

/* components/ui/StatefulButton.module.css */

.statefulButton {
    position: relative;
    overflow: hidden;
    transition: width 0.4s ease, height 0.4s ease, border-radius 0.4s ease, background-color 0.2s ease, transform 0.2s ease-out, box-shadow 0.2s ease-out !important;
  }
  
  .loader {
    position: absolute;
    top: 50%;
    right: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
  }
  
  .loader circle {
    stroke: #fff;
  }
  
  [data-theme="dark"] .loader circle {
    stroke: var(--bg-primary);
  }
  
  /* For Editor Save Button */
  .saveButton {
    min-width: 140px;
    min-height: 44px;
  }
  
  .saveButton.saving,
  .saveButton.success {
    color: transparent; /* Hide text during animation */
  }
  
  .saveButton.success {
    background-color: #16A34A;
  }
  
  .saveButton.error {
    background-color: #DC2626;
    animation: shake 0.5s ease-in-out;
  }
  
  @keyframes shake {
    0%, 100% { transform: translateX(-0); }
    25% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
  }
  
  .saveButtonContent {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
  }







--- END OF FILE components/ui/StatefulButton.module.css ---

================================================================================

--- START OF FILE components/ui/Toast.tsx ---

// components/ui/Toast.tsx

'use client';

import { motion } from 'framer-motion';
import { useEffect } from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastProps {
id: string;
message: string;
type: ToastType;
onDismiss: (id: string) => void;
duration?: number;
}

const icons: Record<ToastType, JSX.Element> = {
success: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>,
error: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
info: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>,
};

//  DEFINITIVE FIX FOR COLORS
// 'success' now uses the brand's accent color.
const bgColors: Record<ToastType, string> = {
success: 'var(--accent)',
error: '#DC2626',
info: '#6B7280', // Using a neutral secondary text color for info
};

const toastVariants = {
initial: { opacity: 0, y: 50, scale: 0.8 },
animate: { opacity: 1, y: 0, scale: 1, transition: { type: 'spring', damping: 20, stiffness: 200 } },
exit: { opacity: 0, scale: 0.9, transition: { duration: 0.2, ease: 'easeOut' } },
};

export const Toast = ({ id, message, type, onDismiss, duration = 5000 }: ToastProps) => {
useEffect(() => {
const timer = setTimeout(() => {
onDismiss(id);
}, duration);

return () => clearTimeout(timer);
}, [id, duration, onDismiss]);

return (
<motion.div
layout
variants={toastVariants}
initial="initial"
animate="animate"
exit="exit"
style={{
display: 'flex',
alignItems: 'center',
gap: '1rem',
padding: '1.25rem 1.5rem',
borderRadius: '8px',
color: '#fff',
backgroundColor: bgColors[type],
boxShadow: '0 10px 25px -5px rgba(0,0,0,0.2)',
width: '100%',
maxWidth: '380px',
}}
>
<div style={{ flexShrink: 0 }}>{icons[type]}</div>
<p style={{ margin: 0, flexGrow: 1, fontWeight: 500 }}>{message}</p>
<button onClick={() => onDismiss(id)} style={{ background: 'none', border: 'none', color: 'inherit', cursor: 'pointer', padding: '0.25rem', marginLeft: 'auto' }}>
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
</button>
</motion.div>
);
};





























--- END OF FILE components/ui/Toast.tsx ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.module.css ---

/* components/VanguardReviews/VanguardReviews.module.css */

.vanguardContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 500px;
    position: relative;
    padding: 6rem 0 12rem 0;
    --card-gap: 1.5rem;
    --center-width: 400px;
    --side-width: 280px;
}

.spotlightGlow {
    position: absolute;
    width: 800px;
    height: 800px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle at 50% 50%, color-mix(in srgb, var(--accent) 15%, transparent) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
}

.cardSlot {
    position: absolute;
    transition: transform 0.7s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.5s ease-out;
}

.cardWrapper {
    height: 100%;
    will-change: transform;
    transition: filter 0.4s ease-out;
    position: relative;
}

.vanguardContainer[data-hovered="true"] .cardWrapper {
    filter: brightness(0.6) saturate(0.8);
}

.vanguardContainer[data-hovered="true"] .cardSlot:hover .cardWrapper {
    filter: brightness(1) saturate(1);
}

.vanguardCard {
    background-color: var(--bg-secondary);
    border-radius: 12px;
    overflow: visible;
    height: 100%;
    border: 1px solid var(--border-color);
    box-shadow: 0 20px 40px -15px rgba(0,0,0,0.5);
    color: #fff;
    position: relative;
    transition: border-color 0.3s ease-out;
}

.cardSlot:hover .vanguardCard {
    border-color: var(--accent);
}

.cardImageContainer {
    position: absolute;
    inset: 0;
    border-radius: 12px;
    overflow: hidden;
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
}

.cardSlot:hover .cardImage {
    transform: scale(1.05);
}

.cardContent {
    position: absolute;
    inset: 0;
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    text-align: right;
    border-radius: 12px;
    pointer-events: none;
}

.cardContent h3 { font-size: 2rem; line-height: 1.3; margin: 0; }

.vanguardScoreBadge {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: var(--accent);
    color: var(--bg-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-heading), sans-serif;
    font-weight: 800;
    font-size: 2.2rem;
    border: none;
    box-shadow: 0 0 20px 0px color-mix(in srgb, var(--accent) 80%, transparent);
    z-index: 3;
    transform: translateZ(60px);
    transition: transform 0.4s ease, box-shadow 0.4s ease;
}

.cardSlot:hover .vanguardScoreBadge {
    transform: translateZ(80px) scale(1.05);
    box-shadow: 0 0 25px 3px color-mix(in srgb, var(--accent) 90%, transparent);
}


/* --- LATEST SETTINGS CONFIRMED --- */
.creatorBubbleContainer {
    position: absolute;
    top: 30%;
    right: -3.5rem;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.1rem;
    z-index: 5;
}

.creatorBubble {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    background-color: var(--bg-secondary);
    border: 1.2px solid var(--accent);
    border-radius: 999px;
    padding: 0.3rem 1.2rem;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

.creatorBubble:hover {
    background-color: var(--accent);
    box-shadow: 0 0 15px -0.5px var(--accent);
}

.creatorLabel { color: var(--text-secondary); font-size: 1rem; font-weight: 500; transition: color 0.3s ease; }
.creatorBubble:hover .creatorLabel { color: color-mix(in srgb, var(--bg-primary) 70%, transparent); }
.creatorName { font-size: 1.2rem; font-weight: 600; transition: color 0.3s ease; }
.creatorBubble:hover .creatorName { color: var(--bg-primary); }
.creatorArrow { position: absolute; left: -18px; top: 50%; transform: translateY(-50%); color: var(--accent); transition: opacity 0.3s ease, transform 0.3s ease; opacity: 0; }
.creatorBubble:hover .creatorArrow { opacity: 1; transform: translateY(-50%) translateX(-5px); }

.kineticNavigator {
    position: absolute;
    bottom: -3rem;
    width: 100%;
    display: flex;
    justify-content: center;
}

.navTrack {
    display: flex;
    flex-direction: row-reverse;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    backdrop-filter: blur(10px);
    z-index: 10;
    max-width: 90vw;
    overflow-x: auto;
    scrollbar-width: none;
}
.navTrack::-webkit-scrollbar { display: none; }

.navItem {
    position: relative;
    border-radius: 8px;
    cursor: pointer;
    overflow: hidden;
    border: 1px solid transparent;
    transition: border-color 0.4s ease;
}

.navImage {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: filter 0.4s ease, transform 0.4s ease;
}

.navItem[data-active="false"] .navImage {
    filter: grayscale(100%) brightness(0.7);
}

.navItem[data-active="true"] {
    border-color: var(--accent);
    box-shadow: 0 0 15px -2px var(--accent);
}

.navTitle {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 8px;
    font-size: 1.2rem;
    font-weight: 600;
    color: #fff;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
    text-align: right;
}

--- END OF FILE components/VanguardReviews/VanguardReviews.module.css ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.tsx ---

// components/VanguardReviews/VanguardReviews.tsx
'use client';

import { useState, useEffect, useRef, memo, useCallback } from 'react';
import { motion, AnimatePresence, useInView, animate } from 'framer-motion';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import Link from 'next/link';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import type { SanityAuthor } from '@/types/sanity';
import type { CardProps } from '@/types';
import styles from './VanguardReviews.module.css';

const VANGUARD_SLOTS = 5;
const ANIMATION_COOLDOWN = 450;

const creatorBubbleContainerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.15, delayChildren: 0.2 } }
};
const creatorBubbleItemVariants = {
    hidden: { opacity: 0, x: 20 },
    visible: { opacity: 1, x: 0, transition: { type: 'spring', stiffness: 300, damping: 20 } }
};
const ArrowIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="22" y1="12" x2="2" y2="12"></line><polyline points="15 5 22 12 15 19"></polyline></svg>;
const CreatorBubble = ({ label, creator }: { label: string, creator: SanityAuthor }) => {
    const bubbleContent = (
        <motion.div 
            className={styles.creatorBubble} 
            whileHover={{ scale: 1.1, x: -10, transition: { type: 'spring', stiffness: 400, damping: 15 } }}
        >
            <span className={styles.creatorLabel}>{label}</span>
            <span className={styles.creatorName}>{creator.name}</span>
            <div className={styles.creatorArrow}><ArrowIcon /></div>
        </motion.div>
    );
    return (
        <motion.div variants={creatorBubbleItemVariants}>
            {creator.username ? (
                <Link href={`/creators/${creator.username}`} passHref legacyBehavior>
                    <a onClick={(e) => e.stopPropagation()} className="no-underline" title={`View creator profile for ${creator.name}`}>{bubbleContent}</a>
                </Link>
            ) : (<div title={`${creator.name} (no public profile)`}>{bubbleContent}</div>)}
        </motion.div>
    );
};
const VanguardCard = memo(({ review, isCenter, isInView }: { review: CardProps, isCenter: boolean, isInView: boolean }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();
    const router = useRouter(); const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const [isCardHovered, setIsCardHovered] = useState(false); const layoutIdPrefix = "vanguard-reviews";
    const scoreRef = useRef<HTMLParagraphElement>(null);
    useEffect(() => {
        if (isInView && scoreRef.current && typeof review.score === 'number') {
            const controls = animate(0, review.score, {
                duration: 1.5, ease: [0.22, 1, 0.36, 1],
                onUpdate(value) { if (scoreRef.current) { scoreRef.current.textContent = value.toFixed(1); } }
            });
            return () => controls.stop();
        }
    }, [isInView, review.score]);
    const handleClick = (e: React.MouseEvent) => { e.preventDefault(); setPrefix(layoutIdPrefix); router.push(`/reviews/${review.slug}`, { scroll: false }); };
    const imageParams = isCenter ? 'w=800&h=1000' : 'w=560&h=700';
    const baseUrl = review.imageUrl.split('?')[0]; const imageUrl = `${baseUrl}?${imageParams}&fit=crop&auto=format&q=80`;
    const showCredits = isCenter || isCardHovered;
    return (
        <motion.div ref={livingCardRef} onMouseMove={livingCardAnimation.onMouseMove} onMouseEnter={() => { livingCardAnimation.onHoverStart(); setIsCardHovered(true); }} onMouseLeave={() => { livingCardAnimation.onHoverEnd(); setIsCardHovered(false); }} className={styles.cardWrapper} style={{...livingCardAnimation.style, transformStyle: 'preserve-3d'}}>
            <Link href={`/reviews/${review.slug}`} onClick={handleClick} className="no-underline" style={{ display: 'block', height: '100%', cursor: 'pointer' }}>
                <div className={styles.vanguardCard}>
                    {typeof review.score === 'number' && (<div className={styles.vanguardScoreBadge}><p ref={scoreRef} style={{ margin: 0 }}>0.0</p></div>)}
                    <div className={styles.cardImageContainer}><Image src={imageUrl} alt={review.title} fill sizes="(max-width: 768px) 50vw, 30vw" className={styles.cardImage} placeholder="blur" blurDataURL={review.blurDataURL} unoptimized /></div>
                    <motion.div className={styles.cardContent} animate={{ background: isCenter ? 'linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 50%)' : 'linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 60%)' }} transition={{ duration: 0.5, ease: 'circOut' }}><h3>{review.title}</h3></motion.div>
                </div>
            </Link>
            <AnimatePresence>
                {showCredits && (
                    <motion.div className={styles.creatorBubbleContainer} variants={creatorBubbleContainerVariants} initial="hidden" animate="visible" exit="hidden">
                        {review.authors.map(author => <CreatorBubble key={author._id} label="مراجعة" creator={author} />)}
                        {review.designers?.map(designer => <CreatorBubble key={designer._id} label="تصميم" creator={designer} />)}
                    </motion.div>
                )}
            </AnimatePresence>
        </motion.div>
    );
});
VanguardCard.displayName = "VanguardCard";
const KineticNavigator = ({ reviews, currentIndex, navigateToIndex }: { reviews: CardProps[], currentIndex: number, navigateToIndex: (index: number) => void }) => {
    const itemRefs = useRef<(HTMLButtonElement | null)[]>([]);
    useEffect(() => { const activeItem = itemRefs.current[currentIndex]; if (activeItem) { activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' }); } }, [currentIndex]);
    return (
        <div className={styles.kineticNavigator}>
            <div className={styles.navTrack}>
                {reviews.map((review, index) => {
                    const isActive = currentIndex === index;
                    return (
                        <motion.button key={review.id} ref={el => itemRefs.current[index] = el} className={styles.navItem} data-active={isActive} onClick={() => navigateToIndex(index)} animate={{ width: isActive ? 100 : 50, height: isActive ? 60 : 40 }} transition={{ type: 'spring', stiffness: 400, damping: 30 }}>
                            <Image src={`${review.imageUrl.split('?')[0]}?w=200&auto=format&q=70`} alt={review.title} fill sizes="10vw" className={styles.navImage} unoptimized />
                            <AnimatePresence>{isActive && <motion.div className={styles.navTitle} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{review.title}</motion.div>}</AnimatePresence>
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
};

export default function VanguardReviews({ reviews }: { reviews: CardProps[] }) {
    const [currentIndex, setCurrentIndex] = useState(0);
    const [hoveredId, setHoveredId] = useState<string | number | null>(null);
    const intervalRef = useRef<NodeJS.Timeout | null>(null);
    const [isAnimating, setIsAnimating] = useState(false);
    const containerRef = useRef(null);
    
    const [isClient, setIsClient] = useState(false);
    useEffect(() => { setIsClient(true); }, []);

    const hasAnimatedIn = useInView(containerRef, { once: true, amount: 0.1 });
    const isCurrentlyInView = useInView(containerRef, { amount: 0.4 });
    
    const stopInterval = useCallback(() => {
        if (intervalRef.current) clearInterval(intervalRef.current);
    }, []);
    
    const startInterval = useCallback(() => {
        stopInterval();
        intervalRef.current = setInterval(() => {
            setCurrentIndex(prevIndex => (prevIndex + 1) % reviews.length);
        }, 2500);
    }, [reviews.length, stopInterval]);
    
    const navigateToIndex = useCallback((index: number) => {
        if (isAnimating || index === currentIndex) return;
        setIsAnimating(true);
        setCurrentIndex(index);
        startInterval();
        setTimeout(() => setIsAnimating(false), ANIMATION_COOLDOWN);
    }, [isAnimating, currentIndex, startInterval]);
    
    useEffect(() => {
        if (!hoveredId && isCurrentlyInView) {
            startInterval();
        } else {
            stopInterval();
        }
        return () => stopInterval();
    }, [hoveredId, isCurrentlyInView, startInterval, stopInterval]);
    
    const getSlotStyle = (index: number, reviewId: string | number) => {
        const style: any = { width: `var(--${index === 2 ? 'center' : 'side'}-width)`, height: index === 2 ? '500px' : '350px', opacity: 1, zIndex: 0 };
        const offset = (isClient && window.innerWidth > 768) ? 250 : 160;
        let transform = '';
        switch (index) {
            case 0: transform = `translateX(${-offset * 1.7}px) scale(0.75)`; break;
            case 1: transform = `translateX(${-offset}px) scale(0.85)`; style.zIndex = 1; break;
            case 2: transform = `translateX(0) scale(1)`; style.zIndex = 2; break;
            case 3: transform = `translateX(${offset}px) scale(0.85)`; style.zIndex = 1; break;
            case 4: transform = `translateX(${offset * 1.7}px) scale(0.75)`; break;
            default: style.opacity = 0;
        }
        if (hoveredId === reviewId) { style.zIndex = 3; transform += ' translateY(-15px)'; }
        style.transform = transform; return style;
    };

    const getReviewForSlot = (slotIndex: number) => reviews[(currentIndex + slotIndex - 2 + reviews.length) % reviews.length];
    
    if (reviews.length < VANGUARD_SLOTS) return null;

    return (
        <div ref={containerRef} className={styles.vanguardContainer} data-hovered={!!hoveredId}>
            <motion.div className={styles.spotlightGlow} animate={{ opacity: hoveredId ? 0.5 : 1 }} />
            
            {Array.from({ length: VANGUARD_SLOTS }).map((_, index) => {
                const review = getReviewForSlot(index); if (!review) return null;
                return (
                    <motion.div 
                        key={review.id} 
                        layoutId={`vanguard-card-${review.id}`} 
                        className={styles.cardSlot} 
                        onMouseEnter={() => setHoveredId(review.id)} 
                        onMouseLeave={() => setHoveredId(null)}
                        animate={getSlotStyle(index, review.id)}
                        transition={{ type: 'spring', stiffness: 400, damping: 40 }}
                    >
                        <VanguardCard review={review} isCenter={index === 2} isInView={hasAnimatedIn} />
                    </motion.div>
                );
            })}
            
            {/* --- THE FIX: Use `hasAnimatedIn` and remove AnimatePresence --- */}
            {hasAnimatedIn && <KineticNavigator reviews={reviews} currentIndex={currentIndex} navigateToIndex={navigateToIndex} />}
        </div>
    );
}

--- END OF FILE components/VanguardReviews/VanguardReviews.tsx ---

================================================================================

--- START OF FILE hooks/useDebounce.ts ---

'use client'

import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
const [debouncedValue, setDebouncedValue] = useState<T>(value)

useEffect(() => {
const handler = setTimeout(() => {
setDebouncedValue(value)
}, delay)

return () => {
clearTimeout(handler)
}
}, [value, delay])

return debouncedValue
}





























--- END OF FILE hooks/useDebounce.ts ---

================================================================================

--- START OF FILE hooks/useEngagementScores.ts ---

// hooks/useEngagementScores.ts

'use client';

import { useState, useEffect } from 'react';

type EngagementScore = { id: number; engagementScore: number };

/**
 * Fetches and maintains viral engagement scores (likes + shares) for content.
 * Returns an array of { id: legacyId, engagementScore: number }.
 */
export const useEngagementScores = () => {
    const [scores, setScores] = useState<EngagementScore[]>([]);
    
    useEffect(() => {
        const fetchScores = async () => {
            try {
                const res = await fetch('/api/news-engagement');
                const data = await res.json();
                if (data.error) {
                    console.error("Engagement fetch error:", data.error);
                } else {
                    setScores(data);
                }
            } catch (e) {
                console.error("Engagement fetch failed", e);
            }
        };
        
        fetchScores();
        const intervalId = setInterval(fetchScores, 60000); 
        return () => clearInterval(intervalId);

    }, []);
    return scores;
}




--- END OF FILE hooks/useEngagementScores.ts ---

================================================================================

--- START OF FILE hooks/useLivingCard.ts ---

// hooks/useLivingCard.ts
'use client';

import { useRef, useState } from 'react';
import { useMotionValue, useSpring, useTransform } from 'framer-motion';
import { useTheme } from 'next-themes';

const springConfig = { stiffness: 250, damping: 25 };

/**
 * A custom hook to apply a "living card" 3D tilt and shadow effect.
 * @param {object} options - Optional configuration.
 * @param {boolean} options.isLead - If true, applies a more subtle rotation effect.
 * @returns An object containing the ref and motion props to apply to a Framer Motion component.
 */
export function useLivingCard({ isLead = false } = {}) {
    const ref = useRef<HTMLDivElement>(null);
    const { resolvedTheme } = useTheme();
    const [isHovered, setIsHovered] = useState(false);

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);

    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);

    const rotateMultiplier = isLead ? 8 / 15 : 1;
    const rotateX = useTransform(smoothMouseY, [0, 1], [15 * rotateMultiplier, -15 * rotateMultiplier]);
    const rotateY = useTransform(smoothMouseX, [0, 1], [-15 * rotateMultiplier, 15 * rotateMultiplier]);
    const scale = useSpring(isHovered ? 1.03 : 1, { stiffness: 400, damping: 30 });

    const transform = useTransform(
        [rotateX, rotateY, scale],
        ([rX, rY, s]) => `perspective(1000px) rotateX(${rX}deg) rotateY(${rY}deg) scale(${s})`
    );

    const boxShadow = useTransform(
        [smoothMouseX, smoothMouseY],
        ([x, y]) => {
            const offsetX = (0.5 - x) * 30;
            const offsetY = (0.5 - y) * 30;
            const shadowOpacity = isHovered ? 0.1 : 0;
            const shadowColor = resolvedTheme === 'dark' 
                ? `rgba(0, 229, 255, ${shadowOpacity})`
                : `rgba(0, 0, 0, ${shadowOpacity * 1.5})`;
            return `${offsetX}px ${offsetY}px 35px ${shadowColor}`;
        }
    );

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        if (!ref.current) return;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const onHoverStart = () => {
        setIsHovered(true);
    };

    const onHoverEnd = () => {
        setIsHovered(false);
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    return {
        livingCardRef: ref,
        livingCardAnimation: {
            style: {
                transform,
                boxShadow,
            },
            onMouseMove: handleMouseMove,
            onHoverStart: onHoverStart,
            onHoverEnd: onHoverEnd,
        },
    };
}







--- END OF FILE hooks/useLivingCard.ts ---

================================================================================

--- START OF FILE hooks/usePopoverManager.ts ---

// hooks/usePopoverManager.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

type PopoverIdentifier = string | null;

/**
 * Manages the state for a group of popovers, including opening/closing
 * and handling clicks outside the component to close them.
 * @returns An object containing the popover ref, the currently open popover's ID,
 * and functions to toggle and close popovers.
 */
export function usePopoverManager() {
    const [openPopover, setOpenPopover] = useState<PopoverIdentifier>(null);
    const popoverRef = useRef<HTMLDivElement>(null);

    const togglePopover = useCallback((popoverId: string) => {
        setOpenPopover(current => (current === popoverId ? null : popoverId));
    }, []);

    const closePopover = useCallback(() => {
        setOpenPopover(null);
    }, []);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (popoverRef.current && !popoverRef.current.contains(event.target as Node)) {
                closePopover();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [closePopover]);

    return { popoverRef, openPopover, togglePopover, closePopover };
}







--- END OF FILE hooks/usePopoverManager.ts ---

================================================================================

--- START OF FILE lib/adapters.ts ---

// lib/adapters.ts
import { urlFor } from '@/sanity/lib/image';

const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

export const adaptToCardProps = (item: any) => {
    if (!item) return null;

    let imageUrl = null;
    let blurDataURL: string = '';

    if (item.mainImage?.url) { // Handles data from "heavy" queries
        imageUrl = item.mainImage.url;
        blurDataURL = item.mainImage.blurDataURL || '';
    } else if (item.mainImageRef) { // Handles data from our "lean" queries
        imageUrl = urlFor(item.mainImageRef).width(1920).auto('format').url();
        blurDataURL = urlFor(item.mainImageRef).width(20).blur(10).quality(30).auto('format').url();
    }

    if (!imageUrl) return null;

    let formattedDate = '';
    let publishedYear = null;

    if (item.publishedAt) {
        const date = new Date(item.publishedAt);
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;
        publishedYear = year;
    }

    // Determine the primary authors/reporters based on type
    const primaryCreators = item.authors || item.reporters || [];

    return {
        type: item._type,
        id: item.legacyId ?? item._id,
        slug: item.slug?.current ?? item.slug ?? '',
        game: item.game?.title,
        title: item.title,
        authors: primaryCreators, // Pass the full array
        designers: item.designers || [], // Pass the full array
        date: formattedDate,
        year: publishedYear,
        imageUrl: imageUrl,
        score: item.score,
        tags: (item.tags || []).map((t: any) => t.title).filter(Boolean),
        blurDataURL: blurDataURL,
        verdict: item.verdict || '',
        pros: item.pros || [],
        cons: item.cons || [],
        content: item.content || [],
        relatedReviewIds: item.relatedReviewIds || [],
        category: item.category,
    };
};

--- END OF FILE lib/adapters.ts ---

================================================================================

--- START OF FILE lib/auth.ts ---

// lib/auth.ts
'use server';

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { Session } from 'next-auth';

/**
 * A server-side helper to get the authenticated user's session.
 * Throws an error if the user is not authenticated.
 * @returns {Promise<Session>} The user's session object.
 * @throws {Error} If the user is not signed in.
 */
export async function getAuthenticatedSession(): Promise<Session> {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.id) { // More robust check for user.id
        throw new Error('Authentication required. Please sign in.');
    }
    return session;
}







--- END OF FILE lib/auth.ts ---

================================================================================

--- START OF FILE lib/badges.tsx ---

// lib/badges.tsx

export type BadgeId = 'DIRECTOR' | 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER' | 'FOUNDER' | 'FIRST_COMMENT' | 'ENGAGED_COMMENTER' | 'TOP_CONTRIBUTOR';

export interface Badge {
    id: BadgeId;
    name: string;
    description: string;
    Icon: (props: { className?: string }) => JSX.Element;
}

const DirectorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2z"/></svg>;
const ReviewerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5.17 11.17l-2.83-2.83-2.83 2.83-1.17-1.17 2.83-2.83-2.83-2.83 1.17-1.17 2.83 2.83 2.83-2.83 1.17 1.17-2.83 2.83 2.83 2.83-1.17 1.17z"/></svg>;
const AuthorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>;
const ReporterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg>;
const DesignerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-2.5-11.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm5 0c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm-2.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>;

const FounderIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>;
const FirstCommentIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 12H5v-2h14v2zm0-3H5V9h14v2zm0-3H5V6h14v2z"/></svg>;
const EngagedCommenterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/></svg>;
const TopContributorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l-5.5 9h11zM12 21.8l-5.5-9h11z"/></svg>;

export const BADGES: Record<BadgeId, Badge> = {
    DIRECTOR: { id: 'DIRECTOR', name: 'مدير', description: 'يشرف على مشروع EternalGames.', Icon: DirectorIcon },
    REVIEWER: { id: 'REVIEWER', name: 'مُراجع', description: 'صوت موثوق لمراجعات الألعاب.', Icon: ReviewerIcon },
    AUTHOR: { id: 'AUTHOR', name: 'كاتب', description: 'يكتب المقالات والمواضيع المميزة.', Icon: AuthorIcon },
    REPORTER: { id: 'REPORTER', name: 'مراسل', description: 'يغطي آخر أخبار الصناعة.', Icon: ReporterIcon },
    DESIGNER: { id: 'DESIGNER', name: 'مصمم', description: 'يساهم في التصميم البصري للمحتوى.', Icon: DesignerIcon },
    FOUNDER: { id: 'FOUNDER', name: 'مؤسس', description: 'انضم إلى EternalGames في الشهر الأول من إطلاقه.', Icon: FounderIcon },
    FIRST_COMMENT: { id: 'FIRST_COMMENT', name: 'مبادر', description: 'نشر أول تعليق له.', Icon: FirstCommentIcon },
    ENGAGED_COMMENTER: { id: 'ENGAGED_COMMENTER', name: 'مساهم', description: 'نشر أكثر من 10 تعليقات.', Icon: EngagedCommenterIcon },
    TOP_CONTRIBUTOR: { id: 'TOP_CONTRIBUTOR', name: 'عمود المجتمع', description: 'نشر أكثر من 50 تعليقًا.', Icon: TopContributorIcon },
};

export function getBadgesForUser(user: { createdAt: Date; _count: { comments: number }, roles: string[] }): Badge[] {
    const earnedBadges: Badge[] = [];
    const roles = new Set(user.roles);

    if (roles.has('DIRECTOR')) earnedBadges.push(BADGES.DIRECTOR);
    if (roles.has('REVIEWER')) earnedBadges.push(BADGES.REVIEWER);
    if (roles.has('AUTHOR')) earnedBadges.push(BADGES.AUTHOR);
    if (roles.has('REPORTER')) earnedBadges.push(BADGES.REPORTER);
    if (roles.has('DESIGNER')) earnedBadges.push(BADGES.DESIGNER);

    const founderCutoffDate = new Date('2025-11-01');
    if (user.createdAt < founderCutoffDate) {
        earnedBadges.push(BADGES.FOUNDER);
    }

    const commentCount = user._count.comments;
    if (commentCount >= 50) earnedBadges.push(BADGES.TOP_CONTRIBUTOR);
    else if (commentCount >= 10) earnedBadges.push(BADGES.ENGAGED_COMMENTER);
    else if (commentCount >= 1) earnedBadges.push(BADGES.FIRST_COMMENT);

    return earnedBadges;
}




--- END OF FILE lib/badges.tsx ---

================================================================================

--- START OF FILE lib/countries.ts ---

// lib/countries.ts

export const countries: string[] = [
  'Afghanistan', 'Albania', 'Algeria', 'Andorra', 'Angola', 'Antigua and Barbuda', 'Argentina', 'Armenia', 'Australia', 'Austria',
  'Azerbaijan', 'Bahamas', 'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium', 'Belize', 'Benin', 'Bhutan',
  'Bolivia', 'Bosnia and Herzegovina', 'Botswana', 'Brazil', 'Brunei', 'Bulgaria', 'Burkina Faso', 'Burundi', 'Cabo Verde', 'Cambodia',
  'Cameroon', 'Canada', 'Central African Republic', 'Chad', 'Chile', 'China', 'Colombia', 'Comoros', 'Congo, Democratic Republic of the', 'Congo, Republic of the',
  'Costa Rica', 'Cote d\'Ivoire', 'Croatia', 'Cuba', 'Cyprus', 'Czech Republic', 'Denmark', 'Djibouti', 'Dominica', 'Dominican Republic',
  'Ecuador', 'Egypt', 'El Salvador', 'Equatorial Guinea', 'Eritrea', 'Estonia', 'Eswatini', 'Ethiopia', 'Fiji', 'Finland',
  'France', 'Gabon', 'Gambia', 'Georgia', 'Germany', 'Ghana', 'Greece', 'Grenada', 'Guatemala', 'Guinea',
  'Guinea-Bissau', 'Guyana', 'Haiti', 'Honduras', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq',
  'Ireland', 'Israel', 'Italy', 'Jamaica', 'Japan', 'Jordan', 'Kazakhstan', 'Kenya', 'Kiribati', 'Kuwait',
  'Kyrgyzstan', 'Laos', 'Latvia', 'Lebanon', 'Lesotho', 'Liberia', 'Libya', 'Liechtenstein', 'Lithuania', 'Luxembourg',
  'Madagascar', 'Malawi', 'Malaysia', 'Maldives', 'Mali', 'Malta', 'Marshall Islands', 'Mauritania', 'Mauritius', 'Mexico',
  'Micronesia', 'Moldova', 'Monaco', 'Mongolia', 'Montenegro', 'Morocco', 'Mozambique', 'Myanmar', 'Namibia', 'Nauru',
  'Nepal', 'Netherlands', 'New Zealand', 'Nicaragua', 'Niger', 'Nigeria', 'North Korea', 'North Macedonia', 'Norway', 'Oman',
  'Pakistan', 'Palau', 'Palestine State', 'Panama', 'Papua New Guinea', 'Paraguay', 'Peru', 'Philippines', 'Poland', 'Portugal',
  'Qatar', 'Romania', 'Russia', 'Rwanda', 'Saint Kitts and Nevis', 'Saint Lucia', 'Saint Vincent and the Grenadines', 'Samoa', 'San Marino', 'Sao Tome and Principe',
  'Saudi Arabia', 'Senegal', 'Serbia', 'Seychelles', 'Sierra Leone', 'Singapore', 'Slovakia', 'Slovenia', 'Solomon Islands', 'Somalia',
  'South Africa', 'South Korea', 'South Sudan', 'Spain', 'Sri Lanka', 'Sudan', 'Suriname', 'Sweden', 'Switzerland', 'Syria',
  'Taiwan', 'Tajikistan', 'Tanzania', 'Thailand', 'Timor-Leste', 'Togo', 'Tonga', 'Trinidad and Tobago', 'Tunisia', 'Turkey',
  'Turkmenistan', 'Tuvalu', 'Uganda', 'Ukraine', 'United Arab Emirates', 'United Kingdom', 'United States of America', 'Uruguay', 'Uzbekistan', 'Vanuatu',
  'Vatican City', 'Venezuela', 'Vietnam', 'Yemen', 'Zambia', 'Zimbabwe'
];




--- END OF FILE lib/countries.ts ---

================================================================================

--- START OF FILE lib/image-optimizer.ts ---

// lib/image-optimizer.ts

export type UploadQuality = '1080p' | '4k' | '8k';

const RESOLUTIONS: Record<UploadQuality, { width: number; height: number }> = {
    '1080p': { width: 1920, height: 1080 },
    '4k': { width: 3840, height: 2160 },
    '8k': { width: 7680, height: 4320 },
};

const MAX_UPLOAD_SIZE_BYTES = 4.5 * 1024 * 1024; // 4.5MB Target, aligned with Vercel's Pro plan body limit
const MAX_INITIAL_FILE_SIZE_BYTES = 25 * 1024 * 1024; // 25MB Hard Limit for initial file read

/**
 * A robust, goal-oriented image optimizer.
 * It guarantees the output file will be under MAX_UPLOAD_SIZE_BYTES, or it will fail with a clear error.
 * THE FIX: Returns an object with the file and the final quality setting.
 */
export function optimizeImageForUpload(file: File, quality: UploadQuality): Promise<{ file: File; finalQuality: number; }> {
  return new Promise((resolve, reject) => {
    if (file.size > MAX_INITIAL_FILE_SIZE_BYTES) {
        return reject(new Error(`حجم الملف يتجاوز الحد الأقصى (25MB).`));
    }
    if (!file.type.startsWith('image/')) {
        return reject(new Error("الملف ليس صورة صالحة."));
    }

    const resolution = RESOLUTIONS[quality];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target?.result as string;
      img.onload = () => {
        if (!img.width || !img.height) {
            return reject(new Error("تعذر قراءة أبعاد الصورة. قد يكون الملف تالفًا."));
        }

        let { width, height } = img;
        const aspectRatio = width / height;

        if (img.width > resolution.width || img.height > resolution.height) {
            const widthRatio = resolution.width / img.width;
            const heightRatio = resolution.height / img.height;
            const ratio = Math.min(widthRatio, heightRatio);
            width = Math.round(img.width * ratio);
            height = Math.round(img.height * ratio);
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return reject(new Error('لا يمكن إنشاء سياق الكانفاس.'));

        ctx.drawImage(img, 0, 0, width, height);
        
        let currentQuality = 0.92;
        
        const attemptCompression = () => {
            canvas.toBlob(
              (blob) => {
                if (!blob) return reject(new Error('فشل تحويل الكانفاس إلى Blob.'));
                
                if (blob.size > MAX_UPLOAD_SIZE_BYTES && currentQuality > 0.5) {
                    currentQuality -= 0.08;
                    attemptCompression();
                } else {
                    if (blob.size > MAX_UPLOAD_SIZE_BYTES) {
                        reject(new Error("تعذر ضغط الصورة إلى حجم مقبول (<4.5MB). الرجاء اختيار جودة أقل أو استخدم صورة مختلفة."));
                    } else {
                        const newFileName = file.name.replace(/\.[^/.]+$/, ".jpg");
                        const optimizedFile = new File([blob], newFileName, { type: 'image/jpeg', lastModified: Date.now() });
                        // THE FIX: Resolve with the object containing file and quality
                        resolve({ file: optimizedFile, finalQuality: currentQuality });
                    }
                }
              }, 'image/jpeg', currentQuality );
        };

        attemptCompression();
      };
      img.onerror = () => reject(new Error("تعذر تحميل الصورة. قد يكون الملف تالفًا أو غير مدعوم."));
    };
    reader.onerror = () => reject(new Error("فشل قراءة الملف."));
  });
}

--- END OF FILE lib/image-optimizer.ts ---

================================================================================

--- START OF FILE lib/layoutIdStore.ts ---

// lib/layoutIdStore.ts
import { create } from 'zustand';

interface LayoutIdState {
    prefix: string;
    setPrefix: (prefix: string) => void;
}

export const useLayoutIdStore = create<LayoutIdState>((set) => ({
    prefix: 'default',
    setPrefix: (prefix) => set({ prefix }),
}));




--- END OF FILE lib/layoutIdStore.ts ---

================================================================================

--- START OF FILE lib/lightboxStore.ts ---

// lib/lightboxStore.ts
import { create } from 'zustand';

interface LightboxState {
  isOpen: boolean;
  imageUrls: string[];
  currentIndex: number;
  openLightbox: (urls: string[], startIndex: number) => void;
  closeLightbox: () => void;
  goToNext: () => void;
  goToPrevious: () => void;
}

export const useLightboxStore = create<LightboxState>((set, get) => ({
  isOpen: false,
  imageUrls: [],
  currentIndex: 0,
  openLightbox: (urls, startIndex = 0) => set({ 
    isOpen: true, 
    imageUrls: urls,
    currentIndex: startIndex 
  }),
  closeLightbox: () => set({ 
    isOpen: false, 
    imageUrls: [], 
    currentIndex: 0 
  }),
  goToNext: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const nextIndex = (currentIndex + 1) % imageUrls.length;
      set({ currentIndex: nextIndex });
    }
  },
  goToPrevious: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const prevIndex = (currentIndex - 1 + imageUrls.length) % imageUrls.length;
      set({ currentIndex: prevIndex });
    }
  },
}));

--- END OF FILE lib/lightboxStore.ts ---

================================================================================

--- START OF FILE lib/prisma.ts ---

// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
    // --- THE FIX ---
    // Modify the DATABASE_URL in development to be more resilient.
    let databaseUrl = process.env.DATABASE_URL;

    if (process.env.NODE_ENV === 'development') {
        // 1. Remove the pgbouncer parameter to connect directly. This helps avoid
        //    connection pooler instability during hot-reloading.
        // 2. Add a longer connection timeout. Serverless databases (like Neon's free tier)
        //    "sleep" after inactivity and can take a few seconds to wake up. This
        //    prevents Prisma from timing out before the database is ready.
        databaseUrl = process.env.DATABASE_URL?.replace('&pgbouncer=true', '') + '&connect_timeout=30';
    }

    if (!databaseUrl) {
        throw new Error('DATABASE_URL is not set in your environment variables');
    }

    return new PrismaClient({
        datasources: {
            db: {
                url: databaseUrl,
            },
        },
    });
}

declare global {
    var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma




--- END OF FILE lib/prisma.ts ---

================================================================================

--- START OF FILE lib/sanity.client.ts ---

// lib/sanity.client.ts

import { createClient } from '@sanity/client'

export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID
export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET
export const apiVersion = process.env.NEXT_PUBLIC_SANITY_API_VERSION

export const client = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_READ_TOKEN,
})

export const clientAssetUploader = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    // THE FIX: Use the NEXT_PUBLIC_ prefixed variable
    token: process.env.NEXT_PUBLIC_SANITY_API_WRITE_TOKEN,
})




--- END OF FILE lib/sanity.client.ts ---

================================================================================

--- START OF FILE lib/sanity.client.write.ts ---




--- END OF FILE lib/sanity.client.write.ts ---

================================================================================

--- START OF FILE lib/sanity.queries.ts ---

// lib/sanity.queries.ts

import { groq } from 'next-sanity'

// --- Base Fields & Projections (Optimized) ---
const mainImageFields = groq`"url": asset->url, "blurDataURL": asset->metadata.lqip, alt`
const creatorFields = groq`_id, name, prismaUserId, "username": *[_type=="user" && id==^.prismaUserId][0].username` // Add username for linking
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- Projections ---
const cardProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}}, 
"publishedAt": publishedAt, "game": game->{_id, title}, "tags": tags[]->{title}, category
`
const cardListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset._ref, 
"mainImageDimensions": mainImage.asset->metadata.dimensions,
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title}, "tags": tags[]->{title}, category
`

// --- List Page Queries ---
export const vanguardReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0...10] { ${cardProjection} }`
export const featuredHeroReviewQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} }`
export const featuredShowcaseArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...7] { ${cardProjection} }`
export const allReviewsListQuery = groq`*[_type == "review" && ${publishedFilter}] | order(publishedAt desc) { ${cardListProjection} }`
export const allArticlesListQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc) { ${cardListProjection} }`
export const allNewsListQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByGameListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByTagListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && $slug in tags[]->slug.current] | order(publishedAt desc) { ${cardListProjection} }`

// --- Detail Page Queries ---
const contentProjection = groq`content[]{ ..., _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} } }`
const relatedContentProjection = groq`{ _id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, "mainImageDimensions": mainImage.asset->metadata.dimensions, score, "authors": authors[]->{name, prismaUserId}, "reporters": reporters[]->{name, prismaUserId}, "publishedAt": publishedAt }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{${tagFields}},
  "relatedReviews": relatedReviews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{title}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{title},
  "relatedArticles": relatedArticles[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "reporters": reporters[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{title},
  "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{title},
  ${contentProjection}
}`

// --- Fallback & Miscellaneous Queries ---
export const latestReviewsFallbackQuery = groq`*[_type == "review" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestArticlesFallbackQuery = groq`*[_type == "article" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsFallbackQuery = groq`*[_type == "news" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...15] { _id, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, category, "reporters": reporters[]->{name, prismaUserId}, publishedAt }`
export const heroContentQuery = groq`{
  "featuredReview": *[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} },
  "latestNews": *[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} },
  "featuredArticle": *[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} }
}`
export const featuredReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const featuredArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && title match $query] | order(_createdAt desc) [0...10] {
  _id, _type, title, "slug": slug.current, "imageUrl": mainImage.asset->url, 
  "authors": authors[]->{name}, "reporters": reporters[]->{name}, 
  "gameTitle": game->title, category
}`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${cardProjection} }`
export const allReleasesQuery = groq`*[_type == "gameRelease" && defined(releaseDate)] | order(releaseDate asc) { _id, legacyId, title, "slug": slug.current, releaseDate, platforms, synopsis, "mainImage": mainImage{${mainImageFields}}, }`

// --- Studio Editor Query ---
export const editorDocumentQuery = groq`*[_id == $id || _id == 'drafts.' + $id] | order(_updatedAt desc)[0]{
  ...,
  "authors": authors[]->{_id, name, prismaUserId},
  "reporters": reporters[]->{_id, name, prismaUserId},
  "designers": designers[]->{_id, name, prismaUserId},
  "game": game->{_id, title},
  "tags": tags[]->{_id, title},
  "mainImage": mainImage.asset->{
    "_ref": _id,
    "url": url,
    "metadata": metadata
  },
  content[]{
    ...,
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } },
    _type == "imageCompare" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "twoImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "fourImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}},
      "image3": image3{..., asset->{_id, url, metadata}},
      "image4": image4{..., asset->{_id, url, metadata}}
    }
  }
}`;

--- END OF FILE lib/sanity.queries.ts ---

================================================================================

--- START OF FILE lib/sanity.server.ts ---

import { createClient } from '@sanity/client'
import { apiVersion, dataset, projectId } from '@/lib/sanity.client'

// This is a server-only client for performing mutations.
// It uses a write-enabled token and should never be exposed to the client.
export const sanityWriteClient = createClient({
projectId,
dataset,
apiVersion,
useCdn: false, // Writes should always go directly to the API
token: process.env.SANITY_API_WRITE_TOKEN, // Use a dedicated write token
});





























--- END OF FILE lib/sanity.server.ts ---

================================================================================

--- START OF FILE lib/store.ts ---

// lib/store.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
// THE FIX: Import the new idempotent actions
import { setBookmarkAction, setLikeAction, recordShareAction } from '@/app/actions/contentActions';
import { useToast } from './toastStore';

const createContentKey = (id: number, type: string) => `${type}-${id}`;

const debounceTimers: { [key: string]: NodeJS.Timeout } = {};

const initialState = {
    bookmarks: [] as string[],
    likes: [] as string[],
    shares: [] as string[],
    isSignInModalOpen: false,
    isSyncedWithDb: false,
};

type UserState = typeof initialState & { _hasHydrated: boolean };

type UserActions = {
    toggleBookmark: (contentId: number, contentType: string) => void;
    setSignInModalOpen: (isOpen: boolean) => void;
    toggleLike: (contentId: number, contentType: string, contentSlug: string) => void;
    addShare: (contentId: number, contentType: string, contentSlug: string) => void;
    syncWithDb: (dbData: { 
        engagements: { contentId: number, contentType: string, type: 'LIKE' | 'BOOKMARK' }[],
        shares: { contentId: number, contentType: string }[]
    }) => void;
    setIsSyncedWithDb: (isSynced: boolean) => void;
    reset: () => void;
};

export const useUserStore = create<UserState & UserActions>()(
    persist(
        (set, get) => ({
            ...initialState,
            _hasHydrated: false,

            toggleBookmark: (contentId, contentType) => {
                const key = createContentKey(contentId, contentType);
                const originalBookmarks = get().bookmarks;
                const isCurrentlyBookmarked = originalBookmarks.includes(key);

                // This is the final state the user wants.
                const finalState = !isCurrentlyBookmarked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);
                
                // Perform the optimistic update immediately.
                set({ bookmarks: finalState ? [...originalBookmarks, key] : originalBookmarks.filter(k => k !== key) });

                // Debounce the server action, sending the FINAL state.
                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setBookmarkAction(contentId, contentType, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        useToast.getState().error('فشل حفظ العلامة المرجعية.');
                        set({ bookmarks: originalBookmarks });
                    }
                }, 500);
            },
            
            setSignInModalOpen: (isOpen: boolean) => set({ isSignInModalOpen: isOpen }),

            toggleLike: (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                const originalLikes = get().likes;
                const isCurrentlyLiked = originalLikes.includes(key);

                // This is the final state the user wants.
                const finalState = !isCurrentlyLiked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);

                // Perform the optimistic update immediately.
                set({ likes: finalState ? [...originalLikes, key] : originalLikes.filter(k => k !== key) });
                
                // Debounce the server action, sending the FINAL state.
                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setLikeAction(contentId, contentType, contentSlug, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        useToast.getState().error('فشل تسجيل الإعجاب.');
                        set({ likes: originalLikes });
                    }
                }, 500);
            },

            addShare: async (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                if (get().shares.includes(key)) return;
                set(state => ({ shares: [...state.shares, key] }));
                const result = await recordShareAction(contentId, contentType, contentSlug);
                if (result.success && result.shares) {
                    set({ shares: result.shares.map(s => createContentKey(s.contentId, s.contentType)) });
                }
            },

            syncWithDb: (dbData) => {
                const dbLikes: string[] = [];
                const dbBookmarks: string[] = [];
                (dbData.engagements || []).forEach(engagement => {
                    const key = createContentKey(engagement.contentId, engagement.contentType);
                    if (engagement.type === 'LIKE') dbLikes.push(key);
                    else if (engagement.type === 'BOOKMARK') dbBookmarks.push(key);
                });
                const dbShares = (dbData.shares || []).map(s => createContentKey(s.contentId, s.contentType));
                set({ likes: dbLikes, bookmarks: dbBookmarks, shares: dbShares });
            },

            setIsSyncedWithDb: (isSynced: boolean) => set({ isSyncedWithDb: isSynced }),
            reset: () => set(initialState),
        }),
        {
            name: 'eternalgames-user-preferences-v3',
            onRehydrateStorage: () => (state) => { if (state) { state._hasHydrated = true; } },
            partialize: (state) => ({
                bookmarks: state.bookmarks,
                likes: state.likes,
                shares: state.shares,
            }),
        }
    )
);




--- END OF FILE lib/store.ts ---

================================================================================

--- START OF FILE lib/toastStore.ts ---

// lib/toastStore.ts

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

export type ToastType = 'success' | 'error' | 'info';
export type ToastPosition = 'right' | 'left'; // <-- NEW TYPE

interface ToastMessage {
id: string;
message: string;
type: ToastType;
position?: ToastPosition; // <-- NEW PROPERTY
}

interface ToastState {
toasts: ToastMessage[];
addToast: (message: string, type: ToastType, position?: ToastPosition) => void; // <-- MODIFIED
dismissToast: (id: string) => void;
}

const useToastStore = create<ToastState>((set) => ({
toasts: [],
addToast: (message, type, position = 'right') => { // <-- SET DEFAULT TO RIGHT
const id = uuidv4();
set((state) => ({ toasts: [...state.toasts, { id, message, type, position }] }));
},
dismissToast: (id) => {
set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id) }));
},
}));

// This is the public hook that components will use.
export const useToast = () => {
const { addToast } = useToastStore();
return {
success: (message: string, position?: ToastPosition) => addToast(message, 'success', position),
error: (message: string, position?: ToastPosition) => addToast(message, 'error', position),
info: (message: string, position?: ToastPosition) => addToast(message, 'info', position),
};
};

export default useToastStore;





























--- END OF FILE lib/toastStore.ts ---

================================================================================

--- START OF FILE lib/translations.ts ---

// lib/translations.ts

const TAG_TRANSLATIONS: Record<string, string> = {
    // === Game Tags (For Reviews & Articles) ===
    "Action": "أكشن",
    "Adventure": "مغامرات",
    "RPG": "تقمص الأدوار",
    "JRPG": "تقمص أدوار ياباني",
    "Strategy": "استراتيجية",
    "Simulation": "محاكاة",
    "Sports": "رياضة",
    "Racing": "سباقات",
    "Puzzle": "ألغاز",
    "Fighting": "قتال",
    "Horror": "رُعب",
    "Survival": "نجاة",
    "Platformer": "منصات",
    "FPS": "منظور الشخص الأول",
    "TPS": "منظور الشخص الثالث",
    "Sci-Fi": "خيال علمي",
    "Fantasy": "فانتازيا",
    "Historical": "تاريخي",
    "Post-Apocalyptic": "ما بعد الفناء",
    "Cyberpunk": "سايبربنك",
    "Mystery": "غموض",
    "Atmospheric": "أجواء غامرة",
    "Open World": "عالم مفتوح",
    "Single-Player": "طور فردي",
    "Multiplayer": "طور جماعي",
    "Co-op": "طور تعاوني",
    "Competitive": "طور تنافسي",
    "Story-Driven": "عمق قصصي",
    "Pixel Art": "فن البكسل",
    "Anime": "أنمي",
    "Classic": "كلاسيكي",
    "Indie": "ألعاب مستقلة",

    // === News-Specific Tags ===
    "Acquisition": "استحواذ",
    "Sales": "أرقام المبيعات",
    "Game Announcement": "الكشف عن لعبة",
    "Industry News": "نبض الصناعة",
    "Financials": "شؤون مالية",
    "Technology": "تقنية",
    "Esports": "المنافسات الإلكترونية",
    "Game Update": "تحديث للعبة",
    "Layoffs": "تسريح موظفين",
    "Game Size": "حجم اللعبة",
    "Release Date": "موعد الإصدار",
    "Age Ratings": "تقييمات عمرية",

    // === Article-Specific Tags ===
    "Opinion": "رأي",
    "Guide": "إعانة",
    "Everything You Need to Know": "الدليل الشامل",
    "Analysis": "تحليل",
    "Biography": "سيرة",
    "Story": "قصة",
};

/**
 * Translates an English tag title to Arabic.
 * If no translation is found, it returns the original English title.
 * @param tagTitle The English tag title from Sanity.
 * @returns The translated Arabic string or the original string.
 */
export const translateTag = (tagTitle: string): string => {
    return TAG_TRANSLATIONS[tagTitle] || tagTitle;
};




--- END OF FILE lib/translations.ts ---

================================================================================

--- START OF FILE prisma/schema.prisma ---

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[] @relation("RoleToUser")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  username            String?              @unique
  email               String?              @unique
  emailVerified       DateTime?
  image               String?
  password            String?
  createdAt           DateTime             @default(now())
  bio                 String?
  twitterHandle       String?
  age                 Int?
  country             String?
  agePublic           Boolean              @default(true)
  countryPublic       Boolean              @default(true)
  instagramHandle     String?
  accounts            Account[]
  engagements         Engagement[]
  comments            Comment[]
  commentVotes        CommentVote[]
  passwordResetTokens PasswordResetToken[]
  sessions            Session[]
  shares              Share[]
  roles               Role[]               @relation("RoleToUser")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  token   String   @unique
  expires DateTime
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Engagement {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  type        EngagementType
  userId      String
  contentId   Int
  contentType String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId, contentType, type])
}

model Share {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  userId      String
  contentId   Int
  contentType String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Comment {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  content     String
  contentSlug String
  isDeleted   Boolean       @default(false)
  authorId    String
  parentId    String?
  author      User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent      Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies     Comment[]     @relation("CommentReplies")
  votes       CommentVote[]
}

model CommentVote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  type      VoteType
  userId    String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
}

enum VoteType {
  LIKE
  DISLIKE
}

enum EngagementType {
  LIKE
  BOOKMARK
}




--- END OF FILE prisma/schema.prisma ---

================================================================================

--- START OF FILE prisma/seed.ts ---

// prisma/seed.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

const ROLES_TO_CREATE = [
  'DIRECTOR',
  'ADMIN',
  'REVIEWER',
  'AUTHOR',
  'REPORTER',
  'DESIGNER',
  'USER'
];

async function main() {
  console.log('Start seeding roles...');
  for (const roleName of ROLES_TO_CREATE) {
    const role = await prisma.role.upsert({
      where: { name: roleName },
      update: {},
      create: { name: roleName },
    });
    console.log(`Created or found role: ${role.name}`);
  }
  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

















--- END OF FILE prisma/seed.ts ---

================================================================================

--- START OF FILE prisma/migrations/migration_lock.toml ---

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"





--- END OF FILE prisma/migrations/migration_lock.toml ---

================================================================================

--- START OF FILE prisma/migrations/0_baseline/migration.sql ---

-- CreateEnum
CREATE TYPE "VoteType" AS ENUM ('LIKE', 'DISLIKE');

-- CreateTable
CREATE TABLE "Role" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "Role_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "username" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "password" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "bio" TEXT,
    "twitterHandle" TEXT,
    "instagramHandle" TEXT,
    "age" INTEGER,
    "country" TEXT,
    "agePublic" BOOLEAN NOT NULL DEFAULT true,
    "countryPublic" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "Like" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Like_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Share" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Share_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Bookmark" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Bookmark_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "content" TEXT NOT NULL,
    "contentSlug" TEXT NOT NULL,
    "isDeleted" BOOLEAN NOT NULL DEFAULT false,
    "authorId" TEXT NOT NULL,
    "parentId" TEXT,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CommentVote" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "VoteType" NOT NULL,
    "userId" TEXT NOT NULL,
    "commentId" TEXT NOT NULL,

    CONSTRAINT "CommentVote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_RoleToUser" (
    "A" INTEGER NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_RoleToUser_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Role_name_key" ON "Role"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "Like_userId_contentId_contentType_key" ON "Like"("userId", "contentId", "contentType");

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_key" ON "Bookmark"("userId", "contentId");

-- CreateIndex
CREATE UNIQUE INDEX "CommentVote_userId_commentId_key" ON "CommentVote"("userId", "commentId");

-- CreateIndex
CREATE INDEX "_RoleToUser_B_index" ON "_RoleToUser"("B");

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Like" ADD CONSTRAINT "Like_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Share" ADD CONSTRAINT "Share_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Bookmark" ADD CONSTRAINT "Bookmark_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "Comment"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_A_fkey" FOREIGN KEY ("A") REFERENCES "Role"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_B_fkey" FOREIGN KEY ("B") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;






--- END OF FILE prisma/migrations/0_baseline/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

-- CreateTable
CREATE TABLE "PasswordResetToken" (
    "id" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "PasswordResetToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "PasswordResetToken_token_key" ON "PasswordResetToken"("token");

-- AddForeignKey
ALTER TABLE "PasswordResetToken" ADD CONSTRAINT "PasswordResetToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;





--- END OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

/*
  Warnings:

  - A unique constraint covering the columns `[userId,contentId,contentType]` on the table `Bookmark` will be added. If there are existing duplicate values, this will fail.

*/
-- DropIndex
DROP INDEX "public"."Bookmark_userId_contentId_key";

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_contentType_key" ON "Bookmark"("userId", "contentId", "contentType");





--- END OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

/*
  Warnings:

  - You are about to drop the `Bookmark` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Like` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "EngagementType" AS ENUM ('LIKE', 'BOOKMARK');

-- DropForeignKey
ALTER TABLE "public"."Bookmark" DROP CONSTRAINT "Bookmark_userId_fkey";

-- DropForeignKey
ALTER TABLE "public"."Like" DROP CONSTRAINT "Like_userId_fkey";

-- DropTable
DROP TABLE "public"."Bookmark";

-- DropTable
DROP TABLE "public"."Like";

-- CreateTable
CREATE TABLE "Engagement" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "EngagementType" NOT NULL,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Engagement_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Engagement_userId_contentId_contentType_type_key" ON "Engagement"("userId", "contentId", "contentType", "type");

-- AddForeignKey
ALTER TABLE "Engagement" ADD CONSTRAINT "Engagement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;





--- END OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

================================================================================

--- START OF FILE sanity/.env ---

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"




--- END OF FILE sanity/.env ---

================================================================================

--- START OF FILE sanity/env.ts ---

export const apiVersion =
process.env.NEXT_PUBLIC_SANITY_API_VERSION || '2025-09-28'

export const dataset = assertValue(
process.env.NEXT_PUBLIC_SANITY_DATASET,
'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET'
)

export const projectId = assertValue(
process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID'
)

function assertValue<T>(v: T | undefined, errorMessage: string): T {
if (v === undefined) {
throw new Error(errorMessage)
}

return v
}





























--- END OF FILE sanity/env.ts ---

================================================================================

--- START OF FILE sanity/package-lock.json ---

{
  "name": "eternalgames-studio",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "eternalgames-studio",
      "version": "1.0.0",
      "license": "UNLICENSED",
      "dependencies": {
        "styled-components": "^6.1.19"
      }
    },
    "node_modules/@emotion/is-prop-valid": {
      "version": "1.2.2",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.8.1"
      }
    },
    "node_modules/@emotion/memoize": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@emotion/unitless": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@types/stylis": {
      "version": "4.2.5",
      "license": "MIT"
    },
    "node_modules/camelize": {
      "version": "1.0.1",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/css-color-keywords": {
      "version": "1.0.0",
      "license": "ISC",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/css-to-react-native": {
      "version": "3.2.0",
      "license": "MIT",
      "dependencies": {
        "camelize": "^1.0.0",
        "css-color-keywords": "^1.0.0",
        "postcss-value-parser": "^4.0.2"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.4.49",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.7",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "license": "MIT"
    },
    "node_modules/shallowequal": {
      "version": "1.1.0",
      "license": "MIT"
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/styled-components": {
      "version": "6.1.19",
      "resolved": "https://registry.npmjs.org/styled-components/-/styled-components-6.1.19.tgz",
      "integrity": "sha512-1v/e3Dl1BknC37cXMhwGomhO8AkYmN41CqyX9xhUDxry1ns3BFQy2lLDRQXJRdVVWB9OHemv/53xaStimvWyuA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/is-prop-valid": "1.2.2",
        "@emotion/unitless": "0.8.1",
        "@types/stylis": "4.2.5",
        "css-to-react-native": "3.2.0",
        "csstype": "3.1.3",
        "postcss": "8.4.49",
        "shallowequal": "1.1.0",
        "stylis": "4.3.2",
        "tslib": "2.6.2"
      },
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/styled-components"
      },
      "peerDependencies": {
        "react": ">= 16.8.0",
        "react-dom": ">= 16.8.0"
      }
    },
    "node_modules/stylis": {
      "version": "4.3.2",
      "license": "MIT"
    },
    "node_modules/tslib": {
      "version": "2.6.2",
      "license": "0BSD"
    }
  }
}


--- END OF FILE sanity/package-lock.json ---

================================================================================

--- START OF FILE sanity/package.json ---

{
  "name": "eternalgames-studio",
  "private": true,
  "version": "1.0.0",
  "main": "package.json",
  "license": "UNLICENSED",
  "dependencies": {
    "styled-components": "^6.1.19"
  }
}


--- END OF FILE sanity/package.json ---

================================================================================

--- START OF FILE sanity/sanity.config.ts ---

import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

// DEFINITIVE FIX: Hardcode the public, non-secret values.
// The dev server launched by the CLI also lacks Next.js context.
const projectId = '0zany1dm'
const dataset = 'production'
const apiVersion = '2024-03-11'

export default defineConfig({
  basePath: '/studio',
  projectId,
  dataset,
  schema: {
    types: schemaTypes,
  },
  plugins: [
    structureTool(),
    visionTool({defaultApiVersion: apiVersion}),
  ],
})




--- END OF FILE sanity/sanity.config.ts ---

================================================================================

--- START OF FILE sanity/lib/client.ts ---

import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId } from '../env'

export const client = createClient({
projectId,
dataset,
apiVersion,
useCdn: true, // Set to false if statically generating pages, using ISR or tag-based revalidation
})





























--- END OF FILE sanity/lib/client.ts ---

================================================================================

--- START OF FILE sanity/lib/image.ts ---

import createImageUrlBuilder from '@sanity/image-url'
import { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source: SanityImageSource) => {
return builder.image(source)
}





























--- END OF FILE sanity/lib/image.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/articleType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
name: 'article',
title: 'Article',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'slug', title: 'slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'authors', title: 'Authors', type: 'array', of: [{type: 'reference', to: {type: 'author'}}], validation: (Rule) => Rule.required().min(1)}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category in ["Game", "Article"]' }}]}),
defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
defineField({name: 'content', title: 'Content', type: 'blockContent'}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', media: 'mainImage'},
},
})

--- END OF FILE sanity/schemaTypes/articleType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/blockContentType.ts ---

import {defineType, defineArrayMember, defineField} from 'sanity'

/**
 * This is the schema definition for the rich text fields used for
 * author biography, collaborator details, and sub-descriptions.
 **/
export default defineType({
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    defineArrayMember({
      title: 'Block',
      type: 'block',
      // Styles let you set what textual styles there are for blocks.
      // These are the styles that will be available when the user selects
      // a top-level block from the menu.
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      // Marks let you mark up inline text in the block editor.
      marks: {
        // Decorators usually describe a single property – e.g. a typographic
        // preference or highlighting by editors.
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        // Annotations can be any object structure – e.g. a link or a footnote.
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              defineField({
                title: 'URL',
                name: 'href',
                type: 'url',
              }),
            ],
          },
        ],
      },
    }),
    // You can add additional types here. Note that you can't use
    // primitive types such as 'string' and 'number' in the same array
    // as a block type.
    defineArrayMember({
      type: 'image',
      options: {hotspot: true},
    }),
    defineArrayMember({
      type: 'imageCompare',
    }),
    defineArrayMember({
      type: 'twoImageGrid',
    }),
    defineArrayMember({
      type: 'fourImageGrid',
    }),
  ],
})

--- END OF FILE sanity/schemaTypes/blockContentType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/fourImageGridType.ts ---

// sanity/schemaTypes/fourImageGridType.ts
import { defineType, defineField } from 'sanity';

export default defineType({
    name: 'fourImageGrid',
    title: 'Four Image Grid',
    type: 'object',
    fields: [
        defineField({ name: 'image1', title: 'Image 1', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image2', title: 'Image 2', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image3', title: 'Image 3', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image4', title: 'Image 4', type: 'image', options: { hotspot: true } }),
    ],
    preview: {
        select: { media: 'image1' },
        prepare({ media }) {
            return { title: 'Four Image Grid', media };
        },
    },
});

--- END OF FILE sanity/schemaTypes/fourImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameReleaseType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
name: 'gameRelease',
title: 'Game Release',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
defineField({name: 'releaseDate', title: 'Release Date', type: 'date', validation: (Rule) => Rule.required()}),
defineField({name: 'platforms', title: 'Platforms', type: 'array', of: [{type: 'string'}], options: {list: ['PC', 'PS5', 'Xbox', 'Switch']}}),
defineField({name: 'mainImage', title: 'Main Image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'synopsis', title: 'Synopsis', type: 'text', validation: (Rule) => Rule.required()}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', subtitle: 'releaseDate', media: 'mainImage'},
},
})




--- END OF FILE sanity/schemaTypes/gameReleaseType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
name: 'game',
title: 'Game',
type: 'document',
fields: [
defineField({
name: 'title',
title: 'Title',
type: 'string',
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'slug',
title: 'Slug',
type: 'slug',
options: {
source: 'title',
maxLength: 96,
},
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'mainImage',
title: 'Main Image',
type: 'image',
options: {
hotspot: true,
},
}),
],
})




--- END OF FILE sanity/schemaTypes/gameType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/imageCompareType.ts ---

// sanity/schemaTypes/imageCompareType.ts
import { defineType, defineField } from 'sanity';

export default defineType({
    name: 'imageCompare',
    title: 'Image Comparison',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1 (Before)',
            type: 'image',
            options: { hotspot: true },
            validation: Rule => Rule.required(),
        }),
        defineField({
            name: 'image2',
            title: 'Image 2 (After)',
            type: 'image',
            options: { hotspot: true },
            validation: Rule => Rule.required(),
        }),
        defineField({
            name: 'size',
            title: 'Display Size',
            type: 'string',
            options: {
                list: [
                    { title: 'Small', value: 'small' },
                    { title: 'Medium', value: 'medium' },
                    { title: 'Large', value: 'large' },
                ],
                layout: 'radio',
            },
            initialValue: 'large',
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }) {
            return {
                title: 'Image Comparison',
                media: media || media2,
            };
        },
    },
});




--- END OF FILE sanity/schemaTypes/imageCompareType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/index.ts ---

import blockContent from './blockContentType'
import tag from './tagType'
import review from './reviewType'
import article from './articleType'
import news from './newsType'
import game from './gameType'
import gameRelease from './gameReleaseType'
import imageCompare from './imageCompareType'
import twoImageGrid from './twoImageGridType'
import fourImageGrid from './fourImageGridType'
// NEW IMPORTS
import author from './creators/authorType'
import designer from './creators/designerType'
import reporter from './creators/reporterType'
import reviewer from './creators/reviewerType'

export const schemaTypes = [review, article, news, author, designer, reporter, reviewer, game, tag, gameRelease, blockContent, imageCompare, twoImageGrid, fourImageGrid]

--- END OF FILE sanity/schemaTypes/index.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/newsType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'news',
    title: 'News',
    type: 'document',
    fields: [
        defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
        defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
        defineField({name: 'reporters', title: 'Reporters', type: 'array', of: [{type: 'reference', to: {type: 'reporter'}}], validation: (Rule) => Rule.required().min(1)}),
        defineField({name: 'game', title: 'Game (Optional)', type: 'reference', to: {type: 'game'}}),
        defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
        defineField({name: 'category', title: 'Category', type: 'string', options: {list: ["Industry", "Hardware", "Updates", "Esports"], layout: 'radio'}, validation: (Rule) => Rule.required()}),
        defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "News"' }}]}),
        defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
        defineField({name: 'content', title: 'Content', type: 'blockContent'}),
        defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
    ],
    preview: {
        select: {title: 'title', media: 'mainImage'},
    },
})

--- END OF FILE sanity/schemaTypes/newsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/reviewType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
name: 'review',
title: 'Review',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'authors', title: 'Reviewers', type: 'array', of: [{type: 'reference', to: {type: 'reviewer'}}], validation: (Rule) => Rule.required().min(1)}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'mainImage', title: 'Main image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'score', title: 'Score', type: 'number', validation: (Rule) => Rule.required().min(0).max(10)}),
defineField({name: 'verdict', title: 'Verdict', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'pros', title: 'Pros', type: 'array', of: [{type: 'string'}]}),
defineField({name: 'cons', title: 'Cons', type: 'array', of: [{type: 'string'}]}),
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
defineField({name: 'content', title: 'Content', type: 'blockContent', validation: (Rule) => Rule.required()}),
defineField({name: 'relatedReviews', title: 'Related Reviews', type: 'array', of: [{type: 'reference', to: {type: 'review'}}]}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', author: 'authors.0.name', media: 'mainImage'},
prepare(selection) {
const {author} = selection
return {...selection, subtitle: author && `by ${author}`}
},
},
})

--- END OF FILE sanity/schemaTypes/reviewType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/tagType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'tag',
    title: 'Tag',
    type: 'document',
    fields: [
        defineField({
            name: 'title',
            title: 'Title',
            type: 'string',
        }),
        defineField({
            name: 'slug',
            title: 'Slug',
            type: 'slug',
            options: {
                source: 'title',
                maxLength: 96,
            },
        }),
        defineField({
            name: 'category',
            title: 'Category',
            type: 'string',
            options: {
                list: [
                    { title: 'Game (For Reviews & Articles)', value: 'Game' },
                    { title: 'News (For News only)', value: 'News' },
                    { title: 'Article (For Articles only)', value: 'Article' }
                ],
                layout: 'radio'
            },
            validation: Rule => Rule.required(),
            initialValue: 'Game'
        }),
    ],
})




--- END OF FILE sanity/schemaTypes/tagType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/twoImageGridType.ts ---

// sanity/schemaTypes/twoImageGridType.ts
import { defineType, defineField } from 'sanity';

export default defineType({
    name: 'twoImageGrid',
    title: 'Two Image Grid',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1',
            type: 'image',
            options: { hotspot: true },
        }),
        defineField({
            name: 'image2',
            title: 'Image 2',
            type: 'image',
            options: { hotspot: true },
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }) {
            return {
                title: 'Two Image Grid',
                media: media || media2,
            };
        },
    },
});

--- END OF FILE sanity/schemaTypes/twoImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/authorType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'author',
    title: 'Author', // For Articles
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/authorType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/designerType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'designer',
    title: 'Designer',
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/designerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reporterType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'reporter',
    title: 'Reporter', // For News
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/reporterType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

import {defineField, defineType} from 'sanity'

export default defineType({
    name: 'reviewer',
    title: 'Reviewer', // For Reviews
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})




--- END OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom/fourImageGridType.ts ---




--- END OF FILE sanity/schemaTypes/custom/fourImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom/twoImageGridType.ts ---




--- END OF FILE sanity/schemaTypes/custom/twoImageGridType.ts ---

================================================================================

--- START OF FILE types/index.ts ---

// types/index.ts
import type { SanityAuthor } from "./sanity";

// This type represents the standardized data structure for all content cards,
// as produced by the `adaptToCardProps` adapter.
export type CardProps = {
    type: 'review' | 'article' | 'news';
    id: number | string;
    slug: string;
    game?: string;
    title: string;
    authors: SanityAuthor[]; // UPDATED
    designers?: SanityAuthor[]; // NEW
    date?: string;
    imageUrl: string;
    score?: number;
    tags: string[];
    blurDataURL: string;
    category?: string;
    verdict?: string;
    pros?: string[];
    cons?: string[];
    content?: any[];
    relatedReviewIds?: string[];
};

--- END OF FILE types/index.ts ---

================================================================================

--- START OF FILE types/sanity.ts ---

// types/sanity.ts
import type { Image, PortableTextBlock } from 'sanity'

export interface SanityImage extends Image {
    url: string;
    blurDataURL: string;
    alt?: string;
}

export interface SanityTag {
    _id: string;
    title: string;
    slug: string;
}

export interface SanityAuthor {
    _id: string;
    name: string;
    slug: string;
    prismaUserId: string;
    // --- ENRICHED DATA ---
    username?: string | null;
    image?: string | null;
    bio?: string | null;
}

export interface SanityGame {
    _id: string;
    title: string;
    slug: string;
    mainImage?: SanityImage;
}

export interface SanityReview {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { _id: string, title: string };
    mainImage: SanityImage;
    score: number;
    verdict: string;
    pros: string[];
    cons: string[];
    content: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string;
    relatedReviews: {
        _id: string;
        legacyId: number;
        title: string;
        slug: string;
        mainImage: SanityImage;
        score: number;
        author: { name: string };
        publishedAt: string;
    }[];
}

export interface SanityArticle {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { title: string };
    mainImage: { url: string, blurDataURL: string };
    content?: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string; // <-- NOW REQUIRED
    // publishedYear REMOVED
    relatedArticles?: any[];
}

export interface SanityNews {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    reporters: SanityAuthor[];
    designers?: SanityAuthor[];
    mainImage: { url: string, blurDataURL: string };
    category: string;
    tags: { _id: string, title: string }[];
    publishedAt: string; // <-- NOW REQUIRED
    content?: PortableTextBlock[];
}

export interface SanityGameRelease {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    releaseDate: string;
    platforms: ('PC' | 'PS5' | 'Xbox' | 'Switch')[];
    synopsis: string;
    mainImage: { url: string, blurDataURL: string };
}

export interface SanitySearchResult {
    _id: string;
    _type: 'review' | 'article' | 'news';
    title: string;
    slug: string;
    imageUrl?: string;
    authorName?: string;
    gameTitle?: string;
    category?: string;
}




--- END OF FILE types/sanity.ts ---

================================================================================

