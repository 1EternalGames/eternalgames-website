--- START OF FILE lib/sanity.client.ts ---

// lib/sanity.client.ts

import { createClient } from '@sanity/client'

export const projectId = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID
export const dataset = process.env.NEXT_PUBLIC_SANITY_DATASET
export const apiVersion = process.env.NEXT_PUBLIC_SANITY_API_VERSION

export const client = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    // THE DEFINITIVE FIX: The public, client-side client should NOT use a secret token.
    // Server-side fetching will use the authenticated `sanityWriteClient`.
    // token: process.env.SANITY_API_READ_TOKEN, // <-- THIS LINE IS REMOVED
})

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE lib/sanity.server.ts ---

import { createClient } from '@sanity/client'

const projectId = '0zany1dm'
const dataset = 'production'
const apiVersion = '2025-09-30'

export const sanityWriteClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN,
});

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE app/studio/page.tsx ---

// app/studio/page.tsx

import { createClient } from 'next-sanity';
import { groq } from 'next-sanity';
import { StudioDashboard } from './StudioDashboard';
import { projectId, dataset, apiVersion } from '@/lib/sanity.client';
import { unstable_noStore as noStore } from 'next/cache';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';

// THE DEFINITIVE FIX: Force this page to use the Node.js runtime on Vercel.
export const runtime = 'nodejs';

const studioClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false,
    token: process.env.SANITY_API_WRITE_TOKEN,
});

const allEditableContentQuery = groq`
*[_type in $allowedTypes] | order(_updatedAt desc) {
    _id,
    _type,
    _updatedAt,
    title,
    "slug": slug.current,
    "status": select(
        _type == "gameRelease" => "published",
        defined(publishedAt) && publishedAt < now() => "published",
        !defined(publishedAt) => "draft",
        "scheduled"
    ),
    "mainImage": mainImage,
    "blurDataURL": mainImage.asset->metadata.lqip
}
`;

export default async function StudioPage() {
    noStore();
    
    const session = await getServerSession(authOptions);
    const userRoles = (session?.user as any)?.roles || [];
    
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const allowedContentTypes: string[] = [];

    if (isAdminOrDirector) {
        allowedContentTypes.push('review', 'article', 'news', 'gameRelease');
    } else {
        if (userRoles.includes('REVIEWER')) allowedContentTypes.push('review');
        if (userRoles.includes('AUTHOR')) allowedContentTypes.push('article');
        if (userRoles.includes('REPORTER')) allowedContentTypes.push('news');
    }
    
    if (allowedContentTypes.length === 0 && !userRoles.includes('DESIGNER')) {
        redirect('/'); 
    }

    const content = allowedContentTypes.length > 0
        ? await studioClient.fetch(allEditableContentQuery, { allowedTypes: allowedContentTypes })
        : [];

    return (
        <div className="container page-container">
            <StudioDashboard initialContent={content} userRoles={userRoles} />
        </div>
    );
}

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/page.tsx ---

// app/studio/[contentType]/[id]/page.tsx

import { sanityWriteClient } from '@/lib/sanity.server';
import { editorDocumentQuery, allGamesForStudioQuery, allTagsForStudioQuery, allCreatorsForStudioQuery } from '@/lib/sanity.queries';
import { EditorClient } from "./EditorClient";
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';
import { notFound } from 'next/navigation';

// THE DEFINITIVE FIX: Force this page to use the Node.js runtime on Vercel.
export const runtime = 'nodejs';

// This is now a Server Component
export default async function EditorPage({ params }: { params: { contentType: string; id: string } }) {
    const { id } = params;

    try {
        const [document, allGames, allTags, allCreators] = await Promise.all([
            sanityWriteClient.fetch(editorDocumentQuery, { id }),
            sanityWriteClient.fetch(allGamesForStudioQuery),
            sanityWriteClient.fetch(allTagsForStudioQuery),
            sanityWriteClient.fetch(allCreatorsForStudioQuery)
        ]);

        if (!document) {
            // Use notFound() for a proper 404 page in Next.js App Router
            notFound();
        }
        
        const tiptapContent = portableTextToTiptap(document.content ?? []);
        const documentWithTiptapContent = { ...document, tiptapContent };
        
        return (
            <EditorClient 
                document={documentWithTiptapContent} 
                allGames={allGames}
                allTags={allTags}
                allCreators={allCreators}
            />
        );

    } catch (err: any) {
        console.error("Failed to load editor data:", err);
        // Render an error state if fetching fails
        return (
            <div className="container page-container" style={{ textAlign: 'center' }}>
                <h1 className="page-title">Error Loading Editor</h1>
                <p style={{color: 'var(--text-secondary)'}}>Failed to load editor data. Please check the console for details.</p>
            </div>
        );
    }
}

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE next.config.ts ---

// next.config.ts

/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,

    env: {
        NEXT_PUBLIC_SANITY_PROJECT_ID: '0zany1dm',
        NEXT_PUBLIC_SANITY_DATASET: 'production',
        NEXT_PUBLIC_SANITY_API_VERSION: '2025-09-30',
    },
    images: {
        remotePatterns: [
            // Sanity CMS
            {
                protocol: 'https',
                hostname: 'cdn.sanity.io',
            },
            // Vercel Blob Storage (for user avatars) - WILDCARD ADDED
            {
                protocol: 'https',
                hostname: '*.public.blob.vercel-storage.com',
            },
            // Google OAuth Avatars
            {
                protocol: 'https',
                hostname: 'lh3.googleusercontent.com',
            },
            // GitHub OAuth Avatars
            {
                protocol: 'https',
                hostname: 'avatars.githubusercontent.com',
            },
        ],
    },
    experimental: {
        serverActions: {
            bodySizeLimit: '10mb',
        },
    },
};

export default nextConfig;




--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE .env ---

# .env (COMBINED AND CLEANED)

# --- Primary Application Secrets ---
NEXTAUTH_SECRET=newS3cl7686ZQEQZWop8o7kQ2oiuAmWiA1OV/hDaQp6Xg=
NEXTAUTH_URL=http://localhost:3000

# --- Database (Used by Prisma and Runtime) ---
# RUNTIME POOLED CONNECTION for Serverless functions
DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&pgbouncer=true&pool_timeout=60"

# BUILD-TIME DIRECT CONNECTION for long-lived build processes
BUILD_DATABASE_URL="postgresql://neondb_owner:npg_bgnZWvKH07Xa@ep-still-resonance-adesxhfv.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require"

# --- Vercel Blob ---
BLOB_READ_WRITE_TOKEN="vercel_blob_rw_0dG10aVH15DAsZWd_NvTqPADY3zK83uptFEkaUZCEY0lC8P"

# --- Sanity Tokens ---
# SERVER-SIDE WRITE TOKEN (Used for creating drafts, etc.)
SANITY_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"

# SERVER-SIDE READ TOKEN (Used for fetching data in server components)
SANITY_API_READ_TOKEN="skWyr0w9l0GX2Cm2Zpmu9lApLQFcMxxnJtH8cpIyiWYurpe7FbNQncMSwQxifl2CPjrZKD24UNX1ssTdAvKNQIKD4JXzVH1Ja3AWuepTEtTRwBeOL64AyCG0xcF1UEtW25HInglUx9r8uhJ2HUFxatMJytU4RTdsy84Np8gHsNxDDgJsAhE0"

# --- Revalidation Secret ---
REVALIDATION_SECRET_TOKEN="f9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f9a8"

# --- OAuth Keys ---
AUTH_GITHUB_ID=Ov23liESurJ80uqMFTV0
AUTH_GITHUB_SECRET=e2a8a1fcf50a9f8f2e703858a1a84a7db185e035
GOOGLE_CLIENT_ID=239586132598-orantodqlrirebbhpi5f3dvcu12bampv.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
TWITTER_CLIENT_ID=X3dFNFptdlYzZDJwTVc4TWI1NE06MTpjaQ
TWITTER_CLIENT_SECRET=GzXf4VvOHb7N02qvPZ7SwSLQbujQtu9PtRQHZOUBh2x7mVHHNc

# --- Giscus (Public, but kept here for completeness) ---
NEXT_PUBLIC_GISCUS_REPO=1-eyx/eternalgames-comments
NEXT_PUBLIC_GISCUS_REPO_ID=R_kgDOPt_3hA
NEXT_PUBLIC_GISCUS_CATEGORY=Article Comments
NEXT_PUBLIC_GISCUS_CATEGORY_ID=DIC_kwDOPt_3hM4CvTrq

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE package.json ---

{
  "name": "eternalgames-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "cross-env IS_BUILDING=true next build",
    "start": "next start",
    "lint": "eslint",
    "prisma:seed": "npx ts-node -r dotenv/config prisma/seed.ts",
    "type-check": "tsc --noEmit",
    "type-watch": "tsc --noEmit --watch"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@portabletext/react": "^4.0.3",
    "@prisma/client": "^6.16.1",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@react-three/postprocessing": "^3.0.4",
    "@sanity/client": "^7.12.0",
    "@sanity/icons": "^3.7.4",
    "@sanity/image-url": "^1.2.0",
    "@sanity/vision": "^4.10.1",
    "@tiptap/extension-image": "^2.5.5",
    "@tiptap/extension-link": "^2.5.5",
    "@tiptap/extension-placeholder": "^2.5.5",
    "@tiptap/react": "^2.5.5",
    "@tiptap/starter-kit": "^2.5.5",
    "@types/bcryptjs": "^2.4.6",
    "@vercel/blob": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "dotenv": "^17.2.2",
    "framer-motion": "^12.23.12",
    "next": "16.0.1",
    "next-auth": "^4.24.11",
    "next-sanity": "^11.4.2",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-compare-slider": "^3.1.0",
    "react-dom": "19.1.0",
    "react-image-crop": "^11.0.10",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19",
    "three": "^0.180.0",
    "transliteration": "^2.3.5",
    "uuid": "^9.0.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@fullhuman/postcss-purgecss": "^7.0.2",
    "@sanity/types": "^4.10.1",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "@types/uuid": "^9.0.8",
    "cross-env": "^10.1.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "postcss": "^8.5.6",
    "postcss-cli": "^11.0.1",
    "prisma": "^6.16.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5"
  }
}




--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE tsconfig.json ---

{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "sanity"
  ]
}





--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE app/layout.tsx ---

// app/layout.tsx
import { Cairo } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { ThemeProvider } from '@/components/ThemeProvider';
import NextAuthProvider from '@/components/SessionProvider';
import StudioBar from '@/components/StudioBar';
import ToastProvider from '@/components/ToastProvider';
import UserStoreHydration from '@/components/UserStoreHydration';
import Lightbox from '@/components/Lightbox';
import ScrollToTopButton from '@/components/ui/ScrollToTopButton';

const cairo = Cairo({
subsets: ['arabic', 'latin'],
display: 'swap',
variable: '--font-main',
weight: ['400', '500', '700', '800'],
});

export const metadata = { title: 'EternalGames | الألعاب أبدية', description: 'الألعاب أبدية.', };

export default function RootLayout({ children }: { children: React.ReactNode; }) {
return (
<html lang="ar" dir="rtl" className={cairo.variable} suppressHydrationWarning>
<head>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link
    rel="preconnect"
    href="https://fonts.gstatic.com"
    crossOrigin="anonymous"
/>
<link
    rel="preconnect"
    href="https://cdn.sanity.io"
    crossOrigin="anonymous"
/>
</head>
<body>
<NextAuthProvider>
<UserStoreHydration />
<ThemeProvider attribute="data-theme" defaultTheme="system" enableSystem disableTransitionOnChange>
<div style={{ position: 'relative', width: '100%', overflowX: 'clip' }}>
    <ToastProvider />
    <Lightbox /> 
    <Navbar />
    <main>{children}</main>
    <Footer />
    <StudioBar />
    <ScrollToTopButton />
</div>
</ThemeProvider>
</NextAuthProvider>
</body>
</html>
);
}

--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE app/lib/authOptions.ts ---

// app/lib/authOptions.ts

import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import TwitterProvider from "next-auth/providers/twitter";
import CredentialsProvider from "next-auth/providers/credentials";

export const authOptions = {
    adapter: PrismaAdapter(prisma),
    providers: [
        CredentialsProvider({
            id: 'credentials',
            name: "Credentials",
            credentials: {
                email: { label: "البريد الإلكتروني", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) throw new Error("البيانات ناقصة.");
                const user = await prisma.user.findUnique({ where: { email: credentials.email } });
                if (!user) throw new Error("لا حساب بهذا البريد. تفضل بالتسجيل.");
                if (!user.password) throw new Error("هذا الحساب مرتبط بمزود خارجي.");
                const isPasswordValid = await bcrypt.compare(credentials.password, user.password);
                if (isPasswordValid) return user;
                else throw new Error("كلمة السر غير صحيحة.");
            }
        }),
        CredentialsProvider({
            id: 'signup',
            name: "SignUp",
            credentials: {
                email: { label: "البريد الإلكتروني", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials) throw new Error("Missing sign-up details.");
                const { email, password } = credentials;
                if (!email || !password) throw new Error("كافة الحقول إلزامية.");
                if (!/\S+@\S+\.\S+/.test(email)) throw new Error('البريد الإلكتروني غير صالح.');
                if (password.length < 8) throw new Error('يجب ألا تقل كلمة السر عن ثمانية أحرف.');
                
                const existingEmail = await prisma.user.findUnique({ where: { email } });
                if (existingEmail) throw new Error('هذا البريد مسجل بالفعل.');

                const hashedPassword = await bcrypt.hash(credentials.password, 10);
                const newUser = await prisma.user.create({
                    data: {
                        email: credentials.email,
                        password: hashedPassword,
                    }
                });
                return newUser;
            }
        }),
        GithubProvider({ 
            clientId: process.env.AUTH_GITHUB_ID as string, 
            clientSecret: process.env.AUTH_GITHUB_SECRET as string, 
        }),
        GoogleProvider({ 
            clientId: process.env.GOOGLE_CLIENT_ID as string, 
            clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, 
        }),
        TwitterProvider({ 
            clientId: process.env.TWITTER_CLIENT_ID as string, 
            clientSecret: process.env.TWITTER_CLIENT_SECRET as string, 
            version: "2.0", 
        }),
    ],
    events: {
        createUser: async ({ user }: any) => {
            const userRole = await prisma.role.findUnique({ where: { name: 'USER' } });
            if (userRole) {
                await prisma.user.update({ 
                    where: { id: user.id }, 
                    data: { roles: { connect: { id: userRole.id } } } 
                });
            }
        }
    },
    session: { strategy: "jwt" as const },
    secret: process.env.NEXTAUTH_SECRET,
    callbacks: {
        async signIn({ user }: any) {
            return true;
        },
        async jwt({ token, user, trigger }: any) {
            if (user || trigger === "update") {
                const dbUser = await prisma.user.findUnique({
                    where: { id: (token.id as string) || user?.id },
                    include: { roles: true }
                });

                if (dbUser) {
                    token.id = dbUser.id;
                    token.picture = dbUser.image;
                    token.name = dbUser.name;
                    token.roles = dbUser.roles.map(role => role.name);
                    token.username = dbUser.username;
                    token.needsOnboarding = !dbUser.name || !dbUser.username;
                }
            }
            return token;
        },
        async session({ session, token }: any) {
            if (token && session.user) {
                session.user.id = token.id;
                session.user.roles = token.roles;
                session.user.name = token.name;
                session.user.email = token.email;
                session.user.image = token.picture;
                session.user.username = token.username;
                session.needsOnboarding = token.needsOnboarding;
            }
            return session;
        },
    },
    pages: { signIn: '/', error: '/', },
};




--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE prisma/schema.prisma ---

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[] @relation("RoleToUser")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  username            String?              @unique
  email               String?              @unique
  emailVerified       DateTime?
  image               String?
  password            String?
  createdAt           DateTime             @default(now())
  bio                 String?
  twitterHandle       String?
  age                 Int?
  country             String?
  agePublic           Boolean              @default(true)
  countryPublic       Boolean              @default(true)
  instagramHandle     String?
  accounts            Account[]
  engagements         Engagement[]
  comments            Comment[]
  commentVotes        CommentVote[]
  passwordResetTokens PasswordResetToken[]
  sessions            Session[]
  shares              Share[]
  roles               Role[]               @relation("RoleToUser")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  token   String   @unique
  expires DateTime
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Engagement {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  type        EngagementType
  userId      String
  contentId   Int
  contentType String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId, contentType, type])
}

model Share {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  userId      String
  contentId   Int
  contentType String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Comment {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  content     String
  contentSlug String
  isDeleted   Boolean       @default(false)
  authorId    String
  parentId    String?
  author      User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent      Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies     Comment[]     @relation("CommentReplies")
  votes       CommentVote[]
}

model CommentVote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  type      VoteType
  userId    String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
}

enum VoteType {
  LIKE
  DISLIKE
}

enum EngagementType {
  LIKE
  BOOKMARK
}







--- END OF FILE {filepath} ---

================================================================================

--- START OF FILE sanity/sanity.config.ts ---

import {defineConfig} from 'sanity'
import {structureTool} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'

const projectId = '0zany1dm'
const dataset = 'production'
// THE FIX: Aligned the API version to match the rest of the application.
const apiVersion = '2025-09-30'

export default defineConfig({
  basePath: '/studio',
  projectId,
  dataset,
  schema: {
    types: schemaTypes,
  },
  plugins: [
    structureTool(),
    visionTool({defaultApiVersion: apiVersion}),
  ],
})

--- END OF FILE {filepath} ---

================================================================================

