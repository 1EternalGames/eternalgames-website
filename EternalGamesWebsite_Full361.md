--- START OF FILE next-auth.d.ts ---

// next-auth.d.ts
import 'next-auth';
import 'next-auth/jwt';

declare module 'next-auth' {
  /**
   * The `User` object is available in callbacks.
   */
  interface User {
    id: string;
    roles: string[];
    username?: string | null;
    name?: string | null;
    email?: string | null;
    image?: string | null;
  }

  /**
   * The `Session` object is what is returned to the client.
   */
  interface Session {
    user: User; // The user object now includes all our custom and default fields.
    needsOnboarding?: boolean;
    expires: string; // THE FIX: Explicitly add expires to satisfy SessionProvider requirements
  }
}

declare module 'next-auth/jwt' {
  /**
   * The `JWT` interface is used in the `jwt` callback.
   */
  interface JWT {
    id: string;
    roles: string[];
    username?: string | null;
    needsOnboarding?: boolean;
  }
}




--- END OF FILE next-auth.d.ts ---

================================================================================

--- START OF FILE next.config.ts ---

// next.config.ts

const cspHeader = `
    default-src 'self';
    script-src 'self' 'unsafe-eval' 'unsafe-inline' https://va.vercel-scripts.com https://www.googletagmanager.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    img-src 'self' blob: data: https://cdn.sanity.io https://*.public.blob.vercel-storage.com https://lh3.googleusercontent.com https://avatars.githubusercontent.com https://images.unsplash.com https://img.youtube.com https://www.googletagmanager.com;
    font-src 'self' https://fonts.gstatic.com;
    frame-src 'self' https://www.youtube.com https://youtube.com;
    connect-src 'self' https://*.sanity.io https://api.sanity.io https://*.vercel-storage.com https://www.google-analytics.com https://analytics.google.com https://googletagmanager.com;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    block-all-mixed-content;
    upgrade-insecure-requests;
`;

/** @type {import('next').NextConfig} */
const nextConfig = {
    reactStrictMode: true,

    // SECURITY: Hardened Headers with CSP + HSTS
    async headers() {
        return [
            {
                source: '/(.*)',
                headers: [
                    {
                        key: 'Content-Security-Policy',
                        value: cspHeader.replace(/\n/g, ''),
                    },
                    {
                        key: 'X-Content-Type-Options',
                        value: 'nosniff',
                    },
                    {
                        key: 'X-Frame-Options',
                        value: 'DENY',
                    },
                    {
                        key: 'X-XSS-Protection',
                        value: '1; mode=block',
                    },
                    {
                        key: 'Referrer-Policy',
                        value: 'strict-origin-when-cross-origin',
                    },
                    {
                        key: 'Permissions-Policy',
                        value: 'camera=(), microphone=(), geolocation=()',
                    },
                    // NEW: HSTS (Force HTTPS for 2 years)
                    {
                        key: 'Strict-Transport-Security',
                        value: 'max-age=63072000; includeSubDomains; preload',
                    },
                ],
            },
        ];
    },

    images: {
        formats: ['image/avif', 'image/webp'],
        // OPTIMIZATION: Explicit device sizes to ensure 2K and 4K screens get exact resolutions
        deviceSizes: [640, 750, 828, 1080, 1200, 1440, 1920, 2048, 2560, 3840],
        remotePatterns: [
            { protocol: 'https', hostname: 'cdn.sanity.io' },
            { protocol: 'https', hostname: '*.public.blob.vercel-storage.com' },
            { protocol: 'https', hostname: 'lh3.googleusercontent.com' },
            { protocol: 'https', hostname: 'avatars.githubusercontent.com' },
            { protocol: 'https', hostname: 'images.unsplash.com' },
            // ADDED: YouTube Thumbnails
            { protocol: 'https', hostname: 'img.youtube.com' },
        ],
    },

    experimental: {
        serverActions: {
            bodySizeLimit: '10mb',
        },
    },
};

export default nextConfig;

--- END OF FILE next.config.ts ---

================================================================================

--- START OF FILE package.json ---

{
  "name": "eternalgames-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "prisma generate && next build",
    "postinstall": "prisma generate",
    "start": "next start",
    "lint": "eslint",
    "prisma:seed": "npx ts-node -r dotenv/config prisma/seed.ts",
    "type-check": "tsc --noEmit",
    "type-watch": "tsc --noEmit --watch",
    "screenshots": "npx ts-node scripts/capture-screenshots.ts"
  },
  "dependencies": {
    "@next-auth/prisma-adapter": "^1.0.7",
    "@portabletext/react": "^4.0.3",
    "@prisma/adapter-pg": "^7.0.0",
    "@prisma/client": "latest",
    "@react-three/drei": "^10.7.6",
    "@react-three/fiber": "^9.3.0",
    "@react-three/postprocessing": "^3.0.4",
    "@sanity/client": "^7.12.0",
    "@sanity/icons": "^3.7.4",
    "@sanity/image-url": "^1.2.0",
    "@sanity/vision": "^4.10.1",
    "@tiptap/extension-color": "^2.27.1",
    "@tiptap/extension-image": "^2.5.5",
    "@tiptap/extension-link": "^2.5.5",
    "@tiptap/extension-placeholder": "^2.5.5",
    "@tiptap/extension-table": "^2.5.5",
    "@tiptap/extension-table-cell": "^2.5.5",
    "@tiptap/extension-table-header": "^2.5.5",
    "@tiptap/extension-table-row": "^2.5.5",
    "@tiptap/extension-text-style": "^2.27.1",
    "@tiptap/react": "^2.5.5",
    "@tiptap/starter-kit": "^2.5.5",
    "@types/bcryptjs": "^2.4.6",
    "@upstash/ratelimit": "^2.0.7",
    "@upstash/redis": "^1.35.8",
    "@vercel/analytics": "^1.6.1",
    "@vercel/blob": "^2.0.0",
    "bcryptjs": "^3.0.2",
    "dotenv": "^17.2.2",
    "framer-motion": "^12.23.12",
    "lenis": "^1.3.16",
    "next": "^16.0.10",
    "next-auth": "^4.24.11",
    "next-sanity": "^11.4.2",
    "next-themes": "^0.4.6",
    "pg": "^8.11.3",
    "react": "^19.2.3",
    "react-compare-slider": "^3.1.0",
    "react-dom": "^19.2.3",
    "react-image-crop": "^11.0.10",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19",
    "three": "^0.180.0",
    "transliteration": "^2.3.5",
    "uuid": "^9.0.1",
    "xss": "^1.0.15",
    "zod": "^3.25.76",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@fullhuman/postcss-purgecss": "^7.0.2",
    "@sanity/types": "^4.10.1",
    "@types/node": "^20",
    "@types/pg": "^8.10.9",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.180.0",
    "@types/uuid": "^9.0.8",
    "baseline-browser-mapping": "^2.9.9",
    "cross-env": "^10.1.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "postcss": "^8.5.6",
    "postcss-cli": "^11.0.1",
    "prisma": "latest",
    "puppeteer": "^24.34.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.6",
    "typescript": "^5"
  }
}


--- END OF FILE package.json ---

================================================================================

--- START OF FILE tsconfig.json ---

{
  "compilerOptions": {
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "target": "ES2017"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "lib/generated/client/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "sanity"
  ]
}


--- END OF FILE tsconfig.json ---

================================================================================

--- START OF FILE sanity.cli.ts ---

import { defineCliConfig } from 'sanity/cli'

const projectId = '0zany1dm'
const dataset = 'production'

export default defineCliConfig({
  api: { projectId, dataset }
})







--- END OF FILE sanity.cli.ts ---

================================================================================

--- START OF FILE app/global-error.tsx ---

// app/global-error.tsx
'use client';

import { useEffect } from 'react';
import { Cairo } from 'next/font/google';

// Use Google Font for error page consistency
const cairo = Cairo({
  subsets: ['arabic', 'latin'],
  weight: ['400', '700'],
  variable: '--font-main',
  display: 'swap',
});

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
        console.error('Global Error caught:', error);
    }
  }, [error]);

  return (
    <html lang="ar" dir="rtl" className={cairo.className}>
      <body style={{ 
        margin: 0, 
        padding: 0, 
        backgroundColor: '#050505', 
        color: '#E1E1E6', 
        fontFamily: 'var(--font-main), sans-serif',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        backgroundImage: 'radial-gradient(circle at 50% 0%, #1a1a1a 0%, #050505 70%)'
      }}>
        <div style={{ 
            textAlign: 'center', 
            padding: '4rem', 
            maxWidth: '500px',
            border: '1px solid #2a2e3c',
            borderRadius: '12px',
            backgroundColor: '#0A0B0F',
            boxShadow: '0 20px 50px rgba(0,0,0,0.5)'
        }}>
          <h2 style={{ fontSize: '3.2rem', marginBottom: '1.5rem', color: '#DC2626', fontWeight: 800 }}>
            عذراً، حدث خطأ غير متوقع
          </h2>
          <p style={{ color: '#7D808C', marginBottom: '3rem', fontSize: '1.6rem', lineHeight: 1.6 }}>
             واجه النظام خللاً تقنياً مفاجئاً. فريقنا يعمل على استعادة الخدمة.
             {error.digest && (
                 <span style={{
                     display: 'block', 
                     marginTop: '2rem', 
                     padding: '1rem',
                     backgroundColor: 'rgba(255,255,255,0.05)',
                     borderRadius: '6px',
                     fontFamily: 'monospace',
                     fontSize: '1.2rem',
                     color: '#555'
                 }}>
                     رمز الخطأ: {error.digest}
                 </span>
             )}
          </p>
          <button
            onClick={() => reset()}
            style={{
              padding: '1.2rem 3rem',
              backgroundColor: '#00FFF0',
              color: '#050505',
              border: 'none',
              borderRadius: '8px',
              fontWeight: '800',
              fontSize: '1.6rem',
              cursor: 'pointer',
              boxShadow: '0 0 15px rgba(0, 255, 240, 0.3)',
              transition: 'transform 0.2s',
              fontFamily: 'inherit'
            }}
            onMouseOver={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
            onMouseOut={(e) => e.currentTarget.style.transform = 'scale(1)'}
          >
            تحديث الصفحة
          </button>
        </div>
      </body>
    </html>
  );
}

--- END OF FILE app/global-error.tsx ---

================================================================================

--- START OF FILE app/globals.css ---

:root {
  /* --- DEFAULT (DARK) --- */
  /* Swapped: Dark is now the default for immediate painting */
  --bg-primary: #0A0B0F; 
  --bg-secondary: #14161D;
  --text-primary: #E1E1E6;
  --text-secondary: #7D808C;
  --accent: #00FFF0; 
  --warning: #FFD700; 
  --critical: #DC2626; 
  --overlay-color: rgba(10, 11, 15, 0.7);
  --border-color: #2a2e3c;
  --nav-height: 8rem;
  --nav-height-scrolled: 6rem;
  
  /* Shared Font Stack for Social Templates */
  --font-social: 'Dystopian', var(--font-main), sans-serif;
}

/* --- SOCIAL MEDIA FONT SETUP --- */
@font-face {
  font-family: 'Dystopian';
  src: url('/fonts/SDDystopianFull.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  /* English Letters, Numbers, Dot, Colon */
  unicode-range: U+002E, U+0030-003A, U+0041-005A, U+0061-007A;
}

[data-theme="light"] {
  /* --- LIGHT THEME OVERRIDES --- */
  --bg-primary: #F9FAFB;
  --bg-secondary: #FFFFFF;
  --text-primary: #1F2937;
  --text-secondary: #6B7280;
  --accent: #00d1c6; /* Cyan maintained */
  --warning: #FFD700; 
  --critical: #DC2626; 
  --overlay-color: rgba(249, 250, 251, 0.7);
  --border-color: #E5E7EB;
}

/* --- BRANDED SELECTION --- */
::selection {
    background-color: var(--accent);
    color: #050505;
    text-shadow: none;
}

*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
}

html {
  font-size: 62.5%;
  scroll-behavior: smooth;
  scrollbar-width: thin;
  scrollbar-color: var(--accent) transparent;
  direction: rtl;
  overflow-x: hidden;
  
  /* CRITICAL FIX: Paint the canvas immediately with the primary background */
  background-color: var(--bg-primary);
}

body::-webkit-scrollbar { width: 8px; }
body::-webkit-scrollbar-track { background: transparent; }
body::-webkit-scrollbar-thumb { background-color: var(--accent); border-radius: 4px; }

body {
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-main), sans-serif;
  font-size: 1.8rem;
  line-height: 1.7;
  transition: background-color 0.3s ease, color 0.3s ease;
  position: relative;
}

[data-theme="dark"] body {
  /* In dark mode, we allow transparency so the SpaceBackground (if visible) can shine through */
  /* Note: html background color is still #0A0B0F behind this, preventing white flash */
  background-color: transparent; 
}

/* --- NO GLASS MODE (Global Fallback) --- */
body.no-glass * {
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

/* --- GROUNDBREAKING OPTIMIZATION: Render Culling --- */
.gpu-cull {
    content-visibility: auto;
    contain-intrinsic-size: 1px 500px;
}

/* --- GROUNDBREAKING OPTIMIZATION: Texture Decoding --- */
img {
    content-visibility: auto;
}

h1,h2,h3,h4,h5,h6{
font-family:var(--font-main), sans-serif;
font-weight:700;
line-height:1.2;
}
h1{font-size:5.6rem;}
h2{font-size:4.0rem;}
h3{font-size:2.8rem;}
a{color:var(--accent);text-decoration:none;position:relative;display:inline-block;}
a:not(.no-underline)::after{
content:'';position:absolute;width:100%;transform:scaleX(0);height:2px;
bottom:-4px;right:0;
background-color:var(--accent);
transform-origin:bottom right;
transition:transform 0.3s ease-out;
}
@media (hover: hover) {
  
  a:not(.no-underline):hover::after  {transform:scaleX(1);}
}
a:not(.no-underline):active::after {transform:scaleX(1);}

img{max-width:100%;height:auto;display:block;}
.container{max-width:1200px;margin:0 auto;padding:0 2rem;}
.section{padding:8rem 0;}
.section-title{text-align:center;margin-bottom:4rem;font-weight:800;color:var(--text-primary);}
.sr-only{
position:absolute;width:1px;height:1px;padding:0;margin:-1px;
overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0;
}
.page-container{padding-top:calc(var(--nav-height-scrolled) + 4rem);padding-bottom:6rem;min-height:80vh;}
.page-title{font-size:4.2rem;font-weight:800;text-align:center;margin-bottom:4rem;color:var(--text-primary);overflow-wrap:break-word;word-break:break-word;}

.content-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill,minmax(320px,1fr));
  gap: 3rem;
  grid-auto-rows: 1fr;
  padding: 3rem; 
  margin: -3rem; 
}

.portable-text-content {
  overflow-wrap: break-word;
  word-break: break-word;
}

.portable-text-content p:empty {
  height: 3rem;
}

.toast-container-global {
position: fixed;
bottom: 2rem;
left: 2rem;
z-index: 9999;
display: flex;
flex-direction: column;
gap: 1rem;
}
.toast-container-global[style*="right: 2rem"] {
    right: 2rem;
    left: auto;
}
.toast-container-global[style*="left: 2rem"] {
    left: 2rem;
    right: auto;
}
@media (hover: hover) {
  
  .primary-button.delete-forever:hover  {
  box-shadow: 0 0 20px color-mix(in srgb, #DC2626 50%, transparent) !important;
  transform: scale(1.05) translateY(-1px) !important;
}
}
.primary-button.delete-forever:active {
  box-shadow: 0 0 20px color-mix(in srgb, #DC2626 50%, transparent) !important;
  transform: scale(1.05) translateY(-1px) !important;
}


.primary-button{background-color:var(--accent);color:#050505;border:none;padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:800;cursor:pointer;box-shadow:0 0 15px color-mix(in srgb,var(--accent) 30%,transparent);transition:transform 0.2s ease-out,box-shadow 0.2s ease-out;}
@media (hover: hover) {
  
  .primary-button:hover:not(:disabled)  {transform:scale(1.05) translateY(-1px);box-shadow:0 0 25px color-mix(in srgb,var(--accent) 50%,transparent);}
}
.primary-button:active:not(:disabled) {transform:scale(1.05) translateY(-1px);box-shadow:0 0 25px color-mix(in srgb,var(--accent) 50%,transparent);}

.primary-button:disabled{background-color:var(--border-color);color:var(--text-secondary);box-shadow:none;cursor:not-allowed;opacity:0.6;}
.outline-button{background:transparent;border:1px solid var(--border-color);color:var(--text-secondary);padding:1rem 2.4rem;border-radius:5px;font-family:var(--font-main),sans-serif;font-weight:500;cursor:pointer;transition:background-color 0.15s ease-out,color 0.15s ease-out,border-color 0.15s ease-out;}
@media (hover: hover) {
  
  .outline-button:hover:not(:disabled)  {border-color:var(--accent);color:var(--accent);background-color:color-mix(in srgb,var(--accent) 10%,transparent);}
}
.outline-button:active:not(:disabled) {border-color:var(--accent);color:var(--accent);background-color:color-mix(in srgb,var(--accent) 10%,transparent);}

.outline-button:disabled{opacity:0.6;cursor:not-allowed;}

.profile-form-group{
  position:relative;
  margin-bottom:2.5rem;
}

.profile-form-label{
  position:absolute;
  right:1.5rem;
  left: auto;
  top:1rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-secondary);
  pointer-events:none;
  transition:all 0.2s ease-out;
}

.profile-input:focus ~ .profile-form-label,
.profile-input:not([value=""]):not(:placeholder-shown) ~ .profile-form-label {
  top:-2rem;
  right:0;
  left: auto;
  font-size:1.4rem;
  font-weight:600;
  color:var(--accent);
}

.profile-input{
  width:100%;
  background-color:var(--bg-secondary);
  border:1px solid var(--border-color);
  border-radius:8px;
  padding: 1.2rem 1.5rem;
  height: 4.8rem;
  font-family:var(--font-main);
  font-size:1.6rem;
  color:var(--text-primary);
  transition:border-color 0.3s ease,box-shadow 0.3s ease;
  text-align: right;
}

.profile-input:focus{
  outline:none;
  border-color:var(--accent);
  box-shadow:0 0 0 3px color-mix(in srgb,var(--accent) 20%,transparent);
}

.profile-input::placeholder {
  color: var(--text-secondary);
  opacity: 0.7;
}

.profile-input:focus::placeholder {
  opacity: 0.5;
}

.profile-input[type=number]::-webkit-inner-spin-button, 
.profile-input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
}
.profile-input[type=number] {
    -moz-appearance: textfield;
}

.user-avatar{
  border-radius:50%;
  border:2px solid transparent;
  transition:border-color 0.3s ease;
}

.primary-button.delete-forever {
  background-color: #DC2626;
  box-shadow: 0 0 15px color-mix(in srgb, #DC2626 30%, transparent);
  color: #fff;
}

.country-picker-button {
    display: block;
    width: 100%;
    padding: 0.75rem 1.5rem;
    text-align: right;
    background: none;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease;
}
@media (hover: hover) {
  
  .country-picker-button:hover  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}
}
.country-picker-button:active {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}


.info-tooltip-container {
    position: relative;
}
.info-tooltip-text {
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.75rem 1rem;
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    z-index: 10;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    border: 1px solid var(--border-color);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease-out, visibility 0.2s;
    pointer-events: none;
}
@media (hover: hover) {
  
  .info-tooltip-container:hover .info-tooltip-text  {
    opacity: 1;
    visibility: visible;
}
}
.info-tooltip-container:active .info-tooltip-text {
    opacity: 1;
    visibility: visible;
}


.toggle {
  width: 44px;
  height: 24px;
  background-color: var(--border-color);
  border-radius: 999px;
  padding: 2px;
  display: flex;
  cursor: pointer;
  justify-content: flex-start;
  border: none;
  transition: background-color 0.2s ease-out;
}
.toggle.active {
  background-color: var(--accent);
  justify-content: flex-end;
}
.toggle-handle {
  width: 20px;
  height: 20px;
  background-color: white;
  border-radius: 50%;
}

.creator-credit-link {
  color: var(--accent);
  font-weight: 500;
}

.news-card-category {
    display: inline-block;
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    font-family: var(--font-main), sans-serif;
    font-size: 1.4rem;
    font-weight: 600;
    border: 1px solid var(--accent);
}

.sidebar-input::placeholder,
div[class*="sidebarInput"] > span {
    text-align: right;
    color: var(--text-secondary);
}

div[class*="sidebarInput"] > span[style*="position: absolute"] {
    right: 1rem !important;
    left: auto !important;
}

body.editor-active,
body.mobile-menu-open {
    overflow: hidden !important;
}

body.editor-active footer,
body.constellation-active footer {
    display: none !important;
}

/* --- FULLSCREEN MODE (Constellation / Almanac) --- */

/* Hide Footer and Studio Bar */
body.fullscreen-active > footer,
body.fullscreen-active > div[class*="StudioBar_studioBar"] {
    display: none !important;
}

/* Make Navbar Transparent */
body.fullscreen-active header {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border: none !important;
    box-shadow: none !important;
    pointer-events: none; /* Click-through */
}

/* Keep Logo Interactive */
body.fullscreen-active header a[href="/"] {
    pointer-events: auto !important;
    opacity: 1 !important; /* THE FIX: Force full opacity */
    transition: opacity 0.3s;
}
/* REMOVED: Hover opacity change as we want it fully visible always */

/* Hide Navigation Links & Controls */
body.fullscreen-active header #navbar-desktop-nav,
body.fullscreen-active header #navbar-desktop-controls,
body.fullscreen-active header #navbar-mobile-left,
body.fullscreen-active header #navbar-mobile-right {
    display: none !important;
    opacity: 0;
    pointer-events: none;
}

/* --- End Fullscreen Mode --- */

body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"] {
    background: transparent !important;
    border-color: transparent !important;
    color: rgba(255,255,255,0.4) !important;
}
@media (hover: hover) {
  
  body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"]:hover  {
    color: var(--accent) !important;
    box-shadow: none !important;
}
}
body.fullscreen-active button[class*="ConstellationControlPanel_settingsButton"]:active {
    color: var(--accent) !important;
    box-shadow: none !important;
}


.image-lightbox-trigger {
    position: relative;
    display: block;
    cursor: zoom-in;
    border-radius: 8px;
    overflow: hidden;
}

.image-lightbox-trigger::after {
    content: 'عرض الصورة كاملة';
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-main);
    font-weight: 600;
    font-size: 1.6rem;
    color: white;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(2px);
    opacity: 0;
    transition: opacity 0.2s ease-out;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3Cline x1='11' y1='8' x2='11' y2='14'%3E%3C/line%3E%3Cline x1='8' y1='11' x2='14' y2='11'%3E%3C/line%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center 25%;
    padding-top: 40px;
}
@media (hover: hover) {
  
  .image-lightbox-trigger:hover::after  {
    opacity: 1;
}
}
.image-lightbox-trigger:active::after {
    opacity: 1;
}


.image-lightbox-trigger img {
    transition: transform 0.3s ease-out;
}
@media (hover: hover) {
  
  .image-lightbox-trigger:hover img  {
    transform: scale(1.03);
}
}
.image-lightbox-trigger:active img {
    transform: scale(1.03);
}


body.lightbox-active {
    overflow: hidden !important;
}

@media (max-width: 1024px) {
  html { font-size: 60%; }
}

@media (max-width: 768px) {
  h1 { font-size: 4.2rem; }
  h2 { font-size: 3.2rem; }
  h3 { font-size: 2.4rem; }
  .page-title { font-size: 3.6rem; }
  .section { padding: 6rem 0; }
  .page-container { padding-top: calc(var(--nav-height-scrolled) + 2rem); padding-bottom: 4rem; }
  .container { padding: 0 1.5rem; }
  .content-grid { 
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 2rem;
  }
  .toast-container-global { bottom: 1.5rem; left: 1.5rem; right: 1.5rem !important; width: auto; }
  .primary-button, .outline-button { padding: 1.2rem 2rem; font-size: 1.6rem; }
  .news-card-category {
    font-size: 1.2rem;
    padding: 0.3rem 1rem;
  }
}

@media (max-width: 480px) {
  html { font-size: 58%; }
  body { font-size: 1.6rem; }
  h1 { font-size: 3.6rem; }
  h2 { font-size: 2.8rem; }
  h3 { font-size: 2.2rem; }
  .page-title { font-size: 2.5rem; }
  .content-grid { 
    grid-template-columns: 1fr;
  }
}

.text-stroke-effect {
    -webkit-text-stroke: 1.5px #FFFFFF;
    color: transparent !important;
    font-weight: 900;
    paint-order: stroke fill;
}

.social-editor-content .ProseMirror {
    outline: none;
    min-height: 100%;
}

.social-editor-content .ProseMirror p.is-editor-empty:first-child::before {
    content: attr(data-placeholder);
    color: rgba(255,255,255,0.3);
    float: right;
    pointer-events: none;
    height: 0;
}

.social-editor-content .ProseMirror p {
    margin: 0 !important;
}

/* --- PRINT STYLES --- */
@media print {
    @page { margin: 2cm; }
    
    /* Hide navigational and interactive elements */
    header, footer, nav, 
    .studioBar, .scrollToTopButton, 
    .toast-container-global, 
    .readingHud, .sidebar, 
    .content-grid > *:not(main),
    button, .filterButton, .navSearch {
        display: none !important;
    }

    /* Reset background and colors for readability on paper */
    body {
        background-color: white !important;
        color: black !important;
        font-size: 12pt;
    }

    /* Ensure text is black */
    p, h1, h2, h3, h4, h5, h6, li, span, div {
        color: #000 !important;
        text-shadow: none !important;
    }

    /* Expand main content */
    main {
        width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
    }

    /* Handle Images */
    img {
        max-width: 100% !important;
        filter: none !important;
        break-inside: avoid;
    }

    /* Links */
    a {
        text-decoration: underline;
        color: #000 !important;
    }
    
    /* Show URLs after links */
    a[href^="http"]::after {
        content: " (" attr(href) ")";
        font-size: 0.8em;
        color: #666;
    }
}

--- END OF FILE app/globals.css ---

================================================================================

--- START OF FILE app/icon.tsx ---

// app/icon.tsx
import { ImageResponse } from 'next/og';

// Route segment config
export const runtime = 'edge';

// Image metadata
export const size = {
  width: 32,
  height: 32,
};
export const contentType = 'image/png';

// Image generation
export default function Icon() {
  return new ImageResponse(
    (
      <div
        style={{
          background: '#0A0B0F',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          borderRadius: '20%', // Squircle shape
        }}
      >
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            viewBox="0 0 892 1617" 
            width="14" 
            height="24"
        >
          <path 
            fill="#0dffff" 
            d="M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z"
          />
        </svg>
      </div>
    ),
    {
      ...size,
      headers: {
        'Cache-Control': 'public, max-age=31536000, immutable',
      },
    }
  );
}

--- END OF FILE app/icon.tsx ---

================================================================================

--- START OF FILE app/layout.tsx ---

// app/layout.tsx

import { Cairo } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import { ThemeProvider } from '@/components/ThemeProvider';
import NextAuthProvider from '@/components/SessionProvider';
import StudioBar from '@/components/StudioBar';
import ToastProvider from '@/components/ToastProvider';
import UserStoreHydration from '@/components/UserStoreHydration';
import Lightbox from '@/components/Lightbox';
import ScrollToTopButton from '@/components/ui/ScrollToTopButton';
import PageTransitionWrapper from '@/components/PageTransitionWrapper';
import SpaceBackground from '@/components/ui/SpaceBackground';
import type { Metadata } from 'next';
import FPSAutoTuner from '@/components/FPSAutoTuner'; 
import KonamiCode from '@/components/effects/KonamiCode';
import GoogleAnalytics from '@/components/seo/GoogleAnalytics';
import SmoothScrolling from '@/components/ui/SmoothScrolling';
import OrganizationJsonLd from '@/components/seo/OrganizationJsonLd';
import CookieConsent from '@/components/CookieConsent';
import KineticOverlayManager from '@/components/kinetic/KineticOverlayManager'; 
import { getCachedColorDictionary } from '@/lib/sanity.fetch';
import UniversalBaseLoader from '@/components/UniversalBaseLoader';
import PerformanceHint from '@/components/PerformanceHint';
import ProgressBar from '@/components/ui/ProgressBar';
import { Analytics } from '@vercel/analytics/react';

const cairo = Cairo({
  subsets: ['arabic', 'latin'],
  weight: ['400', '500', '700', '800', '900'], 
  variable: '--font-main',
  display: 'swap',
});

const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';

export const metadata: Metadata = {
  metadataBase: new URL(siteUrl), 
  title: {
    default: 'EternalGames | حيث لا تُفنى الألعاب',
    template: '%s | EternalGames',
  },
  description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
  alternates: {
    canonical: './',
    types: {
      'application/rss+xml': [
          { url: '/feed.xml', title: 'EternalGames Main Feed' },
          { url: '/feed/reviews', title: 'EternalGames Reviews' },
          { url: '/feed/news', title: 'EternalGames News' },
          { url: '/feed/articles', title: 'EternalGames Articles' },
      ],
    },
  },
  other: {
      'application/opensearchdescription+xml': '/opensearch.xml',
  },
  authors: [
      { name: 'EternalGames Team', url: siteUrl },
      { name: 'MoVisionX', url: '/humans.txt' }
  ],
  openGraph: {
    title: {
      default: 'EternalGames | حيث لا تُفنى الألعاب',
      template: '%s | EternalGames',
    },
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    url: siteUrl,
    siteName: 'EternalGames',
    images: [
      {
        url: `/og.png`, 
        width: 1200,
        height: 630,
        alt: 'EternalGames Logo',
      },
    ],
    locale: 'ar_SA',
    type: 'website',
  },
  twitter: {
    card: 'summary_large_image',
    title: {
      default: 'EternalGames | حيث لا تُفنى الألعاب',
      template: '%s | EternalGames',
    },
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار بتجربة تفاعلية فريدة.',
    images: [`/og.png`],
  },
  verification: {
    google: 'YOUR_GOOGLE_VERIFICATION_CODE', 
    yandex: 'YOUR_YANDEX_VERIFICATION_CODE',
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
};

export default async function RootLayout({ children }: { children: React.ReactNode; }) {
  const dictionary = await getCachedColorDictionary();
  const colors = dictionary?.autoColors || [];

  return (
    <html lang="ar" dir="rtl" className={cairo.variable} suppressHydrationWarning>
      <head>
        <link
          rel="preconnect"
          href="https://cdn.sanity.io"
          crossOrigin="anonymous"
        />
      </head>
      <body>
        <NextAuthProvider>
          <UserStoreHydration />
          
          <Analytics />
          
          <GoogleAnalytics gaId={process.env.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID} />
          <OrganizationJsonLd />
          
          <ThemeProvider attribute="data-theme" defaultTheme="system" enableSystem disableTransitionOnChange>
            <SmoothScrolling>
              <div style={{ position: 'relative', width: '100%', minHeight: '100vh', display: 'flex', flexDirection: 'column', overflowX: 'clip' }}>
                <ProgressBar />
                <FPSAutoTuner /> 
                <KonamiCode />
                <SpaceBackground />
                <ToastProvider />
                <CookieConsent />
                <PerformanceHint /> 
                <Lightbox />
                
                <KineticOverlayManager colorDictionary={colors} />

                <Navbar />
                
                <main id="main-content" style={{ flexGrow: 1, position: 'relative', overflow: 'clip', display: 'block' }}>
                  <PageTransitionWrapper>
                    <UniversalBaseLoader />
                    
                    {children}
                  </PageTransitionWrapper>
                </main>
                
                <Footer />
                <StudioBar />
                <ScrollToTopButton />
              </div>
            </SmoothScrolling>
          </ThemeProvider>
        </NextAuthProvider>
      </body>
    </html>
  );
}

--- END OF FILE app/layout.tsx ---

================================================================================

--- START OF FILE app/manifest.ts ---

// app/manifest.ts
import { MetadataRoute } from 'next';

// FORCE STATIC: Prevents this from counting as a dynamic server request
export const dynamic = 'force-static';

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: 'EternalGames',
    short_name: 'EternalGames',
    description: 'منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار.',
    start_url: '/',
    display: 'standalone',
    background_color: '#0A0B0F',
    theme_color: '#00FFF0',
    icons: [
      {
        // FIX: Point to the dynamic icon route, not a static file
        src: '/icon', 
        sizes: '32x32',
        type: 'image/png',
      },
      {
        // For larger sizes, we can reuse the same endpoint or rely on Next.js to handle scaling 
        // if using the generateImageMetadata API, but pointing to /icon is the safest quick fix 
        // if you don't have static files.
        src: '/icon', 
        sizes: '192x192',
        type: 'image/png',
      },
      {
        src: '/icon',
        sizes: '512x512',
        type: 'image/png',
      },
    ],
    // Shortcuts removed or updated to use the same icon
    shortcuts: [
      {
        name: "المراجعات",
        short_name: "مراجعات",
        description: "أحدث مراجعات الألعاب",
        url: "/reviews",
        icons: [{ src: "/icon", sizes: "96x96" }]
      },
      {
        name: "الأخبار",
        short_name: "أخبار",
        description: "آخر أخبار الصناعة",
        url: "/news",
        icons: [{ src: "/icon", sizes: "96x96" }]
      }
    ],
    screenshots: [
      {
        src: "/screenshot-mobile.png",
        sizes: "390x844",
        type: "image/png",
        // @ts-ignore
        form_factor: "narrow"
      },
      {
        src: "/screenshot-wide.png",
        sizes: "1280x720",
        type: "image/png",
        // @ts-ignore
        form_factor: "wide"
      }
    ]
  };
}

--- END OF FILE app/manifest.ts ---

================================================================================

--- START OF FILE app/not-found.tsx ---

// app/not-found.tsx
import Link from 'next/link';

export default function NotFound() {
  return (
    <div style={{ 
      minHeight: '80vh', 
      display: 'flex', 
      flexDirection: 'column', 
      alignItems: 'center', 
      justifyContent: 'center', 
      textAlign: 'center',
      padding: '2rem',
      paddingTop: 'var(--nav-height-scrolled)' 
    }}>
      <h1 style={{ 
        fontSize: 'clamp(8rem, 15vw, 12rem)', 
        fontWeight: 900, 
        color: 'var(--accent)',
        textShadow: '0 0 30px color-mix(in srgb, var(--accent) 30%, transparent)',
        margin: 0,
        lineHeight: 1
      }}>
        404
      </h1>
      <h2 style={{ fontSize: '2.4rem', margin: '1rem 0 2rem 0' }}>
        الطريق مسدود
      </h2>
      <p style={{ color: 'var(--text-secondary)', maxWidth: '500px', margin: '0 auto 4rem auto', fontSize: '1.6rem' }}>
        الصفحة التي تبحث عنها قد تكون حُذفت، نُقلت، أو أنها لم تكن موجودة من الأساس في هذا الموقع.
      </p>

      {/* Retention Links */}
      <div style={{ display: 'flex', gap: '1.5rem', flexWrap: 'wrap', justifyContent: 'center', marginBottom: '4rem' }}>
        <Link href="/reviews" className="outline-button no-underline">
           المراجعات
        </Link>
        <Link href="/news" className="outline-button no-underline">
           الأخبار
        </Link>
        <Link href="/releases" className="outline-button no-underline">
           الإصدارات
        </Link>
      </div>

      <Link href="/" className="primary-button no-underline">
        العودة إلى الصفحة الرئيسية
      </Link>
    </div>
  );
}

--- END OF FILE app/not-found.tsx ---

================================================================================

--- START OF FILE app/page.tsx ---

// app/page.tsx
import React from 'react';
import HomeJsonLd from '@/components/seo/HomeJsonLd'; 
import CarouselJsonLd from '@/components/seo/CarouselJsonLd'; 
import { getUniversalBaseData } from '@/app/actions/layoutActions';
import { urlFor } from '@/sanity/lib/image';
import HomepageHydrator from '@/components/HomepageHydrator';

export const dynamic = 'force-static';

export default async function HomePage() {
    // Only the homepage fetches the heavy data at build time.
    const data = await getUniversalBaseData();
    // UPDATE: Changed base URL
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';
    
    const carouselItems = data.reviews.slice(0, 5).map((review: any, index: number) => ({
        url: `${siteUrl}/reviews/${review.slug}`,
        position: index + 1,
        name: review.title,
        image: review.mainImage ? urlFor(review.mainImage).width(1200).url() : undefined
    }));

    return (
        <>
            <HomeJsonLd />
            {carouselItems.length > 0 && <CarouselJsonLd data={carouselItems} />}
            
            {/* Hydrate the store so UniversalBaseLoader (in layout) can render */}
            <HomepageHydrator data={data} />
        </>
    );
}

--- END OF FILE app/page.tsx ---

================================================================================

--- START OF FILE app/robots.ts ---

// app/robots.ts
import { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';

  return {
    rules: {
      userAgent: '*',
      allow: [
          '/', 
          '/api/og/*' 
      ],
      disallow: [
        '/studio/',
        '/admin/',
        '/private/',
        '/search',
        '/api/', 
        // SECURITY: Block all query parameters to prevent "Fast Origin Transfer" attacks / cache bust attempts.
        // Canonical URLs on this site do not use query params for static content.
        '/*?*', 
      ],
    },
    sitemap: `${baseUrl}/sitemap.xml`,
  };
}

--- END OF FILE app/robots.ts ---

================================================================================

--- START OF FILE app/sitemap.ts ---

// app/sitemap.ts
import { MetadataRoute } from 'next';
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

// OPTIMIZATION: Removed time-based revalidation.
// We now rely on On-Demand Revalidation via the 'content' tag.
// This sitemap will stay cached forever until a Sanity Webhook fires.

const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com'; 

const sitemapQuery = groq`{
  "reviews": *[_type == "review" && defined(slug.current) && !(_id in path("drafts.**"))] { "slug": slug.current, _updatedAt },
  "articles": *[_type == "article" && defined(slug.current) && !(_id in path("drafts.**"))] { "slug": slug.current, _updatedAt },
  "news": *[_type == "news" && defined(slug.current) && !(_id in path("drafts.**"))] { "slug": slug.current, _updatedAt },
  "games": *[_type == "game" && defined(slug.current)] { "slug": slug.current, _updatedAt },
  "tags": *[_type == "tag" && defined(slug.current)] { "slug": slug.current, _updatedAt },
  "developers": *[_type == "developer" && defined(slug.current)] { "slug": slug.current, _updatedAt },
  "publishers": *[_type == "publisher" && defined(slug.current)] { "slug": slug.current, _updatedAt }
}`;

const getPriority = (dateStr: string, basePriority: number) => {
    const date = new Date(dateStr);
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - date.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays <= 30) return Math.min(1.0, basePriority + 0.2);
    if (diffDays > 365) return Math.max(0.1, basePriority - 0.2);
    
    return basePriority;
};

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  // FIX: Use 'next: { tags: ['content'] }'.
  // This connects the sitemap to the global 'content' revalidation tag.
  const data = await client.fetch(sitemapQuery, {}, { 
      next: { tags: ['content'] } 
  });

  const routes: MetadataRoute.Sitemap = [
    { url: baseUrl, lastModified: new Date(), changeFrequency: 'daily', priority: 1 },
    { url: `${baseUrl}/reviews`, lastModified: new Date(), changeFrequency: 'daily', priority: 0.9 },
    { url: `${baseUrl}/articles`, lastModified: new Date(), changeFrequency: 'daily', priority: 0.9 },
    { url: `${baseUrl}/news`, lastModified: new Date(), changeFrequency: 'hourly', priority: 0.9 },
    { url: `${baseUrl}/releases`, lastModified: new Date(), changeFrequency: 'weekly', priority: 0.8 },
    { url: `${baseUrl}/celestial-almanac`, lastModified: new Date(), changeFrequency: 'weekly', priority: 0.7 },
    { url: `${baseUrl}/tools/upscaler`, lastModified: new Date(), changeFrequency: 'monthly', priority: 0.6 },
    { url: `${baseUrl}/login`, lastModified: new Date(), changeFrequency: 'yearly', priority: 0.3 },
    { url: `${baseUrl}/about`, lastModified: new Date(), changeFrequency: 'monthly', priority: 0.8 },
    { url: `${baseUrl}/sitemap-html`, lastModified: new Date(), changeFrequency: 'daily', priority: 0.8 },
  ];

  (data.reviews || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/reviews/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'weekly',
      priority: getPriority(item._updatedAt, 0.8), 
    });
  });

  (data.articles || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/articles/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'monthly',
      priority: getPriority(item._updatedAt, 0.7),
    });
  });

  (data.news || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/news/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'never',
      priority: getPriority(item._updatedAt, 0.6), 
    });
  });

  (data.games || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/games/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'weekly',
      priority: 0.6,
    });
  });

  (data.tags || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/tags/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'weekly',
      priority: 0.5,
    });
  });

  (data.developers || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/developers/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'monthly',
      priority: 0.4,
    });
  });

  (data.publishers || []).forEach((item: any) => {
    routes.push({
      url: `${baseUrl}/publishers/${item.slug}`,
      lastModified: new Date(item._updatedAt),
      changeFrequency: 'monthly',
      priority: 0.4,
    });
  });

  return routes;
}

--- END OF FILE app/sitemap.ts ---

================================================================================

--- START OF FILE app/template.tsx ---

// app/template.tsx
'use client';

import React from 'react';

export default function Template({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}




--- END OF FILE app/template.tsx ---

================================================================================

--- START OF FILE app/(content)/[...slug]/page.tsx ---

// app/(content)/[...slug]/page.tsx
import { notFound } from 'next/navigation';
import ContentPageClient from '@/components/content/ContentPageClient';
import CommentSection from '@/components/comments/CommentSection';
import type { Metadata } from 'next';
import { getCachedContentAndDictionary, getCachedMetadata } from '@/lib/sanity.fetch';
import { client } from '@/lib/sanity.client'; 
import { enrichContentList } from '@/lib/enrichment'; 
import JsonLd from '@/components/seo/JsonLd';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd'; 
import SpeakableJsonLd from '@/components/seo/SpeakableJsonLd'; 
import { urlFor } from '@/sanity/lib/image';
import { calculateReadingTime, toPlainText } from '@/lib/readingTime'; 
import { extractHeadingsFromContent } from '@/lib/text-utils'; 
import { groq } from 'next-sanity';

// Allow ISR for pages not generated at build time (e.g. older archives)
export const dynamicParams = true;

const typeMap: Record<string, string> = {
    reviews: 'review',
    articles: 'article',
    news: 'news',
};

const sectionLabelMap: Record<string, string> = {
    reviews: 'المراجعات',
    articles: 'المقالات',
    news: 'الأخبار',
};

function generateStructuredData(item: any, type: string, url: string) {
    // UPDATE: Changed base URL
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';
    const imageUrl = item.mainImage ? urlFor(item.mainImage).width(1200).height(630).url() : `${siteUrl}/og.png`;
    const datePublished = item.publishedAt || new Date().toISOString();
    const dateModified = item._updatedAt || datePublished;
    
    const authorName = item.authors?.[0]?.name || item.reporters?.[0]?.name || 'EternalGames Team';
    const authorUsername = item.authors?.[0]?.username || item.reporters?.[0]?.username || 'team';
    const authorUrl = `${siteUrl}/creators/${authorUsername}`;

    const baseSchema = {
        "@context": "https://schema.org",
        "@type": type === 'review' ? "Review" : "NewsArticle",
        "headline": item.title,
        "image": [imageUrl],
        "datePublished": datePublished,
        "dateModified": dateModified,
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": url
        },
        "author": [{
            "@type": "Person",
            "name": authorName,
            "url": authorUrl
        }],
        "publisher": {
            "@type": "Organization",
            "name": "EternalGames",
            "logo": {
                "@type": "ImageObject",
                "url": `${siteUrl}/icon.png`
            }
        }
    };

    if (type === 'review') {
        return {
            ...baseSchema,
            "itemReviewed": {
                "@type": "VideoGame",
                "name": item.game?.title || "Game",
                "applicationCategory": "Game"
            },
            "reviewRating": {
                "@type": "Rating",
                "ratingValue": item.score,
                "bestRating": "10",
                "worstRating": "0"
            },
            "description": item.synopsis || item.verdict,
            "positiveNotes": item.pros ? {
                "@type": "ItemList",
                "itemListElement": item.pros.map((p: string, i: number) => ({
                    "@type": "ListItem",
                    "position": i + 1,
                    "name": p
                }))
            } : undefined,
            "negativeNotes": item.cons ? {
                "@type": "ItemList",
                "itemListElement": item.cons.map((c: string, i: number) => ({
                    "@type": "ListItem",
                    "position": i + 1,
                    "name": c
                }))
            } : undefined
        };
    }

    if (type === 'news') {
        return {
            ...baseSchema,
            "@type": "NewsArticle",
            "description": item.synopsis
        };
    }

    return {
        ...baseSchema,
        "@type": "Article",
        "description": item.synopsis
    };
}

export async function generateMetadata({ params }: { params: Promise<{ slug: string[] }> }): Promise<Metadata> {
    const { slug: slugArray } = await params;
    if (!slugArray || slugArray.length < 2) return {};
    
    const [section, slug] = slugArray;
    const sanityType = typeMap[section];
    if (!sanityType) return {};
    
    const item = await getCachedMetadata(slug);

    if (!item) return {};
    
    // UPDATE: Changed base URL
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';
    const ogImageUrl = `${siteUrl}/api/og?slug=${slug}`;
    const canonicalUrl = `${siteUrl}/${section}/${slug}`;

    return { 
        title: item.title, 
        description: item.synopsis || `Read the full ${sanityType} on EternalGames.`,
        alternates: {
            canonical: canonicalUrl,
        },
        openGraph: {
            title: item.title,
            description: item.synopsis,
            url: canonicalUrl,
            images: [{ url: ogImageUrl, width: 1200, height: 630, alt: item.title }],
            type: 'article',
            publishedTime: item.publishedAt,
            authors: [item.authors?.[0]?.name || 'EternalGames'],
            siteName: 'EternalGames',
            modifiedTime: item._updatedAt, 
        },
        twitter: {
            card: 'summary_large_image',
            title: item.title,
            description: item.synopsis,
            images: [ogImageUrl],
            site: '@1EternalGames',
        }
    };
}

export async function generateStaticParams() {
    try {
        // OPTIMIZATION: Only generate the 100 most recent items at build time.
        // Older items will be generated on-demand (ISR) when accessed.
        // This dramatically reduces build time and prevents timeouts/memory issues.
        const query = groq`*[_type in ["review", "article", "news"]] | order(_createdAt desc)[0...100] { "slug": slug.current, _type }`;
        const recentContent = await client.fetch<{ slug: string, _type: string }[]>(query);
        
        return recentContent
            .filter(c => c.slug)
            .map(c => {
                const type = c._type === 'review' ? 'reviews' : (c._type === 'article' ? 'articles' : 'news');
                return { slug: [type, c.slug] };
            });
    } catch (error) {
        console.error("Error generating static params:", error);
        return [];
    }
}

export default async function ContentPage({ params }: { params: Promise<{ slug: string[] }> }) {
    const { slug: slugArray } = await params;
    
    if (!slugArray || slugArray.length !== 2) notFound();
    
    const [section, slug] = slugArray;
    const sanityType = typeMap[section];
    
    if (!sanityType) notFound();

    const { item: rawItem, dictionary } = await getCachedContentAndDictionary(sanityType, slug);
    
    if (!rawItem) notFound();

    const [enrichedItem] = await enrichContentList([rawItem]);

    const plainText = toPlainText(enrichedItem.content);
    const readingTime = calculateReadingTime(plainText);
    enrichedItem.readingTime = readingTime;
    
    const tocHeadings = extractHeadingsFromContent(enrichedItem.content);
    
    if (sanityType === 'review' && enrichedItem.verdict) {
        tocHeadings.push({ id: 'verdict-summary', text: 'الخلاصة', level: 2 });
    }
    
    enrichedItem.toc = tocHeadings;

    const colorDictionary = dictionary?.autoColors || [];
    
    // UPDATE: Changed base URL
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';
    const jsonLdData = generateStructuredData(enrichedItem, sanityType, `${siteUrl}/${section}/${slug}`);

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: sectionLabelMap[section] || section, item: `/${section}` },
        { name: enrichedItem.title, item: `/${section}/${slug}` }
    ];

    return (
        <>
            <JsonLd data={jsonLdData} />
            <BreadcrumbJsonLd items={breadcrumbItems} />
            {sanityType === 'news' && (
                <SpeakableJsonLd cssSelectors={['.page-title', '.article-body p:first-of-type']} />
            )}
            
            <ContentPageClient item={enrichedItem} type={section as any} colorDictionary={colorDictionary}>
                 <CommentSection 
                    slug={slug} 
                    contentType={section} 
                 />
            </ContentPageClient>
        </>
    );
}

--- END OF FILE app/(content)/[...slug]/page.tsx ---

================================================================================

--- START OF FILE app/about/AboutPageClient.tsx ---

// app/about/AboutPageClient.tsx
'use client';

import React, { useState } from 'react';
import { useSession } from 'next-auth/react';
import { ContentBlock } from '@/components/ContentBlock';
import AboutPageJsonLd from '@/components/seo/AboutPageJsonLd';
import { urlFor } from '@/sanity/lib/image';
import StaffCard from '@/components/about/StaffCard';
import EditTeamModal from '@/components/about/EditTeamModal';

export default function AboutPageClient({ initialData }: { initialData: any }) {
    const { data: session } = useSession();
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [teamData, setTeamData] = useState(initialData);

    const userRoles = (session?.user as any)?.roles || [];
    const canEdit = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

    const getImg = (member: any) => member?.image
        ? urlFor(member.image).width(400).height(400).fit('crop').url()
        : '/default-avatar.svg';

    const handleSave = (newData: any) => {
        setTeamData(newData);
    };

    return (
        <>
            <AboutPageJsonLd />
            <div className="container page-container">
                <div style={{ maxWidth: '800px', margin: '0 auto 6rem auto', textAlign: 'center' }}>
                    <h1 className="page-title">من نحن</h1>
                    <p style={{ fontSize: '1.8rem', lineHeight: 1.8, color: 'var(--text-secondary)' }}>
                        في <strong>EternalGames</strong>، نؤمن بأن الألعاب ليست مجرد وسيلة ترفيه، بل هي شكل من أشكال الفن الحديث.
                        تأسست منصتنا لتكون صوتًا موثوقًا للاعب العربي، نقدم مراجعات دقيقة، أخبارًا موثقة، ومقالات تحليلية تغوص في عمق الصناعة.
                    </p>
                </div>
                
                <ContentBlock title="فريق العمل">
                    {canEdit && (
                        <div style={{ textAlign: 'center', marginBottom: '3rem' }}>
                            <button onClick={() => setIsModalOpen(true)} className="outline-button">تعديل الفريق</button>
                        </div>
                    )}
                    {teamData ? (
                        <>
                            {teamData.ceo && (
                                <section style={{ marginBottom: '6rem' }}>
                                    <h2 className="section-title">المؤسس</h2>
                                    <div style={{ maxWidth: '350px', margin: '0 auto' }}>
                                        <StaffCard name={teamData.ceo.name} username={teamData.ceo.username} imageUrl={getImg(teamData.ceo)} />
                                    </div>
                                </section>
                            )}

                            <section style={{ marginBottom: '8rem' }}>
                                <h2 className="section-title">قيادة الفريق</h2>
                                <div style={{ 
                                    display: 'grid', 
                                    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
                                    gap: '2.5rem',
                                    maxWidth: '1200px',
                                    margin: '0 auto'
                                }}>
                                    {teamData.editorInChief && (
                                        <div style={{display:'flex', flexDirection: 'column', gap: '1rem'}}><div style={{textAlign:'center', color:'var(--accent)', fontWeight:700}}>رئيس التحرير</div><StaffCard name={teamData.editorInChief.name} username={teamData.editorInChief.username} imageUrl={getImg(teamData.editorInChief)} /></div>
                                    )}
                                    {teamData.headOfReviews && (
                                        <div style={{display:'flex', flexDirection: 'column', gap: '1rem'}}><div style={{textAlign:'center', color:'var(--accent)', fontWeight:700}}>رئيس قسم المراجعات</div><StaffCard name={teamData.headOfReviews.name} username={teamData.headOfReviews.username} imageUrl={getImg(teamData.headOfReviews)} /></div>
                                    )}
                                    {teamData.headOfCommunication && (
                                        <div style={{display:'flex', flexDirection: 'column', gap: '1rem'}}><div style={{textAlign:'center', color:'var(--accent)', fontWeight:700}}>رئيس التواصل</div><StaffCard name={teamData.headOfCommunication.name} username={teamData.headOfCommunication.username} imageUrl={getImg(teamData.headOfCommunication)} /></div>
                                    )}
                                    {teamData.headOfVisuals && (
                                        <div style={{display:'flex', flexDirection: 'column', gap: '1rem'}}><div style={{textAlign:'center', color:'var(--accent)', fontWeight:700}}>رئيس المرئيات</div><StaffCard name={teamData.headOfVisuals.name} username={teamData.headOfVisuals.username} imageUrl={getImg(teamData.headOfVisuals)} /></div>
                                    )}
                                </div>
                            </section>

                            {teamData.reportersSection?.length > 0 && <ContentBlock title="فريق التغطية الإخبارية"><div className="content-grid gpu-cull">{teamData.reportersSection.map((m: any) => <StaffCard key={m._id} name={m.name} username={m.username} imageUrl={getImg(m)} />)}</div></ContentBlock>}
                            {teamData.authorsSection?.length > 0 && <ContentBlock title="فريق التحرير والمحتوى"><div className="content-grid gpu-cull">{teamData.authorsSection.map((m: any) => <StaffCard key={m._id} name={m.name} username={m.username} imageUrl={getImg(m)} />)}</div></ContentBlock>}
                            {teamData.designersSection?.length > 0 && <ContentBlock title="فريق التصميم والإبداع"><div className="content-grid gpu-cull">{teamData.designersSection.map((m: any) => <StaffCard key={m._id} name={m.name} username={m.username} imageUrl={getImg(m)} />)}</div></ContentBlock>}
                        </>
                    ) : <div style={{ textAlign: 'center', padding: '4rem', color: 'var(--text-secondary)' }}><p>يتم تحديث هيكل الفريق حالياً...</p></div>}
                </ContentBlock>

                <ContentBlock title="تواصل معنا">
                    <div style={{ backgroundColor: 'var(--bg-secondary)', padding: '3rem', borderRadius: '12px', border: '1px solid var(--border-color)', textAlign: 'center' }}>
                        <p style={{ fontSize: '1.6rem', marginBottom: '2rem' }}>هل لديك استفسار، اقتراح، أو ترغب في الانضمام لفريقنا؟ لا تتردد في مراسلتنا.</p>
                        <a href="mailto:me@EternalGamesWeb.com" className="primary-button no-underline">
                            me@EternalGamesWeb.com
                        </a>
                    </div>
                </ContentBlock>
            </div>
            
            {isModalOpen && <EditTeamModal currentTeam={teamData} onClose={() => setIsModalOpen(false)} onSave={handleSave} />}
        </>
    );
}

--- END OF FILE app/about/AboutPageClient.tsx ---

================================================================================

--- START OF FILE app/about/page.tsx ---

// app/about/page.tsx
import React from 'react';
import { Metadata } from 'next';
import { getAboutPageDataAction } from '@/app/actions/aboutActions';
import AboutPageClient from './AboutPageClient';

export const metadata: Metadata = {
    title: 'من نحن',
    description: 'تعرف على فريق EternalGames ورؤيتنا في تقديم محتوى ألعاب عربي احترافي وموضوعي.',
};

export const dynamic = 'force-static';

export default async function AboutPage() {
    const data = await getAboutPageDataAction();

    return <AboutPageClient initialData={data} />;
}

--- END OF FILE app/about/page.tsx ---

================================================================================

--- START OF FILE app/actions/aboutActions.ts ---

// app/actions/aboutActions.ts
'use server';

import { client } from '@/lib/sanity.client';
import { aboutPageQuery } from '@/lib/sanity.queries';
import prisma from '@/lib/prisma';
import { unstable_cache, revalidateTag } from 'next/cache';
import { sanityWriteClient } from '@/lib/sanity.server';
import { getAuthenticatedSession } from '@/lib/auth';

// Cached Action: Fetches the configured about page data and enriches it with usernames
export const getAboutPageDataAction = unstable_cache(
    async () => {
        try {
            const rawData = await client.fetch(aboutPageQuery);
            
            if (!rawData) return null;

            // Collect all Prisma User IDs from the fetched data
            const userIds = new Set<string>();

            const collect = (item: any) => {
                if (item && item.prismaUserId) {
                    userIds.add(item.prismaUserId);
                }
            };

            collect(rawData.ceo);
            collect(rawData.headOfCommunication);
            collect(rawData.headOfReviews);
            collect(rawData.editorInChief);
            collect(rawData.headOfVisuals);
            (rawData.reportersSection || []).forEach(collect);
            (rawData.authorsSection || []).forEach(collect);
            (rawData.designersSection || []).forEach(collect);

            const uniqueIds = Array.from(userIds);
            const usernameMap = new Map<string, string>();

            if (uniqueIds.length > 0) {
                const users = await prisma.user.findMany({
                    where: { id: { in: uniqueIds } },
                    select: { id: true, username: true }
                });
                users.forEach((u: any) => {
                    if (u.username) usernameMap.set(u.id, u.username);
                });
            }

            // Enrich the data
            const enrich = (item: any) => {
                if (item && item.prismaUserId && usernameMap.has(item.prismaUserId)) {
                    return { ...item, username: usernameMap.get(item.prismaUserId) };
                }
                return item;
            };

            return {
                ceo: enrich(rawData.ceo),
                headOfCommunication: enrich(rawData.headOfCommunication),
                headOfReviews: enrich(rawData.headOfReviews),
                editorInChief: enrich(rawData.editorInChief),
                headOfVisuals: enrich(rawData.headOfVisuals),
                reportersSection: (rawData.reportersSection || []).map(enrich),
                authorsSection: (rawData.authorsSection || []).map(enrich),
                designersSection: (rawData.designersSection || []).map(enrich),
            };

        } catch (error) {
            console.error("Failed to fetch about page data:", error);
            return null;
        }
    },
    ['about-page-data'],
    // OPTIMIZATION: Infinite cache, relying on 'about-page' tag invalidation
    { revalidate: false, tags: ['about-page', 'studio-metadata'] }
);

// Server Action to update the about page settings
export async function updateAboutPageAction(data: Record<string, string | string[] | null>) {
    try {
        const session = await getAuthenticatedSession();
        const userRoles = session.user.roles;
        const canEdit = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

        if (!canEdit) {
            return { success: false, message: 'غير مصرح لك.' };
        }

        const patchData: Record<string, any> = {};

        for (const [key, value] of Object.entries(data)) {
            if (Array.isArray(value)) {
                patchData[key] = value.map(id => ({ _type: 'reference', _ref: id, _key: id }));
            } else if (value) {
                patchData[key] = { _type: 'reference', _ref: value };
            } else {
                // If value is null, unset the reference
                patchData[key] = undefined;
            }
        }
        
        await sanityWriteClient.createIfNotExists({
            _id: 'aboutPageSettings',
            _type: 'aboutPageSettings'
        });

        await sanityWriteClient
            .patch('aboutPageSettings')
            .set(patchData)
            .commit();

        revalidateTag('about-page', 'max');

        return { success: true, message: 'تم تحديث صفحة "من نحن".' };
    } catch (error) {
        console.error("Failed to update about page:", error);
        return { success: false, message: 'حدث خطأ أثناء التحديث.' };
    }
}

--- END OF FILE app/actions/aboutActions.ts ---

================================================================================

--- START OF FILE app/actions/authActions.ts ---

// app/actions/authActions.ts
'use server';

import prisma from '@/lib/prisma';
// FIX: Removed 'crypto' import to avoid Edge Runtime error
// import crypto from 'crypto'; 
import bcrypt from 'bcryptjs';
import { sensitiveLimiter } from '@/lib/rate-limit'; // Rate Limiter
import { passwordResetSchema } from '@/lib/validations'; // Zod Schema
import { headers } from 'next/headers';
import { z } from 'zod';

// This would be your email sending function.
async function sendPasswordResetEmail(email: string, token: string) {
    const resetLink = `${process.env.NEXTAUTH_URL}/reset-password?token=${token}`;
    
    if (process.env.NODE_ENV === 'development') {
        console.log(`[DEV ONLY] Reset Link: ${resetLink}`);
    } else {
        console.log(`[Email Service] Sending password reset to ${email}`);
    }
}

export async function requestPasswordReset(email: string) {
    try {
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`reset-req-${ip}`, 3); 
        if (!limitCheck.success) return { success: false, message: 'محاولات كثيرة جدًا. انتظر قليلاً.' };

        const emailValidation = z.string().email().safeParse(email);
        if (!emailValidation.success) return { success: false, message: 'البريد الإلكتروني غير صالح.' };

        const lowercasedEmail = emailValidation.data.toLowerCase();
        const user = await prisma.user.findUnique({ where: { email: lowercasedEmail } });
        
        if (!user || !user.password) {
            return { success: true, message: 'إن صَحَّ بريدُك، أتاك الرابط.' };
        }

        await prisma.passwordResetToken.deleteMany({ where: { userId: user.id } });

        // FIX: Use Web Crypto API for Edge compatibility
        const array = new Uint8Array(32);
        crypto.getRandomValues(array);
        const token = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
        
        const expires = new Date(new Date().getTime() + 60 * 60 * 1000); 

        await prisma.passwordResetToken.create({
            data: {
                userId: user.id,
                token,
                expires,
            },
        });

        await sendPasswordResetEmail(lowercasedEmail, token);

        return { success: true, message: 'إن صَحَّ بريدُك، أتاك الرابط.' };
    } catch (error) {
        console.error('Password reset request failed:', error);
        return { success: false, message: 'طرأ خطبٌ ما.' };
    }
}

export async function resetPassword(token: string, newPassword: string) {
    try {
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`reset-submit-${ip}`, 3);
        if (!limitCheck.success) return { success: false, message: 'محاولات كثيرة جدًا.' };

        const validation = passwordResetSchema.safeParse({ token, newPassword });
        if (!validation.success) {
            return { success: false, message: validation.error.issues[0].message };
        }

        const safeData = validation.data;

        const resetToken = await prisma.passwordResetToken.findUnique({
            where: { token: safeData.token },
        });

        if (!resetToken || resetToken.expires < new Date()) {
            if (resetToken) {
                await prisma.passwordResetToken.delete({ where: { id: resetToken.id } });
            }
            return { success: false, message: 'الرمز باطل أو منتهي الصلاحية.' };
        }

        const hashedPassword = await bcrypt.hash(safeData.newPassword, 10);

        await prisma.user.update({
            where: { id: resetToken.userId },
            data: { password: hashedPassword },
        });

        await prisma.passwordResetToken.delete({
            where: { id: resetToken.id },
        });

        return { success: true, message: 'استُعيدت كلمة السّر.' };
    } catch (error) {
        console.error('Password reset failed:', error);
        return { success: false, message: 'طرأ خطبٌ ما.' };
    }
}

--- END OF FILE app/actions/authActions.ts ---

================================================================================

--- START OF FILE app/actions/banActions.ts ---

// app/actions/banActions.ts
'use server';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";
import prisma from "@/lib/prisma";
import { revalidatePath, revalidateTag } from "next/cache";
import { unstable_cache } from "next/cache";

// --- CONFIGURATION ---
const OWNER_EMAIL = "mhmfalsaadd@gmail.com"; 

const PROTECTED_ROLES = ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'];

const getCachedBanStatus = unstable_cache(
    async (userId: string) => {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { isBanned: true, banReason: true }
        });
        return { 
            isBanned: user?.isBanned || false, 
            banReason: user?.banReason || null 
        };
    },
    ['user-ban-status'], 
    { revalidate: false, tags: ['ban-status'] }
);

export async function checkBanStatus() {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) return { isBanned: false, banReason: null };
    return await getCachedBanStatus(session.user.id);
}

export async function toggleUserBanAction(targetUserId: string, reason: string, shouldBan: boolean) {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
        return { success: false, message: "غير مصرح لك." };
    }

    try {
        const actor = await prisma.user.findUnique({
            where: { id: session.user.id },
            select: { id: true, email: true, roles: { select: { name: true } } }
        });

        if (!actor) return { success: false, message: "المستخدم غير موجود." };
        
        const actorRoles = actor.roles.map((r: any) => r.name);
        const isDirector = actorRoles.includes('DIRECTOR');
        const isAdmin = actorRoles.includes('ADMIN');
        const isOwner = actor.email === OWNER_EMAIL; 

        if (!isDirector && !isAdmin && !isOwner) {
            return { success: false, message: "صلاحياتك لا تسمح بالحظر." };
        }

        const target = await prisma.user.findUnique({
            where: { id: targetUserId },
            select: { id: true, email: true, roles: { select: { name: true } } }
        });

        if (!target) return { success: false, message: "المستخدم المستهدف غير موجود." };
        const targetRoles = target.roles.map((r: any) => r.name);

        if (target.email === OWNER_EMAIL) {
            return { success: false, message: "هذا الكيان محصن ضد الحظر." };
        }

        if (!isOwner) {
            if (actor.id === target.id) {
                return { success: false, message: "لا يمكنك حظر نفسك." };
            }

            if (isDirector) {
                if (targetRoles.includes('DIRECTOR')) {
                    return { success: false, message: "لا يمكن للمدير حظر مدير آخر." };
                }
            } 
            else if (isAdmin) {
                const hasProtectedRole = targetRoles.some((role: string) => PROTECTED_ROLES.includes(role));
                if (hasProtectedRole) {
                    return { success: false, message: "المسؤولون لا يملكون صلاحية حظر طاقم العمل." };
                }
            }
        }

        await prisma.user.update({
            where: { id: targetUserId },
            data: {
                isBanned: shouldBan,
                banReason: shouldBan ? reason : null,
                bannedAt: shouldBan ? new Date() : null,
            }
        });

        // THE FIX: Added 'max' profile argument
        revalidateTag('ban-status', 'max');
        revalidatePath('/studio/director');
        
        return { success: true, message: shouldBan ? "تم حظر المستخدم." : "تم رفع الحظر." };

    } catch (error) {
        console.error("Ban action failed:", error);
        return { success: false, message: "حدث خطأ في النظام." };
    }
}

--- END OF FILE app/actions/banActions.ts ---

================================================================================

--- START OF FILE app/actions/batchActions.ts ---

// app/actions/batchActions.ts
'use server';

import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';
import { enrichContentList } from '@/lib/enrichment';
import { extractHeadingsFromContent } from '@/lib/text-utils';
import prisma from '@/lib/prisma';
import { unstable_cache } from 'next/cache';
import { 
    fullDocProjection, 
    paginatedReviewsQuery, 
    paginatedArticlesQuery, 
    paginatedNewsQuery,
    cardListProjection,
    batchGameHubsQuery,
    gamePageDataQuery 
} from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';

// OPTIMIZATION NOTE: 
// For batch fetching and pagination, we explicitly set { cache: 'no-store' }.
// This prevents Next.js from creating a persistent Data Cache entry for every single
// offset/limit combination (which causes the 5k+ writes/day issue).
// We rely on Sanity's Edge CDN (configured in client) for speed.

export async function batchFetchFullContentAction(ids: string[]) {
  if (!ids || ids.length === 0) return [];
  try {
    const query = groq`*[_id in $ids] { ${fullDocProjection} }`;
    // FIX: Disable Data Cache writes for arbitrary ID sets
    const rawData = await client.fetch(query, { ids }, { cache: 'no-store' });
    const enrichedData = await enrichContentList(rawData);
    const dataWithToc = enrichedData.map((item: any) => {
        const tocHeadings = extractHeadingsFromContent(item.content);
        if (item._type === 'review' && item.verdict) {
            tocHeadings.push({ id: 'verdict-summary', text: 'الخلاصة', level: 2 });
        }
        return { ...item, toc: tocHeadings };
    });
    return dataWithToc;
  } catch (error) {
    console.error("Batch fetch failed", error);
    return [];
  }
}

export async function batchFetchTagsAction(slugs: string[]) {
    if (!slugs || slugs.length === 0) return [];
    try {
        const query = groq`*[_type == "tag" && slug.current in $slugs] {
            _id, title, "slug": slug.current,
            "items": *[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && (references(^._id) || category._ref == ^._id)] | order(publishedAt desc)[0...12] { ${cardListProjection} }
        }`;
        // FIX: Disable Data Cache
        const rawTags = await client.fetch(query, { slugs }, { cache: 'no-store' });
        const enrichedTags = await Promise.all(rawTags.map(async (tag: any) => {
            const items = await enrichContentList(tag.items || []);
            return { ...tag, items };
        }));
        return enrichedTags;
    } catch (error) {
        console.error("Batch tag fetch failed", error);
        return [];
    }
}

export async function batchFetchCreatorsAction(creatorIds: string[]) {
    if (!creatorIds || creatorIds.length === 0) return [];
    try {
        const query = groq`*[_type in ["reviewer", "author", "reporter", "designer"] && (_id in $ids || prismaUserId in $ids)] {
            _id, name, prismaUserId, username, image, bio,
            "linkedContent": *[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && references(^._id)] | order(publishedAt desc)[0...12] { ${cardListProjection} }
        }`;
        // FIX: Disable Data Cache
        const rawCreators = await client.fetch(query, { ids: creatorIds }, { cache: 'no-store' });
        const enrichedCreators = await Promise.all(rawCreators.map(async (c: any) => {
            const items = await enrichContentList(c.linkedContent || []);
            return { ...c, linkedContent: items };
        }));
        return enrichedCreators;
    } catch (error) {
        console.error("Batch creator fetch failed", error);
        return [];
    }
}

export const fetchCreatorByUsernameAction = unstable_cache(
    async (username: string) => {
        if (!username) return null;
        
        try {
            const user = await prisma.user.findUnique({
                where: { username },
                select: { id: true, name: true, username: true, image: true, bio: true }
            });
            
            if (!user) return null;

            const creatorDocs = await client.fetch<{ _id: string, bio?: string }[]>(
                `*[_type in ["author", "reviewer", "reporter", "designer"] && prismaUserId == $prismaUserId]{_id, bio}`,
                { prismaUserId: user.id }
            );
            
            const creatorIds = creatorDocs.map(d => d._id);
            const sanityBio = creatorDocs.find(d => d.bio)?.bio;
            const finalBio = user.bio || sanityBio || null;
            
            let enrichedContent: any[] = [];
            
            if (creatorIds.length > 0) {
                const query = groq`*[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && references($creatorIds)] | order(publishedAt desc)[0...24] { ${cardListProjection} }`;
                // Keep this cached via unstable_cache wrapper, but internal fetch doesn't need double caching
                const rawContent = await client.fetch(query, { creatorIds });
                enrichedContent = await enrichContentList(rawContent);
            }

            return {
                _id: creatorIds[0] || `prisma-${user.id}`,
                prismaUserId: user.id,
                name: user.name,
                username: user.username,
                image: user.image, 
                bio: finalBio,
                linkedContent: enrichedContent,
                contentLoaded: true
            };

        } catch (error) {
            console.error("fetchCreatorByUsernameAction failed", error);
            return null;
        }
    },
    ['creator-profile-by-username-v3'],
    { tags: ['creator-profile', 'content'] }
);

export async function fetchGameContentAction(slug: string) {
    if (!slug) return [];
    try {
        const query = groq`*[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`;
        // FIX: Disable Data Cache
        const raw = await client.fetch(query, { slug }, { cache: 'no-store' });
        const enriched = await enrichContentList(raw);
        return enriched.map((i: any) => adaptToCardProps(i, { width: 600 })).filter(Boolean);
    } catch (e) {
        console.error("fetchGameContentAction error", e);
        return [];
    }
}

export async function fetchGameHubDataAction(slug: string) {
    if (!slug) return null;
    try {
        // FIX: Disable Data Cache
        const data = await client.fetch(gamePageDataQuery, { slug }, { cache: 'no-store' });
        if (!data) return null;

        const enrichedItems = await enrichContentList(data.items || []);
        
        const releaseData = data.release || {};
        
        return {
            ...data,
            items: enrichedItems.map((i: any) => adaptToCardProps(i, { width: 600 })).filter(Boolean),
            tags: releaseData.releaseTags || [],
            synopsis: releaseData.synopsis || null,
            releaseDate: releaseData.releaseDate,
            price: releaseData.price,
            developer: releaseData.developer,
            publisher: releaseData.publisher,
            platforms: releaseData.platforms,
            onGamePass: releaseData.onGamePass,
            onPSPlus: releaseData.onPSPlus,
            mainImage: data.mainImage || releaseData.releaseImage,
            contentLoaded: true
        };
    } catch (error) {
        console.error("fetchGameHubDataAction failed", error);
        return null;
    }
}


export async function fetchCreatorContentAction(creatorId: string) {
    if (!creatorId) return [];
    try {
        const query = groq`*[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`;
        // FIX: Disable Data Cache
        const raw = await client.fetch(query, { creatorIds: [creatorId] }, { cache: 'no-store' });
        const enriched = await enrichContentList(raw);
        return enriched.map((i: any) => adaptToCardProps(i, { width: 600 })).filter(Boolean);
    } catch (e) {
        console.error("fetchCreatorContentAction error", e);
        return [];
    }
}

export async function fetchTagContentAction(slug: string) {
    if (!slug) return null;
    try {
        const tags = await batchFetchTagsAction([slug]);
        return tags.length > 0 ? tags[0] : null;
    } catch (e) {
        console.error("fetchTagContentAction error", e);
        return null;
    }
}

export async function fetchSingleContentAction(slug: string) {
    if (!slug) return null;
    try {
        const query = groq`*[_type in ["review", "article", "news"] && slug.current == $slug][0] { ${fullDocProjection} }`;
        // FIX: Disable Data Cache for individual fetch in overlay to ensure freshness and avoid key explosion
        const rawData = await client.fetch(query, { slug }, { cache: 'no-store' });
        if (!rawData) return null;
        const enrichedList = await enrichContentList([rawData]);
        const item = enrichedList[0];
        if (item) {
             const tocHeadings = extractHeadingsFromContent(item.content);
             if (item._type === 'review' && item.verdict) {
                tocHeadings.push({ id: 'verdict-summary', text: 'الخلاصة', level: 2 });
             }
             item.toc = tocHeadings;
        }
        return item;
    } catch (error) {
        console.error("Single content fetch failed", error);
        return null;
    }
}

export async function loadMoreReviews(params: { offset: number, limit: number, sort: 'latest' | 'score', scoreRange?: string, gameSlug?: string, tagSlugs?: string[], searchTerm?: string }) {
    const query = paginatedReviewsQuery(
        params.gameSlug, 
        params.tagSlugs, 
        params.searchTerm, 
        params.scoreRange, 
        params.offset, 
        params.limit, 
        params.sort, 
        fullDocProjection
    );
    // CRITICAL FIX: Disable Data Cache for infinite scroll pagination
    const rawData = await client.fetch(query, {}, { cache: 'no-store' });
    return await processUnifiedResponse(rawData, params.limit, params.offset);
}

export async function loadMoreArticles(params: { offset: number, limit: number, sort: 'latest' | 'viral', gameSlug?: string, tagSlugs?: string[], searchTerm?: string }) {
    const query = paginatedArticlesQuery(
        params.gameSlug, 
        params.tagSlugs, 
        params.searchTerm, 
        params.offset, 
        params.limit, 
        params.sort, 
        fullDocProjection
    );
    // CRITICAL FIX: Disable Data Cache for infinite scroll pagination
    const rawData = await client.fetch(query, {}, { cache: 'no-store' });
    return await processUnifiedResponse(rawData, params.limit, params.offset);
}

export async function loadMoreNews(params: { offset: number, limit: number, sort: 'latest' | 'viral', gameSlug?: string, tagSlugs?: string[], searchTerm?: string }) {
    const query = paginatedNewsQuery(
        params.gameSlug, 
        params.tagSlugs, 
        params.searchTerm, 
        params.offset, 
        params.limit, 
        params.sort, 
        fullDocProjection
    );
    // CRITICAL FIX: Disable Data Cache for infinite scroll pagination
    const rawData = await client.fetch(query, {}, { cache: 'no-store' });
    return await processUnifiedResponse(rawData, params.limit, params.offset);
}

async function processUnifiedResponse(rawData: any[], limit: number, offset: number) {
    const enrichedData = await enrichContentList(rawData);
    
    const gameIds = new Set<string>();
    rawData.forEach(item => {
        if (item.game && item.game._id) {
            gameIds.add(item.game._id);
        }
    });

    let enrichedHubs: any[] = [];
    
    if (gameIds.size > 0) {
        try {
            // Also disable cache for this side-load
            const gameHubs = await client.fetch(batchGameHubsQuery, { ids: Array.from(gameIds) }, { cache: 'no-store' });
            enrichedHubs = await Promise.all(gameHubs.map(async (hub: any) => {
                if (hub.linkedContent && hub.linkedContent.length > 0) {
                    hub.linkedContent = await enrichContentList(hub.linkedContent);
                }
                return { ...hub, contentLoaded: true };
            }));
        } catch (error) {
            console.error("Failed to pre-fetch game hubs in loadMore:", error);
        }
    }

    const fullContent = enrichedData.map((item: any) => {
        const tocHeadings = extractHeadingsFromContent(item.content);
        if (item._type === 'review' && item.verdict) {
            tocHeadings.push({ id: 'verdict-summary', text: 'الخلاصة', level: 2 });
        }
        return { 
            ...item, 
            toc: tocHeadings,
            contentLoaded: true
        };
    });
    
    const cards = fullContent.map((item: any) => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[];
    const nextOffset = rawData.length === limit ? offset + limit : null;
    
    return { 
        cards, 
        fullContent, 
        hubs: enrichedHubs, 
        nextOffset 
    };
}

--- END OF FILE app/actions/batchActions.ts ---

================================================================================

--- START OF FILE app/actions/commentActions.ts ---

// app/actions/commentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath } from 'next/cache';
import { VoteType, NotificationType } from '@/lib/generated/client';
import { getAuthenticatedSession } from '@/lib/auth';
import { sensitiveLimiter } from '@/lib/rate-limit';
import { commentSchema } from '@/lib/validations';
import { headers } from 'next/headers';

export async function postReplyOrComment(contentSlug: string, content: string, path: string, parentId?: string) {
    try {
        const session = await getAuthenticatedSession();
        const userId = session.user.id;

        // 1. Rate Limiting (IP + UserID)
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitKey = `comment-${userId}-${ip}`;
        const limitCheck = await sensitiveLimiter.check(limitKey, 5); // Max 5 comments per minute
        
        if (!limitCheck.success) {
            return { success: false, error: 'تم تجاوز حد التعليقات. يرجى الانتظار قليلاً.' };
        }

        // 2. Input Validation & Sanitization
        const validation = commentSchema.safeParse({ content, contentSlug, parentId });
        if (!validation.success) {
            return { success: false, error: validation.error.issues[0].message };
        }
        
        const safeData = validation.data;

        const newComment = await prisma.comment.create({
            data: { 
                contentSlug: safeData.contentSlug, 
                content: safeData.content, 
                authorId: userId, 
                parentId: safeData.parentId || null 
            },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });

        // --- NOTIFICATION LOGIC ---
        if (parentId) {
            try {
                const parentComment = await prisma.comment.findUnique({
                    where: { id: parentId },
                    select: { authorId: true }
                });

                if (parentComment && parentComment.authorId !== session.user.id) {
                    await prisma.notification.create({
                        data: {
                            userId: parentComment.authorId,
                            senderId: session.user.id,
                            type: NotificationType.REPLY,
                            resourceId: newComment.id,
                            resourceSlug: contentSlug,
                            link: `${path}#comment-${newComment.id}`
                        }
                    });
                }
            } catch (notifError) {
                // Silently fail notifications to not block comment
            }
        }
        // --------------------------

        revalidatePath(path);
        return { success: true, comment: newComment };
    } catch (error: any) {
        return { success: false, error: error.message || "تعذر نشر التعليق." };
    }
}

export async function deleteComment(commentId: string) {
    try {
        const session = await getAuthenticatedSession();
        // Validation for ID format could be added here if using uuids strictly
        
        const commentToDelete = await prisma.comment.findUnique({
            where: { id: commentId },
            include: { _count: { select: { replies: true } } }
        });
        
        if (!commentToDelete) return { success: false, error: 'التعليق غير موجود.' };

        const userRoles = session.user.roles || [];
        const isAuthor = commentToDelete.authorId === session.user.id;
        const isModerator = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

        if (!isAuthor && !isModerator) {
            return { success: false, error: 'غير مصرح لك.' };
        }

        if (commentToDelete._count.replies > 0) {
            const updatedComment = await prisma.comment.update({
                where: { id: commentId },
                data: { content: '[طُمِسَ التعليق]', isDeleted: true }
            });
            return { success: true, wasDeleted: false, updatedComment };
        } else {
            await prisma.comment.delete({ where: { id: commentId } });
            return { success: true, wasDeleted: true, deletedId: commentId };
        }
    } catch (error: any) {
        return { success: false, error: error.message || 'يأبى التعليقُ الحذف.' };
    }
}

export async function updateComment(commentId: string, content: string) {
    try {
        const session = await getAuthenticatedSession();
        
        // Rate Limit Updates too
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`update-comment-${session.user.id}-${ip}`, 10);
        if (!limitCheck.success) return { success: false, error: "مهلاً، أبطئ قليلاً." };

        // Validation
        const validation = commentSchema.pick({ content: true }).safeParse({ content });
        if (!validation.success) return { success: false, error: validation.error.issues[0].message };

        const comment = await prisma.comment.findUnique({ where: { id: commentId }, select: { authorId: true, contentSlug: true } });
        if (!comment || comment.authorId !== session.user.id) return { success: false, error: 'غير مصرح لك.' };

        const updatedComment = await prisma.comment.update({
            where: { id: commentId },
            data: { content: validation.data.content },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            }
        });

        revalidatePath(`/reviews/${comment.contentSlug}`);
        revalidatePath(`/articles/${comment.contentSlug}`);
        revalidatePath(`/news/${comment.contentSlug}`);
        return { success: true, updatedComment };
    } catch (error: any) {
        return { success: false, error: error.message || "أخفق التحديث." };
    }
}

export async function voteOnComment(commentId: string, voteType: VoteType) {
    try {
        const session = await getAuthenticatedSession();
        // Rate limit voting to prevent spam clicking
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`vote-${session.user.id}-${ip}`, 30); // 30 votes per minute
        if (!limitCheck.success) throw new Error("تم تجاوز حد التصويت.");

        const existingVote = await prisma.commentVote.findUnique({ where: { userId_commentId: { userId: session.user.id, commentId } } });
        
        if (existingVote) {
            if (existingVote.type === voteType) { await prisma.commentVote.delete({ where: { id: existingVote.id } }); } 
            else { await prisma.commentVote.update({ where: { id: existingVote.id }, data: { type: voteType } }); }
        } else {
            await prisma.commentVote.create({ data: { userId: session.user.id, commentId, type: voteType } });
        }
        
        const updatedComment = await prisma.comment.findUnique({ where: { id: commentId }, select: { votes: true } });
        if (!updatedComment) throw new Error("Comment not found after vote update.");
        return { success: true, updatedVotes: updatedComment.votes };
    } catch (error: any) {
        return { success: false, error: error.message || 'تعذّر تسجيل التصويت.' };
    }
}

export async function getReplies(parentId: string) {
    try {
        const replies = await prisma.comment.findMany({
            where: { parentId },
            include: {
                author: { select: { id: true, name: true, image: true, username: true } },
                votes: true,
                _count: { select: { replies: true } }
            },
            orderBy: { createdAt: 'asc' }
        });
        return { success: true, replies };
    } catch (error) {
        return { success: false, error: 'أبت الردودُ أن تُجلَب.' };
    }
}

--- END OF FILE app/actions/commentActions.ts ---

================================================================================

--- START OF FILE app/actions/contentActions.ts ---

// app/actions/contentActions.ts
'use server';

import prisma from '@/lib/prisma';
import { getAuthenticatedSession } from '@/lib/auth';
import { EngagementType } from '@/lib/generated/client';
import { revalidateTag } from 'next/cache';
import { standardLimiter } from '@/lib/rate-limit'; // Security Import
import { headers } from 'next/headers';

async function setEngagement(userId: string, contentId: number, contentType: string, engagementType: EngagementType, isEngaged: boolean) {
    const whereClause = {
        userId_contentId_contentType_type: { userId, contentId, contentType, type: engagementType },
    };

    if (isEngaged) {
        await prisma.engagement.upsert({
            where: whereClause,
            update: {},
            create: { userId, contentId, contentType, type: engagementType },
        });
    } else {
        await prisma.engagement.deleteMany({
            where: { userId, contentId, contentType, type: engagementType },
        });
    }
}

export async function setBookmarkAction(contentId: number, contentType: string, isBookmarked: boolean) {
    try {
        const session = await getAuthenticatedSession();
        
        // Rate Limit (10 requests per 10s is generous enough for clicking, but stops scripts)
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`bookmark-${session.user.id}-${ip}`, 10);
        if (!limitCheck.success) return { success: false, error: "تم تجاوز الحد المسموح." };

        await setEngagement(session.user.id, contentId, contentType, 'BOOKMARK', isBookmarked);
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setBookmarkAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطبٌ ما.' };
    }
}

export async function setLikeAction(contentId: number, contentType: string, contentSlug: string, isLiked: boolean) {
    try {
        const session = await getAuthenticatedSession();

        // Rate Limit
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`like-${session.user.id}-${ip}`, 20); // Higher limit for rapid liking
        if (!limitCheck.success) return { success: false, error: "تم تجاوز الحد المسموح." };

        await setEngagement(session.user.id, contentId, contentType, 'LIKE', isLiked);
        revalidateTag('engagement-scores', 'max');
        return { success: true };
    } catch (error: any) {
        console.error("CRITICAL: setLikeAction failed:", error);
        return { success: false, error: error.message || 'طرأ خطبٌ ما.' };
    }
}

export async function recordShareAction(contentId: number, contentType: string, contentSlug: string) {
    try {
        const session = await getAuthenticatedSession();
        const userId = session.user.id;

        // Rate Limit (Strict - sharing is heavy)
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`share-${userId}-${ip}`, 5);
        if (!limitCheck.success) return { success: false, error: "تم تجاوز الحد المسموح." };

        await prisma.share.create({
            data: { userId, contentId, contentType },
        });
        revalidateTag('engagement-scores', 'max');
        
        const updatedShares = await prisma.share.findMany({
            where: { userId },
            select: { contentId: true, contentType: true }
        });
        
        return { success: true, shares: updatedShares, message: 'Share recorded.' };
    } catch (error: any) {
        console.error("CRITICAL: recordShareAction failed:", error);
        return { success: false, error: error.message || 'Could not record share.' };
    }
}

--- END OF FILE app/actions/contentActions.ts ---

================================================================================

--- START OF FILE app/actions/creatorActions.ts ---

'use server';

import prisma from '@/lib/prisma';

// BATCH ACTION:
// Accepts an array of IDs and returns a Map.
// This allows client components to gather all missing IDs and resolve them in one go.
export async function getCreatorUsernames(creatorIds: string[]) {
    if (!creatorIds || creatorIds.length === 0) {
        return {};
    }

    try {
        const users = await prisma.user.findMany({
            where: {
                id: { in: creatorIds }
            },
            select: {
                id: true,
                username: true
            }
        });

        // Create a map of prismaUserId -> username
        const usernameMap = users.reduce((acc: any, user: any) => {
            if (user.username) {
                acc[user.id] = user.username;
            }
            return acc;
        }, {} as Record<string, string>);

        return usernameMap;
    } catch (error) {
        console.error("Failed to fetch creator usernames:", error);
        return {};
    }
}




--- END OF FILE app/actions/creatorActions.ts ---

================================================================================

--- START OF FILE app/actions/homepageActions.ts ---

// app/actions/homepageActions.ts
'use server';

import { sanityWriteClient } from '@/lib/sanity.server';
import { client } from '@/lib/sanity.client';
import { getAuthenticatedSession } from '@/lib/auth';
import { revalidateTag, unstable_cache } from 'next/cache';
import { groq } from 'next-sanity';
import { cardListProjection, mainImageFields } from '@/lib/sanity.queries'; 
import { enrichContentList } from '@/lib/enrichment'; 
import prisma from '@/lib/prisma';

export async function updateReleasesCreditsAction(creatorIds: string[]) {
    try {
        const session = await getAuthenticatedSession();
        const userRoles = session.user.roles;
        const canEdit = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

        if (!canEdit) {
            return { success: false, message: 'غير مصرح لك.' };
        }

        const references = creatorIds.map(id => ({
            _type: 'reference',
            _ref: id,
            _key: id 
        }));

        await sanityWriteClient.createIfNotExists({
            _id: 'homepageSettings',
            _type: 'homepageSettings',
            releasesCredits: []
        });

        await sanityWriteClient
            .patch('homepageSettings')
            .set({ releasesCredits: references })
            .commit();

        revalidateTag('content', 'max');
        revalidateTag('homepage-content-consolidated-v2', 'max');

        return { success: true, message: 'تم تحديث القائمة.' };
    } catch (error) {
        console.error("Failed to update releases credits:", error);
        return { success: false, message: 'حدث خطأ أثناء التحديث.' };
    }
}

// CACHED ACTION: Fetches all staff members and their recent content
export const getAllStaffAction = unstable_cache(
    async () => {
        try {
            const query = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] {
                _id,
                name,
                "image": image,
                bio,
                prismaUserId,
                username,
                "linkedContent": *[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && references(^._id)] | order(publishedAt desc)[0...24] { ${cardListProjection} }
            }`;
            
            const rawStaff = await client.fetch(query);

            const userIds = rawStaff
                .map((c: any) => c.prismaUserId)
                .filter((id: string) => id);

            let usernameMap = new Map<string, string>();
            
            if (userIds.length > 0) {
                try {
                    const users = await prisma.user.findMany({
                        where: { id: { in: userIds } },
                        select: { id: true, username: true }
                    });
                    users.forEach((u: any) => {
                        if (u.username) usernameMap.set(u.id, u.username);
                    });
                } catch (dbError) {
                    console.error("DB Error fetching usernames for staff:", dbError);
                }
            }

            const uniqueMap = new Map();
            
            rawStaff.forEach((creator: any) => {
                let key = creator.prismaUserId;
                if (!key) {
                    key = `name:${creator.name}`;
                }
                
                if (creator.prismaUserId && usernameMap.has(creator.prismaUserId)) {
                    creator.username = usernameMap.get(creator.prismaUserId);
                }

                if (!uniqueMap.has(key)) {
                    uniqueMap.set(key, creator);
                } else {
                    const existing = uniqueMap.get(key);
                    const combinedContent = [...(existing.linkedContent || []), ...(creator.linkedContent || [])];
                    const uniqueContentMap = new Map();
                    combinedContent.forEach(item => uniqueContentMap.set(item._id, item));
                    const uniqueContent = Array.from(uniqueContentMap.values());
                    uniqueContent.sort((a: any, b: any) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());
                    
                    existing.linkedContent = uniqueContent.slice(0, 24); 
                    
                    if (!existing.image && creator.image) existing.image = creator.image;
                    if (!existing.bio && creator.bio) existing.bio = creator.bio;
                }
            });

            const uniqueStaff = Array.from(uniqueMap.values());

            const enrichedStaff = await Promise.all(uniqueStaff.map(async (creator: any) => {
                if (creator.linkedContent && creator.linkedContent.length > 0) {
                    creator.linkedContent = await enrichContentList(creator.linkedContent);
                }
                return creator;
            }));

            return enrichedStaff.sort((a: any, b: any) => a.name.localeCompare(b.name));
        } catch (error) {
            console.error("Failed to fetch staff:", error);
            return [];
        }
    },
    ['all-staff-full-data-v4'], 
    { 
        revalidate: 3600, 
        tags: ['creators', 'content', 'enriched-creators'] 
    }
);

// CACHED ACTION: Fetches all tags and their recent items
export const getAllTagsAction = unstable_cache(
    async () => {
        try {
            const query = groq`*[_type == "tag"] {
                _id,
                title,
                "slug": slug.current,
                category,
                "items": *[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && (references(^._id) || category._ref == ^._id)] | order(publishedAt desc)[0...24] { ${cardListProjection} }
            }`;
            
            const rawTags = await client.fetch(query);

            const enrichedTags = await Promise.all(rawTags.map(async (tag: any) => {
                if (tag.items && tag.items.length > 0) {
                    tag.items = await enrichContentList(tag.items);
                }
                return tag;
            }));

            return enrichedTags;
        } catch (error) {
            console.error("Failed to fetch all tags:", error);
            return [];
        }
    },
    ['all-tags-full-data'], 
    { 
        revalidate: 3600, 
        tags: ['tag', 'content'] 
    }
);

// NEW: CACHED ACTION for RECENT GAMES
// Strictly targeted pre-fetching for:
// 1. Top 10 Reviews
// 2. Top 12 Articles
// 3. Top 18 News
// 4. ALL Releases visible in the system (TBA + Any Date)
export const getRecentGamesAction = unstable_cache(
    async () => {
        try {
            // FIX: Removed date restrictions to fetch ALL relevant game hubs for releases.
            // We fetch slugs for:
            // 1. Recent content (Review/Article/News)
            // 2. ALL Game Releases that have a linked game
            const slugQuery = groq`{
                "reviews": *[_type == "review" && defined(game) && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[0...10].game->slug.current,
                "articles": *[_type == "article" && defined(game) && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[0...12].game->slug.current,
                "news": *[_type == "news" && defined(game) && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[0...18].game->slug.current,
                "releases": *[_type == "gameRelease" && defined(game)].game->slug.current
            }`;

            const slugsData = await client.fetch(slugQuery);
            
            const slugs = new Set<string>();
            
            // Add all found slugs to the Set
            (slugsData.reviews || []).forEach((s: string) => s && slugs.add(s));
            (slugsData.articles || []).forEach((s: string) => s && slugs.add(s));
            (slugsData.news || []).forEach((s: string) => s && slugs.add(s));
            (slugsData.releases || []).forEach((s: string) => s && slugs.add(s));

            const uniqueSlugs = Array.from(slugs);

            if (uniqueSlugs.length === 0) return [];

            // 2. Fetch full Game Hub data for these specific games
            const query = groq`*[_type == "game" && slug.current in $slugs] {
                _id,
                title,
                "slug": slug.current,
                "mainImage": mainImage{${mainImageFields}},
                
                // Get ALL content for this game (up to 24 items)
                "linkedContent": *[_type in ["review", "article", "news"] && defined(publishedAt) && publishedAt < now() && game->slug.current == ^.slug.current] | order(publishedAt desc)[0...24] { ${cardListProjection} }
            }`;
            
            const rawGames = await client.fetch(query, { slugs: uniqueSlugs });
            
            // 3. Enrich the content lists
            const enrichedGames = await Promise.all(rawGames.map(async (game: any) => {
                if (game.linkedContent && game.linkedContent.length > 0) {
                    game.linkedContent = await enrichContentList(game.linkedContent);
                    // Mark as loaded so store knows not to fetch again
                    game.contentLoaded = true;
                }
                return game;
            }));

            return enrichedGames;
        } catch (error) {
            console.error("Failed to fetch recent games:", error);
            return [];
        }
    },
    ['recent-games-hubs-targeted-v7'], // Key updated
    { 
        revalidate: 3600, 
        tags: ['game', 'content'] 
    }
);

--- END OF FILE app/actions/homepageActions.ts ---

================================================================================

--- START OF FILE app/actions/layoutActions.ts ---

// app/actions/layoutActions.ts
'use server';

import { fetchUniversalData } from '@/lib/universal-data';

// This action is now just a wrapper for the shared logic,
// used primarily by the Homepage for Server-Side Rendering (SSG).
export async function getUniversalBaseData() {
    return await fetchUniversalData();
}

--- END OF FILE app/actions/layoutActions.ts ---

================================================================================

--- START OF FILE app/actions/notificationActions.ts ---

// app/actions/notificationActions.ts
'use server';

import prisma from '@/lib/prisma';
import { getAuthenticatedSession } from '@/lib/auth';

// Removed getNotifications action as it's now handled by the API route

export async function markNotificationAsRead(notificationId: string) {
    try {
        const session = await getAuthenticatedSession();
        await prisma.notification.updateMany({
            where: { id: notificationId, userId: session.user.id },
            data: { read: true }
        });
        return { success: true };
    } catch (error) {
        return { success: false, error: 'Failed to mark as read.' };
    }
}

export async function markAllNotificationsAsRead() {
    try {
        const session = await getAuthenticatedSession();
        await prisma.notification.updateMany({
            where: { userId: session.user.id, read: false },
            data: { read: true }
        });
        return { success: true };
    } catch (error) {
        return { success: false, error: 'Failed to mark all as read.' };
    }
}




--- END OF FILE app/actions/notificationActions.ts ---

================================================================================

--- START OF FILE app/actions/sectionActions.ts ---



--- END OF FILE app/actions/sectionActions.ts ---

================================================================================

--- START OF FILE app/actions/userActions.ts ---

// app/actions/userActions.ts
'use server';

import prisma from '@/lib/prisma';
import { revalidatePath, revalidateTag } from 'next/cache';
import { put } from '@vercel/blob';
import bcrypt from 'bcryptjs';
import { getAuthenticatedSession } from '@/lib/auth';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';
import { profileSchema, signUpSchema } from '@/lib/validations';
import { sensitiveLimiter } from '@/lib/rate-limit';
import { headers } from 'next/headers';
import { validateImageFile } from '@/lib/security'; // SECURITY IMPORT

// ... (Keep existing syncUserToSanity function as is) ...
async function syncUserToSanity(userId: string) {
    try {
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: { id: true, name: true, image: true, bio: true, roles: { select: { name: true } } },
        });
        if (!user || !user.name) return;
        const userRoles = user.roles.map((r: any) => r.name);
        const creatorTypes = userRoles
            .map((role: string) => ({ 'REVIEWER': 'reviewer', 'AUTHOR': 'author', 'REPORTER': 'reporter', 'DESIGNER': 'designer' }[role]))
            .filter(Boolean) as string[];
        if (creatorTypes.length === 0) return;
        const sanityDocs = await sanityWriteClient.fetch(groq`*[_type in $creatorTypes && prismaUserId == $userId]`, { creatorTypes, userId: user.id });
        let imageAssetRef: string | undefined = undefined;
        if (user.image && user.image.startsWith('https://')) {
            try {
                const existingAsset = await sanityWriteClient.fetch(groq`*[_type == "sanity.imageAsset" && url == $imageUrl][0]._id`, { imageUrl: user.image });
                if (existingAsset) imageAssetRef = existingAsset;
                else {
                    const response = await fetch(user.image);
                    const imageBlob = await response.blob();
                    const imageAsset = await sanityWriteClient.assets.upload('image', imageBlob, { contentType: imageBlob.type, filename: `${user.id}-avatar.jpg` });
                    imageAssetRef = imageAsset._id;
                }
            } catch (e) { console.warn(`[Sanity Sync] Image upload failed`, e); }
        }
        const transaction = sanityWriteClient.transaction();
        for (const doc of sanityDocs) {
            const patchData: any = { name: user.name, bio: user.bio };
            if (imageAssetRef) patchData.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAssetRef } };
            transaction.patch(doc._id, { set: patchData });
        }
        await transaction.commit();
    } catch (error) { console.error(`[CRITICAL] Failed to sync user ${userId} to Sanity:`, error); }
}

export async function getUserState() {
    try {
        const session = await getAuthenticatedSession();
        
        const [engagements, shares] = await Promise.all([
            prisma.engagement.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true, type: true } 
            }),
            prisma.share.findMany({ 
                where: { userId: session.user.id }, 
                select: { contentId: true, contentType: true } 
            }),
        ]);

        const likes: string[] = [];
        const bookmarks: string[] = [];
        const shareKeys: string[] = [];

        engagements.forEach(e => {
            const key = `${e.contentType}-${e.contentId}`;
            if (e.type === 'LIKE') likes.push(key);
            else if (e.type === 'BOOKMARK') bookmarks.push(key);
        });

        shares.forEach(s => {
            shareKeys.push(`${s.contentType}-${s.contentId}`);
        });

        return { 
            success: true, 
            data: { likes, bookmarks, shares: shareKeys } 
        };
    } catch (error) { 
        return { success: false, data: null }; 
    }
}

export async function updateUserProfile(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`update-profile-${session.user.id}-${ip}`, 5);
        if (!limitCheck.success) throw new Error("تجاوزت حد التحديثات المسموح به.");

        const rawData = {
            name: formData.get('name'),
            username: formData.get('username'),
            bio: formData.get('bio'),
            twitterHandle: formData.get('twitterHandle'),
            instagramHandle: formData.get('instagramHandle'),
        };

        const validation = profileSchema.safeParse(rawData);
        if (!validation.success) {
            throw new Error(validation.error.issues[0].message);
        }
        const data = validation.data;

        const agePublic = formData.get('agePublic') === 'on';
        const countryPublic = formData.get('countryPublic') === 'on';

        if (data.username) {
            const existingUser = await prisma.user.findUnique({ where: { username: data.username } });
            if (existingUser && existingUser.id !== session.user.id) throw new Error('اسمٌ محجوز.');
        }
        
        await prisma.user.update({
            where: { id: session.user.id },
            data: { 
                name: data.name, 
                username: data.username, 
                bio: data.bio, 
                twitterHandle: data.twitterHandle, 
                instagramHandle: data.instagramHandle, 
                agePublic, 
                countryPublic 
            },
        });
        
        await syncUserToSanity(session.user.id);

        revalidateTag(`user-session-${session.user.id}`, 'max');
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidatePath('/profile');
        revalidatePath(`/profile/${session.user.id}`);
        if (data.username) revalidatePath(`/creators/${data.username}`);

        return { success: true, message: 'تَجَدَّدَ مَلَفُكَ الشخصي.' };
    } catch (error: any) { return { success: false, message: error.message || 'أخفق تحديث الملف.' }; }
}

export async function completeOnboardingAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        const rawData = {
            name: formData.get('fullName'),
            username: formData.get('username'),
        };
        
        const nameVal = profileSchema.shape.name.safeParse(rawData.name);
        const userVal = profileSchema.shape.username.safeParse(rawData.username);
        
        if (!nameVal.success) return { success: false, message: nameVal.error.issues[0].message };
        if (!userVal.success) return { success: false, message: userVal.error.issues[0].message };
        
        const fullName = nameVal.data;
        const username = userVal.data;

        const ageStr = formData.get('age') as string;
        const country = formData.get('country') as string;

        const user = await prisma.user.findUnique({ where: { id: session.user.id } });

        if (username !== user?.username) {
            const usernameValidation = await checkUsernameAvailability(username);
            if (!usernameValidation.available) return { success: false, message: usernameValidation.message };
        }

        await prisma.user.update({
            where: { id: session.user.id },
            data: { name: fullName, username: username, age: ageStr ? parseInt(ageStr, 10) : null, country: country || null },
        });

        revalidateTag(`user-session-${session.user.id}`, 'max');
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidatePath('/profile');
        if (username) revalidatePath(`/profile/${username}`);
        return { success: true };
    } catch (error: any) { return { success: false, message: error.message || 'طرأ خطبٌ عند التهيئة.' }; }
}

export async function changePasswordAction(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`change-pw-${session.user.id}-${ip}`, 3); 
        if (!limitCheck.success) throw new Error("محاولات كثيرة جدًا.");

        const user = await prisma.user.findUnique({ where: { id: session.user.id } });
        if (!user?.password) return { success: false, message: 'لا يمكن تغيير كلمة السر للحسابات المربوطة بمزود خارجي.' };
        
        const currentPassword = formData.get('currentPassword') as string;
        const newPassword = formData.get('newPassword') as string;
        const confirmPassword = formData.get('confirmPassword') as string;
        
        // DIRECTOR Override check
        const userRoles = session.user.roles || [];
        const isDirector = userRoles.includes('DIRECTOR');

        // Logic split: Director doesn't need currentPassword
        if (!isDirector) {
            if (!currentPassword) return { success: false, message: 'كلمة السر الحالية مطلوبة.' };
            const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
            if (!isPasswordValid) return { success: false, message: 'كلمة السر الحالية خاطئة.' };
        }

        if (!newPassword || !confirmPassword) return { success: false, message: 'الكلمة الجديدة وتأكيدها مطلوبان.' };
        
        const pwVal = signUpSchema.shape.password.safeParse(newPassword);
        if (!pwVal.success) return { success: false, message: pwVal.error.issues[0].message };
        
        if (newPassword !== confirmPassword) return { success: false, message: 'الكلمتان الجديدتان لا تتطابقان.' };
        
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        await prisma.user.update({ where: { id: user.id }, data: { password: hashedPassword } });
        
        return { success: true, message: 'تغيَّرت كلمة السر.' };
    } catch (error: any) { return { success: false, message: error.message || 'طرأ خطبٌ ما.' }; }
}

export async function checkUsernameAvailability(username: string): Promise<{ available: boolean; message: string }> {
    const validation = profileSchema.shape.username.safeParse(username);
    if (!validation.success) return { available: false, message: validation.error.issues[0].message };
    
    const existingUser = await prisma.user.findUnique({ where: { username: validation.data } });
    if (existingUser) return { available: false, message: 'اسمٌ محجوز.' };
    return { available: true, message: 'الاسمُ متاح.' };
}

export async function signUp(formData: FormData) {
    const ip = (await headers()).get('x-forwarded-for') || 'unknown';
    const limitCheck = await sensitiveLimiter.check(`signup-${ip}`, 3); 
    if (!limitCheck.success) return { success: false, message: "يرجى الانتظار قبل المحاولة مرة أخرى." };

    const rawData = {
        name: formData.get('name'),
        email: formData.get('email'),
        password: formData.get('password'),
        username: formData.get('username'),
    };

    const validation = signUpSchema.safeParse(rawData);
    if (!validation.success) {
        return { success: false, message: validation.error.issues[0].message };
    }
    const data = validation.data;

    const usernameCheck = await checkUsernameAvailability(data.username);
    if (!usernameCheck.available) return { success: false, message: usernameCheck.message };
    
    const existingEmail = await prisma.user.findUnique({ where: { email: data.email } });
    if (existingEmail) return { success: false, message: 'بريدٌ مسجل.' };
    
    return { success: true, message: 'تمَّت المصادقة.' };
}

export async function setUsernameAction(username: string) {
    try {
        const session = await getAuthenticatedSession();
        const user = await prisma.user.findUnique({ where: { id: session.user.id } });
        if (user?.username) return { success: false, message: 'الاسمُ قد عُيِّن.' };
        
        const validation = profileSchema.shape.username.safeParse(username);
        if (!validation.success) return { success: false, message: validation.error.issues[0].message };
        const cleanUsername = validation.data;

        const availability = await checkUsernameAvailability(cleanUsername);
        if (!availability.available) return { success: false, message: availability.message };
        
        await prisma.user.update({ where: { id: session.user.id }, data: { username: cleanUsername } });
        revalidatePath('/profile');
        revalidateTag(`user-session-${session.user.id}`, 'max');
        return { success: true };
    } catch (error: any) { return { success: false, message: error.message || 'أخفق تحديث الاسم.' }; }
}

export async function updateUserAvatar(formData: FormData) {
    try {
        const session = await getAuthenticatedSession();
        
        // Rate limit for uploads (heavy operation)
        const ip = (await headers()).get('x-forwarded-for') || 'unknown';
        const limitCheck = await sensitiveLimiter.check(`avatar-upload-${session.user.id}-${ip}`, 3); 
        if (!limitCheck.success) throw new Error("محاولات رفع كثيرة جداً.");

        const avatarFile = formData.get('avatar') as File | null;
        if (!avatarFile || avatarFile.size === 0) return { success: true, message: 'لا صورة جديدة.' };
        
        // SECURITY: Strict File Validation
        if (avatarFile.size > 5 * 1024 * 1024) throw new Error('حجم الصورة كبير جدًا (أقصى حد 5 ميجابايت).');
        
        // SECURITY: Verify Magic Bytes
        const validation = await validateImageFile(avatarFile);
        if (!validation.isValid) throw new Error(validation.error);

        const sanitizedFilename = `${session.user.id}-${Date.now()}-${avatarFile.name.replace(/[^a-zA-Z0-9._-]/g, '-')}`;
        const blob = await put(sanitizedFilename, avatarFile, { access: 'public', contentType: avatarFile.type });
        
        await prisma.user.update({ where: { id: session.user.id }, data: { image: blob.url } });
        await syncUserToSanity(session.user.id);
        
        revalidatePath('/profile');
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidateTag(`user-session-${session.user.id}`, 'max');
        
        return { success: true, message: 'تجدَّدت الصورة الرمزية.' };
    } catch (error: any) { return { success: false, message: error.message || 'أخفق الرفع.' }; }
}

export async function getCommentedContentIds() {
    try {
        const session = await getAuthenticatedSession();
        const comments = await prisma.comment.findMany({
            where: { authorId: session.user.id, isDeleted: false },
            select: { contentSlug: true },
            distinct: ['contentSlug'],
        });
        return comments.map((c: any) => c.contentSlug);
    } catch (error) { return []; }
}

--- END OF FILE app/actions/userActions.ts ---

================================================================================

--- START OF FILE app/api/articles/route.ts ---

// app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedArticlesQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { enrichContentList } from '@/lib/enrichment';
import { standardLimiter } from '@/lib/rate-limit'; 

export const dynamic = 'force-dynamic';

export async function GET(req: NextRequest) {
    try {
        const ip = req.headers.get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`api-articles-${ip}`, 20);
        if (!limitCheck.success) {
            return NextResponse.json({ error: 'Too many requests' }, { status: 429 });
        }

        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '0');
        const limit = parseInt(searchParams.get('limit') || '20');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'viral') || 'latest';

        const query = paginatedArticlesQuery(gameSlug, tagSlugs, searchTerm, offset, limit, sort);
        
        const sanityData = await client.fetch(query, {}, { cache: 'no-store' });
        
        const enrichedData = await enrichContentList(sanityData);
        const data = enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);

        const response = NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });

        response.headers.set('Cache-Control', 'public, max-age=60, s-maxage=60');

        return response;

    } catch (error) {
        console.error('Error fetching paginated articles:', error);
        return NextResponse.json({ error: 'Failed to fetch articles data' }, { status: 500 });
    }
}

--- END OF FILE app/api/articles/route.ts ---

================================================================================

--- START OF FILE app/api/auth/[...nextauth]/route.ts ---

// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

--- END OF FILE app/api/auth/[...nextauth]/route.ts ---

================================================================================

--- START OF FILE app/api/comments/[slug]/route.ts ---

// app/api/comments/[slug]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';

export const dynamic = 'force-dynamic'; // Ensures this route is always server-rendered

// MODIFIED: The context for params is now correctly typed as a Promise.
export async function GET(req: NextRequest, { params: paramsPromise }: { params: Promise<{ slug: string }> }) {
    try {
        // MODIFIED: We must await the promise to get the slug.
        const { slug } = await paramsPromise;

        if (!slug) {
            return NextResponse.json({ error: 'Slug is required' }, { status: 400 });
        }
        
        const comments = await prisma.comment.findMany({
            where: { contentSlug: slug, parentId: null },
            include: { 
                author: { select: { id: true, name: true, image: true, username: true } }, 
                votes: true, 
                _count: { select: { replies: true } }, 
                replies: { 
                    take: 2, 
                    include: { 
                        author: { select: { id: true, name: true, image: true, username: true } }, 
                        votes: true, 
                        _count: { select: { replies: true } } 
                    }, 
                    orderBy: { createdAt: 'asc' } 
                } 
            },
            orderBy: { createdAt: 'desc' },
        });

        return NextResponse.json(comments);

    } catch (error) {
        console.error('API Error fetching comments:', error);
        return NextResponse.json({ error: 'Failed to fetch comments.' }, { status: 500 });
    }
}




--- END OF FILE app/api/comments/[slug]/route.ts ---

================================================================================

--- START OF FILE app/api/content-by-ids/route.ts ---

// app/api/content-by-ids/route.ts

import { NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { contentByIdsQuery } from '@/lib/sanity.queries';

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { ids } = body;

    if (!Array.isArray(ids) || ids.length === 0) {
      return NextResponse.json([]);
    }

    // FIX: Disable Data Cache for arbitrary ID combinations to prevent cache explosion.
    const content = await client.fetch(contentByIdsQuery, { ids }, { cache: 'no-store' });

    return NextResponse.json(content);

  } catch (error) {
    console.error('API Error in /api/content-by-ids:', error);
    return NextResponse.json(
      { error: 'Failed to fetch content by IDs.' },
      { status: 500 }
    );
  }
}

--- END OF FILE app/api/content-by-ids/route.ts ---

================================================================================

--- START OF FILE app/api/cron/revalidate-scheduled/route.ts ---

// app/api/cron/revalidate-scheduled/route.ts

import { revalidatePath } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';
import { sanityWriteClient } from '@/lib/sanity.server';
import { groq } from 'next-sanity';

// This is the CRON job handler. It is secured by a secret token from Vercel.
export async function GET(request: NextRequest) {
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return new Response('غير مُخَوَّل.', { status: 401 });
  }

  // Find all documents that were scheduled to be published in the last minute
  // and are now past their publication date.
  const now = new Date();
  const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);

  const query = groq`*[_type in ["مراجعة", "مقالة", "خبر"] && publishedAt >= $oneMinuteAgo && publishedAt < $now] {
    _type,
    "slug": slug.current
  }`;

  try {
    const docsToRevalidate: { _type: string; slug: string }[] = await sanityWriteClient.fetch(query, {
      oneMinuteAgo: oneMinuteAgo.toISOString(),
      now: now.toISOString(),
    });

    if (docsToRevalidate.length === 0) {
      return NextResponse.json({ success: true, message: 'لا وثائقَ لإعادة المصادقة.' });
    }

    // Use a Set to avoid revalidating the same path multiple times
    const pathsToRevalidate = new Set<string>();
    docsToRevalidate.forEach(doc => {
      const contentTypePlural = doc._type === 'خبر' ? 'خبر' : `${doc._type}s`;
      pathsToRevalidate.add(`/${contentTypePlural}`); // e.g., /articles
      pathsToRevalidate.add(`/${contentTypePlural}/${doc.slug}`); // e.g., /articles/my-slug
    });

    // Trigger revalidation for all unique paths
    pathsToRevalidate.forEach(path => {
      revalidatePath(path);
    });

    return NextResponse.json({ success: true, revalidatedPaths: Array.from(pathsToRevalidate) });

  } catch (error) {
    console.error('Cron job failed:', error);
    return NextResponse.json({ success: false, message: 'Cron job failed.' }, { status: 500 });
  }
}






















--- END OF FILE app/api/cron/revalidate-scheduled/route.ts ---

================================================================================

--- START OF FILE app/api/engagement-scores/route.ts ---

// app/api/engagement-scores/route.ts
import prisma from '@/lib/prisma';
import { NextResponse } from 'next/server';
import { unstable_cache } from 'next/cache';

const getCachedScores = unstable_cache(
    async () => {
        const contentTypes = ['review', 'article', 'news'];
        
        // OPTIMIZATION: Minimal selection to reduce DB load
        const contentIdsQuery = await prisma.engagement.findMany({
            where: { contentType: { in: contentTypes }, type: 'LIKE' },
            select: { contentId: true },
            distinct: ['contentId']
        });
        const ids = contentIdsQuery.map((i: any) => i.contentId);

        if (ids.length === 0) return [];

        // OPTIMIZATION: Run groupBys in parallel
        const [likes, shares] = await Promise.all([
            prisma.engagement.groupBy({
                by: ['contentId'],
                where: { contentId: { in: ids }, type: 'LIKE' },
                _count: { userId: true },
            }),
            prisma.share.groupBy({
                by: ['contentId'],
                where: { contentId: { in: ids } },
                _count: { userId: true },
            })
        ]);
        
        return ids.map((id: number) => {
            const likeCount = likes.find((s: any) => s.contentId === id)?._count.userId || 0;
            const shareCount = shares.find((s: any) => s.contentId === id)?._count.userId || 0;
            
            const engagementScore = (likeCount * 2) + (shareCount * 5); 
            
            return { id, engagementScore };
        });
    },
    ['global-engagement-scores'], 
    // OPTIMIZATION: Infinite cache.
    // Invalidated ONLY by user interaction (Like/Share actions).
    { 
        revalidate: false,
        tags: ['engagement-scores'] 
    } 
);

export async function GET() {
  try {
    const result = await getCachedScores();
    return NextResponse.json(result);
  } catch (error) {
    console.error('Failed to fetch engagement scores:', error);
    return NextResponse.json({ error: 'Failed to fetch engagement metrics' }, { status: 500 });
  }
}

--- END OF FILE app/api/engagement-scores/route.ts ---

================================================================================

--- START OF FILE app/api/news/route.ts ---

// app/api/news/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedNewsQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { enrichContentList } from '@/lib/enrichment';
import { standardLimiter } from '@/lib/rate-limit'; 

export const dynamic = 'force-dynamic';

export async function GET(req: NextRequest) {
    try {
        const ip = req.headers.get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`api-news-${ip}`, 20);
        if (!limitCheck.success) {
            return NextResponse.json({ error: 'Too many requests' }, { status: 429 });
        }

        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '50');
        const limit = parseInt(searchParams.get('limit') || '50');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'viral') || 'latest';
        
        const tags = tagSlugs?.length === 0 ? undefined : tagSlugs;
        const query = paginatedNewsQuery(gameSlug, tags, searchTerm, offset, limit, sort);
        
        const sanityData = await client.fetch(query, {}, { cache: 'no-store' });
        
        const enrichedData = await enrichContentList(sanityData);
        const data = enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);

        const response = NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });
        
        response.headers.set('Cache-Control', 'public, max-age=60, s-maxage=60');

        return response;

    } catch (error) {
        console.error('Error fetching paginated news:', error);
        return NextResponse.json({ error: 'Failed to fetch news data' }, { status: 500 });
    }
}

--- END OF FILE app/api/news/route.ts ---

================================================================================

--- START OF FILE app/api/news-engagement/route.ts ---

// app/api/news-engagement/route.ts

import prisma from '@/lib/prisma';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // 1. Find all unique legacyIds (contentIds) tagged as 'خبر' and of type 'LIKE'
    const contentIdsQuery = await prisma.engagement.findMany({
        where: { contentType: 'خبر', type: 'LIKE' },
        select: { contentId: true },
        distinct: ['contentId']
    });
    const ids = contentIdsQuery.map((i: any) => i.contentId);

    // 2. Aggregate Likes and Shares separately
    const likes = await prisma.engagement.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر', type: 'LIKE' },
        _count: { userId: true },
    });

    const shares = await prisma.share.groupBy({
        by: ['contentId'],
        where: { contentId: { in: ids }, contentType: 'خبر' },
        _count: { userId: true },
    });
    
    // Note: We cannot reliably calculate comments in this API without complex database mappings, 
    // so we maintain the weighted scoring structure based on available data (Likes/Shares).

    // 3. Aggregate results and calculate viral score
    const result = ids.map((id: number) => {
        const likeCount = likes.find((s: any) => s.contentId === id)?._count.userId || 0;
        const shareCount = shares.find((s: any) => s.contentId === id)?._count.userId || 0;
        
        // Weighted viral score: Shares (x5) + Likes (x2)
        const engagementScore = likeCount * 2 + shareCount * 5; 
        
        return {
            id,
            engagementScore,
        };
    });

    return NextResponse.json(result);
  } catch (error) {
    console.error('Failed to fetch news engagement:', error);
    return NextResponse.json({ error: 'Failed to fetch engagement metrics' }, { status: 500 });
  }
}




--- END OF FILE app/api/news-engagement/route.ts ---

================================================================================

--- START OF FILE app/api/notifications/route.ts ---

// app/api/notifications/route.ts
import { NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { getAuthenticatedSession } from '@/lib/auth';

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const session = await getAuthenticatedSession();
        
        const notifications = await prisma.notification.findMany({
            where: { userId: session.user.id },
            include: {
                sender: { select: { name: true, image: true, username: true } }
            },
            orderBy: { createdAt: 'desc' },
            take: 20
        });
        
        const unreadCount = await prisma.notification.count({
            where: { userId: session.user.id, read: false }
        });

        return NextResponse.json({ success: true, notifications, unreadCount });
    } catch (error) {
        // Return empty if unauthorized or error, to fail gracefully without crashing UI
        return NextResponse.json({ success: false, notifications: [], unreadCount: 0 }, { status: 200 });
    }
}




--- END OF FILE app/api/notifications/route.ts ---

================================================================================

--- START OF FILE app/api/og/route.tsx ---

// app/api/og/route.tsx
import { ImageResponse } from 'next/og';

export const runtime = 'edge';

const PROJECT_ID = process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || '0zany1dm';
const DATASET = process.env.NEXT_PUBLIC_SANITY_DATASET || 'production';
const SITE_URL = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgamesweb.com';

const QUERY = `*[_type in ["review", "article", "news"] && slug.current == $slug][0]{
    "imageUrl": mainImage.asset->url,
    score
}`;

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const slug = searchParams.get('slug');

    // Default to the site screenshot
    let imageUrl = `${SITE_URL}/screenshot-wide.png`;
    let score = null;

    // If a slug is provided, try to fetch specific content data
    if (slug) {
        try {
            const url = `https://${PROJECT_ID}.api.sanity.io/v2021-10-21/data/query/${DATASET}?query=${encodeURIComponent(QUERY)}&%24slug="${slug}"`;
            const sanityRes = await fetch(url, { next: { revalidate: 3600 } }); // Cache Sanity lookup
            
            if (sanityRes.ok) {
                const json = await sanityRes.json();
                const data = json.result;

                if (data && data.imageUrl) {
                    // Force Sanity CDN to deliver Max Quality (100) at exact Dimensions
                    imageUrl = `${data.imageUrl}?w=1200&h=630&fit=crop&q=100&auto=format`;
                    score = data.score;
                }
            }
        } catch (e) {
            console.error("Sanity fetch failed for OG, using default screenshot.", e);
        }
    }

    const ACCENT = '#00FFF0';

    return new ImageResponse(
        (
            // 1. OUTER CONTAINER: Full square rectangle with dark background.
            <div
                style={{
                    display: 'flex',
                    width: '100%',
                    height: '100%',
                    backgroundColor: '#0A0B0F', 
                    alignItems: 'center',
                    justifyContent: 'center',
                }}
            >
                {/* 2. INNER CONTAINER: Rounded and Clipped */}
                <div
                    style={{
                        display: 'flex',
                        width: '100%',
                        height: '100%',
                        position: 'relative',
                        borderRadius: '42px', // Visible rounding
                        overflow: 'hidden',   // Clips the image
                    }}
                >
                    {/* 1. Background Image (Screenshot or Article Image) */}
                    {/* eslint-disable-next-line @next/next/no-img-element */}
                    <img
                        src={imageUrl}
                        alt="EternalGames Preview"
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'cover',
                            position: 'absolute',
                            top: 0,
                            left: 0,
                        }}
                    />

                    {/* 2. Gradient Overlay */}
                    <div
                        style={{
                            position: 'absolute',
                            bottom: 0,
                            left: 0,
                            width: '100%',
                            height: '60%',
                            display: 'flex',
                            background: 'linear-gradient(to top, #0A0B0F 0%, rgba(10,11,15,0.6) 40%, transparent 100%)',
                        }}
                    />

                    {/* 3. Cyber Border Overlay */}
                    <div
                        style={{
                            position: 'absolute',
                            top: 0,
                            left: 0,
                            width: '100%',
                            height: '100%',
                            border: `4px solid ${ACCENT}`,
                            borderRadius: '42px', // Match inner container radius
                            boxShadow: `inset 0 0 50px ${ACCENT}60`, 
                            display: 'flex', 
                        }}
                    />

                    {/* 4. Score Badge (Only shows if content has a score) */}
                    {score && (
                        <div style={{
                            position: 'absolute',
                            top: '40px',
                            right: '40px',
                            width: '140px',
                            height: '140px',
                            borderRadius: '50%',
                            backgroundColor: '#0A0B0F', 
                            border: `5px solid ${ACCENT}`,
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            boxShadow: `0 10px 40px rgba(0,0,0,0.8)`,
                        }}>
                            <div style={{
                                display: 'flex',
                                color: ACCENT,
                                fontSize: '72px',
                                fontWeight: 900,
                                fontFamily: 'sans-serif',
                                marginTop: '-10px',
                            }}>
                                {score}
                            </div>
                        </div>
                    )}
                </div>
            </div>
        ),
        {
            width: 1200,
            height: 630,
            // ADDED: Cache-Control header to prevent excessive edge function execution
            headers: {
                'Cache-Control': 'public, max-age=604800, immutable', // Cache for 7 days
            },
        }
    );
  } catch (e: any) {
    return new Response(JSON.stringify({ error: e.message }), { status: 500, headers: {'Content-Type': 'application/json'} });
  }
}

--- END OF FILE app/api/og/route.tsx ---

================================================================================

--- START OF FILE app/api/revalidate-sanity/route.ts ---

import { revalidateTag } from 'next/cache';
import { type NextRequest, NextResponse } from 'next/server';
import { parseBody } from 'next-sanity/webhook';

type WebhookPayload = {
  _type: string;
  _id: string;
  slug?: {
    current: string;
  };
};

export async function POST(req: NextRequest) {
  try {
    const { body, isValidSignature } = await parseBody<WebhookPayload>(
      req,
      process.env.REVALIDATION_SECRET_TOKEN,
    );

    if (!isValidSignature) {
      return new Response('Invalid signature', { status: 401 });
    }

    if (!body?._type || !body?._id) {
      return new Response('Bad Request: Missing _type or _id', { status: 400 });
    }

    // 1. IGNORE DRAFTS
    if (body._id.startsWith('drafts.')) {
      return NextResponse.json({
        status: 200,
        revalidated: false,
        message: 'Ignored draft document',
        now: Date.now(),
      });
    }

    // 2. IGNORE SYSTEM ASSETS (The "Asset Trap" Fix)
    // Uploading images/files triggers webhooks but shouldn't nuke the homepage cache
    // until they are actually ATTACHED to a published document.
    if (['sanity.imageAsset', 'sanity.fileAsset'].includes(body._type)) {
       return NextResponse.json({
        status: 200,
        revalidated: false,
        message: 'Ignored system asset',
        now: Date.now(),
      });
    }

    // 3. SURGICAL REVALIDATION
    
    // A. Always invalidate the specific document by its SLUG
    if (body.slug?.current) {
        revalidateTag(body.slug.current, 'max');
        console.log(`[REVALIDATE] Invalidated Slug: ${body.slug.current}`);
    }

    // B. Global Content (Menus, Lists, Feeds)
    // Only revalidate this heavy tag for actual content types
    revalidateTag('content', 'max');

    // C. Metadata Singletons
    if (['tag', 'game', 'developer', 'publisher', 'author', 'reviewer', 'reporter', 'designer'].includes(body._type)) {
        revalidateTag('studio-metadata', 'max');
    }

    return NextResponse.json({
      status: 200,
      revalidated: true,
      now: Date.now(),
      type: body._type,
      slug: body.slug?.current
    });

  } catch (err: any) {
    console.error('[REVALIDATE ERROR]', err);
    return new Response(err.message, { status: 500 });
  }
}

// Manual Handler
export async function GET(req: NextRequest) {
    const { searchParams } = new URL(req.url);
    const secret = searchParams.get('secret');
    const tag = searchParams.get('tag');

    if (secret !== process.env.REVALIDATION_SECRET_TOKEN) {
        return new Response('Invalid token', { status: 401 });
    }

    if (tag) {
        revalidateTag(tag, 'max');
        return NextResponse.json({ revalidated: true, tag, now: Date.now() });
    }
    
    revalidateTag('content', 'max');
    revalidateTag('studio-metadata', 'max');

    return NextResponse.json({ revalidated: true, message: 'Global content tags revalidated', now: Date.now() });
}

--- END OF FILE app/api/revalidate-sanity/route.ts ---

================================================================================

--- START OF FILE app/api/reviews/route.ts ---

// app/api/reviews/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { paginatedReviewsQuery } from '@/lib/sanity.queries';
import { adaptToCardProps } from '@/lib/adapters';
import { ScoreFilter } from '@/components/filters/ReviewFilters';
import { enrichContentList } from '@/lib/enrichment';
import { standardLimiter } from '@/lib/rate-limit'; 

export const dynamic = 'force-dynamic';

export async function GET(req: NextRequest) {
    try {
        const ip = req.headers.get('x-forwarded-for') || 'unknown';
        const limitCheck = await standardLimiter.check(`api-reviews-${ip}`, 20);
        if (!limitCheck.success) {
            return NextResponse.json({ error: 'Too many requests' }, { status: 429 });
        }

        const { searchParams } = new URL(req.url);
        
        const offset = parseInt(searchParams.get('offset') || '0');
        const limit = parseInt(searchParams.get('limit') || '20');
        const gameSlug = searchParams.get('game') || undefined;
        const searchTerm = searchParams.get('q') || undefined;
        const tagSlugsString = searchParams.get('tags');
        const tagSlugs = tagSlugsString ? tagSlugsString.split(',') : undefined;
        const sort = (searchParams.get('sort') as 'latest' | 'score') || 'latest';
        const scoreRange = searchParams.get('score') as ScoreFilter || undefined;

        const query = paginatedReviewsQuery(gameSlug, tagSlugs, searchTerm, scoreRange, offset, limit, sort);
        
        const sanityData = await client.fetch(query, {}, { cache: 'no-store' });
        
        const enrichedData = await enrichContentList(sanityData);
        const data = enrichedData.map(item => adaptToCardProps(item, { width: 600 })).filter(Boolean);

        const response = NextResponse.json({
            data,
            nextOffset: data.length === limit ? offset + limit : null,
        });

        response.headers.set('Cache-Control', 'public, max-age=60, s-maxage=60');
        
        return response;

    } catch (error) {
        console.error('Error fetching paginated reviews:', error);
        return NextResponse.json({ error: 'Failed to fetch reviews data' }, { status: 500 });
    }
}

--- END OF FILE app/api/reviews/route.ts ---

================================================================================

--- START OF FILE app/api/search/route.ts ---

import { NextRequest, NextResponse } from 'next/server';
import { client } from '@/lib/sanity.client';
import { searchQuery } from '@/lib/sanity.queries';
import { SanitySearchResult } from '@/types/sanity';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q') || '';

  if (query.length < 3) {
    return NextResponse.json([]);
  }

  try {
    // FIX: cache: 'no-store' prevents Next.js from writing these infinite permutations to the Data Cache (ISR Writes).
    // Sanity's CDN will still handle repeated requests efficiently if useCdn is true globally, 
    // but here we want to avoid Vercel cache explosion.
    const results = await client.fetch<SanitySearchResult[]>(
      searchQuery, 
      { searchTerm: query },
      { cache: 'no-store' } 
    );
    
    return NextResponse.json(results, {
        headers: {
            'Cache-Control': 'public, max-age=60' 
        }
    });
  } catch (error) {
    console.error('Sanity search failed:', error);
    return NextResponse.json({ error: 'Search failed' }, { status: 500 });
  }
}

--- END OF FILE app/api/search/route.ts ---

================================================================================

--- START OF FILE app/api/translate/route.ts ---

// app/api/translate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { translateTitleToAction } from '@/app/studio/actions';
import prisma from '@/lib/prisma'; // <-- THE FIX: Import prisma

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
        return NextResponse.json({ error: 'غير مُصرَّح به.' }, { status: 401 });
    }

    // THE DEFINITIVE FIX: Fetch fresh roles from DB
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id },
        select: { roles: { select: { name: true } } }
    });
    const userRoles = user?.roles.map((r: any) => r.name) || [];

    const isAuthorized = userRoles.some((role: string) =>
      ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role)
    );

    if (!isAuthorized) {
      return NextResponse.json({ error: 'غير مُصرَّح به.' }, { status: 401 });
    }

    const { title } = await request.json();

    if (!title || typeof title !== 'string') {
      return NextResponse.json({ error: 'العنوان مطلوب.' }, { status: 400 });
    }

    const slug = await translateTitleToAction(title);

    return NextResponse.json({ slug });
  } catch (error) {
    console.error('API Error in /api/translate:', error);
    return NextResponse.json(
      { error: 'فشل في الترجمة.' },
      { status: 500 }
    );
  }
}




--- END OF FILE app/api/translate/route.ts ---

================================================================================

--- START OF FILE app/api/universal/route.ts ---

// app/api/universal/route.ts
import { NextResponse } from 'next/server';
import { fetchUniversalData } from '@/lib/universal-data';

// OPTIMIZATION: Set to false (Infinite).
// This route will now return the exact same JSON forever until 
// the underlying 'fetchUniversalData' cache is invalidated by a Sanity Webhook.
export const revalidate = false; 

export async function GET() {
    try {
        const data = await fetchUniversalData();
        return NextResponse.json(data);
    } catch (error) {
        return NextResponse.json({ error: 'Failed to fetch universal data' }, { status: 500 });
    }
}

--- END OF FILE app/api/universal/route.ts ---

================================================================================

--- START OF FILE app/api/user/init/route.ts ---

// app/api/user/init/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import prisma from '@/lib/prisma';

export const dynamic = 'force-dynamic';

export async function GET() {
    try {
        const session = await getServerSession(authOptions);
        
        if (!session?.user?.id) {
            return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
        }

        const userId = session.user.id;

        const [engagements, shares, notifications, unreadCount] = await Promise.all([
            prisma.engagement.findMany({ 
                where: { userId }, 
                select: { contentId: true, contentType: true, type: true } 
            }),
            prisma.share.findMany({ 
                where: { userId }, 
                select: { contentId: true, contentType: true } 
            }),
            prisma.notification.findMany({
                where: { userId },
                include: {
                    sender: { select: { name: true, image: true, username: true } }
                },
                orderBy: { createdAt: 'desc' },
                take: 20
            }),
            prisma.notification.count({
                where: { userId, read: false }
            })
        ]);

        const likes: string[] = [];
        const bookmarks: string[] = [];
        const shareKeys: string[] = [];

        engagements.forEach(e => {
            const key = `${e.contentType}-${e.contentId}`;
            if (e.type === 'LIKE') likes.push(key);
            else if (e.type === 'BOOKMARK') bookmarks.push(key);
        });

        shares.forEach(s => {
            shareKeys.push(`${s.contentType}-${s.contentId}`);
        });

        return NextResponse.json({ 
            success: true, 
            userState: { 
                likes, 
                bookmarks, 
                shares: shareKeys 
            },
            notifications: {
                items: notifications,
                unreadCount
            }
        });

    } catch (error) {
        console.error('Error in /api/user/init:', error);
        return NextResponse.json({ success: false, error: 'Initialization failed' }, { status: 500 });
    }
}

--- END OF FILE app/api/user/init/route.ts ---

================================================================================

--- START OF FILE app/articles/ArticlesPageClient.tsx ---

// app/articles/ArticlesPageClient.tsx
'use client';

import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import type { SanityArticle, SanityGame, SanityTag } from '@/types/sanity';
import HorizontalShowcase from '@/components/HorizontalShowcase';
import ArticleFilters from '@/components/filters/ArticleFilters';
import ArticleCard from '@/components/ArticleCard';
import Image from 'next/image';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from '@/components/HorizontalShowcase.module.css';
import { ContentBlock } from '@/components/ContentBlock';
import { ArticleIcon } from '@/components/icons';
import { sanityLoader } from '@/lib/sanity.loader';
import InfiniteScrollSentinel from '@/components/ui/InfiniteScrollSentinel';
import ArticleCardSkeleton from '@/components/ui/ArticleCardSkeleton';
import { useContentStore } from '@/lib/contentStore';
import { loadMoreArticles, batchFetchFullContentAction } from '@/app/actions/batchActions';

const ArrowIcon = ({ direction = 'right' }: { direction?: 'left' | 'right' }) => ( <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"> <polyline points={direction === 'right' ? "9 18 15 12 9 6" : "15 18 9 12 15 6"} /> </svg> );
const MobileShowcase = ({ articles, onActiveIndexChange }: { articles: CardProps[], onActiveIndexChange: (index: number) => void }) => {
    const [[page, direction], setPage] = useState([0, 0]);
    const paginate = (newDirection: number) => { const newIndex = (page + newDirection + articles.length) % articles.length; setPage([newIndex, newDirection]); onActiveIndexChange(newIndex); };
    const activeArticle = articles[page];
    const variants = { enter: (direction: number) => ({ opacity: 0, x: direction > 0 ? 50 : -50, scale: 0.9 }), center: { opacity: 1, x: 0, scale: 1 }, exit: (direction: number) => ({ opacity: 0, x: direction < 0 ? 50 : -50, scale: 0.9 }), };
    return (
        <div className={styles.mobileShowcaseContainer}>
             <AnimatePresence initial={false} custom={direction} mode="wait">
                <motion.div key={page} custom={direction} variants={variants} initial="enter" animate="center" exit="exit" className={styles.mobileShowcaseCardWrapper} transition={{ duration: 0.4, ease: 'easeOut' }} style={{ height: '100%', width: '100%' }}>
                    <ArticleCard article={activeArticle} layoutIdPrefix={"articles-showcase"} isPriority={true} disableLivingEffect={false} />
                </motion.div>
            </AnimatePresence>
            <button className={`${styles.showcaseArrow} ${styles.left}`} onClick={() => paginate(-1)}><ArrowIcon direction="left" /></button>
            <button className={`${styles.showcaseArrow} ${styles.right}`} onClick={() => paginate(1)}><ArrowIcon direction="right" /></button>
        </div>
    );
};

export default function ArticlesPageClient({ featuredArticles, initialGridArticles, allGames, allGameTags, allArticleTypeTags }: {
  featuredArticles: SanityArticle[]; initialGridArticles: SanityArticle[]; allGames: SanityGame[]; allGameTags: SanityTag[]; allArticleTypeTags: SanityTag[];
}) {
    const [activeIndex, setActiveIndex] = useState(0);
    const [isMobile, setIsMobile] = useState(false);
    const { hydrateContent, pageMap, hydrateIndex, appendToSection, contentMap } = useContentStore();
    const storedData = pageMap.get('articles');
    const hasStoredData = storedData && storedData.grid && storedData.grid.length >= initialGridArticles.length;
    const sourceGrid = hasStoredData ? storedData.grid : initialGridArticles;
    const initialOffset = hasStoredData ? storedData.nextOffset : initialGridArticles.length;
    const initialCards = useMemo(() => sourceGrid.map((item: any) => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [sourceGrid]);
    const [allFetchedArticles, setAllFetchedArticles] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    
    if (!hasStoredData) {
        hydrateIndex('articles', { featured: featuredArticles, grid: initialGridArticles, allGames: allGames, allGameTags: allGameTags, allArticleTypeTags: allArticleTypeTags, nextOffset: initialGridArticles.length });
    }

    // Smart Pre-fetch Effect
    useEffect(() => {
        const itemsToFetch = allFetchedArticles.filter(item => !contentMap.get(item.slug)?.contentLoaded).map(item => item.id);
        if (itemsToFetch.length > 0) {
            const prefetch = async () => {
                const fullContent = await batchFetchFullContentAction(itemsToFetch);
                if (fullContent.length > 0) hydrateContent(fullContent);
            };
            const timeoutId = setTimeout(prefetch, 500);
            return () => clearTimeout(timeoutId);
        }
    }, [allFetchedArticles, contentMap, hydrateContent]);

    const [nextOffset, setNextOffset] = useState<number | null>(initialOffset);
    useEffect(() => { const checkMobile = () => setIsMobile(window.innerWidth <= 768); checkMobile(); window.addEventListener('resize', checkMobile); return () => window.removeEventListener('resize', checkMobile); }, []);
    const [searchTerm, setSearchTerm] = useState('');
    const [sortOrder, setSortOrder] = useState<'latest' | 'viral'>('latest');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedGameTags, setSelectedGameTags] = useState<SanityTag[]>([]);
    const [selectedArticleType, setSelectedArticleType] = useState<SanityTag | null>(null);
    
    const gridArticles = useMemo(() => {
        let items = [...allFetchedArticles];
        if (searchTerm) { items = items.filter(article => article.title.toLowerCase().includes(searchTerm.toLowerCase())); }
        if (selectedGame) { items = items.filter(article => article.game === selectedGame.title); }
        const allSelectedTags = [...selectedGameTags, ...(selectedArticleType ? [selectedArticleType] : [])];
        if (allSelectedTags.length > 0) { const selectedTagTitles = new Set(allSelectedTags.map(t => t.title)); items = items.filter(article => article.tags.some(t => selectedTagTitles.has(t.title))); }
        return items;
    }, [allFetchedArticles, searchTerm, selectedGame, selectedGameTags, selectedArticleType]);

    const hasActiveFilters = useMemo(() => !!searchTerm || !!selectedGame || selectedGameTags.length > 0 || !!selectedArticleType || sortOrder !== 'latest', [searchTerm, selectedGame, selectedGameTags, selectedArticleType, sortOrder]);
    const canLoadMore = nextOffset !== null && !hasActiveFilters && !isLoading;

    const handleLoadMore = useCallback(async () => {
        if (!canLoadMore) return;
        setIsLoading(true);
        try {
            const result = await loadMoreArticles({ offset: nextOffset as number, limit: 20, sort: sortOrder });
            const newItems = result.cards.filter((newItem: CardProps) => !allFetchedArticles.some(p => p.id === newItem.id));
            if (newItems.length > 0) {
                hydrateContent(result.fullContent);
                if (result.hubs) hydrateContent(result.hubs);
                appendToSection('articles', result.fullContent, result.nextOffset);
                setAllFetchedArticles(prev => [...prev, ...newItems]);
            }
            setNextOffset(result.nextOffset);
        } catch (error) { console.error("Failed to load more articles:", error); } 
        finally { setIsLoading(false); }
    }, [canLoadMore, nextOffset, sortOrder, allFetchedArticles, hydrateContent, appendToSection]);

    const handleGameTagToggle = (tag: SanityTag) => { setSelectedGameTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]); };
    const handleClearAllFilters = () => { setSelectedGame(null); setSelectedGameTags([]); setSelectedArticleType(null); setSearchTerm(''); setSortOrder('latest'); };
    const featuredForShowcase = useMemo(() => featuredArticles.map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[], [featuredArticles]);
    const activeBackgroundUrl = featuredForShowcase[activeIndex]?.imageUrl;

    return (
        <React.Fragment>
            <div className={styles.articlesPageContainer}>
                <AnimatePresence>
                    {activeBackgroundUrl && (<motion.div key={activeBackgroundUrl} className={styles.articlesPageBg} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><Image loader={sanityLoader} src={activeBackgroundUrl} alt="Dynamic background" fill style={{ objectFit: 'cover' }} /><div className={styles.articlesPageBgOverlay} /></motion.div>)}
                </AnimatePresence>
                <div className="container" style={{ paddingTop: '4rem', paddingBottom: '6rem', minHeight: '80vh' }}>
                    <h1 className="page-title" style={{ color: '#fff', textShadow: '0 3px 15px rgba(0,0,0,0.5)', fontSize: '5rem', marginTop: '0.7rem', marginBottom: '4rem' }}>أحدث المقالات</h1>
                    <div className={styles.showcaseSection}>{isMobile ? (<MobileShowcase articles={featuredForShowcase} onActiveIndexChange={setActiveIndex} />) : (<HorizontalShowcase articles={featuredForShowcase} onActiveIndexChange={setActiveIndex} />)}</div>
                    <div className={styles.gridSection}>
                        <ArticleFilters sortOrder={sortOrder} onSortChange={setSortOrder} searchTerm={searchTerm} onSearchChange={setSearchTerm} allGames={allGames} selectedGame={selectedGame} onGameSelect={setSelectedGame} allGameTags={allGameTags} selectedGameTags={selectedGameTags} onGameTagToggle={handleGameTagToggle} allArticleTypeTags={allArticleTypeTags} selectedArticleType={selectedArticleType} onArticleTypeSelect={setSelectedArticleType} onClearAllFilters={handleClearAllFilters} />
                        <ContentBlock title="كل المقالات" Icon={ArticleIcon}>
                            <div className="content-grid">
                                <AnimatePresence mode="popLayout">
                                    {gridArticles.map((article, index) => (
                                        <motion.div key={article.id} initial={false} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}>
                                            <ArticleCard article={article} layoutIdPrefix="articles-grid" isPriority={index < 3} />
                                        </motion.div>
                                    ))}
                                    {isLoading && (<> <ArticleCardSkeleton variant="no-score" /> <ArticleCardSkeleton variant="no-score" /> </>)}
                                </AnimatePresence>
                            </div>
                            <InfiniteScrollSentinel onIntersect={handleLoadMore} />
                            <AnimatePresence>
                                {(!isLoading && gridArticles.length > 0 && (nextOffset === null || hasActiveFilters)) && (<motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}</motion.p>)}
                            </AnimatePresence>
                            {gridArticles.length === 0 && !isLoading && ( <motion.p key="no-match" style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}> لم نعثر على مقالاتٍ توافقُ مُرادك. </motion.p> )}
                        </ContentBlock>
                    </div>
                </div>
            </div>
        </React.Fragment>
    );
}

--- END OF FILE app/articles/ArticlesPageClient.tsx ---

================================================================================

--- START OF FILE app/articles/page.tsx ---

// app/articles/page.tsx
import React from 'react';
import type { Metadata } from 'next';
import ArticlesPageClient from './ArticlesPageClient';
import { getUniversalBaseData } from '@/app/actions/layoutActions';

export const dynamic = 'force-static';

export const metadata: Metadata = {
  title: 'المقالات',
  description: 'مقالات معمقة، آراء جريئة، وتحليلات شاملة.',
  alternates: { canonical: '/articles' }
};

export default async function ArticlesPage() {
  const data = await getUniversalBaseData();
  const { articles: allArticles, metadata: meta } = data;

  const featuredArticles = allArticles.slice(0, 5);
  // Pass full list to grid for client-side filtering power
  const gridArticles = allArticles;

  if (allArticles.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">أحدث المقالات</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>بلغتَ المنتهى.</p>
        </div>
    );
  }

  return (
    <ArticlesPageClient
      featuredArticles={featuredArticles}
      initialGridArticles={gridArticles}
      allGames={meta?.games || []}
      allGameTags={meta?.gameTags || []}
      allArticleTypeTags={meta?.articleTags || []}
    />
  );
}

--- END OF FILE app/articles/page.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/Scene.tsx ---

// app/celestial-almanac/Scene.tsx

import React, { useRef, useMemo, Suspense, useCallback, useState } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Line, Text } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition, Placement, OrbitalSystemData } from './config';
import { ConstellationSettings } from '@/components/constellation/ConstellationControlPanel';

// Background starfield component (repurposed directly from Constellation)
const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
  const positions = useMemo(() => {
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
      pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
    }
    return pos;
  }, [count, radius]);
  return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
  const ref = useRef<THREE.Group>(null!);
  useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 60; });
  return (
    <group ref={ref}>
      <StarLayer count={Math.floor(1500 * countMultiplier)} radius={8} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
      <StarLayer count={Math.floor(1000 * countMultiplier)} radius={12} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
    </group>
  );
};

// Interactive game release "planet" component
const ReleasePlanet = ({ body, colors, onHover, onClick }: {
  body: OrbitalBodyData, colors: typeof THEME_CONFIG.dark,
  onHover: (body: OrbitalBodyData | null) => void,
  onClick: (body: OrbitalBodyData) => void
}) => {
  const ref = useRef<THREE.Mesh>(null!);
  const [isHovered, setIsHovered] = useState(false);

  useFrame(() => {
    ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.8 : 1), 0.2);
  });

  const handlePointerOver = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation();
    document.body.style.cursor = 'pointer';
    setIsHovered(true);
    onHover(body);
  };

  const handlePointerOut = () => {
    document.body.style.cursor = 'auto';
    setIsHovered(false);
    onHover(null);
  };

  return (
    <mesh ref={ref} position={body.position} onClick={(e) => { e.stopPropagation(); onClick(body); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
      <sphereGeometry args={[0.04, 16, 16]} />
      <meshBasicMaterial color={isHovered ? colors.hoverStarColor : colors.starColor} toneMapped={false} />
    </mesh>
  );
};

// Main Scene Logic
function InteractiveLayer({ orbitalData, themeColors, setActiveStar, settings }: any) {
  const [hoveredBody, setHoveredBody] = useState<OrbitalBodyData | null>(null);
  const { camera, gl } = useThree();

  const handleBodyClick = useCallback((body: OrbitalBodyData) => {
    const canvasRect = gl.domElement.getBoundingClientRect();
    const vec = new THREE.Vector3().copy(body.position);
    vec.project(camera);
    const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
    const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
    const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
    let finalX = x;
    const cardWidth = 300; const padding = 20;
    if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
    if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
    setActiveStar(body, { top: y, left: finalX, placement });
  }, [camera, gl.domElement, setActiveStar]);

  const controlsRef = useRef<any>(null);
  useFrame(() => {
    if (controlsRef.current) {
      controlsRef.current.autoRotate = !hoveredBody;
      controlsRef.current.update();
    }
  });

  const { bloomIntensity } = settings;
  const isBloomEnabled = bloomIntensity > 0;

  return (
    <>
      {isBloomEnabled ? (
        <Selection>
          <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={0}>
            <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
          </EffectComposer>
          <Select enabled>
            <mesh>
              <sphereGeometry args={[0.5, 32, 32]} />
              <meshStandardMaterial color={themeColors.sunColor} emissive={themeColors.sunColor} emissiveIntensity={3} toneMapped={false} />
            </mesh>
          </Select>
        </Selection>
      ) : (
        <mesh>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshBasicMaterial color={themeColors.sunColor} toneMapped={false} />
        </mesh>
      )}

      {orbitalData.map((monthSystem: OrbitalSystemData) => {
        const circlePoints = useMemo(() => {
          const points = [];
          for (let i = 0; i <= 64; i++) {
            const angle = (i / 64) * Math.PI * 2;
            points.push(new THREE.Vector3(Math.cos(angle) * monthSystem.radius, Math.sin(angle) * monthSystem.radius, 0));
          }
          return points;
        }, [monthSystem.radius]);

        return (
          <group key={monthSystem.month}>
            <Line points={circlePoints} color={themeColors.orbitColor} lineWidth={1} />
            <Text
              position={[monthSystem.radius + 0.2, 0, 0]}
              color={themeColors.orbitColor}
              fontSize={0.15}
              anchorX="left"
              anchorY="middle"
            >
              {monthSystem.month}
            </Text>
            {monthSystem.bodies.map(body => (
              <ReleasePlanet key={body.id} body={body} colors={themeColors} onHover={setHoveredBody} onClick={handleBodyClick} />
            ))}
          </group>
        );
      })}

      <OrbitControls
        ref={controlsRef}
        enableZoom
        autoRotate={true}
        autoRotateSpeed={0.1}
        minDistance={3}
        maxDistance={15}
        zoomSpeed={0.5}
        enablePan={false}
      />
    </>
  );
}

// MODIFIED: Added isFeatureLive prop
export const Scene = ({ orbitalData, themeColors, setActiveStar, settings, isFeatureLive }: any) => {
  return (
    <Suspense fallback={null}>
      <color attach="background" args={[themeColors.bgColor]} />
      <ambientLight intensity={0.8} />
      <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
      {/* MODIFIED: Conditionally render the InteractiveLayer */}
      {isFeatureLive && (
        <InteractiveLayer orbitalData={orbitalData} themeColors={themeColors} setActiveStar={setActiveStar} settings={settings} />
      )}
    </Suspense>
  );
};




--- END OF FILE app/celestial-almanac/Scene.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

// app/celestial-almanac/StarPreviewCard.tsx

import React from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { urlFor } from '@/sanity/lib/image';
import { OrbitalBodyData, ScreenPosition } from './config';
import { sanityLoader } from '@/lib/sanity.loader'; // <-- IMPORT ADDED

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
  'PC': PCIcon,
  'PlayStation': PS5Icon,
  'PlayStation 5': PS5Icon, 
  'Xbox': XboxIcon,
  'Switch': SwitchIcon,
};

export const StarPreviewCard = ({ orbitalBody, position, onClose }: {
    orbitalBody: OrbitalBodyData;
    position: ScreenPosition;
    onClose: () => void;
}) => {
  const { content } = orbitalBody;
  const imageUrl = content.mainImage?.asset ? urlFor(content.mainImage).width(600).height(338).fit('crop').auto('format').url() : null;
  const blurDataURL = content.mainImage?.blurDataURL;
  const linkPath = '/games/' + content.slug;

  const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
  const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  const date = new Date(content.releaseDate);
  const day = date.getUTCDate();
  const year = date.getUTCFullYear();
  const monthIndex = date.getUTCMonth();
  const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;

  return (
    <motion.div
      onClick={(e) => e.stopPropagation()}
      initial={{ opacity: 0, scale: 0.9 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.9 }}
      transition={{ type: 'spring', damping: 25, stiffness: 300 }}
      style={{
        position: 'fixed', top: position.top, left: position.left,
        width: '300px',
        background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px',
        boxShadow: '0 10px 30px rgba(0,0,0,0.3)', overflow: 'hidden', zIndex: 10001,
        transform: position.placement === 'below'
          ? 'translate(-50%, 20px)'
          : 'translate(-50%, calc(-100% - 20px))',
        transformOrigin: position.placement === 'below' ? 'top center' : 'bottom center',
      }}
    >
      <motion.button
        onClick={onClose} whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
        style={{
          position: 'absolute', top: '10px', right: '10px', zIndex: 2, width: '32px', height: '32px',
          borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.3)', color: 'white',
          display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
        }} aria-label="إغلاق"
      >
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
      </motion.button>

      <div style={{ position: 'relative', width: '100%', height: '150px' }}>
        {imageUrl ? (
          <Image 
            loader={sanityLoader} // <-- LOADER ADDED
            src={imageUrl} 
            alt={content.title} 
            fill 
            sizes="300px"
            style={{ objectFit: 'cover' }} 
            placeholder={blurDataURL ? 'blur' : 'empty'}
            blurDataURL={blurDataURL || ''}
          />
        ) : (
          <div style={{ width: '100%', height: '100%', backgroundColor: 'var(--border-color)' }} />
        )}
      </div>

      <div style={{ padding: '1.5rem', textAlign: 'right' }}>
        <p style={{ color: 'var(--text-secondary)', fontFamily: 'var(--font-main)', fontSize: '1.3rem', margin: '0 0 0.5rem 0' }}>
          الإصدار:{formattedDate}
        </p>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.7rem' }}>{content.title}</h3>
        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center', marginBottom: '1.5rem', justifyContent: 'flex-end' }}>
          {(content.platforms || []).map(p => {
            const Icon = PlatformIcons[p];
            return Icon ? (
              <div key={p} title={p}>
                <Icon className="platform-icon" />
              </div>
            ) : null;
          })}
        </div>
        <Link href={linkPath} onClick={onClose} className="primary-button no-underline" style={{ display: 'block', textAlign: 'center' }}>
          محور اللعبة
        </Link>
      </div>
    </motion.div>
  );
};




--- END OF FILE app/celestial-almanac/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/config.ts ---

// app/celestial-almanac/config.ts

import * as THREE from 'three';
import type { SanityGameRelease } from '@/types/sanity';

//  Type Definitions adapted for the Almanac
export type ContentObject = SanityGameRelease;

export type OrbitalBodyData = {
  id: string; // Sanity document _id
  position: THREE.Vector3;
  content: ContentObject;
};

export type OrbitalSystemData = {
  month: string;
  radius: number;
  bodies: OrbitalBodyData[];
};

export type Placement = 'above' | 'below';

export type ScreenPosition = {
  top: number;
  left: number;
  placement: Placement;
};

//  Theme-aware Color & Size Mapping (Retained from Constellation)
export const THEME_CONFIG = {
  dark: {
    sunColor: '#00E5FF', // As requested
    orbitColor: 'rgba(255, 255, 255, 0.2)',
    starColor: '#FFFFFF',
    hoverStarColor: '#00E5FF',
    pathColor: '#FFFFFF',
    bgStarColor: '#FFFFFF',
    bgColor: '#0A0B0F',
  },
  light: {
    sunColor: '#0891B2',
    orbitColor: 'rgba(0, 0, 0, 0.15)',
    starColor: '#1F2937',
    hoverStarColor: '#0891B2',
    pathColor: '#1F2937',
    bgStarColor: '#1F2937',
    bgColor: '#F0F2F5',
  },
};


























--- END OF FILE app/celestial-almanac/config.ts ---

================================================================================

--- START OF FILE app/celestial-almanac/index.tsx ---

// app/celestial-almanac/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { useBodyClass } from '@/hooks/useBodyClass';
import * as THREE from 'three';
import { THEME_CONFIG, OrbitalBodyData, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from '@/components/constellation/ConstellationControlPanel';
import type { SanityGameRelease } from '@/types/sanity';
import styles from '@/components/constellation/ConstellationControlPanel.module.css';
import { PerformanceMonitor } from '@react-three/drei'; // <-- IMPORT ADDED

const isFeatureLive = false;

const CelestialGearIcon = () => (
  <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
    <circle cx="12" cy="12" r="8"></circle>
    <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
  </svg>
);

const ComingSoonOverlay = () => {
    return (
        <motion.div
            style={{
                position: 'absolute',
                inset: 0,
                zIndex: 100,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                background: 'radial-gradient(ellipse at center, color-mix(in srgb, var(--bg-primary) 80%, transparent) 0%, color-mix(in srgb, var(--bg-primary) 98%, transparent) 70%)',
                backdropFilter: 'blur(4px)',
                pointerEvents: 'none',
            }}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 1, delay: 0.5, ease: 'easeOut' }}
        >
            <motion.h1
                style={{
                    fontFamily: 'var(--font-main)',
                    fontSize: 'clamp(4rem, 10vw, 8rem)',
                    fontWeight: 800,
                    color: 'var(--text-primary)',
                    textShadow: '0 0 30px var(--border-color)',
                }}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.8, delay: 1, ease: 'easeOut' }}
            >
                قريبا
            </motion.h1>
        </motion.div>
    );
};


export default function CelestialAlmanac({ releases }: { releases: SanityGameRelease[] }) {
  const [isHydrated, setIsHydrated] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  // SMART PERFORMANCE: Start at 1.5, let the monitor adjust up to 2 or down to 0.5
  const [dpr, setDpr] = useState(1.5);

  useEffect(() => { 
      setIsHydrated(true); 
      const checkMobile = () => setIsMobile(window.innerWidth <= 768);
      checkMobile();
      window.addEventListener('resize', checkMobile);
      return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const [isFullscreen, setIsFullscreen] = useState(false);
  
  useBodyClass('constellation-active');
  useBodyClass('fullscreen-active', isFullscreen);

  const { resolvedTheme } = useTheme();
  const [activeBody, setActiveBody] = useState<OrbitalBodyData | null>(null);
  const [activeBodyPosition, setActiveBodyPosition] = useState<ScreenPosition | null>(null);
  const [isPanelOpen, setIsPanelOpen] = useState(false);

  const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
    'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1 },
    'مُتَّزِن': { activePreset: 'مُتَّزِن', starCountMultiplier: 1.0, bloomIntensity: 1.1, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
    'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.8, alwaysShowOrbits: false, flawlessPathThickness: 2.0 },
  }), []);

  const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['مُتَّزِن']);
  const userIntentBloom = useRef(PRESETS['مُتَّزِن'].bloomIntensity);

  useEffect(() => {
    if (resolvedTheme === 'light') {
        if (settings.bloomIntensity > 0) {
            setSettings(s => ({ ...s, bloomIntensity: 0 }));
        }
    } else {
        if (settings.bloomIntensity !== userIntentBloom.current) {
            setSettings(s => ({ ...s, bloomIntensity: userIntentBloom.current }));
        }
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [resolvedTheme]);

  useEffect(() => {
    if (resolvedTheme === 'dark' && settings.activePreset === 'custom') {
        userIntentBloom.current = settings.bloomIntensity;
    }
  }, [settings.bloomIntensity, settings.activePreset, resolvedTheme]);

  const handlePresetChange = (preset: Preset) => {
    let newSettings = { ...PRESETS[preset] };
    userIntentBloom.current = newSettings.bloomIntensity;
    if (resolvedTheme === 'light') {
        newSettings.bloomIntensity = 0;
    }
    setSettings(newSettings);
  };

  const isDark = resolvedTheme === 'dark';
  const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;
  
  const orbitalData = useMemo(() => {
    if (!isHydrated) return [];
    const releasesToUse = releases.length > 0 ? releases : Array.from({ length: 30 }).map((_, i) => ({
        _id: `placeholder-${i}`,
        legacyId: 9000 + i, 
        title: `Upcoming Game ${i + 1}`,
        releaseDate: new Date(2025, Math.floor(i / 3), (i % 28) + 1).toISOString(),
        slug: `upcoming-game-${i+1}`,
        synopsis: 'Details to be revealed soon.',
        platforms: [] as any,
        mainImage: {} as any
    }));
    
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    const releasesByMonth = releasesToUse.reduce((acc, release) => {
        const date = new Date(release.releaseDate);
        const year = date.getUTCFullYear();
        const monthIndex = date.getUTCMonth();
        const monthKey = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;
        
        if (!acc[monthKey]) acc[monthKey] = [];
        acc[monthKey].push(release as SanityGameRelease);
        return acc;
    }, {} as Record<string, SanityGameRelease[]>);
    
    const sortedMonths = Object.keys(releasesByMonth).sort((a, b) => {
        const dateA = new Date(a.split(' - ')[1]);
        const dateB = new Date(b.split(' - ')[1]);
        return dateA.getTime() - dateB.getTime();
    });

    const startRadius = 2; const radiusIncrement = 0.8;
    return sortedMonths.map((month, index) => {
      const monthReleases = releasesByMonth[month]; const radius = startRadius + index * radiusIncrement;
      const bodies = monthReleases.map((release, bodyIndex) => {
        const angle = (bodyIndex / monthReleases.length) * Math.PI * 2;
        const position = new THREE.Vector3( radius * Math.cos(angle), radius * Math.sin(angle), (Math.random() - 0.5) * 0.1 );
        return { id: release._id, position, content: release };
      });
      return { month, radius, bodies };
    });
  }, [isHydrated, releases]);

  const handleSetActiveBody = useCallback((body: OrbitalBodyData, position: ScreenPosition) => { setActiveBody(body); setActiveBodyPosition(position); }, []);
  const handleClosePreview = useCallback(() => { setActiveBody(null); setActiveBodyPosition(null); }, []);

  if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

  return (
    <>
      {isFeatureLive && (
          <AnimatePresence>
            {activeBody && activeBodyPosition && (
              <motion.div style={{ position: 'fixed', inset: 0, zIndex: 10000 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                <StarPreviewCard orbitalBody={activeBody} position={activeBodyPosition} onClose={handleClosePreview} />
              </motion.div>
            )}
            {isPanelOpen && <ConstellationControlPanel settings={settings} setSettings={setSettings} onClose={() => setIsPanelOpen(false)} onPresetChange={handlePresetChange} isFullscreen={isFullscreen} onToggleFullscreen={() => setIsFullscreen(!isFullscreen)} />}
          </AnimatePresence>
      )}

      {/* FIX: Set height to 100vh to fill screen behind transparent navbar */}
      <div style={{ position: 'relative', width: '100%', height: '100vh' }}>
        {isFeatureLive && (
            <motion.button className={styles.settingsButton} onClick={() => setIsPanelOpen(true)} title="فتح إعدادات الفلك" whileHover={{ scale: 1.1, rotate: 90 }} transition={{ type: 'spring', stiffness: 500, damping: 20 }} whileTap={{ scale: 0.9 }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.5 } }}>
                <CelestialGearIcon />
            </motion.button>
        )}
        <Canvas 
            camera={{ position: [0, 0, 8], fov: 60 }}
            dpr={dpr}
        >
          {/* SMART MONITOR: Adjusts resolution based on actual FPS */}
          <PerformanceMonitor onDecline={() => setDpr(1)} onIncline={() => setDpr(2)} />
          <Scene settings={settings} orbitalData={orbitalData} themeColors={themeColors} setActiveStar={handleSetActiveBody} isFeatureLive={isFeatureLive} />
        </Canvas>

        <ComingSoonOverlay />
      </div>
    </>
  );
}

--- END OF FILE app/celestial-almanac/index.tsx ---

================================================================================

--- START OF FILE app/celestial-almanac/page.tsx ---

// app/celestial-almanac/page.tsx
'use client';

import React from 'react';
import SpaceBackground from '@/components/ui/SpaceBackground';
import { motion } from 'framer-motion';

export default function CelestialAlmanacPage() {
  return (
    <div style={{ position: 'relative', width: '100%', height: '100vh', overflow: 'hidden' }}>
      {/* Background Layer */}
      <div style={{ position: 'absolute', inset: 0, zIndex: 0 }}>
        <SpaceBackground />
      </div>

      {/* Content Layer */}
      <div style={{
          position: 'relative',
          zIndex: 10,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          height: '100%',
          textAlign: 'center',
          color: '#fff',
          paddingBottom: '10vh' // Visual balance
      }}>
          <motion.h1 
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8, ease: "easeOut" }}
              style={{
                  fontSize: 'clamp(4rem, 10vw, 8rem)',
                  fontWeight: 900,
                  margin: 0,
                  textShadow: '0 0 40px rgba(0, 255, 240, 0.3)',
                  fontFamily: 'var(--font-heading)'
              }}
          >
              قريباً
          </motion.h1>
          
          <motion.p
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 1, delay: 0.5 }}
              style={{
                  fontSize: '1.8rem',
                  color: 'var(--text-secondary)',
                  marginTop: '2.5rem',
                  fontFamily: 'var(--font-main)'
              }}
          >
              يأتيكم في قادم الأيام...
          </motion.p>
      </div>
    </div>
  );
}

--- END OF FILE app/celestial-almanac/page.tsx ---

================================================================================

--- START OF FILE app/constellation/ConstellationWrapper.tsx ---

// app/constellation/ConstellationWrapper.tsx
'use client';

import dynamic from 'next/dynamic';
import type { SanityContentObject } from '@/components/constellation/config';

type InitialData = {
    userContent: SanityContentObject[];
    commentedSlugs: string[];
    isGuest: boolean;
} | null;

// Move the dynamic import here, inside a "use client" file
const Constellation = dynamic(() => import('@/components/constellation'), {
    ssr: false,
    loading: () => (
        <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <div className="spinner" style={{ width: '60px', height: '60px' }} />
        </div>
    ),
});

export default function ConstellationWrapper({ initialData }: { initialData: InitialData }) {
    return <Constellation initialData={initialData} />;
}




--- END OF FILE app/constellation/ConstellationWrapper.tsx ---

================================================================================

--- START OF FILE app/constellation/page.tsx ---

// app/constellation/page.tsx
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import prisma from '@/lib/prisma';
import { client } from '@/lib/sanity.client';
import { contentByIdsQuery } from '@/lib/sanity.queries';
import { enrichContentList } from '@/lib/enrichment';
import ConstellationWrapper from './ConstellationWrapper';
import type { SanityContentObject } from '@/components/constellation/config';

// Force dynamic rendering because this page relies on user session cookies
export const dynamic = 'force-dynamic';

async function getConstellationData() {
    try {
        const session = await getServerSession(authOptions);
        if (!session?.user?.id) { 
            return null; // Guest user
        }

        const userId = session.user.id;

        const [engagements, shares, comments] = await Promise.all([
            prisma.engagement.findMany({
                where: { userId },
                select: { contentId: true }
            }),
            prisma.share.findMany({
                where: { userId },
                select: { contentId: true }
            }),
            prisma.comment.findMany({
                where: { authorId: userId },
                select: { contentSlug: true },
                distinct: ['contentSlug']
            })
        ]);

        const contentIds = new Set<number>();
        // THE FIX: Added explicit type annotations
        engagements.forEach((e: { contentId: number }) => contentIds.add(e.contentId));
        shares.forEach((s: { contentId: number }) => contentIds.add(s.contentId));
        
        const uniqueIds = Array.from(contentIds);
        
        let userContent: SanityContentObject[] = [];
        if (uniqueIds.length > 0) {
            const rawContent = await client.fetch(contentByIdsQuery, { ids: uniqueIds });
            userContent = (await enrichContentList(rawContent)) as SanityContentObject[];
        }

        return {
            userContent,
            // THE FIX: Added explicit type annotation
            commentedSlugs: comments.map((c: { contentSlug: string }) => c.contentSlug),
            isGuest: false
        };

    } catch (error) {
        console.error("Failed to fetch server-side constellation data:", error);
        return null;
    }
}

export default async function ConstellationPage() {
    const initialData = await getConstellationData();

    return (
        // FIX: Removed padding-top so the 3D scene fills the background behind the transparent navbar
        <div style={{ paddingTop: 0 }}>
            <ConstellationWrapper initialData={initialData} />
        </div>
    );
}

--- END OF FILE app/constellation/page.tsx ---

================================================================================

--- START OF FILE app/creators/[username]/page.tsx ---

// app/creators/[username]/page.tsx
import { client } from '@/lib/sanity.client';
import { allContentByCreatorListQuery } from '@/lib/sanity.queries'; 
import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import Link from 'next/link';
import { cache } from 'react';
import type { Metadata } from 'next';
import { enrichContentList } from '@/lib/enrichment';
import { unstable_cache } from 'next/cache';
import ProfilePageJsonLd from '@/components/seo/ProfilePageJsonLd'; // UPDATED: Specialized Schema
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd'; // ADDED

export const dynamicParams = true;

type Props = {
  params: Promise<{ username: string }>;
};

const getCachedCreatorData = unstable_cache(
    async (username: string) => {
        const user = await prisma.user.findUnique({
            where: { username: username },
            select: { id: true, name: true, username: true, image: true, bio: true, twitterHandle: true, instagramHandle: true }, 
        });
        if (!user) return null;

        const creatorDocs = await client.fetch< { _id: string }[] >(
            `*[_type in ["author", "reviewer", "reporter", "designer"] && prismaUserId == $prismaUserId]{_id}`,
            { prismaUserId: user.id }
        );

        if (!creatorDocs || creatorDocs.length === 0) {
            return { user, items: [] };
        }
        
        const creatorIds = creatorDocs.map(doc => doc._id);
        const allItemsRaw = await client.fetch(allContentByCreatorListQuery, { creatorIds });
        const allItems = await enrichContentList(allItemsRaw);

        return { user, items: allItems };
    },
    ['creator-page-data'],
    { tags: ['content'] }
);

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { username: encodedUsername } = await params;
  const username = decodeURIComponent(encodedUsername);
  
  const data = await getCachedCreatorData(username);
  if (!data || !data.user) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `أعمال ${data.user.name || username}`;
  const description = `استكشف جميع مساهمات ${data.user.name || username} على منصة EternalGames.`;
  const ogImageUrl = data.user.image || `${siteUrl}/og.png`;
  const canonicalUrl = `/creators/${username}`;

  return {
    title,
    description,
    alternates: {
        canonical: canonicalUrl,
    },
    openGraph: {
      title,
      description,
      url: `${siteUrl}${canonicalUrl}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: data.user.name || username }],
      type: 'profile',
    },
  };
}

export const generateStaticParams = cache(async () => {
    try {
        const usersWithUsernames = await prisma.user.findMany({
            where: {
                username: { not: null },
                roles: { some: { name: { in: ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'] } } }
            },
            select: { username: true },
        });

        return usersWithUsernames.map((user: any) => ({
            username: encodeURIComponent(user.username!),
        }));
    } catch (error) {
        return [];
    }
});

export default async function CreatorHubPage({ params }: { params: Promise<{ username: string }> }) {
    const { username: encodedUsername } = await params;
    const username = decodeURIComponent(encodedUsername);

    const data = await getCachedCreatorData(username);

    if (!data || !data.user) {
        notFound();
    }

    const { user, items: allItems } = data;
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
    const profileUrl = `${siteUrl}/creators/${user.username}`;

    const socialLinks = [];
    if (user.twitterHandle) socialLinks.push(`https://twitter.com/${user.twitterHandle}`);
    if (user.instagramHandle) socialLinks.push(`https://instagram.com/${user.instagramHandle}`);

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: 'فريق العمل', item: '#' },
        { name: user.name || username, item: profileUrl }
    ];

    return (
        <>
            <BreadcrumbJsonLd items={breadcrumbItems} />
            <ProfilePageJsonLd 
                name={user.name || username}
                username={user.username || username}
                image={user.image || undefined}
                description={user.bio || `منشئ محتوى في EternalGames`}
                url={profileUrl}
                sameAs={socialLinks}
                mainEntityOfPage={profileUrl}
            />
            
            {!allItems || allItems.length === 0 ? (
                 <div className="container page-container">
                    <h1 className="page-title">{user.name || 'Creator'}</h1>
                    <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُرَ لهذا المستخدمِ أثرٌ بعد.</p>
                    <div style={{textAlign: 'center', marginTop: '2rem'}}>
                        <Link href={`/profile/${user.username}`} className="primary-button" prefetch={false}>ملف المستخدم</Link>
                    </div>
                </div>
            ) : (
                <HubPageClient
                    initialItems={allItems}
                    hubTitle={user.name || 'Creator'}
                    hubType="أعمال"
                    headerAction={
                        <Link 
                            href={`/profile/${user.username}`} 
                            className="outline-button no-underline" 
                            style={{ backgroundColor: 'color-mix(in srgb, var(--bg-secondary) 80%, transparent)', backdropFilter: 'blur(4px)' }} 
                            prefetch={false}
                        >
                            → الملف الشخصي
                        </Link>
                    }
                />
            )}
        </>
    );
}

--- END OF FILE app/creators/[username]/page.tsx ---

================================================================================

--- START OF FILE app/developers/[slug]/page.tsx ---

// app/developers/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { notFound } from 'next/navigation';
import { groq } from 'next-sanity';
import ReleasePageClient from '@/app/releases/ReleasePageClient';
import type { SanityGameRelease } from '@/types/sanity';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd'; // ADDED

export async function generateStaticParams() {
    const developers = await client.fetch<string[]>(`
        *[_type == "developer"].slug.current
    `);
    
    return developers.map(slug => ({ slug }));
}

export const dynamicParams = true;

export default async function DeveloperPage({ params }: { params: Promise<{ slug: string }> }) {
    const { slug } = await params;

    const query = groq`*[_type == "gameRelease" && developer->slug.current == $slug && (isTBA == true || (defined(releaseDate) && releaseDate >= "2023-01-01"))] | order(releaseDate asc) { 
        _id, legacyId, title, releaseDate, isTBA, platforms, synopsis, price, 
        "developer": developer->{title, "slug": slug.current}, 
        "publisher": publisher->{title, "slug": slug.current},
        "mainImage": mainImage{asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt}, 
        "game": game->{ "slug": slug.current }, 
        "slug": game->slug.current, 
        "tags": tags[]->{title, "slug": slug.current} 
    }`;

    const releases: SanityGameRelease[] = await client.fetch(query, { slug });
    
    if (releases.length === 0) {
        notFound();
    }
    
    const studioName = releases[0].developer?.title || "Unknown Studio";

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: 'المطورون', item: '#' }, 
        { name: studioName, item: `/developers/${slug}` }
    ];

    return (
        <>
            <BreadcrumbJsonLd items={breadcrumbItems} />
            <div className="container page-container" style={{ paddingTop: 'calc(var(--nav-height-scrolled) + 2rem)' }}>
                <h1 className="page-title">أعمال الاستوديو: {studioName}</h1>
                <ReleasePageClient releases={releases} hideHeader={true} />
            </div>
        </>
    );
}

--- END OF FILE app/developers/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/feed/[section]/route.ts ---

// app/feed/[section]/route.ts
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';
import { urlFor } from '@/sanity/lib/image';

const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';

const typeMap: Record<string, string> = {
    'reviews': 'review',
    'articles': 'article',
    'news': 'news',
};

const titleMap: Record<string, string> = {
    'reviews': 'مراجعات EternalGames',
    'articles': 'مقالات EternalGames',
    'news': 'أخبار EternalGames',
};

export async function GET(request: Request, { params }: { params: Promise<{ section: string }> }) {
  const { section } = await params;
  const sanityType = typeMap[section];

  if (!sanityType) {
    return new Response('Invalid feed section', { status: 404 });
  }

  const query = groq`
    *[_type == $type && defined(slug.current) && !(_id in path("drafts.**"))] | order(publishedAt desc)[0...50] {
      title,
      "slug": slug.current,
      "description": synopsis,
      publishedAt,
      _type,
      "author": coalesce(authors[0]->name, reporters[0]->name, "EternalGames Team"),
      "mainImage": mainImage.asset->{
        _id,
        url,
        mimeType,
        size
      }
    }
  `;

  // FIX: Tag-based caching
  const posts = await client.fetch(query, { type: sanityType }, { 
      next: { tags: ['content'] } 
  });

  const itemsXml = posts.map((post: any) => {
    const url = `${siteUrl}/${section}/${post.slug}`;
    const date = new Date(post.publishedAt || new Date()).toUTCString();
    
    let mediaXml = '';
    if (post.mainImage?.url) {
        const imageUrl = urlFor(post.mainImage).width(1200).height(800).fit('crop').url();
        const mimeType = post.mainImage.mimeType || 'image/jpeg';
        const size = post.mainImage.size || 0;
        
        mediaXml = `
            <enclosure url="${imageUrl}" length="${size}" type="${mimeType}" />
            <media:content url="${imageUrl}" type="${mimeType}" medium="image" />
        `;
    }

    return `
      <item>
        <title><![CDATA[${post.title}]]></title>
        <link>${url}</link>
        <guid isPermaLink="true">${url}</guid>
        <pubDate>${date}</pubDate>
        <description><![CDATA[${post.description || ''}]]></description>
        <dc:creator><![CDATA[${post.author}]]></dc:creator>
        <category>${section}</category>
        ${mediaXml}
      </item>
    `;
  }).join('');

  const rssFeed = `<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/">
      <channel>
        <title>${titleMap[section]}</title>
        <link>${siteUrl}/${section}</link>
        <description>أحدث ${titleMap[section]} من منصة EternalGames.</description>
        <language>ar</language>
        <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
        <atom:link href="${siteUrl}/feed/${section}" rel="self" type="application/rss+xml" />
        <image>
            <url>${siteUrl}/icon.png</url>
            <title>${titleMap[section]}</title>
            <link>${siteUrl}/${section}</link>
        </image>
        ${itemsXml}
      </channel>
    </rss>`;

  return new Response(rssFeed, {
    headers: {
      'Content-Type': 'text/xml; charset=utf-8',
      'Cache-Control': 'public, max-age=3600',
    },
  });
}

--- END OF FILE app/feed/[section]/route.ts ---

================================================================================

--- START OF FILE app/feed.xml/route.ts ---

// app/feed.xml/route.ts
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';
import { urlFor } from '@/sanity/lib/image';

// OPTIMIZATION: Removed 'export const revalidate'.
// We now rely on the 'content' tag below for infinite caching + on-demand purge.
const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://www.EternalGamesWeb.com';

export async function GET() {
  const query = groq`
    *[_type in ["review", "article", "news"] && defined(slug.current) && !(_id in path("drafts.**"))] | order(publishedAt desc)[0...50] {
      title,
      "slug": slug.current,
      "description": synopsis,
      publishedAt,
      _type,
      "author": coalesce(authors[0]->name, reporters[0]->name, "EternalGames Team"),
      "mainImage": mainImage.asset->{
        _id,
        url,
        mimeType,
        size
      }
    }
  `;

  // FIX: Tag-based caching
  const posts = await client.fetch(query, {}, { 
      next: { tags: ['content'] } 
  });

  const itemsXml = posts.map((post: any) => {
    let section = 'news';
    if (post._type === 'review') section = 'reviews';
    if (post._type === 'article') section = 'articles';

    const url = `${siteUrl}/${section}/${post.slug}`;
    const date = new Date(post.publishedAt || new Date()).toUTCString();
    
    let mediaXml = '';
    if (post.mainImage?.url) {
        const imageUrl = urlFor(post.mainImage).width(1200).height(800).fit('crop').url();
        const mimeType = post.mainImage.mimeType || 'image/jpeg';
        const size = post.mainImage.size || 0;
        
        mediaXml = `
            <enclosure url="${imageUrl}" length="${size}" type="${mimeType}" />
            <media:content url="${imageUrl}" type="${mimeType}" medium="image" />
        `;
    }

    return `
      <item>
        <title><![CDATA[${post.title}]]></title>
        <link>${url}</link>
        <guid isPermaLink="true">${url}</guid>
        <pubDate>${date}</pubDate>
        <description><![CDATA[${post.description || ''}]]></description>
        <dc:creator><![CDATA[${post.author}]]></dc:creator>
        <category>${section}</category>
        ${mediaXml}
      </item>
    `;
  }).join('');

  const rssFeed = `<?xml version="1.0" encoding="UTF-8" ?>
    <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/">
      <channel>
        <title>EternalGames</title>
        <link>${siteUrl}</link>
        <description>حيث لا تُفنى الألعاب - مراجعات، أخبار، ومقالات.</description>
        <language>ar</language>
        <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
        <atom:link href="${siteUrl}/feed.xml" rel="self" type="application/rss+xml" />
        <image>
            <url>${siteUrl}/icon.png</url>
            <title>EternalGames</title>
            <link>${siteUrl}</link>
        </image>
        ${itemsXml}
      </channel>
    </rss>`;

  return new Response(rssFeed, {
    headers: {
      'Content-Type': 'text/xml; charset=utf-8',
      // Browser Cache: 1 hour (Client side only), Server Cache is handled by tags
      'Cache-Control': 'public, max-age=3600',
    },
  });
}

--- END OF FILE app/feed.xml/route.ts ---

================================================================================

--- START OF FILE app/games/[slug]/page.tsx ---

// app/games/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { notFound } from 'next/navigation';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';
import { getCachedGamePageData } from '@/lib/sanity.fetch';
import { enrichContentList } from '@/lib/enrichment';
import { unstable_cache } from 'next/cache';
import { groq } from 'next-sanity';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd';
import VideoGameJsonLd from '@/components/seo/VideoGameJsonLd';
import GameHubClient from '@/components/GameHubClient'; // <--- IMPORTED

export const dynamicParams = true;

type Props = {
  params: Promise<{ slug: string }>;
};

const getEnrichedGameData = unstable_cache(
    async (slug: string) => {
        const data = await getCachedGamePageData(slug);
        if (!data) return null;
        
        const enrichedItems = await enrichContentList(data.items || []);
        
        const releaseQuery = groq`*[_type == "gameRelease" && game->slug.current == $slug][0]{ 
            synopsis,
            price,
            releaseDate,
            "developer": developer->title,
            "publisher": publisher->title,
            platforms,
            "onGamePass": coalesce(onGamePass, false),
            "onPSPlus": coalesce(onPSPlus, false),
            tags[]->{title, "slug": slug.current},
            "releaseImage": mainImage
        }`;
        const releaseData = await client.fetch(releaseQuery, { slug });
        
        return { 
            ...data, 
            items: enrichedItems, 
            releaseTags: releaseData?.tags || [],
            synopsis: releaseData?.synopsis || null,
            releaseDate: releaseData?.releaseDate,
            price: releaseData?.price,
            developer: releaseData?.developer,
            publisher: releaseData?.publisher,
            platforms: releaseData?.platforms,
            onGamePass: releaseData?.onGamePass,
            onPSPlus: releaseData?.onPSPlus,
            mainImage: data.mainImage || releaseData?.releaseImage 
        };
    },
    ['enriched-game-data'],
    { tags: ['game', 'content'] }
);

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { slug } = await params;
  const gameSlug = decodeURIComponent(slug);

  const data = await getEnrichedGameData(gameSlug);

  if (!data) return {}; 
  
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const title = `محور لعبة: ${data.title}`;
  const description = data.synopsis || `استكشف كل المحتوى المتعلق بلعبة ${data.title} على EternalGames.`;
  const ogImageUrl = data.mainImage 
    ? urlFor(data.mainImage).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/games/${gameSlug}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: data.title }],
    },
  };
}

export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "game" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            slug,
        }));
    } catch (error) {
        return [];
    }
}

export default async function GameHubPage({ params }: { params: Promise<{ slug: string }> }) {
    const { slug } = await params;
    const gameSlug = decodeURIComponent(slug);

    const data = await getEnrichedGameData(gameSlug);

    if (!data) {
        notFound();
    }

    const { title: gameTitle, items: allItems, synopsis, releaseTags, mainImage, price, developer, publisher, platforms, onGamePass, onPSPlus, releaseDate } = data;

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: 'الألعاب', item: '/releases' },
        { name: gameTitle, item: `/games/${gameSlug}` }
    ];

    const genreNames = releaseTags.map((t: any) => t.title);
    const imageUrl = mainImage ? urlFor(mainImage).width(800).url() : undefined;

    return (
        <>
            <BreadcrumbJsonLd items={breadcrumbItems} />
            <VideoGameJsonLd 
                name={gameTitle}
                description={synopsis || `Game Hub for ${gameTitle}`}
                image={imageUrl}
                releaseDate={releaseDate}
                genre={genreNames}
                platforms={platforms}
                developer={developer}
                publisher={publisher}
            />
            <GameHubClient
                gameTitle={gameTitle}
                items={allItems}
                synopsis={synopsis}
                releaseTags={releaseTags}
                mainImage={mainImage}
                price={price}
                developer={developer}
                publisher={publisher}
                platforms={platforms}
                onGamePass={onGamePass}
                onPSPlus={onPSPlus}
            />
        </>
    );
}

--- END OF FILE app/games/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/lib/authOptions.ts ---

// app/lib/authOptions.ts

import { PrismaAdapter } from "@next-auth/prisma-adapter";
import prisma from "@/lib/prisma";
import bcrypt from "bcryptjs";
import GithubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import TwitterProvider from "next-auth/providers/twitter";
import CredentialsProvider from "next-auth/providers/credentials";

export const authOptions = {
    adapter: PrismaAdapter(prisma as any),
    providers: [
        CredentialsProvider({
            id: 'credentials',
            name: "Credentials",
            credentials: {
                email: { label: "البريد", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) throw new Error("البياناتُ ناقصة.");
                // MODIFIED: Normalize email to lowercase before database query
                const user = await prisma.user.findUnique({ where: { email: credentials.email.toLowerCase() } });
                if (!user) throw new Error("لا حساب بهذا البريد. تفضل بالتسجيل.");
                if (!user.password) throw new Error("هذا الحساب مربوط بمزود خارجي.");
                const isPasswordValid = await bcrypt.compare(credentials.password, user.password);
                if (isPasswordValid) return user;
                else throw new Error("كلمة السر خاطئة.");
            }
        }),
        CredentialsProvider({
            id: 'signup',
            name: "SignUp",
            credentials: {
                email: { label: "البريد", type: "email" },
                password: { label: "كلمة السر", type: "password" },
                returnTo: { label: "Return To", type: "text" },
            },
            async authorize(credentials) {
                if (!credentials) throw new Error("تفاصيل التسجيل ناقصة.");
                // MODIFIED: Normalize email to lowercase
                const { email, password } = credentials;
                const lowercasedEmail = email.toLowerCase();

                if (!lowercasedEmail || !password) throw new Error("الحقولُ كلُّها لازمة.");
                if (!/\S+@\S+\.\S+/.test(lowercasedEmail)) throw new Error('البريد الإلكتروني غير صالح.');
                if (password.length < 8) throw new Error('كلمة السر لا تقل عن ثمانيةِ حروف.');
                
                const existingEmail = await prisma.user.findUnique({ where: { email: lowercasedEmail } });
                if (existingEmail) throw new Error('بريدٌ مسجل.');

                const hashedPassword = await bcrypt.hash(credentials.password, 10);
                const newUser = await prisma.user.create({
                    data: {
                        email: lowercasedEmail, // MODIFIED: Store lowercase email
                        password: hashedPassword,
                    }
                });
                return newUser;
            }
        }),
        GithubProvider({ 
            clientId: process.env.AUTH_GITHUB_ID as string, 
            clientSecret: process.env.AUTH_GITHUB_SECRET as string, 
        }),
        GoogleProvider({ 
            clientId: process.env.GOOGLE_CLIENT_ID as string, 
            clientSecret: process.env.GOOGLE_CLIENT_SECRET as string, 
        }),
        TwitterProvider({ 
            clientId: process.env.TWITTER_CLIENT_ID as string, 
            clientSecret: process.env.TWITTER_CLIENT_SECRET as string, 
            version: "2.0", 
        }),
    ],
    events: {
        createUser: async ({ user }: any) => {
            const userRole = await prisma.role.findUnique({ where: { name: 'USER' } });
            if (userRole) {
                await prisma.user.update({ 
                    where: { id: user.id }, 
                    data: { 
                        roles: { connect: { id: userRole.id } },
                        // MODIFIED: Ensure email is lowercase on creation from any provider
                        email: user.email ? user.email.toLowerCase() : null
                    } 
                });
            }
        }
    },
    session: { strategy: "jwt" as const },
    secret: process.env.NEXTAUTH_SECRET,
    callbacks: {
        async signIn({ user }: any) {
            return true;
        },
        async jwt({ token, user, trigger }: any) {
            if (user || trigger === "update") {
                const dbUser = await prisma.user.findUnique({
                    where: { id: (token.id as string) || user?.id },
                    include: { roles: true }
                });

                if (dbUser) {
                    token.id = dbUser.id;
                    token.picture = dbUser.image;
                    token.name = dbUser.name;
                    token.roles = dbUser.roles.map((role: any) => role.name);
                    token.username = dbUser.username;
                    token.needsOnboarding = !dbUser.name || !dbUser.username;
                }
            }
            return token;
        },
        async session({ session, token }: any) {
            if (token && session.user) {
                session.user.id = token.id;
                session.user.roles = token.roles;
                session.user.name = token.name;
                session.user.email = token.email;
                session.user.image = token.picture;
                session.user.username = token.username;
                session.needsOnboarding = token.needsOnboarding;
            }
            return session;
        },
    },
    pages: { signIn: '/', error: '/', },
};




--- END OF FILE app/lib/authOptions.ts ---

================================================================================

--- START OF FILE app/news/NewsPage.module.css ---

/* app/news/NewsPage.module.css */
.newsPageContainer {
    position: relative;
    padding-top: var(--nav-height-scrolled);
}

.heroSection {
    margin-bottom: 6rem;
}

.gridSection {
    padding-top: 4rem;
}

.loadingSpinner {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 4rem 0;
    color: var(--accent);
}

.endOfFeedMessage {
    text-align: center;
    padding: 3rem 0;
    color: var(--text-secondary);
    font-size: 1.6rem;
    font-style: italic;
    opacity: 0.7;
}







--- END OF FILE app/news/NewsPage.module.css ---

================================================================================

--- START OF FILE app/news/NewsPageClient.tsx ---

// app/news/NewsPageClient.tsx
'use client';

import { useState, useMemo, useCallback, useEffect } from 'react';
import type { SanityNews, SanityGame, SanityTag } from '@/types/sanity';
import { motion, AnimatePresence } from 'framer-motion';
import NewsHero from '@/components/news/NewsHero';
import NewsFilters from '@/components/filters/NewsFilters';
import NewsGrid from '@/components/news/NewsGrid';
import { ContentBlock } from '@/components/ContentBlock';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from './NewsPage.module.css';
import { NewsIcon } from '@/components/icons';
import InfiniteScrollSentinel from '@/components/ui/InfiniteScrollSentinel';
import NewsItemSkeleton from '@/components/ui/NewsItemSkeleton';
import { useContentStore } from '@/lib/contentStore';
import { loadMoreNews, batchFetchFullContentAction } from '@/app/actions/batchActions';

export default function NewsPageClient({ heroArticles, initialGridArticles, allGames, allTags }: { heroArticles: SanityNews[]; initialGridArticles: SanityNews[]; allGames: SanityGame[]; allTags: SanityTag[]; }) {
    const { hydrateContent, pageMap, hydrateIndex, appendToSection, contentMap } = useContentStore();

    const storedData = pageMap.get('news');
    const hasStoredData = storedData && storedData.grid && storedData.grid.length >= initialGridArticles.length;
    const sourceGrid = hasStoredData ? storedData.grid : initialGridArticles;
    const initialOffset = hasStoredData ? storedData.nextOffset : initialGridArticles.length;
    const adaptedHeroArticles = useMemo(() => heroArticles.map(item => adaptToCardProps(item, { width: 800 })).filter(Boolean) as CardProps[], [heroArticles]);
    const initialCards = useMemo(() => sourceGrid.map((item: any) => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [sourceGrid]);
    const [allFetchedNews, setAllFetchedNews] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    
    if (!hasStoredData) {
        hydrateIndex('news', { hero: heroArticles, grid: initialGridArticles, allGames: allGames, allTags: allTags, nextOffset: initialGridArticles.length });
    }
    
    // Smart Pre-fetch Effect
    useEffect(() => {
        const itemsToFetch = allFetchedNews.filter(item => !contentMap.get(item.slug)?.contentLoaded).map(item => item.id);
        if (itemsToFetch.length > 0) {
            const prefetch = async () => {
                const fullContent = await batchFetchFullContentAction(itemsToFetch);
                if (fullContent.length > 0) hydrateContent(fullContent);
            };
            const timeoutId = setTimeout(prefetch, 500);
            return () => clearTimeout(timeoutId);
        }
    }, [allFetchedNews, contentMap, hydrateContent]);
    
    const [nextOffset, setNextOffset] = useState<number | null>(initialOffset);
    const [searchTerm, setSearchTerm] = useState('');
    const [activeSort, setActiveSort] = useState<'latest' | 'viral'>('latest');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedTags, setSelectedTags] = useState<SanityTag[]>([]);
    
    const newsItems = useMemo(() => {
        let items = [...allFetchedNews];
        if (searchTerm) items = items.filter(news => news.title.toLowerCase().includes(searchTerm.toLowerCase()));
        if (selectedGame) items = items.filter(news => news.game === selectedGame.title);
        if (selectedTags.length > 0) {
            const selectedTagTitles = new Set(selectedTags.map(t => t.title));
            items = items.filter(news => news.tags.some(t => selectedTagTitles.has(t.title)));
        }
        return items;
    }, [allFetchedNews, searchTerm, selectedGame, selectedTags]);

    const hasActiveFilters = useMemo(() => !!searchTerm || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest', [searchTerm, selectedGame, selectedTags, activeSort]);
    const canLoadMore = nextOffset !== null && !hasActiveFilters && !isLoading;

    const handleLoadMore = useCallback(async () => {
        if (!canLoadMore) return;
        setIsLoading(true);
        try {
            const result = await loadMoreNews({ offset: nextOffset as number, limit: 50, sort: activeSort });
            const newItems = result.cards.filter((newItem: CardProps) => !allFetchedNews.some(p => p.id === newItem.id));
            if (newItems.length > 0) {
                 hydrateContent(result.fullContent);
                 if (result.hubs) hydrateContent(result.hubs);
                 appendToSection('news', result.fullContent, result.nextOffset);
                 setAllFetchedNews(prev => [...prev, ...newItems]);
            }
            setNextOffset(result.nextOffset);
        } catch (error) { console.error("Failed to load more news:", error); } 
        finally { setIsLoading(false); }
    }, [canLoadMore, nextOffset, activeSort, allFetchedNews, hydrateContent, appendToSection]);

    const handleTagToggle = (tag: SanityTag) => { setSelectedTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]); };
    const handleClearAll = () => { setSearchTerm(''); setSelectedGame(null); setSelectedTags([]); setActiveSort('latest'); };

    return (
        <div style={{ paddingBottom: '6rem' }}>
            <NewsHero newsItems={adaptedHeroArticles} />
            <div className="container">
                <NewsFilters activeSort={activeSort} onSortChange={setActiveSort} searchTerm={searchTerm} onSearchChange={setSearchTerm} allGames={allGames} selectedGame={selectedGame} onGameSelect={setSelectedGame} allTags={allTags} selectedTags={selectedTags} onTagToggle={handleTagToggle} onClearAll={handleClearAll} />
                <ContentBlock title="كل الأخبار" Icon={NewsIcon}>
                    <NewsGrid news={newsItems} />
                    <InfiniteScrollSentinel onIntersect={handleLoadMore} />
                    <AnimatePresence>
                        {isLoading && (<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3rem', marginTop: '3rem' }}><motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><NewsItemSkeleton /></motion.div><motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><NewsItemSkeleton /></motion.div></div>)}
                    </AnimatePresence>
                    <AnimatePresence>
                        {(!isLoading && newsItems.length > 0 && (nextOffset === null || hasActiveFilters)) && (<motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}</motion.p>)}
                    </AnimatePresence>
                    {newsItems.length === 0 && !isLoading && (<motion.p key="no-match" style={{textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}>لا أنباءَ توافقُ ما اخترت.</motion.p>)}
                </ContentBlock>
            </div>
        </div>
    );
}

--- END OF FILE app/news/NewsPageClient.tsx ---

================================================================================

--- START OF FILE app/news/page.tsx ---

// app/news/page.tsx
import React from 'react';
import type { Metadata } from 'next';
import NewsPageClient from './NewsPageClient';
import { getUniversalBaseData } from '@/app/actions/layoutActions';

export const dynamic = 'force-static';

export const metadata: Metadata = {
  title: 'الأخبار',
  description: 'تغطية شاملة وموجزة لآخر أخبار صناعة الألعاب.',
  alternates: { canonical: '/news' }
};

export default async function NewsPage() {
  const data = await getUniversalBaseData();
  const { news: allNews, metadata: meta } = data;

  const heroNews = allNews.slice(0, 4);
  const gridNews = allNews;

  if (allNews.length === 0) {
    return (
        <div className="container page-container">
            <h1 className="page-title">موجز الأنباء</h1>
            <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لا أنباءَ تُذكَر.</p>
        </div>
    );
  }

  return (
    <NewsPageClient
      heroArticles={heroNews}
      initialGridArticles={gridNews}
      allGames={meta?.games || []}
      allTags={meta?.newsTags || []}
    />
  );
}

--- END OF FILE app/news/page.tsx ---

================================================================================

--- START OF FILE app/privacy-policy/page.tsx ---

// app/privacy-policy/page.tsx
import { Metadata } from 'next';
import { ContentBlock } from '@/components/ContentBlock';

export const metadata: Metadata = {
    title: 'سياسة الخصوصية',
    description: 'سياسة الخصوصية لمنصة EternalGames.',
};

export default function PrivacyPolicyPage() {
    return (
        <div className="container page-container">
            <h1 className="page-title">سياسة الخصوصية</h1>
            
            <ContentBlock title="مقدمة">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    في EternalGames، نولي خصوصيتك أهمية قصوى. تشرح هذه الوثيقة ما هي المعلومات التي نجمعها، وكيف نستخدمها، وكيف نحميها. باستخدامك للموقع، فإنك توافق على الممارسات الموضحة في هذه السياسة.
                </p>
            </ContentBlock>

            <ContentBlock title="البيانات التي نجمعها">
                <ul style={{ listStyle: 'disc', paddingRight: '2rem', fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    <li style={{ marginBottom: '1rem' }}><strong>معلومات الحساب:</strong> عند التسجيل، نجمع اسمك، بريدك الإلكتروني، وصورتك الرمزية (عبر Google/GitHub أو مباشرة).</li>
                    <li style={{ marginBottom: '1rem' }}><strong>بيانات التفاعل:</strong> تعليقاتك، تقييماتك، والمحتوى الذي تحفظه في المفضلة.</li>
                    <li style={{ marginBottom: '1rem' }}><strong>البيانات التقنية:</strong> عنوان IP (لأغراض الأمان ومنع الاحتيال)، ونوع المتصفح والجهاز لتحسين الأداء.</li>
                </ul>
            </ContentBlock>

            <ContentBlock title="كيف نستخدم بياناتك">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    لا نقوم ببيع بياناتك لأي طرف ثالث. تُستخدم البيانات حصراً لـ:
                </p>
                <ul style={{ listStyle: 'disc', paddingRight: '2rem', fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8, marginTop: '1rem' }}>
                    <li>تخصيص تجربتك (مثل "كوكبة" الاهتمامات).</li>
                    <li>إرسال إشعارات حول الردود على تعليقاتك (يمكنك تعطيلها).</li>
                    <li>حماية المنصة من المحتوى العشوائي (Spam).</li>
                </ul>
            </ContentBlock>
            
            <ContentBlock title="ملفات تعريف الارتباط (Cookies)">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    نستخدم ملفات تعريف الارتباط الضرورية لتسجيل الدخول وحفظ تفضيلاتك (مثل الوضع الليلي). كما نستخدم أدوات تحليلية (مثل Google Analytics) لفهم كيفية استخدام الموقع بشكل مجهول الهوية.
                </p>
            </ContentBlock>
        </div>
    );
}

--- END OF FILE app/privacy-policy/page.tsx ---

================================================================================

--- START OF FILE app/profile/ProfilePage.module.css ---

/* app/profile/ProfilePage.module.css */
.profileGrid{display:grid;grid-template-columns:1fr;gap:5rem}
@media (min-width:1024px){.profileGrid{grid-template-columns:300px 1fr}}
.profileAvatar{border-radius:50%;border:4px solid var(--border-color);margin:0 auto 2rem;transition:all .3s ease-out}
@media (hover: hover) {@media (hover: hover) {
  
  .profileAvatar:hover  {transform:scale(1.05);filter:drop-shadow(0 0 20px color-mix(in srgb,var(--accent) 50%,transparent))}
}

  .profileAvatar:active  {transform:scale(1.05);filter:drop-shadow(0 0 20px color-mix(in srgb,var(--accent) 50%,transparent))}
}
.profileAvatar:active {transform:scale(1.05);filter:drop-shadow(0 0 20px color-mix(in srgb,var(--accent) 50%,transparent))}

.profileName{font-size:3.2rem;font-family:var(--font-main);margin:0;text-align:center}
.profileMeta{font-size:1.6rem;color:var(--text-secondary);margin-top:.5rem;text-align:center}
.profileMain{border-top:1px solid var(--border-color);padding-top:5rem}
@media (min-width:1024px){.profileMain{border-top:none;padding-top:0;border-right:1px solid var(--border-color);border-left: none; padding-right:5rem; padding-left: 0;}}
.profileSection{margin-top:6rem}
.profileSection:first-child{margin-top:0}

/* REMOVED: Boxy styling */
.profileSectionTitle{
    font-size:2.8rem;
    font-family:var(--font-main);
    margin-bottom:2rem;
    /* REMOVED border-bottom:2px solid var(--accent); */
    /* REMOVED padding-bottom:1rem; */
    /* REMOVED display:inline-block; */
    /* REMOVED box-shadow: ... */
    color: var(--text-primary);
    transition: color 0.3s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .profileSectionTitle:hover  {
    color: var(--accent);
}
}

  .profileSectionTitle:active  {
    color: var(--accent);
}
}
.profileSectionTitle:active {
    color: var(--accent);
}

.badgeGrid{display:flex;flex-wrap:wrap;gap:1.5rem}
.badgeItem{display:flex;align-items:center;gap:1rem;background-color:var(--bg-secondary);padding:1rem 1.5rem;border-radius:8px;border:1px solid var(--border-color);transition:all .2s ease-out}
@media (hover: hover) {@media (hover: hover) {
  
  .badgeItem:hover  {transform:translateY(-2px);border-color:var(--accent)}
}

  .badgeItem:active  {transform:translateY(-2px);border-color:var(--accent)}
}
.badgeItem:active {transform:translateY(-2px);border-color:var(--accent)}

.badgeIcon{width:20px;height:20px;color:var(--accent)}
@keyframes glint{0%,100%{transform:scale(1)}50%{transform:scale(1.2) rotate(10deg);filter:brightness(1.5)}}
@media (hover: hover) {@media (hover: hover) {
  
  .badgeItem:hover .badgeIconFOUNDER  {animation:glint .7s ease-in-out}
}

  .badgeItem:active .badgeIconFOUNDER  {animation:glint .7s ease-in-out}
}
.badgeItem:active .badgeIconFOUNDER {animation:glint .7s ease-in-out}


@media (max-width: 768px) {
  .profileSidebar {
    padding-top: 8rem; /* Nudge the content down on mobile to avoid navbar overlap */
  }
}




--- END OF FILE app/profile/ProfilePage.module.css ---

================================================================================

--- START OF FILE app/profile/page.tsx ---

// app/profile/page.tsx
export const maxDuration = 60;
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import ProfileEditForm from '@/components/ProfileEditForm';
import PasswordChangeForm from '@/components/PasswordChangeForm';
import { ContentBlock } from '@/components/ContentBlock';

export default async function ProfilePage() {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) { redirect('/api/auth/signin'); }
    
    // Fetch user and check if they have a password set (i.e., not an OAuth user)
    // Also fetching roles to check for DIRECTOR privilege
    const user = await prisma.user.findUnique({ 
        where: { id: session.user.id }, 
        select: { 
            password: true, 
            id: true, 
            name: true, 
            email: true, 
            username: true, 
            image: true, 
            createdAt: true, 
            bio: true, 
            twitterHandle: true, 
            instagramHandle: true, 
            age: true, 
            country: true, 
            agePublic: true, 
            countryPublic: true, 
            emailVerified: true,
            roles: { select: { name: true } }
        }
    });

    if (!user) { redirect('/api/auth/signin'); }

    const hasPasswordAuth = !!user.password;
    const isDirector = user.roles.some((r: any) => r.name === 'DIRECTOR');

    return (
        <div className="container page-container">
            <h1 className="page-title">إعدادات الحساب</h1>
            <ContentBlock title="تحرير البيانات">
                <ProfileEditForm user={user} />
            </ContentBlock>
            
            {hasPasswordAuth && (
                <ContentBlock title="تغيير كلمة السر">
                    <PasswordChangeForm canSkipCurrentPassword={isDirector} />
                </ContentBlock>
            )}
        </div>
    );
}

--- END OF FILE app/profile/page.tsx ---

================================================================================

--- START OF FILE app/profile/bookmarks/page.tsx ---

// app/profile/bookmarks/page.tsx
import BookmarksGrid from "@/components/BookmarksGrid";
import { getAuthenticatedSession } from "@/lib/auth";
import { client } from "@/lib/sanity.client";
import { contentByIdsQuery } from "@/lib/sanity.queries";
import prisma from "@/lib/prisma";
import { redirect } from "next/navigation";
import { enrichContentList } from "@/lib/enrichment"; // <-- ADDED

async function getBookmarkedContent() {
    let session;
    try {
        session = await getAuthenticatedSession();
    } catch (error) {
        redirect('/api/auth/signin');
    }

    try {
        const bookmarks = await prisma.engagement.findMany({
            where: { userId: session.user.id, type: 'BOOKMARK' },
            select: { contentId: true },
            orderBy: { createdAt: 'desc' }
        });
        
        const ids = bookmarks.map((b: any) => b.contentId);
        if (ids.length === 0) return [];
        
        const contentRaw = await client.fetch(contentByIdsQuery, { ids });
        // THE FIX: Enrich data server-side before returning
        const content = await enrichContentList(contentRaw);
        
        return content;
    } catch (error) {
        console.error("Failed to fetch bookmarked content:", error);
        return []; 
    }
}

export default async function BookmarksPage() {
    const bookmarkedItems = await getBookmarkedContent();

    return (
        <div className="container page-container">
            <h1 className="page-title">محفوظاتك</h1>
            <BookmarksGrid initialItems={bookmarkedItems} />
        </div>
    );
}




--- END OF FILE app/profile/bookmarks/page.tsx ---

================================================================================

--- START OF FILE app/profile/[username]/page.tsx ---

// app/profile/[username]/page.tsx

import prisma from '@/lib/prisma';
import { notFound } from 'next/navigation';
import Image from 'next/image';
import { getBadgesForUser } from '@/lib/badges';
import Link from 'next/link';
import styles from '../ProfilePage.module.css';
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

function hasCreatorRole(userRoles: string[]): boolean {
    return userRoles.some(role => ['REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
}

export default async function PublicProfilePage({ params: paramsPromise }: { params: Promise<{ username: string }> }) {
    const { username: encodedUsername } = await paramsPromise;
    const username = decodeURIComponent(encodedUsername);

    const user = await prisma.user.findUnique({
        where: { username: username },
        include: {
            roles: { select: { name: true } },
            _count: { select: { comments: true } },
            comments: { orderBy: { createdAt: 'desc' }, take: 5 },
        },
    });

    if (!user) { notFound(); }
    
    let contentData: { slug: string, title: string, _type: string }[] = [];
    
    const commentSlugs = user.comments.map((c: any) => c.contentSlug);
    
    if (commentSlugs.length > 0) {
        contentData = await client.fetch(
            groq`*[_type in ["review", "article", "news"] && slug.current in $slugs]{ "slug": slug.current, title, _type }`,
            { slugs: commentSlugs }
        );
    }
    
    const contentMap = new Map(contentData.map(item => [item.slug, { title: item.title, type: item._type }]));

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const joinDate = new Date(user.createdAt);
    const year = joinDate.getFullYear();
    const monthIndex = joinDate.getMonth();
    const formattedJoinDate = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]} ${year}`;


    const userRoles = user.roles.map((r: any) => r.name);
    const earnedBadges = getBadgesForUser({ createdAt: user.createdAt, _count: user._count, roles: userRoles });
    const avatarSrc = user.image || '/default-avatar.svg';

    return (
        <div className="container page-container">
            <div className={styles.profileGrid}>
                <aside className={styles.profileSidebar}>
                    <Image src={avatarSrc} alt={user.name || 'صورة المستخدم'} width={150} height={150} className={styles.profileAvatar} priority />
                    <h1 className={styles.profileName}>{user.name}</h1>
                    {user.username && <p className={styles.profileMeta} style={{color: 'var(--accent)'}}>@{user.username}</p>}
                    <p className={styles.profileMeta}>عضوٌ منذ {formattedJoinDate}</p>
                    
                    {user.username && hasCreatorRole(userRoles) && (
                         <Link 
                            href={`/creators/${user.username}`} 
                            className="primary-button" 
                            style={{marginTop: '2rem', display: 'block', textAlign: 'center'}}
                            prefetch={false} // FIX: Disable prefetch here as well
                        >
                            عرض كل الأعمال
                        </Link>
                    )}
                </aside>

                <main className={styles.profileMain}>
                    {user.bio && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>عن</h2> <p style={{ fontSize: '1.8rem', lineHeight: 1.7 }}>{user.bio}</p> </section> )}
                    {earnedBadges.length > 0 && ( <section className={styles.profileSection}> <h2 className={styles.profileSectionTitle}>الأوسمة</h2> <div className={styles.badgeGrid}> {earnedBadges.map(badge => ( <div key={badge.id} title={badge.description} className={styles.badgeItem}> <badge.Icon className={`${styles.badgeIcon} ${styles[`badgeIcon${badge.id}`]}`} /> <span>{badge.name}</span> </div> ))} </div> </section> )}
                    <section className={styles.profileSection}>
                        <h2 className={styles.profileSectionTitle}>آخرُ نشاط</h2>
                        {user.comments.length > 0 ? (
                            <ul style={{listStyle: 'none', padding: 0, display: 'flex', flexDirection: 'column', gap: '2rem'}}>
                                {user.comments.map((comment: any) => {
                                    const contentInfo = contentMap.get(comment.contentSlug);
                                    const contentTitle = contentInfo?.title || 'تعليقٌ لم يعد متاحًا';
                                    
                                    let pathSection = 'news';
                                    if (contentInfo) {
                                        if (contentInfo.type === 'review') pathSection = 'reviews';
                                        else if (contentInfo.type === 'article') pathSection = 'articles';
                                        else if (contentInfo.type === 'news') pathSection = 'news';
                                    } else {
                                        if (comment.contentSlug.startsWith('review-')) pathSection = 'reviews';
                                        else if (comment.contentSlug.startsWith('article-')) pathSection = 'articles';
                                    }

                                    const linkHref = `/${pathSection}/${comment.contentSlug}`;

                                    return (
                                        <li key={comment.id}>
                                            <p style={{margin: '0 0 0.5rem 0'}}>
                                                علّق على 
                                                {/* FIX: Disable prefetch on content links in history */}
                                                <Link href={linkHref} className="creator-credit-link" prefetch={false}>
                                                    {contentTitle}
                                                </Link>
                                            </p>
                                            <blockquote style={{margin: 0, padding: '1rem', background: 'var(--bg-secondary)', borderRight: '3px solid var(--border-color)', borderLeft: 'none', borderRadius: '4px'}}>
                                                &quot;{comment.content.slice(0, 150)}{comment.content.length > 150 ? '...' : ''}&quot;
                                            </blockquote>
                                        </li>
                                    );
                                })}
                            </ul>
                        ) : ( <p>{user.name} لم يخطَّ تعليقًا بعد.</p> )}
                    </section>
                </main>
            </div>
        </div>
    );
}




--- END OF FILE app/profile/[username]/page.tsx ---

================================================================================

--- START OF FILE app/publishers/[slug]/page.tsx ---

// app/publishers/[slug]/page.tsx
import { client } from '@/lib/sanity.client';
import { notFound } from 'next/navigation';
import { groq } from 'next-sanity';
import ReleasePageClient from '@/app/releases/ReleasePageClient';
import type { SanityGameRelease } from '@/types/sanity';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd'; // ADDED

export async function generateStaticParams() {
    const publishers = await client.fetch<string[]>(`
        *[_type == "publisher"].slug.current
    `);
    
    return publishers.map(slug => ({ slug }));
}

export const dynamicParams = true;

export default async function PublisherPage({ params }: { params: Promise<{ slug: string }> }) {
    const { slug } = await params;

    const query = groq`*[_type == "gameRelease" && publisher->slug.current == $slug && (isTBA == true || (defined(releaseDate) && releaseDate >= "2023-01-01"))] | order(releaseDate asc) { 
        _id, legacyId, title, releaseDate, isTBA, platforms, synopsis, price, 
        "developer": developer->{title, "slug": slug.current}, 
        "publisher": publisher->{title, "slug": slug.current},
        "mainImage": mainImage{asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt}, 
        "game": game->{ "slug": slug.current }, 
        "slug": game->slug.current, 
        "tags": tags[]->{title, "slug": slug.current} 
    }`;

    const releases: SanityGameRelease[] = await client.fetch(query, { slug });
    
    if (releases.length === 0) {
        notFound();
    }
    
    const publisherName = releases[0].publisher?.title || "Unknown Publisher";

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: 'الناشرون', item: '#' },
        { name: publisherName, item: `/publishers/${slug}` }
    ];

    return (
        <>
            <BreadcrumbJsonLd items={breadcrumbItems} />
            <div className="container page-container" style={{ paddingTop: 'calc(var(--nav-height-scrolled) + 2rem)' }}>
                <h1 className="page-title">أعمال الناشر: {publisherName}</h1>
                <ReleasePageClient releases={releases} hideHeader={true} />
            </div>
        </>
    );
}

--- END OF FILE app/publishers/[slug]/page.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasePageClient.tsx ---

// app/releases/ReleasePageClient.tsx
'use client';

import { useState, useMemo, useRef } from 'react';
import type { SanityGameRelease } from '@/types/sanity';
import TimelineCard from '@/components/TimelineCard';
import { motion, useInView, AnimatePresence } from 'framer-motion';
import styles from './ReleasesPage.module.css';
import ReleasesControlBar from '@/components/releases/ReleasesControlBar';
import PinnedReleases from '@/components/releases/PinnedReleases';
import { useUserStore } from '@/lib/store';
import { useSession } from 'next-auth/react';

export default function ReleasePageClient({ releases, hideHeader = false }: { releases: SanityGameRelease[], hideHeader?: boolean }) {
  const { data: session } = useSession();
  const { bookmarks, setSignInModalOpen } = useUserStore();
  const [searchTerm, setSearchTerm] = useState('');
  const [showWishlistOnly, setShowWishlistOnly] = useState(false);

  // New Filters
  const currentYear = new Date().getFullYear();
  const [selectedYear, setSelectedYear] = useState<number | 'TBA'>(currentYear);
  const [selectedMonth, setSelectedMonth] = useState<number | 'all'>('all');
  const [selectedPlatform, setSelectedPlatform] = useState<string | 'all'>('all');
  
  const mainRef = useRef(null);
  const isInView = useInView(mainRef, { once: true, amount: 0.1 });
  
  const handleToggleWishlist = () => {
    if (!session) { setSignInModalOpen(true); return; }
    setShowWishlistOnly(prev => !prev);
  };
  
  const userRoles = (session?.user as any)?.roles || [];
  const isAdmin = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

  const handleJumpToNow = () => {
      const now = new Date();
      const monthIdx = now.getMonth();
      const year = now.getFullYear();
      
      setSelectedYear(year);
      if (selectedMonth !== 'all' && selectedMonth !== monthIdx) {
          setSelectedMonth(monthIdx);
      } else {
          const elements = document.querySelectorAll(`[id^="month-header-${monthIdx}"]`);
          if (elements.length > 0) { elements[0].scrollIntoView({ behavior: 'smooth', block: 'center' }); }
      }
  };

  // 1. Compute Available Years
  const availableYears = useMemo(() => {
      const years = new Set(releases.map(r => r.isTBA ? 'TBA' : new Date(r.releaseDate).getFullYear()));
      const yearArray = Array.from(years).filter(y => y !== 'TBA') as number[];
      return yearArray.sort((a, b) => b - a);
  }, [releases]);

  // 2. Separate Pinned Games
  const { pinnedGames, timelineGames } = useMemo(() => {
      const explicitPins = releases.filter(r => r.isPinned);
      let pinned: SanityGameRelease[] = [];
      let timeline: SanityGameRelease[] = [];

      if (explicitPins.length > 0) {
          pinned = explicitPins;
          timeline = releases.filter(r => !r.isPinned);
      } else {
          // If nothing pinned, take top 3 upcoming non-TBA
          const upcoming = releases.filter(r => !r.isTBA && new Date(r.releaseDate) >= new Date()).sort((a,b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
          pinned = upcoming.slice(0, 3);
          timeline = releases; 
      }
      return { pinnedGames: pinned, timelineGames: timeline };
  }, [releases]);

  // 3. Filter Timeline Games
  const filteredTimeline = useMemo(() => {
      let filtered = timelineGames;

      // Year Filter (Handles TBA specifically)
      if (selectedYear === 'TBA') {
          filtered = filtered.filter(r => r.isTBA);
      } else {
          // If a specific year is selected, exclude TBAs and match year
          filtered = filtered.filter(r => !r.isTBA && new Date(r.releaseDate).getFullYear() === selectedYear);
      }

      // Month Filter (Only applies if not TBA)
      if (selectedMonth !== 'all' && selectedYear !== 'TBA') {
          filtered = filtered.filter(r => new Date(r.releaseDate).getMonth() === selectedMonth);
      }

      if (selectedPlatform !== 'all') {
          filtered = filtered.filter(r => {
              if (!r.platforms) return false;
              if (selectedPlatform === 'PlayStation') {
                  return r.platforms.includes('PlayStation') || r.platforms.includes('PlayStation 5');
              }
              return r.platforms.includes(selectedPlatform as any);
          });
      }

      if (searchTerm) {
          const lowerTerm = searchTerm.toLowerCase();
          filtered = filtered.filter(r => r.title.toLowerCase().includes(lowerTerm));
      }

      if (showWishlistOnly) {
          filtered = filtered.filter(r => bookmarks.includes(`release-${r.legacyId}`));
      }

      return filtered;
  }, [timelineGames, selectedYear, selectedMonth, selectedPlatform, searchTerm, showWishlistOnly, bookmarks]);
  
  // 4. Group by Month
  const flatAnimatedContent = useMemo(() => {
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    
    const sortedReleases = [...filteredTimeline].sort((a, b) => {
         // Primary Sort: TBA status
         if (a.isTBA && !b.isTBA) return 1;
         if (!a.isTBA && b.isTBA) return -1;
         
         // Secondary Sort: Date
         const dateA = new Date(a.releaseDate).getTime();
         const dateB = new Date(b.releaseDate).getTime();
         if (dateA !== dateB) return dateA - dateB;

         // Tertiary Sort: Date Precision (Day < Month < Year)
         // This ensures "Year Only" (2025) comes AFTER "December 2025" even if both are stored as 12-31
         const weight = (p?: string) => p === 'year' ? 3 : (p === 'month' ? 2 : 1);
         return weight(a.datePrecision) - weight(b.datePrecision);
    });
    
    let currentMonth = '';
    let flatList: { type: 'header' | 'card', key: string, data: SanityGameRelease | string, monthIndex?: number }[] = [];

    sortedReleases.forEach(release => {
      let monthLabel = '';
      let monthIdx = -1;

      if (release.isTBA) {
          monthLabel = 'موعد غير معلن'; 
      } else if (release.datePrecision === 'year') {
          monthLabel = 'شهر غير معلن'; 
      } else {
          const date = new Date(release.releaseDate);
          monthIdx = date.getMonth();
          monthLabel = `${arabicMonths[monthIdx]}`;
      }
      
      if (monthLabel && monthLabel !== currentMonth) {
          if (selectedYear === 'TBA') {
               if (flatList.length === 0) {
                   currentMonth = monthLabel;
                   flatList.push({ type: 'header', key: `header-${monthLabel}`, data: monthLabel, monthIndex: -1 });
               }
          } else {
               currentMonth = monthLabel;
               flatList.push({ type: 'header', key: `header-${monthLabel}`, data: monthLabel, monthIndex: monthIdx });
          }
      }
      flatList.push({ type: 'card', key: `card-${release._id}`, data: release });
    });
    return flatList;
  }, [filteredTimeline, selectedYear]);

  const cardVariants = { initial: { opacity: 0, scale: 0.9 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.9 } };

  return (
    <div className={styles.chronoStreamLayoutWrapper}>
      <div className={styles.chronoContentWrapper}>
          {!hideHeader && (
              <h1 className="page-title">إصدارات {selectedYear === 'TBA' ? 'قادمة (TBA)' : selectedYear}</h1>
          )}
          
            <>
                <PinnedReleases 
                items={pinnedGames} 
                showAdminControls={isAdmin} 
                />
    
                <ReleasesControlBar 
                    searchTerm={searchTerm}
                    onSearchChange={setSearchTerm}
                    showWishlistOnly={showWishlistOnly}
                    onToggleWishlist={handleToggleWishlist}
                    onJumpToNow={handleJumpToNow}
                    isAuthenticated={!!session}
                    
                    selectedYear={selectedYear}
                    onYearChange={setSelectedYear}
                    selectedMonth={selectedMonth}
                    onMonthChange={setSelectedMonth}
                    selectedPlatform={selectedPlatform}
                    onPlatformChange={setSelectedPlatform}
                    availableYears={availableYears}
                />
            </>
      </div>
      
        <div ref={mainRef} className={styles.chronoTimelineSections}>
            <div className={`${styles.chronoGamesGrid} gpu-cull`}>
            <AnimatePresence mode="popLayout">
                {flatAnimatedContent.length === 0 ? (
                <motion.p key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0', gridColumn: '1 / -1', fontSize: '1.6rem'}}>
                    لا توجد إصدارات تطابق بحثك.
                </motion.p>
                ) : (
                flatAnimatedContent.map(item => {
                    if (item.type === 'header') {
                    return (
                        <motion.div 
                        key={item.key} 
                        id={item.monthIndex !== undefined && item.monthIndex !== -1 ? `month-header-${item.monthIndex}` : undefined}
                        className={styles.stickyHeaderWrapper} 
                        initial={false} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
                        >
                        <h2 className={styles.timelineMonthTitle}>{item.data as string}</h2>
                        </motion.div>
                    );
                    }
                    const release = item.data as SanityGameRelease;
                    return (
                    <motion.div key={item.key} variants={cardVariants} initial={false} animate="animate" exit="exit" transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
                        <TimelineCard 
                        release={release} 
                        showAdminControls={isAdmin} 
                        autoHeight={false} 
                        />
                    </motion.div>
                    );
                })
                )}
            </AnimatePresence>
            </div>
        </div>
    </div>
  );
}

--- END OF FILE app/releases/ReleasePageClient.tsx ---

================================================================================

--- START OF FILE app/releases/ReleasesPage.module.css ---

/* app/releases/ReleasesPage.module.css */

.chronoStreamLayoutWrapper {
  position: relative;
  min-height: 80vh;
  padding-bottom: 6rem;
}

.chronoContentWrapper {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem;
}

.chronoTimelineSections {
  padding-top: 2rem;
  padding-right: 2rem;
  padding-left: 2rem;
  max-width: 1300px;
  margin: 0 auto;
}

/* Updated Sticky Header Logic */
.stickyHeaderWrapper {
    grid-column: 1 / -1;
    position: relative; /* Changed from sticky */
    top: auto;          /* Reset top */
    z-index: auto;      /* Reset z-index */
    padding: 1rem 0;
    /* Removed background and blur for clean look */
    background: transparent;
    backdrop-filter: none;
    margin-bottom: 1.5rem;
    pointer-events: auto;
}

.timelineMonthTitle {
  font-size: 3.2rem;
  font-weight: 800;
  display: block;
  text-align: right;
  margin: 0;
  color: var(--accent);
  text-shadow: 0 0 20px color-mix(in srgb, var(--accent) 30%, transparent);
}

.chronoGamesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); /* Slightly wider cards */
  gap: 3rem;
  margin: 0 auto;
  
  /* GPU CULL FIX: Expand render boundary */
  padding: 10rem;
  margin: -10rem;
  width: calc(100% + 20rem);
  
  /* FIX: Prevent padding from capturing mouse events */
  pointer-events: none;
}

/* Restore interactions */
.chronoGamesGrid > * {
    pointer-events: auto;
}

@media (max-width: 768px) {
    .chronoGamesGrid {
        grid-template-columns: 1fr;
        gap: 2rem;
        
        /* Reset Expansion on mobile */
    }
    .chronoTimelineSections {
        padding-right: 1.5rem;
        padding-left: 1.5rem;
    }
    .stickyHeaderWrapper {
        /* No override needed as sticky is gone globally */
    }
}

--- END OF FILE app/releases/ReleasesPage.module.css ---

================================================================================

--- START OF FILE app/releases/actions.ts ---

// app/releases/actions.ts
'use server';

import { sanityWriteClient } from '@/lib/sanity.server';
import { getAuthenticatedSession } from '@/lib/auth';
import { revalidateTag } from 'next/cache';

export async function toggleReleasePin(releaseId: string, currentPinStatus: boolean) {
    try {
        const session = await getAuthenticatedSession();
        const userRoles = session.user.roles;
        const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

        if (!isAdminOrDirector) {
            return { success: false, message: 'غير مصرح لك.' };
        }

        // Toggle the isPinned field
        await sanityWriteClient
            .patch(releaseId)
            .set({ isPinned: !currentPinStatus })
            .commit();

        // THE FIX: Added 'max' profile argument
        revalidateTag('gameRelease', 'max');
        revalidateTag('content', 'max');

        return { success: true, message: !currentPinStatus ? 'تم تثبيت الإصدار.' : 'أزيل التثبيت.' };
    } catch (error) {
        console.error("Failed to toggle pin:", error);
        return { success: false, message: 'حدث خطأ.' };
    }
}




--- END OF FILE app/releases/actions.ts ---

================================================================================

--- START OF FILE app/releases/page.tsx ---

// app/releases/page.tsx
import React from 'react';
import ReleasePageClient from './ReleasePageClient';
import { getUniversalBaseData } from '@/app/actions/layoutActions';

export const dynamic = 'force-static';

export default async function ReleasesPage() {
  const data = await getUniversalBaseData();
  const releases = data.releases || [];

  const sanitizedReleases = releases.filter((item: any) =>
    item?.mainImage?.url && item.title
  );

  return (
    <div className="container page-container" style={{ paddingTop: 'calc(var(--nav-height-scrolled) + 2rem)' }}>
      <ReleasePageClient releases={sanitizedReleases} />
    </div>
  );
}

--- END OF FILE app/releases/page.tsx ---

================================================================================

--- START OF FILE app/reset-password/ResetPasswordClientPage.tsx ---

// app/reset-password/ResetPasswordClientPage.tsx
'use client';

import { useState, useTransition } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { resetPassword } from '@/app/actions/authActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function ResetPasswordClientPage() {
    const router = useRouter();
    const searchParams = useSearchParams();
    const token = searchParams.get('token');
    const toast = useToast();

    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [message, setMessage] = useState<{ type: 'error' | 'success', text: string } | null>(null);
    const [isPending, startTransition] = useTransition();

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);

        if (!token) {
            setMessage({ type: 'error', text: 'Invalid or missing reset token.' });
            return;
        }

        if (newPassword !== confirmPassword) {
            setMessage({ type: 'error', text: 'Passwords do not match.' });
            return;
        }

        startTransition(async () => {
            const result = await resetPassword(token, newPassword);
            if (result.success) {
                toast.success(result.message || 'Password reset successfully!');
                router.push('/'); // Redirect to homepage on success
            } else {
                setMessage({ type: 'error', text: result.message || 'Failed to reset password.' });
            }
        });
    };
    
    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
            <motion.div 
                style={{ maxWidth: '420px', width: '100%' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <form onSubmit={handleSubmit} className="profile-form" style={{ background: 'var(--bg-secondary)', padding: '3rem', borderRadius: '12px', border: '1px solid var(--border-color)' }}>
                    <h1 className="page-title" style={{ fontSize: '2.8rem', marginTop: 0 }}>Reset Your Password</h1>
                    <p style={{ color: 'var(--text-secondary)', textAlign: 'center', marginTop: '-2rem', marginBottom: '3rem' }}>
                        Enter a new password for your account.
                    </p>

                    <div className="profile-form-group">
                        <input id="newPassword" type="password" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} required minLength={8} className="profile-input" placeholder=" " />
                        <label htmlFor="newPassword" className="profile-form-label">كلمة السر الجديدة</label>
                    </div>
                    <div className="profile-form-group">
                        <input id="confirmPassword" type="password" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} required className="profile-input" placeholder=" " />
                        <label htmlFor="confirmPassword" className="profile-form-label">تأكيد الجديدة</label>
                    </div>
                    
                    <AnimatePresence>
                        {message && (
                            <motion.p
                                initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}
                                style={{
                                    fontSize: '1.4rem', textAlign: 'center', margin: '0 0 1.5rem 0',
                                    color: message.type === 'error' ? '#DC2626' : '#16A34A'
                                }}
                            >
                                {message.text}
                            </motion.p>
                        )}
                    </AnimatePresence>

                    <button type="submit" className="primary-button" style={{ width: '100%' }} disabled={isPending}>
                        {isPending ? <ButtonLoader /> : 'إعادة تعيين كلمة السر'}
                    </button>
                </form>
            </motion.div>
        </div>
    );
}







--- END OF FILE app/reset-password/ResetPasswordClientPage.tsx ---

================================================================================

--- START OF FILE app/reset-password/page.tsx ---

// app/reset-password/page.tsx
import { Suspense } from 'react';
import ResetPasswordClientPage from './ResetPasswordClientPage';

const ResetPasswordFallback = () => {
    return (
        <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
            <div className="spinner" />
        </div>
    );
};

export default function ResetPasswordPage() {
    return (
        <Suspense fallback={<ResetPasswordFallback />}>
            <ResetPasswordClientPage />
        </Suspense>
    );
}







--- END OF FILE app/reset-password/page.tsx ---

================================================================================

--- START OF FILE app/reviews/ReviewsPage.module.css ---

/* app/reviews/ReviewsPage.module.css */

.reviewHero {
  height: 55vh;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  margin-bottom: -8rem;
  padding-top: var(--nav-height-scrolled);
}

.heroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
}

.heroOverlay {
  position: absolute;
  inset: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 100%);
  z-index: -1;
}

:global([data-theme="light"]) .heroOverlay {
    background: none !important;
}

.heroCategory {
    font-family: var(--font-ui);
    font-size: 1.6rem;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--accent);
    margin: 0;
}

.titleScoreWrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.heroTitle {
  font-size: 4.8rem;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  margin: 0 0 1rem 0;
}

.heroScore {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: var(--accent);
    color: var(--bg-primary);
    font-weight: 800;
    font-size: 2.4rem;
    box-shadow: 0 0 20px 0 color-mix(in srgb, var(--accent) 80%, transparent);
}

.heroGame {
    color: #fff;
    font-weight: 700;
    font-size: 2.4rem;
    margin-top: -0.5rem;
}

/* --- Review Filters Container --- */
.reviewFiltersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-ui);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-ui), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative;
  overflow: hidden;
}
@media (hover: hover) {
  .filterButton:hover  {
    border-color: var(--accent);
    color: var(--accent);
  }
  .filterButton:active  {
    border-color: var(--accent);
    color: var(--accent);
  }
}
.filterButton:active {
  border-color: var(--accent);
  color: var(--accent);
}


.filterButton.active {
  color: #fff;
  z-index: 2;
}
[data-theme="dark"] .filterButton.active {
  color: var(--bg-primary);
}

.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

/* --- Filter Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: left;
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-ui);
  transition: background-color 0.1s ease-out;
}
@media (hover: hover) {
  .popoverItemButton:hover  {
    background-color: var(--bg-primary);
  }
  .popoverItemButton:active  {
    background-color: var(--bg-primary);
  }
}
.popoverItemButton:active {
  background-color: var(--bg-primary);
}

.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem;
  flex-shrink: 0;
  cursor: pointer;
  color: #000000; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
}
@media (hover: hover) {
  .gameClearButton:hover  {
    opacity: 1;
  }
  .gameClearButton:active  {
    opacity: 1;
  }
}
.gameClearButton:active {
  opacity: 1;
}

.gameSelectedButton.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}

@media (max-width: 768px) {
  .reviewHero {
    height: 30vh;
    min-height: 220px;
    margin-bottom: -10rem;
    align-items: flex-end;
    padding-bottom: 8rem;
  }
  .heroCategory {
      font-size: 1.4rem;
  }
  .titleScoreWrapper {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 1rem;
  }
  .heroTitle {
    font-size: 3.2rem !important;
    margin: 0;
  }
  .heroScore {
    width: 50px;
    height: 50px;
    font-size: 2rem;
    flex-shrink: 0;
  }
  .heroGame {
    display: none;
  }
}

--- END OF FILE app/reviews/ReviewsPage.module.css ---

================================================================================

--- START OF FILE app/reviews/ReviewsPageClient.tsx ---

// app/reviews/ReviewsPageClient.tsx
'use client';

import { useState, useMemo, useCallback, useEffect } from 'react';
import type { SanityReview, SanityGame, SanityTag } from '@/types/sanity';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import ReviewFilters, { ScoreFilter } from '@/components/filters/ReviewFilters';
import ArticleCard from '@/components/ArticleCard';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import styles from './ReviewsPage.module.css';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { ContentBlock } from '@/components/ContentBlock';
import { ReviewIcon } from '@/components/icons';
import { sanityLoader } from '@/lib/sanity.loader';
import { useContentStore } from '@/lib/contentStore';
import InfiniteScrollSentinel from '@/components/ui/InfiniteScrollSentinel';
import ArticleCardSkeleton from '@/components/ui/ArticleCardSkeleton';
import { loadMoreReviews, batchFetchFullContentAction } from '@/app/actions/batchActions';

export default function ReviewsPageClient({ heroReview, initialGridReviews, allGames, allTags }: { heroReview: SanityReview, initialGridReviews: SanityReview[], allGames: SanityGame[], allTags: SanityTag[] }) {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const { openOverlay, hydrateContent, pageMap, appendToSection, hydrateIndex, contentMap } = useContentStore();

    const storedData = pageMap.get('reviews');
    const hasStoredData = storedData && storedData.grid && storedData.grid.length >= initialGridReviews.length;
    const sourceGrid = hasStoredData ? storedData.grid : initialGridReviews;
    const initialOffset = hasStoredData ? storedData.nextOffset : initialGridReviews.length;

    const initialCards = useMemo(() => sourceGrid.map((item: any) => adaptToCardProps(item, { width: 600 })).filter(Boolean) as CardProps[], [sourceGrid]);
    const [allFetchedReviews, setAllFetchedReviews] = useState<CardProps[]>(initialCards);
    const [isLoading, setIsLoading] = useState(false);
    
    const [nextOffset, setNextOffset] = useState<number | null>(initialOffset);
    
    if (!hasStoredData) {
        hydrateIndex('reviews', {
            hero: heroReview,
            grid: initialGridReviews,
            allGames: allGames,
            allTags: allTags,
            nextOffset: initialGridReviews.length
        });
    }

    // Smart Pre-fetch Effect
    useEffect(() => {
        const itemsToFetch = allFetchedReviews
            .filter(item => !contentMap.get(item.slug)?.contentLoaded)
            .map(item => item.id);

        if (itemsToFetch.length > 0) {
            const prefetch = async () => {
                const fullContent = await batchFetchFullContentAction(itemsToFetch);
                if (fullContent.length > 0) {
                    hydrateContent(fullContent);
                }
            };
            // Delay slightly to not interfere with initial paint
            const timeoutId = setTimeout(prefetch, 500);
            return () => clearTimeout(timeoutId);
        }
    }, [allFetchedReviews, contentMap, hydrateContent]);

    const [searchTerm, setSearchTerm] = useState('');
    const [activeSort, setActiveSort] = useState<'latest' | 'score'>('latest');
    const [selectedScoreRange, setSelectedScoreRange] = useState<ScoreFilter>('All');
    const [selectedGame, setSelectedGame] = useState<SanityGame | null>(null);
    const [selectedTags, setSelectedTags] = useState<SanityTag[]>([]);

    const gridReviews = useMemo(() => {
        let items = [...allFetchedReviews];
        if (heroReview) items = items.filter(item => item.id !== heroReview._id);
        if (searchTerm) items = items.filter(review => review.title.toLowerCase().includes(searchTerm.toLowerCase()));
        if (selectedScoreRange !== 'All') {
            const rangeMap = { '9-10': [9, 10], '8-8.9': [8, 8.9], '7-7.9': [7, 7.9], '<7': [0, 6.9] };
            const [min, max] = rangeMap[selectedScoreRange as Exclude<ScoreFilter, 'All'>];
            if (min !== undefined) items = items.filter(review => review.score! >= min && review.score! <= max);
        }
        if (selectedGame) items = items.filter(review => review.game === selectedGame.title);
        if (selectedTags.length > 0) {
            const selectedTagTitles = new Set(selectedTags.map(t => t.title));
            items = items.filter(review => review.tags.some(t => selectedTagTitles.has(t.title)));
        }
        if (activeSort === 'score') items.sort((a, b) => (b.score || 0) - (a.score || 0));
        return items;
    }, [allFetchedReviews, searchTerm, activeSort, selectedScoreRange, selectedGame, selectedTags, heroReview]);
    
    const hasActiveFilters = useMemo(() => !!searchTerm || selectedScoreRange !== 'All' || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest', [searchTerm, selectedScoreRange, selectedGame, selectedTags, activeSort]);
    const canLoadMore = nextOffset !== null && !hasActiveFilters && !isLoading;

    const handleLoadMore = useCallback(async () => {
        if (!canLoadMore) return;
        setIsLoading(true);
        try {
            const result = await loadMoreReviews({ offset: nextOffset as number, limit: 20, sort: activeSort, scoreRange: selectedScoreRange !== 'All' ? selectedScoreRange : undefined });
            if (result.cards.length > 0) {
                const newCards = result.cards.filter((newItem: CardProps) => !allFetchedReviews.some(p => p.id === newItem.id));
                if (newCards.length > 0) {
                    hydrateContent(result.fullContent);
                    if (result.hubs) hydrateContent(result.hubs);
                    appendToSection('reviews', result.fullContent, result.nextOffset);
                    setAllFetchedReviews(prev => [...prev, ...newCards]);
                }
                setNextOffset(result.nextOffset);
            } else {
                setNextOffset(null);
            }
        } catch (error) { console.error("Failed to load more reviews:", error); setNextOffset(null); } 
        finally { setIsLoading(false); }
    }, [canLoadMore, nextOffset, activeSort, selectedScoreRange, allFetchedReviews, hydrateContent, appendToSection]);

    const handleTagToggle = (tag: SanityTag) => { setSelectedTags(prev => prev.some(t => t._id === tag._id) ? prev.filter(t => t._id !== tag._id) : [...prev, tag]); };
    const handleClearAll = () => { setSearchTerm(''); setSelectedScoreRange('All'); setSelectedGame(null); setSelectedTags([]); setActiveSort('latest'); };
    const handleHeroClick = (e: React.MouseEvent) => {
        e.preventDefault(); e.stopPropagation();
        setPrefix('reviews-hero');
        const slugStr = typeof heroReview.slug === 'string' ? heroReview.slug : (heroReview.slug as any).current;
        if (slugStr) openOverlay(slugStr, 'reviews', 'reviews-hero', heroReview.mainImage.url);
    };

    return (
        <>
            <motion.div layoutId={`reviews-hero-card-container-${heroReview.legacyId}`} className={styles.reviewHero}>
                <motion.div layoutId={`reviews-hero-card-image-${heroReview.legacyId}`} className={styles.heroBg}>
                    <Image loader={sanityLoader} src={heroReview.mainImage.url} alt={`Background for ${heroReview.title}`} fill style={{ objectFit: 'cover' }} priority placeholder={heroReview.mainImage.blurDataURL ? 'blur' : 'empty'} blurDataURL={heroReview.mainImage.blurDataURL} />
                </motion.div>
                <div className={styles.heroOverlay} />
                <motion.div className="container" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '1rem', zIndex: 5, color: '#fff', textAlign: 'center' }} initial={{opacity: 0, y: 20}} animate={{opacity: 1, y: 0}} transition={{duration: 0.5, delay: 0.2}}>
                    <p className={styles.heroCategory}>الأعلى تقييمًا</p>
                    <div className={styles.titleScoreWrapper}>
                        <motion.h1 layoutId={`reviews-hero-card-title-${heroReview.legacyId}`} className={styles.heroTitle}>{heroReview.title}</motion.h1>
                        <span className={styles.heroScore}>{heroReview.score?.toFixed(1)}</span>
                    </div>
                    {heroReview.game?.title && (<span className={styles.heroGame}>{heroReview.game.title}</span>)}
                    <button onClick={handleHeroClick} className="primary-button no-underline" style={{padding: '1rem 2.4rem', fontSize: '1.6rem'}}>اقرأ المراجعة</button>
                </motion.div>
            </motion.div>
            
            <div className="container" style={{paddingTop: '4rem'}}>
                <ReviewFilters activeSort={activeSort} onSortChange={setActiveSort} selectedScoreRange={selectedScoreRange} onScoreSelect={setSelectedScoreRange} allGames={allGames} selectedGame={selectedGame} onGameSelect={setSelectedGame} allTags={allTags} selectedTags={selectedTags} onTagToggle={handleTagToggle} onClearAll={handleClearAll} searchTerm={searchTerm} onSearchChange={setSearchTerm} />
                <ContentBlock title="كل المراجعات" Icon={ReviewIcon}>
                    <div className="content-grid">
                        {gridReviews.map((review, index) => (
                            <motion.div key={review.id} initial={false} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}>
                                <ArticleCard article={review} layoutIdPrefix="reviews" isPriority={index < 3} />
                            </motion.div>
                        ))}
                        {isLoading && (<> <ArticleCardSkeleton /> <ArticleCardSkeleton /> </>)}
                    </div>
                    <InfiniteScrollSentinel onIntersect={handleLoadMore} />
                    <AnimatePresence>
                        {(!isLoading && gridReviews.length > 0 && (nextOffset === null || hasActiveFilters)) && (<motion.p key="end" style={{textAlign: 'center', padding: '3rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{hasActiveFilters ? 'أزِل المرشحات للمزيد.' : 'بلغتَ المنتهى.'}</motion.p>)}
                    </AnimatePresence>
                    {gridReviews.length === 0 && !isLoading && (<motion.p key="no-match" style={{textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}} initial={{ opacity: 0 }} animate={{ opacity: 1 }}>لا مراجعات توافقُ ما اخترت.</motion.p>)}
                </ContentBlock>
            </div>
        </>
    );
}

--- END OF FILE app/reviews/ReviewsPageClient.tsx ---

================================================================================

--- START OF FILE app/reviews/page.tsx ---

// app/reviews/page.tsx
import React from 'react';
import type { Metadata } from 'next';
import CollectionPageJsonLd from '@/components/seo/CollectionPageJsonLd';
import { getUniversalBaseData } from '@/app/actions/layoutActions';
import ReviewsPageClient from './ReviewsPageClient';

export const dynamic = 'force-static';

export const metadata: Metadata = {
  title: 'المراجعات',
  description: 'استكشف أحدث وأعمق مراجعات الألعاب من فريق EternalGames.',
  alternates: { canonical: '/reviews' }
};

export default async function ReviewsPage() {
  // We fetch Universal Data here too because this page acts as an entry point.
  // The layout has already fetched it, so this cache hit is cheap.
  // We need it to pass to the Client Component for the "Base Layer" if user reloads here.
  const data = await getUniversalBaseData();
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';

  // Extract Review Data from Universal Set
  const { reviews: allReviews, metadata: meta } = data;
  const heroReview = allReviews[0];
  const gridReviews = allReviews; // Full list

  const itemList = gridReviews.map((item: any) => ({
      headline: item.title,
      url: `${siteUrl}/reviews/${item.slug}`,
      datePublished: item.publishedAt
  }));

  if (!heroReview) {
    return (
      <div className="container page-container">
        <h1 className="page-title">المراجعات</h1>
        <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>الأرشيفُ خالٍ من المراجعاتِ حاليًا.</p>
      </div>
    );
  }

  return (
    <>
      <CollectionPageJsonLd 
        name="مراجعات الألعاب" 
        description="أحدث مراجعات الألعاب من فريق EternalGames" 
        url={`${siteUrl}/reviews`}
        hasPart={itemList}
      />
      
      {/* 
         We don't need hydration here anymore because UserStoreHydration (in Layout) 
         has already flooded the store with the Universal Data (including reviews).
         We just render the visual client.
      */}
      <ReviewsPageClient 
        heroReview={heroReview} 
        initialGridReviews={gridReviews}
        allGames={meta?.games || []}
        allTags={meta?.gameTags || []}
      />
    </>
  );
}

--- END OF FILE app/reviews/page.tsx ---

================================================================================

--- START OF FILE app/sitemap-html/page.tsx ---

// app/sitemap-html/page.tsx
import React from 'react';
import { Metadata } from 'next';
import Link from 'next/link';
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

export const metadata: Metadata = {
    title: 'خريطة الموقع',
    description: 'تصفح جميع أقسام ومحتويات موقع EternalGames.',
    robots: {
        index: true,
        follow: true,
    }
};

export const dynamic = 'force-static';

const sitemapDataQuery = groq`{
    "games": *[_type == "game" && !(_id in path("drafts.**"))] | order(title asc) { _id, title, "slug": slug.current },
    "reviews": *[_type == "review" && !(_id in path("drafts.**"))] | order(publishedAt desc)[0...50] { _id, title, "slug": slug.current },
    "articles": *[_type == "article" && !(_id in path("drafts.**"))] | order(publishedAt desc)[0...50] { _id, title, "slug": slug.current },
    "news": *[_type == "news" && !(_id in path("drafts.**"))] | order(publishedAt desc)[0...50] { _id, title, "slug": slug.current }
}`;

export default async function HtmlSitemapPage() {
    const data = await client.fetch(sitemapDataQuery);
    
    const cleanGames = (data.games || []).filter((i: any) => i.slug);
    const cleanReviews = (data.reviews || []).filter((i: any) => i.slug);
    const cleanArticles = (data.articles || []).filter((i: any) => i.slug);
    const cleanNews = (data.news || []).filter((i: any) => i.slug);

    const Section = ({ title, items, basePath }: { title: string, items: any[], basePath: string }) => (
        <div style={{ marginBottom: '4rem' }}>
            <h2 style={{ 
                fontSize: '2.4rem', 
                borderBottom: '2px solid var(--border-color)', 
                paddingBottom: '1rem', 
                marginBottom: '2rem',
                color: 'var(--accent)'
            }}>
                {title}
            </h2>
            <ul style={{ 
                listStyle: 'none', 
                padding: 0, 
                display: 'grid', 
                gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', 
                gap: '1rem' 
            }}>
                {items.map((item: any) => (
                    <li key={item._id}>
                        {/* FIX: Disable prefetching for ALL these links to prevent ISR explosion */}
                        <Link 
                            href={`${basePath}/${item.slug}`} 
                            className="no-underline"
                            prefetch={false}
                            style={{ 
                                color: 'var(--text-primary)', 
                                transition: 'color 0.2s',
                                fontSize: '1.5rem' 
                            }}
                        >
                            {item.title}
                        </Link>
                    </li>
                ))}
            </ul>
        </div>
    );

    return (
        <div className="container page-container">
            <h1 className="page-title">خريطة الموقع</h1>
            
            <div style={{ marginBottom: '4rem' }}>
                <h2 style={{ fontSize: '2.4rem', marginBottom: '2rem', color: 'var(--accent)' }}>أقسام رئيسية</h2>
                <div style={{ display: 'flex', gap: '2rem', flexWrap: 'wrap' }}>
                    <Link href="/" className="primary-button no-underline" prefetch={false}>الرئيسية</Link>
                    <Link href="/reviews" className="outline-button no-underline" prefetch={false}>المراجعات</Link>
                    <Link href="/news" className="outline-button no-underline" prefetch={false}>الأخبار</Link>
                    <Link href="/articles" className="outline-button no-underline" prefetch={false}>المقالات</Link>
                    <Link href="/releases" className="outline-button no-underline" prefetch={false}>الإصدارات</Link>
                    <Link href="/about" className="outline-button no-underline" prefetch={false}>من نحن</Link>
                </div>
            </div>

            <Section title="أحدث المراجعات" items={cleanReviews} basePath="/reviews" />
            <Section title="أحدث المقالات" items={cleanArticles} basePath="/articles" />
            <Section title="آخر الأخبار" items={cleanNews} basePath="/news" />
            
            <div style={{ marginBottom: '4rem' }}>
                <h2 style={{ fontSize: '2.4rem', marginBottom: '2rem', color: 'var(--accent)' }}>مراكز الألعاب</h2>
                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
                    {cleanGames.map((game: any) => (
                        <Link 
                            key={game._id} 
                            href={`/games/${game.slug}`}
                            className="no-underline"
                            prefetch={false} // FIX: Disable prefetch
                            style={{ 
                                background: 'var(--bg-secondary)', 
                                padding: '0.5rem 1.5rem', 
                                borderRadius: '999px', 
                                border: '1px solid var(--border-color)',
                                color: 'var(--text-secondary)',
                                fontSize: '1.3rem'
                            }}
                        >
                            {game.title}
                        </Link>
                    ))}
                </div>
            </div>
        </div>
    );
}

--- END OF FILE app/sitemap-html/page.tsx ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.module.css ---

/* app/studio/ActionDrawer.module.css */

.actionDrawerContainer {
  position: absolute;
  bottom: 0;
  right: 0;
  left: 0;
  z-index: 50; /* Kept relatively low to be under Orb (2000) but over card content */
  overflow: hidden;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  backdrop-filter: blur(8px);
  border-top: 1px solid var(--border-color);
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  pointer-events: auto;
}

:global(body.no-glass) .actionDrawerContainer {
  backdrop-filter: none !important;
  background-color: var(--bg-secondary) !important;
}

.actionDrawerButtons {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
}

.actionDrawerButton {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background-color: transparent;
  border: 1px solid transparent;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  position: relative;
  z-index: 51;
}
.actionDrawerButton svg {
  width: 22px;
  height: 22px;
}
@media (hover: hover) {@media (hover: hover) {
  
  .actionDrawerButton:hover  {
  background-color: var(--border-color);
  color: var(--accent);
}
}

  .actionDrawerButton:active  {
  background-color: var(--border-color);
  color: var(--accent);
}
}
.actionDrawerButton:active {
  background-color: var(--border-color);
  color: var(--accent);
}

@media (hover: hover) {@media (hover: hover) {
  
  .actionDrawerButton.delete:hover  {
  background-color: #3f1a1a;
  color: #DC2626;
}
}

  .actionDrawerButton.delete:active  {
  background-color: #3f1a1a;
  color: #DC2626;
}
}
.actionDrawerButton.delete:active {
  background-color: #3f1a1a;
  color: #DC2626;
}

--- END OF FILE app/studio/ActionDrawer.module.css ---

================================================================================

--- START OF FILE app/studio/ActionDrawer.tsx ---

// app/studio/ActionDrawer.tsx
'use client';

import { motion } from 'framer-motion';
import Link from 'next/link';
import { useState } from 'react';
import { EditIcon, PreviewIcon, DeleteIcon } from './StudioIcons';
import { DeleteConfirmationModal } from './DeleteConfirmationModal';
import styles from './ActionDrawer.module.css';

type ContentCanvasItem = { _id: string; _type: string; slug: string; title: string; };

const drawerVariants = {
    hidden: { y: '100%' },
    visible: { y: '0%', transition: { type: 'spring' as const, damping: 25, stiffness: 200 } },
    exit: { y: '100%', transition: { duration: 0.2 } }
};

const itemContainerVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1, transition: { staggerChildren: 0.07, delayChildren: 0.2 } },
};

const itemVariants = {
    hidden: { opacity: 0, y: 10 },
    visible: { opacity: 1, y: 0 },
};

export function ActionDrawer({ item, onDelete }: { item: ContentCanvasItem, onDelete: (id: string) => Promise<void> }) {
    const [isDeleteModalOpen, setDeleteModalOpen] = useState(false);

    const getPaths = () => {
        // Use item.slug if available, otherwise fallback to empty string to prevent URL errors
        const safeSlug = item.slug || '';
        switch (item._type) {
            case 'review': return { plural: 'reviews', live: `/reviews/${safeSlug}` };
            case 'article': return { plural: 'articles', live: `/articles/${safeSlug}` };
            case 'news': return { plural: 'news', live: `/news/${safeSlug}` };
            case 'gameRelease': return { plural: 'releases', live: `/releases` };
            default: return { plural: '', live: '/' };
        }
    };

    const { plural, live } = getPaths();
    const studioEditUrl = `/studio/${plural}/${item._id}`;
    const livePreviewUrl = live;

    const handleDeleteConfirm = async () => {
        await onDelete(item._id);
        setDeleteModalOpen(false);
    };

    // Explicit type handling for actions
    type ActionItem = {
        label: string;
        icon: React.ReactNode;
        href?: string;
        onClick?: () => void;
        isLink: boolean;
    };

    const actions: ActionItem[] = [
        { label: 'تحرير', icon: <EditIcon />, href: studioEditUrl, isLink: true },
        { label: 'معاينة', icon: <PreviewIcon />, href: livePreviewUrl, isLink: true },
        { label: 'حذف', icon: <DeleteIcon />, onClick: () => setDeleteModalOpen(true), isLink: false },
    ];

    return (
        <>
            <DeleteConfirmationModal
                isOpen={isDeleteModalOpen}
                onClose={() => setDeleteModalOpen(false)}
                onConfirm={handleDeleteConfirm}
                itemName={item.title}
            />
            <motion.div
                className={styles.actionDrawerContainer}
                variants={drawerVariants}
                initial="hidden"
                animate="visible"
                exit="exit"
                // Important: Stop propagation on click/hover to prevent bubbling to card
                onClick={(e) => e.stopPropagation()}
                onMouseEnter={(e) => e.stopPropagation()}
            >
                <motion.div className={styles.actionDrawerButtons} variants={itemContainerVariants}>
                    {actions.map((action) => (
                        <motion.div key={action.label} variants={itemVariants}>
                            {action.isLink ? (
                                <Link 
                                    href={action.href!} 
                                    className={styles.actionDrawerButton} 
                                    aria-label={action.label} 
                                    target={action.label === 'معاينة' ? '_blank' : '_self'}
                                    prefetch={false} // Disable prefetch to reduce load
                                    onClick={(e) => e.stopPropagation()} // Extra safety
                                >
                                    {action.icon}
                                </Link>
                            ) : (
                                <button 
                                    className={`${styles.actionDrawerButton} ${styles.delete}`} 
                                    onClick={(e) => { e.stopPropagation(); action.onClick?.(); }} 
                                    aria-label={action.label}
                                >
                                    {action.icon}
                                </button>
                            )}
                        </motion.div>
                    ))}
                </motion.div>
            </motion.div>
        </>
    );
}




--- END OF FILE app/studio/ActionDrawer.tsx ---

================================================================================

--- START OF FILE app/studio/DeleteConfirmationModal.tsx ---

// app/studio/DeleteConfirmationModal.tsx
'use client';

import { useState } from 'react';
import { motion } from 'framer-motion';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';

interface DeleteConfirmationModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => Promise<void>;
    itemName: string;
}

export function DeleteConfirmationModal({ isOpen, onClose, onConfirm, itemName }: DeleteConfirmationModalProps) {
    const [isPending, setIsPending] = useState(false);

    const handleConfirm = async () => {
        setIsPending(true);
        await onConfirm();
        // No need to set isPending back to false if the modal closes on success
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '450px' }}>
            <h3 style={{ marginTop: 0, fontFamily: 'var(--font-main)', fontSize: '2rem' }}>تأكيد الحذف</h3>
            <p style={{ color: 'var(--text-secondary)', margin: '1rem 0 2rem 0' }}>
                هل أنت متأكد من رغبتك في حذف <strong style={{ color: 'var(--text-primary)' }}>&quot;{itemName}&quot;</strong>? لا رجعةَ في هذا.
            </p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                <motion.button
                    onClick={handleConfirm}
                    className="primary-button delete-forever"
                    style={{ backgroundColor: '#DC2626', boxShadow: 'none' }}
                    disabled={isPending}
                >
                    {isPending ? 'جارٍ الحذف...' : 'حذفٌ نهائي'}
                </motion.button>
            </div>
        </Modal>
    );
}




--- END OF FILE app/studio/DeleteConfirmationModal.tsx ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.module.css ---

/* app/studio/GenesisOrb.module.css */

.genesisContainer {
  position: fixed;
  /* --- CUSTOMIZATION POINT (Desktop) --- */
  /* Adjust these values to change the orb's position on larger screens */
  bottom: 2rem;
  right: 2rem;
  /* --- END CUSTOMIZATION --- */
  left: auto;
  z-index: 2000; /* THE FIX: Increased from 10 to 2000 to float above drawers */
  width: 80px;
  height: 80px;
}

.genesisOrb {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background-color: var(--accent);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--accent) 50%, transparent);
  z-index: 2002; /* THE FIX: Higher than container */
  /* --- THE FIX: Centering styles applied directly to the button --- */
  display: flex;
  /* --- CUSTOMIZATION POINT (Icon Alignment) --- */
  align-items: center; /* Vertical alignment */
  justify-content: center; /* Horizontal alignment */
  /* --- END CUSTOMIZATION --- */
}
/* THE FIX: Added a rule to style the PlusIcon inside */
.genesisOrb svg {
    width: 32px;
    height: 32px;
    stroke-width: 3; /* Increased stroke width for better visibility */
}
[data-theme="dark"] .genesisOrb {
  color: var(--bg-primary);
}

.genesisSatellites {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  z-index: 2001; /* THE FIX: Layer between orb and container */
  pointer-events: none;
}

.satelliteWrapper {
  position: absolute;
  margin-left: -28px;
  margin-top: -28px;
  pointer-events: auto;
  display: flex;
  align-items: center;
}

.satelliteOrb {
  width: 56px;
  height: 56px;
  border-radius: 50%;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease-out;
  box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  flex-shrink: 0;
}

[data-theme="dark"] .satelliteOrb {
  color: var(--text-primary);
}
@media (hover: hover) {@media (hover: hover) {
  
  .satelliteOrb:hover  {
  border-color: var(--accent);
  color: var(--accent);
  transform: scale(1.1);
}
}

  .satelliteOrb:active  {
  border-color: var(--accent);
  color: var(--accent);
  transform: scale(1.1);
}
}
.satelliteOrb:active {
  border-color: var(--accent);
  color: var(--accent);
  transform: scale(1.1);
}


.satelliteOrb svg {
  color: currentColor;
  filter: grayscale(0) opacity(1) !important;
}

.satelliteLabel {
  position: absolute;
  left: calc(100% + 1rem); /* RTL */
  right: auto;
  font-family: var(--font-main);
  font-size: 1.4rem;
  font-weight: 500;
  color: var(--text-primary);
  background: var(--bg-secondary);
  padding: 0.4rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .satelliteWrapper:hover .satelliteLabel  {
  opacity: 1;
}
}

  .satelliteWrapper:active .satelliteLabel  {
  opacity: 1;
}
}
.satelliteWrapper:active .satelliteLabel {
  opacity: 1;
}


.closeIcon {
  color: #fff !important;
}
[data-theme="dark"] .closeIcon {
  color: var(--bg-primary) !important;
}
@media (hover: hover) {@media (hover: hover) {
  
  .closeIcon:hover  {
  filter: drop-shadow(0 0 10px #DC2626); /* Red glow on hover */
}
}

  .closeIcon:active  {
  filter: drop-shadow(0 0 10px #DC2626); /* Red glow on hover */
}
}
.closeIcon:active {
  filter: drop-shadow(0 0 10px #DC2626); /* Red glow on hover */
}


@media (max-width: 768px) {
    .genesisContainer {
        /* --- CUSTOMIZATION POINT (Mobile) --- */
        /* Adjust these values for smaller screens */
        bottom: 2rem;
        right: 2rem;
        /* --- END CUSTOMIZATION --- */
        width: 64px;
        height: 64px;
    }
    /* THE FIX: Adjusted the SVG size for mobile */
    .genesisOrb svg {
        width: 24px;
        height: 24px;
        stroke-width: 3;
    }
    .satelliteWrapper {
        margin-left: -24px;
        margin-top: -24px;
    }
    .satelliteOrb {
        width: 48px;
        height: 48px;
    }
}




--- END OF FILE app/studio/GenesisOrb.module.css ---

================================================================================

--- START OF FILE app/studio/GenesisOrb.tsx ---

// app/studio/GenesisOrb.tsx
'use client';

import { useState, useTransition, useMemo, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
// REMOVED: useSession import is no longer the primary source of truth
import { createDraftAction } from './actions';
import { ReviewIcon, ArticleIcon, NewsIcon, ReleaseIcon } from '@/components/icons/index';
import { useToast } from '@/lib/toastStore';
import styles from './GenesisOrb.module.css';

// THE FIX: Modified viewBox and paths to ensure perfect center alignment of the '+' sign.
const PlusIcon = () => ( <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"> <line x1="12" y1="5" x2="12" y2="19"></line> <line x1="5" y1="12" x2="19" y2="12"></line> </svg> );

const allContentTypes = [
    { type: 'review' as const, label: 'مراجعة جديدة', icon: <ReviewIcon />, requiredRole: 'REVIEWER' },
    { type: 'article' as const, label: 'مقالة جديدة', icon: <ArticleIcon />, requiredRole: 'AUTHOR' },
    { type: 'news' as const, label: 'خبر جديد', icon: <NewsIcon />, requiredRole: 'REPORTER' },
    { type: 'gameRelease' as const, label: 'إصدار جديد', icon: <ReleaseIcon />, requiredRole: 'ADMIN' }, // Restricted
];

const orbContainerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.08, delayChildren: 0.1 } }, };
const satelliteVariants = { hidden: { scale: 0, opacity: 0, x: 0, y: 0 }, visible: (custom: { x: number; y: number }) => ({ scale: 1, opacity: 1, x: custom.x, y: custom.y, transition: { type: 'spring' as const, stiffness: 400, damping: 18 }, }), };
const backdropVariants = { hidden: { scale: 0, opacity: 0, transition: { duration: 0.2, ease: "easeOut" as const } }, visible: { scale: 1, opacity: 1, transition: { type: "spring" as const, stiffness: 400, damping: 25 } }, };

// THE FIX: Accept userRoles as a prop
export function GenesisOrb({ userRoles }: { userRoles: string[] }) {
    const [isOpen, setIsOpen] = useState(false);
    const [isPending, startTransition] = useTransition();
    const router = useRouter();
    const toast = useToast();
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    
    const creationPermissions = useMemo(() => new Set( allContentTypes.filter(item => isAdminOrDirector || userRoles.includes(item.requiredRole)).map(item => item.type) ), [isAdminOrDirector, userRoles]);

    const handleCreate = (contentType: 'review' | 'article' | 'news' | 'gameRelease') => {
        if (isPending) return;
        if (!creationPermissions.has(contentType)) { toast.error("ليس لكَ إذنُ الإنشاء.", "left"); return; }
        setIsOpen(false);
        startTransition(async () => {
            try {
                const newDraft = await createDraftAction(contentType);
                const contentTypePlural = newDraft._type === 'news' ? 'news' : (newDraft._type === 'gameRelease' ? 'releases' : `${newDraft._type}s`);
                const route = contentType === 'gameRelease' ? `/studio/releases/${newDraft._id}` : `/studio/${contentTypePlural}/${newDraft._id}`;
                router.push(route);
            } catch (error: any) {
                toast.error(error.message || "أخفق إنشاء المسودة.", "left");
            }
        });
    };
    
    if (creationPermissions.size === 0 && !isAdminOrDirector) { return null; }

    const availableTypes = allContentTypes.filter(item => creationPermissions.has(item.type));
    const radius = isMobile ? 85 : 100;

    return (
        <div className={styles.genesisContainer}>
            <AnimatePresence>
                {isOpen && (
                    <>
                        <motion.div variants={backdropVariants} initial="hidden" animate="visible" exit="hidden" onClick={() => setIsOpen(false)} style={{ position: 'absolute', top: '-110px', right: '-110px', width: '300px', height: '300px', backgroundColor: 'transparent', borderRadius: '50%', zIndex: 10, cursor: 'default' }} />
                        <motion.div className={styles.genesisSatellites} variants={orbContainerVariants} initial="hidden" animate="visible" exit="hidden" >
                            {availableTypes.map((item, i) => {
                                const totalAngle = 110;
                                const startAngle = 170;
                                const angleInDegrees = startAngle + (i * (totalAngle / (availableTypes.length -1 || 1) ));
                                const angleInRadians = angleInDegrees * (Math.PI / 180);
                                const x = Math.cos(angleInRadians) * radius;
                                const y = Math.sin(angleInRadians) * radius;

                                return (
                                    <motion.div key={item.type} className={styles.satelliteWrapper} custom={{ x, y }} variants={satelliteVariants} >
                                        <button className={styles.satelliteOrb} onClick={() => handleCreate(item.type)} disabled={isPending} title={item.label}>
                                            {item.icon}
                                        </button>
                                    </motion.div>
                                );
                            })}
                        </motion.div>
                    </>
                )}
            </AnimatePresence>
            <motion.button onClick={() => setIsOpen(!isOpen)} disabled={isPending} className={styles.genesisOrb} whileHover={{ scale: 1.05, boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} whileTap={{ scale: 0.95 }} transition={{ type: 'spring' as const, stiffness: 300, damping: 20 }} animate={{ scale: isOpen ? 1.1 : 1, backgroundColor: isOpen ? '#DC2626' : 'var(--accent)', boxShadow: isOpen ? '0 0 35px 0 #DC2626' : '0 0 35px 0 var(--accent)' }} >
                <motion.div animate={{ rotate: isOpen ? 45 : 0 }} className={isOpen ? styles.closeIcon : ''}>
                    <PlusIcon />
                </motion.div>
            </motion.button>
        </div>
    );
}




--- END OF FILE app/studio/GenesisOrb.tsx ---

================================================================================

--- START OF FILE app/studio/StudioDashboard.module.css ---

/* app/studio/StudioDashboard.module.css */
.studioHeader {
    text-align: center;
    margin-bottom: 3rem;
}

.studioTitle {
    margin-bottom: 1rem;
}

.studioSubtitle {
    font-size: 1.8rem;
    color: var(--text-secondary);
    max-width: 600px;
    margin: 0 auto;
}

.searchWrapper {
    display: flex;
    justify-content: center;
    margin-bottom: 3rem;
}

.searchInput {
    width: 100%;
    max-width: 500px;
}

/* --- NEW: Director Gate Button Styles --- */
.directorGateButton {
    margin-top: 2.5rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 1.2rem;
    padding: 1.2rem 3.5rem;
    border: 2px solid #FFD700; /* Gold Border */
    border-radius: 999px;
    color: #FFD700;
    background-color: transparent;
    font-family: var(--font-main);
    font-size: 1.8rem;
    font-weight: 800;
    transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.1);
    text-decoration: none; /* Failsafe against global link styles */
}
@media (hover: hover) {@media (hover: hover) {
  
  .directorGateButton:hover  {
    background-color: #FFD700;
    color: #121212; /* Dark text for contrast against gold */
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
    border-color: #FFD700;
}
}

  .directorGateButton:active  {
    background-color: #FFD700;
    color: #121212; /* Dark text for contrast against gold */
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
    border-color: #FFD700;
}
}
.directorGateButton:active {
    background-color: #FFD700;
    color: #121212; /* Dark text for contrast against gold */
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 30px rgba(255, 215, 0, 0.4);
    border-color: #FFD700;
}


.directorGateButton svg {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .directorGateButton:hover svg  {
    transform: rotate(-15deg) scale(1.1);
}
}

  .directorGateButton:active svg  {
    transform: rotate(-15deg) scale(1.1);
}
}
.directorGateButton:active svg {
    transform: rotate(-15deg) scale(1.1);
}


/* --- Mobile Overrides --- */
@media (max-width: 768px) {
    .studioHeader {
        padding-top: calc(var(--nav-height-scrolled) + 2rem);
        margin-bottom: 2rem;
        padding-right: 1rem;
        padding-left: 1rem;
    }
    .studioTitle {
        font-size: 3.8rem;
    }
    .studioSubtitle {
        font-size: 1.6rem;
    }
    .searchWrapper {
        margin-bottom: 2rem;
        padding: 0 1rem;
    }
    .searchInput {
        max-width: 100%;
    }
    .directorGateButton {
        padding: 1rem 2.5rem;
        font-size: 1.6rem;
    }
}




--- END OF FILE app/studio/StudioDashboard.module.css ---

================================================================================

--- START OF FILE app/studio/StudioDashboard.tsx ---

// app/studio/StudioDashboard.tsx

'use client';

import { useState, useMemo, useTransition, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { StudioTabs, ContentType } from './StudioTabs';
import { ActionDrawer } from './ActionDrawer';
import { GenesisOrb } from './GenesisOrb';
import { deleteDocumentAction } from './actions';
import { useToast } from '@/lib/toastStore';
import { urlFor } from '@/sanity/lib/image';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader'; // Ensure imported
import styles from './StudioDashboard.module.css';
import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { useContentStore } from '@/lib/contentStore'; 

type ContentStatus = 'all' | 'draft' | 'published' | 'scheduled';
type ContentCanvasItem = { _id: string; _type: 'review' | 'article' | 'news' | 'gameRelease'; _updatedAt: string; title: string; slug: string; status: ContentStatus; mainImage?: any; blurDataURL?: string; };

const ContentCanvas = ({ item, onDelete, isActive, onCardClick }: {
    item: ContentCanvasItem;
    onDelete: (id: string) => Promise<void>;
    isActive: boolean;
    onCardClick: () => void;
}) => {
    const [isHovered, setIsHovered] = useState(false);
    const justClickedToClose = useRef(false);

    const handleClick = () => {
        if (isActive) {
            justClickedToClose.current = true;
            setIsHovered(false);
        }
        onCardClick();
    };

    const handleMouseEnter = () => {
        if (justClickedToClose.current) {
            return;
        }
        setIsHovered(true);
    };

    const handleMouseLeave = () => {
        justClickedToClose.current = false;
        setIsHovered(false);
    };

    const isDrawerVisible = isActive || isHovered;

    const imageUrlWithBuster = useMemo(() => {
        if (!item.mainImage?.asset) return null;
        const url = urlFor(item.mainImage).width(800).height(500).fit('crop').auto('format').url();
        return `${url}&buster=${new Date(item._updatedAt).getTime()}`;
    }, [item.mainImage, item._updatedAt]);

    return (
        <motion.div
            layoutId={`canvas-card-${item._id}`}
            style={{ position: 'relative', backgroundColor: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '12px', overflow: 'hidden', aspectRatio: '16 / 10', cursor: 'pointer' }}
            onMouseEnter={handleMouseEnter}
            onMouseLeave={handleMouseLeave}
            onClick={handleClick}
        >
            <motion.div
                className="canvas-image-container"
                animate={{ scale: isDrawerVisible ? 1.05 : 1, filter: isDrawerVisible ? 'brightness(0.8)' : 'brightness(1)' }}
                transition={{ type: 'spring' as const, damping: 20, stiffness: 150 }}
                style={{ width: '100%', height: '100%', position: 'absolute', inset: 0, backgroundColor: 'var(--border-color)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
            >
                {imageUrlWithBuster ? (
                    <Image 
                        loader={sanityLoader} // <-- ADDED: Bypass Vercel Image Optimization
                        src={imageUrlWithBuster} 
                        alt={item.title} 
                        fill
                        sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 350px"
                        style={{ objectFit: 'cover' }}
                    />
                ) : (<span style={{color: 'var(--text-secondary)', fontSize: '1.2rem', fontWeight: 600}}>بلا صورة</span>)}
            </motion.div>
            <div style={{ position: 'absolute', inset: 0, background: 'linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 60%)', pointerEvents: 'none' }} />
            <div style={{ position: 'absolute', bottom: 0, left: 0, padding: '1.25rem', color: 'white', pointerEvents: 'none' }}>
                <span style={{ display: 'inline-block', padding: '0.25rem 0.75rem', fontSize: '0.75rem', fontWeight: 600, borderRadius: '9999px', backgroundColor: item.status === 'published' ? 'rgba(22, 163, 74, 0.8)' : 'rgba(107, 114, 128, 0.8)' }}>{item.status === 'draft' ? 'مسودة' : item.status === 'published' ? 'منشورة' : 'مجدولة'}</span>
                <h3 style={{ marginTop: '0.5rem', fontSize: '1.25rem', fontWeight: 700, fontFamily: 'var(--font-heading)' }}>{item.title}</h3>
            </div>
            <AnimatePresence>{isDrawerVisible && <ActionDrawer item={item} onDelete={onDelete} />}</AnimatePresence>
        </motion.div>
    );
};

export function StudioDashboard({ initialContent, userRoles }: { initialContent: ContentCanvasItem[], userRoles: string[] }) {
    const [content, setContent] = useState(initialContent);
    const [activeTab, setActiveTab] = useState<ContentType>('all');
    const [searchTerm, setSearchTerm] = useState('');
    const [activeCardId, setActiveCardId] = useState<string | null>(null);
    const toast = useToast();
    const [isPending, startTransition] = useTransition();
    
    const { isOverlayOpen } = useContentStore();

    const { data: session, update: updateSession } = useSession();
    
    useEffect(() => {
        const clientRoles = (session?.user as any)?.roles || [];
        if (userRoles.length > 0) {
            const sortedServerRoles = [...userRoles].sort();
            const sortedClientRoles = [...clientRoles].sort();
            
            if (JSON.stringify(sortedServerRoles) !== JSON.stringify(sortedClientRoles)) {
                updateSession(); 
            }
        }
    }, [userRoles, session, updateSession]);

    const availableTabs = useMemo(() => {
        const tabs: { label: string; value: ContentType }[] = [];
        const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
        
        if (isAdminOrDirector || userRoles.includes('REVIEWER')) tabs.push({ label: 'المراجعات', value: 'review' });
        if (isAdminOrDirector || userRoles.includes('AUTHOR')) tabs.push({ label: 'المقالات', value: 'article' });
        if (isAdminOrDirector || userRoles.includes('REPORTER')) tabs.push({ label: 'الأخبار', value: 'news' });
        if (isAdminOrDirector) tabs.push({ label: 'الإصدارات', value: 'gameRelease' });
        
        return tabs;
    }, [userRoles]);
    
    useEffect(() => {
        if (availableTabs.length === 1 && activeTab === 'all') {
            setActiveTab(availableTabs[0].value);
        }
    }, [availableTabs, activeTab]);

    const shouldShowTabs = availableTabs.length > 1;

    const filteredContent = useMemo(() => {
        let filtered = content;
        if (activeTab !== 'all' && shouldShowTabs) {
            filtered = filtered.filter(item => item._type === activeTab);
        } else if (!shouldShowTabs && availableTabs.length === 1) {
            filtered = content.filter(item => item._type === availableTabs[0].value);
        }

        if (searchTerm) {
            filtered = filtered.filter(item => item.title.toLowerCase().includes(searchTerm.toLowerCase()));
        }
        return filtered;
    }, [activeTab, content, searchTerm, shouldShowTabs, availableTabs]);
    
    const handleDelete = async (docId: string) => {
        startTransition(async () => {
            const originalContent = content;
            setContent(prev => prev.filter(item => item._id !== docId));
            const result = await deleteDocumentAction(docId);
            if (!result.success) {
                toast.error(result.message || 'فشل الحذف.');
                setContent(originalContent);
            } else {
                toast.success('تم حذف المستند.');
            }
        });
    };
    
    const handleCardClick = (cardId: string) => {
        setActiveCardId(prevId => (prevId === cardId ? null : cardId));
    };

    const isDirector = userRoles.includes('DIRECTOR');
    
    if (isOverlayOpen) return null;

    return (
        <>
            <header className={styles.studioHeader}>
                <h1 className={`${styles.studioTitle} page-title`}>ديوان الصنعة</h1>
                <p className={styles.studioSubtitle}>قُد دفّة محتواك في رحاب EternalGames.</p>
                {isDirector && (
                    <Link 
                        href="/studio/director" 
                        className={`${styles.directorGateButton} no-underline`}
                        prefetch={false}
                    >
                         <span>بوابة الإدارة</span>
                         <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2L15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2z"/></svg>
                    </Link>
                )}
            </header>

            <div className={styles.searchWrapper}>
                <input type="search" placeholder="استنطق المحفوظات..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className={`${styles.searchInput} profile-input`} />
            </div>

            {shouldShowTabs && (
                <StudioTabs tabs={availableTabs} activeTab={activeTab} setActiveTab={setActiveTab} />
            )}

            <motion.div layout className="content-grid gpu-cull" style={{gap: '1.5rem'}}>
                <AnimatePresence>
                    {filteredContent.map(item => (
                        <motion.div key={item._id} layout initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }} transition={{ type: 'spring' as const, damping: 20, stiffness: 200 }} >
                            <ContentCanvas
                                item={item}
                                onDelete={handleDelete}
                                isActive={activeCardId === item._id}
                                onCardClick={() => handleCardClick(item._id)}
                            />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </motion.div>
            {filteredContent.length === 0 && <p style={{ textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}}>لا محتوى.</p>}

            <GenesisOrb userRoles={userRoles} />
        </>
    );
}

--- END OF FILE app/studio/StudioDashboard.tsx ---

================================================================================

--- START OF FILE app/studio/StudioIcons.tsx ---

// app/studio/StudioIcons.tsx
'use client'

export const GameDetailsIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <rect x="3" y="4" width="18" height="16" rx="2" ry="2"></rect>
    <line x1="3" y1="10" x2="21" y2="10"></line>
    <line x1="9" y1="4" x2="9" y2="20"></line>
  </svg>
)

export const TableIcon = (props: React.SVGProps<SVGSVGElement>) => (
  // ADDED
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <line x1="3" y1="9" x2="21" y2="9"></line>
    <line x1="3" y1="15" x2="21" y2="15"></line>
    <line x1="9" y1="3" x2="9" y2="21"></line>
    <line x1="15" y1="3" x2="15" y2="21"></line>
  </svg>
)

export const YoutubeIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    <path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path>
    <polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>
  </svg>
)

export const SingleImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <circle cx="8.5" cy="8.5" r="1.5"></circle>
    <polyline points="21 15 16 10 5 21"></polyline>
  </svg>
)

export const ImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    <circle cx="8.5" cy="8.5" r="1.5"></circle>
    <polyline points="21 15 16 10 5 21"></polyline>
  </svg>
)
export const CompareIcon = () => (
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
    <path d="M12 2v20M3 12h18M21 12l-3-3m3 3l-3 3M3 12l3-3m-3 3l3 3" />
  </svg>
)
export const TwoImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="7" height="18"></rect>
    <rect x="14" y="3" width="7" height="18"></rect>
  </svg>
)
export const FourImageIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    <rect x="3" y="3" width="7" height="7"></rect>
    <rect x="14" y="3" width="7" height="7"></rect>
    <rect x="14" y="14" width="7" height="7"></rect>
    <rect x="3" y="14" width="7" height="7"></rect>
  </svg>
)
export const ReleaseIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M6 2L3 6v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6l-3-4H6zM3.5 6h17M8 11l4 4 4-4" />{' '}
  </svg>
)
export const ReviewIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>{' '}
  </svg>
)
export const ArticleIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>{' '}
    <polyline points="14 2 14 8 20 8"></polyline>{' '}
    <line x1="16" y1="13" x2="8" y2="13"></line> <line x1="16" y1="17" x2="8" y2="17"></line>{' '}
  </svg>
)
export const NewsIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <circle cx="12" cy="12" r="10"></circle> <line x1="2" y1="12" x2="22" y2="12"></line>{' '}
    <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>{' '}
  </svg>
)
export const EditIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>{' '}
    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>{' '}
  </svg>
)
export const PreviewIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>{' '}
    <circle cx="12" cy="12" r="3"></circle>{' '}
  </svg>
)
export const DeleteIcon = () => (
  <svg
    width="20"
    height="20"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <polyline points="3 6 5 6 21 6"></polyline>{' '}
    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>{' '}
    <line x1="10" y1="11" x2="10" y2="17"></line> <line x1="14" y1="11" x2="14" y2="17"></line>{' '}
  </svg>
)




--- END OF FILE app/studio/StudioIcons.tsx ---

================================================================================

--- START OF FILE app/studio/StudioTabs.module.css ---

/* app/studio/StudioTabs.module.css */

.studioTabsContainer {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 3rem;
    border-bottom: 1px solid var(--border-color);
  }
  
  .studioTabButton {
    position: relative;
    padding: 1rem 1.5rem;
    background: none;
    border: none;
    cursor: pointer;
    font-family: var(--font-ui);
    font-weight: 600;
    font-size: 1.6rem;
    color: var(--text-secondary);
    transition: color 0.2s ease-in-out;
    flex-shrink: 0; /* Prevent buttons from shrinking */
  }
@media (hover: hover) {@media (hover: hover) {
  
  .studioTabButton:hover  {
    color: var(--text-primary);
  }
}

  .studioTabButton:active  {
    color: var(--text-primary);
  }
}
.studioTabButton:active {
    color: var(--text-primary);
  }

  
  .studioTabButton.active {
    color: var(--accent);
  }
  
  .studioTabUnderline {
    position: absolute;
    bottom: -1px;
    right: 0;
    left: 0;
    height: 2px;
    background: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
  }

/* --- Mobile Overrides --- */
@media (max-width: 768px) {
    .studioTabsContainer {
        justify-content: flex-start; /* Align to the start for scrolling */
        overflow-x: auto;
        padding: 0 1rem; /* Add some padding so items don't touch the edge */
        margin: 0 -1.5rem 2rem -1.5rem; /* Negative margin to bleed to edges of .container */

        /* Hide scrollbar */
        -ms-overflow-style: none;  /* IE and Edge */
        scrollbar-width: none;  /* Firefox */
    }
    .studioTabsContainer::-webkit-scrollbar {
        display: none; /* Chrome, Safari, and Opera */
    }
}




--- END OF FILE app/studio/StudioTabs.module.css ---

================================================================================

--- START OF FILE app/studio/StudioTabs.tsx ---

// app/studio/StudioTabs.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './StudioTabs.module.css';

export type ContentType = 'review' | 'article' | 'news' | 'gameRelease' | 'all';

interface StudioTabsProps {
    tabs: { label: string; value: ContentType }[];
    activeTab: ContentType;
    setActiveTab: (tab: ContentType) => void;
}

export function StudioTabs({ tabs, activeTab, setActiveTab }: StudioTabsProps) {
    const allTabs = [{ label: 'كل المحتوى', value: 'all' as ContentType }, ...tabs];

    return (
        <div className={styles.studioTabsContainer}>
            {allTabs.map((tab) => (
                <button
                    key={tab.value}
                    onClick={() => setActiveTab(tab.value)}
                    className={`${styles.studioTabButton} ${activeTab === tab.value ? styles.active : ''}`}
                >
                    {tab.label}
                    {activeTab === tab.value && (
                        <motion.div className={styles.studioTabUnderline} layoutId="studioTabUnderline" />
                    )}
                </button>
            ))}
        </div>
    );
}










--- END OF FILE app/studio/StudioTabs.tsx ---

================================================================================

--- START OF FILE app/studio/actions.ts ---

// app/studio/actions.ts
'use server';

import { getAuthenticatedSession } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { revalidatePath, revalidateTag, unstable_cache } from 'next/cache';
import { sanityWriteClient } from '@/lib/sanity.server';
import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';
import { slugify } from 'transliteration';
import { tiptapToPortableText } from './utils/tiptapToPortableText';
import { portableTextToTiptap } from './utils/portableTextToTiptap';
import { editorDocumentQuery, studioMetadataQuery } from '@/lib/sanity.queries';
import type { IdentifiedSanityDocumentStub } from '@sanity/client';
import { v4 as uuidv4 } from 'uuid';
import { validateImageFile } from '@/lib/security'; 

function revalidateContentPaths(docType: string, slug?: string) {
    revalidateTag(docType, 'max'); 
    revalidatePath('/'); 
    let sectionPath = '';
    switch (docType) {
        case 'review': sectionPath = '/reviews'; break;
        case 'article': sectionPath = '/articles'; break;
        case 'news': sectionPath = '/news'; break;
        case 'gameRelease': sectionPath = '/releases'; break;
    }
    if (sectionPath) {
        revalidatePath(sectionPath); 
        if (slug) {
            revalidatePath(`${sectionPath}/${slug}`); 
        }
    }
}

export const getStudioMetadataAction = unstable_cache(
  async () => {
    return await client.fetch(studioMetadataQuery);
  },
  ['studio-metadata-full'],
  { tags: ['studio-metadata'], revalidate: 3600 } 
);

export async function translateTitleToAction(title: string): Promise<string> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isAuthorized = userRoles.some((role: string) => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
    if (!isAuthorized) throw new Error('غير مُصرَّح به.');
    const apiUrl = process.env.TRANSLATION_API_URL;
    if (!apiUrl) return slugify(title);
    try {
        const url = `${apiUrl}?q=${encodeURIComponent(title)}&langpair=ar|en`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Translation API responded with status: ${response.status}`);
        const data = await response.json();
        const translatedText = data?.responseData?.translatedText;
        if (!translatedText || typeof translatedText !== 'string') throw new Error("Invalid response structure.");
        return slugify(translatedText, { lowercase: true, separator: '-', allowedChars: 'a-zA-Z0-9-' });
    } catch (error) { return slugify(title, { lowercase: true, separator: '-', allowedChars: 'a-zA-Z0-9-' }); }
}

export async function createDraftAction(contentType: 'review' | 'article' | 'news' | 'gameRelease') {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const canCreate = (userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR')) || (contentType === 'review' && userRoles.includes('REVIEWER')) || (contentType === 'article' && userRoles.includes('AUTHOR')) || (contentType === 'news' && userRoles.includes('REPORTER'));
    if (!canCreate) throw new Error('صلاحياتٌ قاصرة.');
    const highestIdQuery = groq`*[_type in ["review", "article", "news", "gameRelease"] && defined(legacyId)] | order(legacyId desc)[0].legacyId`;
    const lastId = await sanityWriteClient.fetch<number>(highestIdQuery, {}, { perspective: 'previewDrafts' });
    const newLegacyId = (lastId || 0) + 1;
    let doc: any = { _type: contentType, title: `Untitled ${contentType.charAt(0).toUpperCase() + contentType.slice(1)}`, legacyId: newLegacyId };
    
    if (contentType === 'review' || contentType === 'article' || contentType === 'news') {
        let sanityCreator;
        const creatorTypeMap: Record<string, string> = { 'review': 'reviewer', 'article': 'author', 'news': 'reporter' };
        const sanityDocType = creatorTypeMap[contentType];
        const user = session.user;
        if (!user || !user.name) throw new Error("المستخدمُ مفقودٌ أو الاسمُ غائب.");
        const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityDocType}" && prismaUserId == $userId][0]`, { userId: user.id });
        if (existingCreator) { sanityCreator = existingCreator; } else {
            const newCreatorPayload: any = { _type: sanityDocType, _id: `${sanityDocType}-${user.id}`, name: user.name, prismaUserId: user.id };
            sanityCreator = await sanityWriteClient.create(newCreatorPayload);
        }
        if (contentType === 'review' || contentType === 'article') { doc.authors = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
        if (contentType === 'news') { doc.reporters = [{ _type: 'reference', _ref: sanityCreator._id, _key: sanityCreator._id }] };
    }
    if (contentType === 'review') { doc.score = 0; doc.verdict = '...'; doc.pros = []; doc.cons = []; }
    if (contentType === 'gameRelease') { doc.releaseDate = new Date().toISOString().split('T')[0]; doc.synopsis = '...'; doc.platforms = []; }
    
    const result = await sanityWriteClient.create(doc, { autoGenerateArrayKeys: true });
    return { _id: result._id, _type: result._type };
}

export async function updateDocumentAction(docId: string, patchData: Record<string, any>): Promise<{ success: boolean; message?: string; updatedDocument?: any }> {
    const session = await getAuthenticatedSession();
    if (!session) return { success: false, message: 'غير مُخَوَّل.' };
    
    // Ensure we handle both draft and public IDs correctly
    const publicId = docId.replace('drafts.', '');
    const draftId = `drafts.${publicId}`;
    
    try {
        const tx = sanityWriteClient.transaction();
        
        // 1. Fetch current state to determine if we need to initialize a draft
        // We assume drafts exist if we are editing, but we must handle the case where it's a new draft from a published doc
        const [existingDraft, originalDoc] = await Promise.all([
            sanityWriteClient.getDocument(draftId),
            sanityWriteClient.getDocument(publicId)
        ]);

        // Capture previous update time for read-your-writes check
        let previousUpdatedAt = existingDraft?._updatedAt || originalDoc?._updatedAt;

        // 2. Prepare Transaction
        // Strategy: 
        // If draft exists? Just Patch.
        // If draft missing? CreateIfNotExists (Base on Original or New) + Patch.
        // Using CreateIfNotExists prevents "Document already exists" race conditions.

        if (!existingDraft) {
            let initialDoc: any;

            if (originalDoc) {
                // Clone published to draft
                // Exclude system fields that shouldn't be copied to new draft
                const { _rev, _updatedAt, _createdAt, ...rest } = originalDoc;
                initialDoc = { ...rest, _id: draftId };
            } else {
                // Rare case: Editing a document that doesn't exist yet in either state.
                // We attempt to fetch type, or rely on patch to create it if possible (though createIfNotExists needs _type)
                const docType = await sanityWriteClient.fetch(`*[_id == $id][0]._type`, { id: publicId });
                if (docType) {
                    initialDoc = { _id: draftId, _type: docType };
                }
            }

            if (initialDoc) {
                // ATOMIC OPERATION: Create if missing, ignore if someone else created it 1ms ago
                tx.createIfNotExists(initialDoc);
            }
        }

        // 3. Always Apply Patch
        // If createIfNotExists ran, this patches the new doc.
        // If it didn't run (doc existed), this patches the existing doc.
        tx.patch(draftId, (p) => p.set(patchData));

        // 4. Commit
        await tx.commit({ autoGenerateArrayKeys: true, returnDocuments: false });
        
        // --- Read-Your-Writes Consistency Check ---
        let finalDoc = null;
        let attempts = 0;
        const maxAttempts = 10; // Max 2 seconds
        
        while (attempts < maxAttempts) {
            // Force no-store to bypass Next.js Data Cache
            finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId }, { cache: 'no-store' });
            
            if (finalDoc) {
                // If it's a new doc (no previous timestamp) or updated (newer timestamp), we are good.
                if (!previousUpdatedAt || finalDoc._updatedAt > previousUpdatedAt) {
                    break;
                }
            }
            
            // Wait 200ms before retrying
            await new Promise(r => setTimeout(r, 200));
            attempts++;
        }

        if (!finalDoc) throw new Error("الوثيقةُ مفقودةٌ بعد تحديثها (timeout).");
        
        const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
        return { success: true, updatedDocument: docWithTiptap };

    } catch (error: any) { 
        console.error("Error during document update:", error); 
        return { success: false, message: error.message || "أصابنا خطبٌ أثناء الحفظ." }; 
    }
}

export async function deleteDocumentAction(docId: string): Promise<{ success: boolean; message?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const baseId = docId.replace(/^drafts\./, '');
    const draftId = `drafts.${baseId}`;
    const docToDelete = await sanityWriteClient.fetch(groq`*[_id in [$baseId, $draftId]][0]{_type, "slug": slug.current}`, { baseId, draftId });
    if (!docToDelete) return { success: false, message: 'الوثيقةُ مفقودة.' };
    
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const docType = docToDelete._type;
    const canDelete = isAdminOrDirector || (docType === 'review' && userRoles.includes('REVIEWER')) || (docType === 'article' && userRoles.includes('AUTHOR')) || (docType === 'news' && userRoles.includes('REPORTER'));
    if (!canDelete) return { success: false, message: 'أذوناتٌ قاصرة.' };

    try {
        const tx = sanityWriteClient.transaction();
        tx.delete(baseId);
        tx.delete(draftId);
        await tx.commit();
        
        revalidateContentPaths(docType, docToDelete.slug);
        
        return { success: true };
    } catch (error) { console.error("Delete failed:", error); return { success: false, message: 'تأبى الحذف.' }; }
}

export async function deleteMetadataAction(id: string): Promise<{ success: boolean; message?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR'].includes(role))) {
        return { success: false, message: 'غير مُصرَّح به. الحذف متاح للمدراء فقط.' };
    }
    
    try {
        await sanityWriteClient.delete(id);
        revalidateTag('studio-metadata', 'max');
        return { success: true };
    } catch (error) {
        console.error("Failed to delete metadata:", error);
        return { success: false, message: 'فشل الحذف. قد يكون العنصر مستخدمًا.' };
    }
}

export async function publishDocumentAction(docId: string, publishTime?: string | null): Promise<{ success: boolean; updatedDocument?: any; message?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isAdminOrDirector = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const doc = await sanityWriteClient.fetch(groq`*[_id == $docId || _id == 'drafts.' + $docId] | order(_updatedAt desc)[0]{_id, _type, "slug": slug.current}`, { docId });
    if (!doc) return { success: false, message: 'الوثيقةُ مفقودة.' };
    const docType = doc._type;
    const canPublish = isAdminOrDirector || (docType === 'review' && userRoles.includes('REVIEWER')) || (docType === 'article' && userRoles.includes('AUTHOR')) || (docType === 'news' && userRoles.includes('REPORTER')) || (docType === 'gameRelease' && isAdminOrDirector);
    if (!canPublish) return { success: false, message: 'صلاحياتٌ قاصرة.' };

    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;
        
        if (publishTime === null) {
             const tx = sanityWriteClient.transaction();
            tx.delete(publicId);
            tx.patch(draftId, (p) => p.unset(['publishedAt']));
            await tx.commit({ returnDocuments: false });
            
            revalidateContentPaths(docType, doc.slug);
            
            const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId }, { cache: 'no-store' });
             const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
            return { success: true, updatedDocument: docWithTiptap, message: 'أُلغيَ نشرُ الوثيقة.' };
        }

        const draft = await sanityWriteClient.getDocument(draftId);
        let finalTime = publishTime || new Date().toISOString();
        if (docType !== 'gameRelease') {
             const publishedDocForDateCheck = await sanityWriteClient.fetch(groq`*[_id == $id][0]{publishedAt}`, { id: publicId });
             if (publishTime) { finalTime = publishTime; } else if (publishedDocForDateCheck?.publishedAt) { finalTime = publishedDocForDateCheck.publishedAt; }
        }

        if (draft) {
            const publishedDocPayload: IdentifiedSanityDocumentStub = { ...draft, _id: publicId };
            if (docType !== 'gameRelease') { publishedDocPayload.publishedAt = finalTime; }
            const tx = sanityWriteClient.transaction();
            tx.createOrReplace(publishedDocPayload);
            tx.delete(draftId);
            await tx.commit({ returnDocuments: false });
        } else if (docType !== 'gameRelease') { await sanityWriteClient.patch(publicId).set({ publishedAt: finalTime }).commit(); }
        
        revalidateContentPaths(docType, doc.slug);
        
        if (docType === 'gameRelease') { revalidatePath('/celestial-almanac'); }
        const finalDoc = await sanityWriteClient.fetch(editorDocumentQuery, { id: publicId }, { cache: 'no-store' });
        const docWithTiptap = { ...finalDoc, tiptapContent: portableTextToTiptap(finalDoc.content ?? []) };
        const message = docType === 'gameRelease' ? 'نُشِرَ الإصدار.' : (publishTime ? 'جُدولت الوثيقة.' : 'نُشِرت الوثيقة.');
        return { success: true, updatedDocument: docWithTiptap, message: message };
    } catch (error) { console.error('Failed to publish/unpublish document:', error); return { success: false, message: 'أخفق تنفيذ حالة النشر.' }; }
}

export async function searchCreatorsAction(query: string, roleName: 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER'): Promise<{ _id: string; name: string }[]> {
    const usersWithRole = await prisma.user.findMany({ where: { roles: { some: { name: roleName } }, name: { contains: query, mode: 'insensitive' } }, select: { id: true }, take: 10 });
    if (usersWithRole.length === 0) return [];
    const prismaUserIds = usersWithRole.map((u: any) => u.id);
    const sanityTypeMap = { REVIEWER: 'reviewer', AUTHOR: 'author', REPORTER: 'reporter', DESIGNER: 'designer' };
    const sanityType = sanityTypeMap[roleName];
    const sanityQuery = `*[_type == $sanityType && prismaUserId in $prismaUserIds]{_id, name}`;
    return await client.fetch(sanityQuery, { sanityType, prismaUserIds }) as {_id: string, name: string}[];
}

export async function createGameAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try { 
        const newGame = await sanityWriteClient.create({ _type: 'game', title, slug: { _type: 'slug', current: slugify(title.toLowerCase(), { separator: '-' }) } }); 
        revalidateTag('studio-metadata', 'max'); 
        return { _id: newGame._id, title: newGame.title }; 
    } catch (error) { console.error("أخفق إنشاء اللعبة:", error); return null; }
}

export async function createTagAction(title: string, category: 'Game' | 'Article' | 'News'): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role))) { return null; }
    try { 
        const newTag = await sanityWriteClient.create({ _type: 'tag', title, category, slug: { _type: 'slug', current: slugify(title.toLowerCase()) } }); 
        revalidateTag('studio-metadata', 'max');
        return { _id: newTag._id, title: newTag.title }; 
    } catch (error) { console.error("أخفق إنشاء الوسم:", error); return null; }
}

export async function createDeveloperAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR'].includes(role))) return null;
    try { 
        const newDev = await sanityWriteClient.create({ _type: 'developer', title, slug: { _type: 'slug', current: slugify(title.toLowerCase(), { separator: '-' }) } }); 
        revalidateTag('studio-metadata', 'max');
        return { _id: newDev._id, title: newDev.title }; 
    } catch (error) { console.error("Failed to create developer:", error); return null; }
}

export async function createPublisherAction(title: string): Promise<{_id: string, title: string} | null> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    if (!userRoles.some((role: string) => ['ADMIN', 'DIRECTOR'].includes(role))) return null;
    try { 
        const newPub = await sanityWriteClient.create({ _type: 'publisher', title, slug: { _type: 'slug', current: slugify(title.toLowerCase(), { separator: '-' }) } }); 
        revalidateTag('studio-metadata', 'max');
        return { _id: newPub._id, title: newPub.title }; 
    } catch (error) { console.error("Failed to create publisher:", error); return null; }
}

export async function validateSlugAction(slug: string, docId: string): Promise<{ isValid: boolean; message: string }> {
    if (!docId) return { isValid: false, message: 'بانتظار مُعرِّف الوثيقة...' };
    if (!slug || slug.trim() === '') return { isValid: false, message: 'لا يكُن المُعرِّفُ خاويًا.' };
    const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    if (!slugRegex.test(slug)) return { isValid: false, message: 'المُعرِّف: حروفٌ وأرقامٌ وشَرْطاتٌ لا غير.' };
    const query = groq`!defined(*[_type in ["review", "article", "news", "gameRelease"] && slug.current == $slug && !(_id in [$draftId, $publicId])][0])`;
    try {
        const publicId = docId.replace('drafts.', '');
        const draftId = `drafts.${publicId}`;
        const isUnique = await client.fetch(query, { slug, draftId, publicId });
        if (isUnique) return { isValid: true, message: 'المُعرِّفُ صالح.' };
        return { isValid: false, message: 'مُعرِّفٌ مُستعمل.' };
    } catch (error) { console.error('Sanity slug validation failed:', error); return { isValid: false, message: 'أخفق التحقق لخطبٍ في الخادم.' }; }
}

export async function uploadSanityAssetAction(formData: FormData): Promise<{ success: boolean; asset?: { _id: string; url: string }; error?: string }> {
    const session = await getAuthenticatedSession();
    const userRoles = session.user.roles;
    const isCreatorOrAdmin = userRoles.some((role: string) => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
    if (!isCreatorOrAdmin) return { success: false, error: 'غير مُصرَّح به' };
    
    const file = formData.get('file') as File | null;
    if (!file) return { success: false, error: 'لم يُقدَّم ملف.' };

    // SECURITY: Size Limit (5MB)
    if (file.size > 5 * 1024 * 1024) {
        return { success: false, error: 'حجم الملف يتجاوز الحد الأقصى (5MB).' };
    }
    
    // SECURITY: Magic Byte Validation
    const validation = await validateImageFile(file);
    if (!validation.isValid) {
        return { success: false, error: validation.error || 'نوع الملف غير مدعوم.' };
    }
    
    // SEO: Filename Sanitization (Slugify)
    // Instead of just removing non-alphanumeric, we slugify the name to be SEO friendly
    // e.g. "My Game Screenshot.jpg" -> "my-game-screenshot.jpg"
    const originalName = file.name.substring(0, file.name.lastIndexOf('.'));
    const extension = file.name.substring(file.name.lastIndexOf('.'));
    
    // Fallback if name is empty after processing
    const safeBaseName = slugify(originalName, { lowercase: true, separator: '-', allowedChars: 'a-zA-Z0-9' }) || `image-${Date.now()}`;
    const safeFilename = `${safeBaseName}${extension}`;
    
    try {
        const arrayBuffer = await file.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);

        const asset = await sanityWriteClient.assets.upload('image', buffer, { 
            filename: safeFilename, 
            contentType: file.type 
        });
        
        return { success: true, asset: { _id: asset._id, url: asset.url } };
    } catch (error: any) { 
        console.error("Sanity asset upload failed:", error); 
        return { success: false, error: 'أخفق رفع الملف.' }; 
    }
}

export async function addOrUpdateColorDictionaryAction(newMapping: { word: string; color: string }) {
  try {
    await getAuthenticatedSession();
    const newEntry = { ...newMapping, _key: uuidv4() };
    const tx = sanityWriteClient.transaction();
    tx.createIfNotExists({ _id: 'colorDictionary', _type: 'colorDictionary', title: 'Color Dictionary' });
    tx.patch('colorDictionary', (p) => p.setIfMissing({ autoColors: [] }));
    tx.patch('colorDictionary', (p) => p.insert('before', 'autoColors[0]', [newEntry]) );
    await tx.commit({ returnDocuments: false });
    const updatedDictionary = await sanityWriteClient.fetch(groq`*[_id == "colorDictionary"][0]`);
    return { success: true, updatedDictionary };
  } catch (error: any) { console.error("Failed to update dictionary:", error); return { success: false, message: error.message || 'Failed to update dictionary.' }; }
}

export async function removeColorDictionaryAction(keyToRemove: string) {
  try {
    await getAuthenticatedSession();
    await sanityWriteClient.patch('colorDictionary').unset([`autoColors[_key=="${keyToRemove}"]`]).commit({ returnDocuments: false, autoGenerateArrayKeys: true });
    const updatedDictionary = await sanityWriteClient.fetch(groq`*[_id == "colorDictionary"][0]`);
    return { success: true, updatedDictionary };
  } catch (error: any) { console.error("Failed to remove from dictionary:", error); return { success: false, message: error.message || 'Failed to remove from dictionary.' }; }
}

--- END OF FILE app/studio/actions.ts ---

================================================================================

--- START OF FILE app/studio/page.tsx ---

// app/studio/page.tsx

import { groq } from 'next-sanity';
import { StudioDashboard } from './StudioDashboard';
import { sanityWriteClient } from '@/lib/sanity.server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';

// FORCE DYNAMIC: Ensure the dashboard list is always fresh
export const dynamic = 'force-dynamic';
export const revalidate = 0;

const allEditableContentQuery = groq`
*[_type in $allowedTypes] | order(_updatedAt desc) {
    _id,
    _type,
    _updatedAt,
    title,
    "slug": slug.current,
    "status": select(
        _id in path("drafts.**") => "draft",
        _type == "gameRelease" => "published",
        defined(publishedAt) && publishedAt > now() => "scheduled",
        defined(publishedAt) && publishedAt < now() => "published",
        "draft"
    ),
    "mainImage": mainImage,
    "blurDataURL": mainImage.asset->metadata.lqip
}
`;

export default async function StudioPage() {
    const session = await getServerSession(authOptions);
    
    let userRoles: string[] = [];
    if (session?.user?.id) {
        const user = await prisma.user.findUnique({ 
            where: { id: session.user.id },
            select: { roles: { select: { name: true } } }
        });
        userRoles = user?.roles.map((r: any) => r.name) || [];
    }
    
    const isAdminOrDirector =
        userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');

    const allowedContentTypes: string[] = [];

    if (isAdminOrDirector) {
        allowedContentTypes.push('review', 'article', 'news', 'gameRelease');
    } else {
        if (userRoles.includes('REVIEWER')) allowedContentTypes.push('review');
        if (userRoles.includes('AUTHOR')) allowedContentTypes.push('article');
        if (userRoles.includes('REPORTER')) allowedContentTypes.push('news');
    }

    if (allowedContentTypes.length === 0 && !userRoles.includes('DESIGNER')) {
        redirect('/');
    }

    // CRITICAL FIX: Added no-store cache option to dashboard list fetch
    const content =
        allowedContentTypes.length > 0
            ? await sanityWriteClient.fetch(
                  allEditableContentQuery, 
                  { allowedTypes: allowedContentTypes },
                  { cache: 'no-store', next: { revalidate: 0 } }
              )
            : [];

    return (
        <div className="container page-container">
            <StudioDashboard
                initialContent={content}
                userRoles={userRoles}
            />
        </div>
    );
}

--- END OF FILE app/studio/page.tsx ---

================================================================================

--- START OF FILE app/studio/tiptap.d.ts ---

// app/studio/tiptap.d.ts
import '@tiptap/core';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    youtube: {
      /**
       * Inserts a YouTube video embed.
       */
      setYoutubeVideo: (options: { src: string }) => ReturnType;
    };
  }
}




--- END OF FILE app/studio/tiptap.d.ts ---

================================================================================

--- START OF FILE app/studio/director/EditRolesModal.tsx ---

// app/studio/director/EditRolesModal.tsx
'use client';

import { useState, useTransition, useMemo } from 'react';
import { updateUserRolesAction } from './actions';
import { useToast } from '@/lib/toastStore';
import type { User, Role } from '@/lib/generated/client';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { translateRole } from '@/lib/translations';

type UserWithRoles = User & { roles: { name: string }[] };

export function EditRolesModal({ user, allRoles, onClose, onUpdate }: { user: UserWithRoles, allRoles: Role[], onClose: () => void, onUpdate: (userId: string, newRoles: Role[]) => void }) {
    // CORRECTED: Removed the duplicate 'const [' and ensured correct type annotations for map
    const [selectedRoleIds, setSelectedRoleIds] = useState<Set<number>>(() => new Set(user.roles.map((r: any) => allRoles.find(ar => ar.name === r.name)!.id)));
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    const router = useRouter();
    
    const { data: session, update: updateSession } = useSession();
    
    const manageableRoles = useMemo(() => allRoles.filter(role => role.name !== 'USER'), [allRoles]);
    const userRoleId = useMemo(() => allRoles.find(role => role.name === 'USER')?.id, [allRoles]);

    const handleRoleToggle = (roleId: number) => {
        setSelectedRoleIds(prev => {
            const newSet = new Set(prev);
            if (newSet.has(roleId)) {
                newSet.delete(roleId);
            } else {
                newSet.add(roleId);
            }
            return newSet;
        });
    };

    const handleSave = () => {
        startTransition(async () => {
            const finalRoleIds = new Set(selectedRoleIds);
            if (userRoleId) {
                finalRoleIds.add(userRoleId);
            }

            const result = await updateUserRolesAction(user.id, Array.from(finalRoleIds));
            if (result.success && result.updatedRoles) {
                onUpdate(user.id, result.updatedRoles);
                
                // If editing self...
                const currentUserId = (session?.user as any)?.id;
                if (currentUserId && currentUserId === user.id) {
                    await updateSession();
                    router.refresh();
                }

                toast.success(`أدوار ${user.name} حُدِّثت.`);
                onClose();
            } else {
                toast.error(result.message || 'أخفق تحديث الأدوار.');
            }
        });
    };

    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0 }}>تعديل رُتَب {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem' }}>اختر المهام الموكلة لهذا العضو.</p>
            <div className="roles-checklist" style={{ 
                display: 'grid', 
                gridTemplateColumns: '1fr 1fr', 
                gap: '1rem', 
                margin: '2rem 0' 
            }}>
                {manageableRoles.map(role => (
                    <label key={role.id} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', cursor: 'pointer', fontFamily: 'var(--font-main)' }}>
                        <input
                            type="checkbox"
                            checked={selectedRoleIds.has(role.id)}
                            onChange={() => handleRoleToggle(role.id)}
                            style={{ width: '1.6rem', height: '1.6rem' }}
                        />
                        <span style={{ fontWeight: role.name === 'DIRECTOR' ? 700 : 500, color: role.name === 'DIRECTOR' ? 'gold' : 'inherit' }}>
                            {translateRole(role.name)}
                        </span>
                    </label>
                ))}
            </div>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                <button onClick={handleSave} className="primary-button" disabled={isPending}>
                    {isPending ? 'جار الحفظ...' : 'حفظ التغييرات'}
                </button>
            </div>
        </Modal>
    );
}




--- END OF FILE app/studio/director/EditRolesModal.tsx ---

================================================================================

--- START OF FILE app/studio/director/UserManagementClient.tsx ---

// app/studio/director/UserManagementClient.tsx
'use client';

import { useState, useMemo, useTransition } from 'react';
import Image from 'next/image';
import { AnimatePresence, motion } from 'framer-motion';
import { EditRolesModal } from './EditRolesModal';
import type { User, Role } from '@/lib/generated/client';
import { translateRole } from '@/lib/translations';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { toggleUserBanAction } from '@/app/actions/banActions';
import { useToast } from '@/lib/toastStore';
import { useRouter } from 'next/navigation';

// Extended type to include ban status
type UserWithRoles = User & { roles: { name: string }[] };

const BanModal = ({ user, onClose, onConfirm }: { user: UserWithRoles, onClose: () => void, onConfirm: (reason: string) => void }) => {
    const [reason, setReason] = useState('');

    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0, color: '#DC2626' }}>حظر المستخدم: {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem' }}>سيتم منع هذا المستخدم من الوصول إلى الموقع.</p>
            
            <div style={{ margin: '2rem 0' }}>
                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '600' }}>سبب الحظر:</label>
                <textarea 
                    className="profile-input" 
                    rows={3} 
                    value={reason} 
                    onChange={(e) => setReason(e.target.value)} 
                    placeholder="مثال: مخالفة شروط المجتمع..."
                />
            </div>

            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button 
                    onClick={() => onConfirm(reason)} 
                    className="primary-button delete-forever"
                    disabled={!reason.trim()}
                >
                    تأكيد الحظر
                </button>
            </div>
        </Modal>
    );
};

const UnbanModal = ({ user, onClose, onConfirm }: { user: UserWithRoles, onClose: () => void, onConfirm: () => void }) => {
    return (
        <Modal isOpen={!!user} onClose={onClose}>
            <h3 style={{ marginTop: 0 }}>رفع الحظر عن {user.name}</h3>
            <p style={{ color: 'var(--text-secondary)' }}>هل أنت متأكد من استعادة صلاحيات هذا المستخدم؟</p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={onConfirm} className="primary-button">تأكيد رفع الحظر</button>
            </div>
        </Modal>
    );
};

const UserRow = ({ user, allRoles, onEdit, onBanClick }: { user: UserWithRoles, allRoles: Role[], onEdit: (user: UserWithRoles) => void, onBanClick: (user: UserWithRoles) => void }) => {
    const currentRoleNames = user.roles.map((r: any) => r.name);
    const rolesToDisplay = currentRoleNames.filter((name: string) => name !== 'USER').sort();
    const displayString = rolesToDisplay.length > 0 ? rolesToDisplay.map(translateRole).join('، ') : 'عضو (افتراضي)';
    
    const isBanned = user.isBanned;

    return (
        <motion.div
            layout
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3 }}
            className={`user-row ${isBanned ? 'banned' : ''}`}
        >
            <div className="user-info">
                <div style={{ position: 'relative' }}>
                    <Image src={user.image || '/default-avatar.svg'} alt={user.name || 'avatar'} width={40} height={40} className="user-avatar" style={{ filter: isBanned ? 'grayscale(100%)' : 'none' }} />
                    {isBanned && <div style={{ position: 'absolute', bottom: -2, right: -2, width: 14, height: 14, background: '#DC2626', borderRadius: '50%', border: '2px solid var(--bg-secondary)' }} />}
                </div>
                <div>
                    <p className="user-name" style={{ color: isBanned ? '#DC2626' : 'inherit', textDecoration: isBanned ? 'line-through' : 'none' }}>{user.name}</p>
                    <p className="user-email">{user.email}</p>
                </div>
            </div>
            <div className="user-roles">
                <span className="roles-badge">{displayString}</span>
            </div>
            <div className="user-actions">
                <button className="outline-button" onClick={() => onEdit(user)} disabled={isBanned} style={{ opacity: isBanned ? 0.5 : 1 }}>الرتب</button>
                <button 
                    className="outline-button" 
                    onClick={() => onBanClick(user)}
                    style={{ 
                        borderColor: isBanned ? 'var(--border-color)' : '#DC2626', 
                        color: isBanned ? 'var(--text-secondary)' : '#DC2626',
                        backgroundColor: isBanned ? 'transparent' : 'rgba(220, 38, 38, 0.05)'
                    }}
                >
                    {isBanned ? 'رفع الحظر' : 'حظر'}
                </button>
            </div>
        </motion.div>
    );
};

export function UserManagementClient({ initialUsers, allRoles }: { initialUsers: UserWithRoles[], allRoles: Role[] }) {
    const [users, setUsers] = useState<UserWithRoles[]>(initialUsers);
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedUser, setSelectedUser] = useState<UserWithRoles | null>(null);
    
    // Ban Modal State
    const [userToBan, setUserToBan] = useState<UserWithRoles | null>(null);
    const [userToUnban, setUserToUnban] = useState<UserWithRoles | null>(null);
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    const router = useRouter();

    const filteredUsers = useMemo(() => {
        if (!searchTerm) return users;
        return users.filter(u =>
            u.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
            u.email?.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [users, searchTerm]);

    const handleUpdateUserRoles = (userId: string, newRoles: Role[]) => {
        setUsers(currentUsers => currentUsers.map(u => 
            u.id === userId ? { ...u, roles: newRoles.map(r => ({ name: r.name })) } : u
        ));
    };
    
    // Ban Handlers
    const handleBan = (reason: string) => {
        if (!userToBan) return;
        const userId = userToBan.id;
        
        startTransition(async () => {
            const result = await toggleUserBanAction(userId, reason, true);
            if (result.success) {
                setUsers(current => current.map(u => u.id === userId ? { ...u, isBanned: true, banReason: reason } : u));
                toast.success(result.message);
                setUserToBan(null);
                router.refresh(); // Update server components to reflect changes
            } else {
                toast.error(result.message);
            }
        });
    };

    const handleUnban = () => {
        if (!userToUnban) return;
        const userId = userToUnban.id;

        startTransition(async () => {
            const result = await toggleUserBanAction(userId, '', false);
            if (result.success) {
                setUsers(current => current.map(u => u.id === userId ? { ...u, isBanned: false, banReason: null } : u));
                toast.success(result.message);
                setUserToUnban(null);
                router.refresh();
            } else {
                toast.error(result.message);
            }
        });
    };

    const onBanButtonClick = (user: UserWithRoles) => {
        if (user.isBanned) {
            setUserToUnban(user);
        } else {
            setUserToBan(user);
        }
    };

    return (
        <>
            <style jsx>{`
                .user-management-container { max-width: 960px; margin: 0 auto; }
                .search-input { width: 100%; margin-bottom: 2rem; }
                .user-list-header, .user-row { 
                    display: grid; 
                    grid-template-columns: 2fr 1.5fr 1fr; /* Increased last col width */
                    align-items: center; 
                    gap: 1rem; 
                    padding: 1rem; 
                    border-bottom: 1px solid var(--border-color); 
                }
                .user-row.banned {
                    background-color: rgba(220, 38, 38, 0.05);
                }
                .user-list-header { font-weight: 600; color: var(--text-secondary); font-family: var(--font-main); }
                .user-info { display: flex; align-items: center; gap: 1rem; }
                .user-name { font-weight: 600; margin: 0; }
                .user-email { font-size: 1.4rem; color: var(--text-secondary); margin: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;}
                .roles-badge { 
                    background-color: var(--bg-secondary); 
                    padding: 0.4rem 0.8rem; 
                    border-radius: 6px; 
                    font-size: 1.3rem; 
                    border: 1px solid var(--border-color); 
                    white-space: nowrap; 
                    overflow: hidden; 
                    text-overflow: ellipsis;
                }
                .user-actions { text-align: left; display: flex; justify-content: flex-end; gap: 0.5rem; }

                @media (max-width: 768px) {
                    .user-list-header { display: none; }
                    .user-row { grid-template-columns: 1fr; gap: 1.5rem; padding: 1.5rem; }
                    .user-info { grid-column: 1; }
                    .user-roles { grid-column: 1; justify-self: start; }
                    .user-actions { grid-column: 1; width: 100%; justify-content: space-between; }
                }
            `}</style>
            <div className="user-management-container">
                <input type="search" placeholder="ابحث بالاسم أو البريد..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="profile-input search-input" />
                <div className="user-list">
                    <div className="user-list-header">
                        <span>العضو</span>
                        <span>الرتب</span>
                        <span>الإجراءات</span>
                    </div>
                    <AnimatePresence>
                        {filteredUsers.map(user => (
                            <UserRow key={user.id} user={user} allRoles={allRoles} onEdit={setSelectedUser} onBanClick={onBanButtonClick} />
                        ))}
                    </AnimatePresence>
                </div>
            </div>
            
            <AnimatePresence>
                {selectedUser && ( <EditRolesModal user={selectedUser} allRoles={allRoles} onClose={() => setSelectedUser(null)} onUpdate={handleUpdateUserRoles} /> )}
                {userToBan && ( <BanModal user={userToBan} onClose={() => setUserToBan(null)} onConfirm={handleBan} /> )}
                {userToUnban && ( <UnbanModal user={userToUnban} onClose={() => setUserToUnban(null)} onConfirm={handleUnban} /> )}
            </AnimatePresence>
        </>
    );
}




--- END OF FILE app/studio/director/UserManagementClient.tsx ---

================================================================================

--- START OF FILE app/studio/director/actions.ts ---

// app/studio/director/actions.ts
'use server';

import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/lib/authOptions";
import prisma from "@/lib/prisma";
import { revalidatePath, revalidateTag } from "next/cache";
import { Role } from "@/lib/generated/client";
import { sanityWriteClient } from "@/lib/sanity.server";
import { isSafeImageUrl } from "@/lib/security"; // SECURITY IMPORT

const ROLE_TO_SANITY_TYPE: Record<string, string> = {
    REVIEWER: 'reviewer',
    AUTHOR: 'author',
    REPORTER: 'reporter',
    DESIGNER: 'designer',
};

async function findOrCreateSanityCreator(userId: string, sanityType: string) {
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { id: true, name: true, image: true } });
    if (!user || !user.name) throw new Error('بيانات العضو غير مكتملة.');

    const existingCreator = await sanityWriteClient.fetch(`*[_type == "${sanityType}" && prismaUserId == $userId][0]`, { userId });

    if (existingCreator) {
        return; 
    }

    const newCreator: any = {
        _type: sanityType,
        _id: `${sanityType}-${userId}`,
        name: user.name,
        prismaUserId: user.id,
    };
    
    if (user.image) {
        // SECURITY: SSRF Protection
        if (isSafeImageUrl(user.image)) {
            try {
                const response = await fetch(user.image);
                if (!response.ok) throw new Error(`Failed to fetch image: ${response.status}`);
                
                const imageBlob = await response.blob();
                const imageAsset = await sanityWriteClient.assets.upload('image', imageBlob, {
                    contentType: imageBlob.type,
                    filename: `${user.id}-avatar.jpg`
                });
                newCreator.image = { _type: 'image', asset: { _type: 'reference', _ref: imageAsset._id } };
            } catch (e) {
                console.warn(`[Security/Sync] Skipped image upload for ${user.name}:`, e);
            }
        } else {
             console.warn(`[Security/Sync] Blocked potential SSRF image URL for ${user.name}: ${user.image}`);
        }
    }

    await sanityWriteClient.create(newCreator);
}

export async function updateUserRolesAction(userId: string, roleIds: number[]) {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.roles.includes('DIRECTOR')) {
        return { success: false, message: "غير مُصرَّح لك بهذا الإجراء." };
    }

    try {
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { roles: { set: roleIds.map(id => ({ id })) } },
            include: { roles: true }
        });

        const userRoles = updatedUser.roles.map((r: any) => r.name);
        
        for (const roleName of userRoles) {
            const sanityType = ROLE_TO_SANITY_TYPE[roleName];
            if (sanityType) {
                try {
                    await findOrCreateSanityCreator(userId, sanityType);
                } catch (sanityError: any) {
                    console.error(`Failed to sync Sanity ${sanityType} for user ${userId}:`, sanityError.message);
                }
            }
        }
        
        revalidateTag('enriched-creators', 'max');
        revalidateTag('enriched-creator-details', 'max');
        revalidateTag('studio-metadata', 'max'); 

        revalidatePath('/studio/director');
        revalidatePath(`/profile/${userId}`);
        if(updatedUser.username) {
            revalidatePath(`/creators/${updatedUser.username}`);
        }

        return { success: true, updatedRoles: updatedUser.roles as Role[] };
    } catch (error) {
        console.error("Failed to update user roles:", error);
        return { success: false, message: "حدث خطأ أثناء التحديث في قاعدة البيانات." };
    }
}

--- END OF FILE app/studio/director/actions.ts ---

================================================================================

--- START OF FILE app/studio/director/page.tsx ---

// app/studio/director/page.tsx

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { redirect } from 'next/navigation';
import prisma from '@/lib/prisma';
import { UserManagementClient } from './UserManagementClient';
import { unstable_noStore as noStore } from 'next/cache';

export default async function DirectorPage() {
    noStore(); 

    const session = await getServerSession(authOptions);
    
    let userRoles: string[] = [];
    if (session?.user?.id) {
        const user = await prisma.user.findUnique({ 
            where: { id: session.user.id },
            select: { roles: { select: { name: true } } }
        });
        userRoles = user?.roles.map((r: any) => r.name) || [];
    }

    if (!userRoles.includes('DIRECTOR')) {
        redirect('/studio');
    }

    const users = await prisma.user.findMany({
        include: {
            roles: {
                select: { name: true }
            }
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    const allRoles = await prisma.role.findMany();

    return (
        <div className="container page-container">
            <header style={{ textAlign: 'center', marginBottom: '3rem' }}>
                <h1 className="page-title">إدارة الديوان</h1>
                <p className="sidebar-subtitle" style={{ fontSize: '1.8rem', maxWidth: '600px', margin: '0 auto' }}>
                    تحكَّم في رُتَب الأعضاء وصلاحياتهم. التغييراتُ نافذةٌ فورًا.
                </p>
            </header>
            <UserManagementClient initialUsers={users} allRoles={allRoles} />
        </div>
    );
}




--- END OF FILE app/studio/director/page.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/actions.ts ---

'use server';

import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';
import { getAuthenticatedSession } from '@/lib/auth';

// Shared projection for consistent data structure
// Added pros and cons for reviews
const templateProjection = `
  _id,
  _type,
  title,
  "slug": slug.current,
  "imageUrl": mainImage.asset->url,
  publishedAt,
  newsType,
  score,
  "verdict": verdict,
  "pros": pros,
  "cons": cons,
  "gameTitle": game->title,
  "synopsis": synopsis,
  // Ensure we get text even if it's just a raw block array
  "excerpt": pt::text(content)
`;

const searchContentQuery = groq`
  *[_type in ["news", "review", "article"] && (title match $query + "*" || pt::text(content) match $query + "*")] | order(publishedAt desc)[0...10] {
    ${templateProjection}
  }
`;

const latestContentQuery = groq`
  *[_type in ["news", "review", "article"]] | order(publishedAt desc)[0...10] {
    ${templateProjection}
  }
`;

export async function searchContentForTemplateAction(query: string) {
    await getAuthenticatedSession(); // Ensure auth

    try {
        if (!query || query.trim() === '') {
            const results = await client.fetch(latestContentQuery);
            return results;
        }

        // FIX: Cast params to any to silence strict type error
        const results = await client.fetch(searchContentQuery, { query } as any);
        return results;
    } catch (error) {
        console.error("Smart Fill Search Error:", error);
        return [];
    }
}




--- END OF FILE app/studio/social-templates/actions.ts ---

================================================================================

--- START OF FILE app/studio/social-templates/page.tsx ---

import Link from 'next/link';
import { CardProps } from '@/types';
import { ContentBlock } from '@/components/ContentBlock';
import styles from '@/components/studio/social/SocialEditor.module.css';

export default function SocialTemplatesDashboard() {
    return (
        <div className="container page-container">
            <h1 className="page-title">قوالب التواصل الاجتماعي</h1>
            <p style={{ color: 'var(--text-secondary)', marginBottom: '4rem', textAlign: 'center' }}>
                أنشئ محتوى بصري احترافي لمنصات التواصل الاجتماعي بسرعة فائقة.
            </p>

            <ContentBlock title="القوالب المتاحة">
                <div className={styles.templateGrid}>
                    {/* Instagram News Template Card */}
                    <Link href="/studio/social-templates/instagram-news" className="no-underline">
                        <div className={styles.templateCard}>
                            <div className={styles.templatePreview}>
                                <span>IG News</span>
                            </div>
                            <div style={{ padding: '1.5rem', textAlign: 'right' }}>
                                <h3 style={{ margin: '0 0 0.5rem 0', color: 'var(--text-primary)' }}>خبر إنستغرام (Titan)</h3>
                                <p style={{ margin: 0, color: 'var(--text-secondary)', fontSize: '1.4rem' }}>
                                    تصميم سايبربنك للأخبار العاجلة والإشاعات.
                                </p>
                            </div>
                        </div>
                    </Link>

                    {/* Review Card Template */}
                    <Link href="/studio/social-templates/review-card" className="no-underline">
                        <div className={styles.templateCard}>
                            <div className={styles.templatePreview} style={{ background: 'linear-gradient(135deg, #1a1a1a 0%, #0d0d0d 100%)' }}>
                                <span style={{ color: '#00FFF0' }}>Review</span>
                            </div>
                            <div style={{ padding: '1.5rem', textAlign: 'right' }}>
                                <h3 style={{ margin: '0 0 0.5rem 0', color: 'var(--text-primary)' }}>بطاقة مراجعة</h3>
                                <p style={{ margin: 0, color: 'var(--text-secondary)', fontSize: '1.4rem' }}>
                                    التقييم، الإيجابيات، والسلبيات بتصميم موشور.
                                </p>
                            </div>
                        </div>
                    </Link>

                     {/* Monthly Games Template */}
                     <Link href="/studio/social-templates/monthly-games" className="no-underline">
                        <div className={styles.templateCard}>
                            <div className={styles.templatePreview} style={{ background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)' }}>
                                <span style={{ color: '#FACC15' }}>Monthly</span>
                            </div>
                            <div style={{ padding: '1.5rem', textAlign: 'right' }}>
                                <h3 style={{ margin: '0 0 0.5rem 0', color: 'var(--text-primary)' }}>ألعاب الشهر</h3>
                                <p style={{ margin: 0, color: 'var(--text-secondary)', fontSize: '1.4rem' }}>
                                    جدول إصدارات شهري لـ 9 ألعاب مع منصات.
                                </p>
                            </div>
                        </div>
                    </Link>

                    {/* Weekly News Template (NEW) */}
                    <Link href="/studio/social-templates/weekly-news" className="no-underline">
                        <div className={styles.templateCard}>
                            <div className={styles.templatePreview} style={{ background: 'linear-gradient(135deg, #10121A 0%, #050505 100%)' }}>
                                <span style={{ color: '#00FFF0', fontSize: '2rem' }}>Weekly</span>
                            </div>
                            <div style={{ padding: '1.5rem', textAlign: 'right' }}>
                                <h3 style={{ margin: '0 0 0.5rem 0', color: 'var(--text-primary)' }}>النشرة الأسبوعية</h3>
                                <p style={{ margin: 0, color: 'var(--text-secondary)', fontSize: '1.4rem' }}>
                                    ملخص لأهم الأحداث وأخبار الأسبوع في صورة واحدة.
                                </p>
                            </div>
                        </div>
                    </Link>
                </div>
            </ContentBlock>
        </div>
    );
}




--- END OF FILE app/studio/social-templates/page.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/instagram-news/page.tsx ---

// app/studio/social-templates/instagram-news/page.tsx
'use client';

import { useState, useRef, useEffect, useTransition } from 'react';
import InstagramNewsCanvas, { TemplateData } from '@/components/studio/social/InstagramNewsCanvas';
import SmartFiller from '@/components/studio/social/SmartFiller';
import styles from '@/components/studio/social/SocialEditor.module.css';
import { motion, AnimatePresence } from 'framer-motion';
import { downloadElementAsImage } from '@/lib/image-export';
import { useToast } from '@/lib/toastStore';
import { SparklesIcon } from '@/components/icons';
import { smartSplitText } from '@/lib/text-utils';
import { useBodyClass } from '@/hooks/useBodyClass';

// Use the type exported from the component to ensure consistency
type SlideData = TemplateData & { id: string };

const DEFAULT_SLIDE: SlideData = {
    id: 'default',
    titleTop: 'عنوان الخبر',
    titleBottom: 'تفاصيل إضافية',
    subTitle: '',
    body: 'نص الخبر يظهر هنا. يمكنك النقر على زر "الملء الذكي" لجلب البيانات من المقالات والأخبار الموجودة على الموقع مباشرة.',
    source: 'المصدر: EternalGames',
    image: 'https://images.unsplash.com/photo-1614145121029-83a9f7cafd8e?q=80&w=1080&auto=format&fit=crop',
    imageSettings: { x: 0, y: 0, scale: 1 },
    type: 'official',
    footerHandle: '@ETERNALGAMES_NET'
};

const ChevronDownIcon = () => (
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9l6 6 6-6"/></svg>
);
const ArrowLeftIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15 18l-6-6 6-6"/></svg>;
const ArrowRightIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 18l6-6-6-6"/></svg>;
const PlusIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
const TrashIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const SettingsIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;
const CanvasIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>;
const DownloadIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;

export default function InstagramNewsEditor() {
    useBodyClass('editor-active');

    const [slides, setSlides] = useState<SlideData[]>([{ ...DEFAULT_SLIDE, id: crypto.randomUUID() }]);
    const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
    
    const [scale, setScale] = useState(0.4);
    const [isFillerOpen, setIsFillerOpen] = useState(false);
    const [isExportMenuOpen, setIsExportMenuOpen] = useState(false);
    const [isExporting, startExport] = useTransition();
    const canvasWrapperRef = useRef<HTMLDivElement>(null);
    const toast = useToast();
    
    const [activeTab, setActiveTab] = useState<'sidebar' | 'canvas'>('canvas');
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (!canvasWrapperRef.current) return;
        
        const updateScale = () => {
            if (!canvasWrapperRef.current) return;
            const { width, height } = canvasWrapperRef.current.getBoundingClientRect();
            // Maximize space: small padding
            const padding = 40; 
            const availableWidth = width - padding;
            const availableHeight = height - padding;
            
            const scaleX = availableWidth / 1080;
            const scaleY = availableHeight / 1350;
            
            const cap = isMobile ? 1 : 0.95;
            const newScale = Math.min(scaleX, scaleY, cap);
            setScale(newScale);
        };

        const resizeObserver = new ResizeObserver(() => {
            requestAnimationFrame(updateScale);
        });
        
        resizeObserver.observe(canvasWrapperRef.current);
        updateScale(); 

        return () => resizeObserver.disconnect();
    }, [isMobile]);

    const handleSmartSelect = (item: any) => {
        let type: 'official' | 'rumor' | 'leak' = 'official';
        if (item.newsType) type = item.newsType; 
        
        const words = item.title.split(' ');
        const mid = Math.ceil(words.length / 2);
        const top = words.slice(0, mid).join(' ');
        const bottom = words.slice(mid).join(' ');

        let fullBodyText = "";
        if (item._type === 'review') {
            const parts = [];
            if (item.verdict) parts.push(`الخلاصة: ${item.verdict}`);
            if (item.score) parts.push(`التقييم: ${item.score}/10`);
            if (item.pros && item.pros.length > 0) parts.push(`\nالمحاسن:\n+ ${item.pros.slice(0, 2).join('\n+ ')}`);
            if (item.cons && item.cons.length > 0) parts.push(`\nالمساوئ:\n- ${item.cons.slice(0, 2).join('\n- ')}`);
            fullBodyText = parts.join('\n\n');
        } else if (item._type === 'gameRelease') {
            fullBodyText = item.synopsis || "";
        } else {
            fullBodyText = item.excerpt || "";
            if (!fullBodyText && item.synopsis) fullBodyText = item.synopsis;
        }

        if (!fullBodyText.trim()) fullBodyText = item.title;

        const textChunks = smartSplitText(fullBodyText, 350);
        
        const newSlides = textChunks.map((chunk) => ({
            id: crypto.randomUUID(),
            titleTop: top || item.title,
            titleBottom: bottom || '',
            subTitle: '',
            body: chunk,
            image: item.imageUrl || DEFAULT_SLIDE.image,
            imageSettings: { x: 0, y: 0, scale: 1 },
            type: type,
            source: item.gameTitle ? `المصدر: ${item.gameTitle}` : (item._type === 'review' ? 'مراجعة: EternalGames' : 'المصدر: خاص'),
            footerHandle: DEFAULT_SLIDE.footerHandle
        }));

        setSlides(newSlides);
        setCurrentSlideIndex(0);
        toast.success(`تم إنشاء ${newSlides.length} شرائح.`);
        
        if (isMobile) setActiveTab('canvas');
    };

    const updateCurrentSlide = (newData: Partial<SlideData>) => {
        setSlides(prev => {
            const newSlides = [...prev];
            newSlides[currentSlideIndex] = { ...newSlides[currentSlideIndex], ...newData };
            return newSlides;
        });
    };

    const handleAddSlide = () => {
        const currentSlide = slides[currentSlideIndex];
        const newSlide: SlideData = { 
            ...currentSlide, 
            id: crypto.randomUUID(),
            body: 'نص الشريحة الجديدة...',
            imageSettings: { ...currentSlide.imageSettings! }
        };
        
        const newSlides = [...slides];
        newSlides.splice(currentSlideIndex + 1, 0, newSlide);
        setSlides(newSlides);
        setCurrentSlideIndex(currentSlideIndex + 1);
    };

    const handleDeleteSlide = () => {
        if (slides.length <= 1) return;
        const newSlides = slides.filter((_, i) => i !== currentSlideIndex);
        setSlides(newSlides);
        if (currentSlideIndex >= newSlides.length) {
            setCurrentSlideIndex(newSlides.length - 1);
        }
    };

    const handleDownload = (format: 'png' | 'jpeg', quality: number = 0.9) => {
        setIsExportMenuOpen(false);
        startExport(async () => {
            try {
                // MODIFIED: 2x scale for 4K
                await downloadElementAsImage('instagram-news-canvas', `ig-news-${Date.now()}`, format, 2, quality);
                toast.success(`تم التنزيل (${format.toUpperCase()}) - 4K`);
            } catch (e) {
                console.error(e);
                toast.error("فشل التصدير.");
            }
        });
    };

    const currentSlide = slides[currentSlideIndex];

    return (
        <div className={styles.editorContainer}>
            <div className={styles.mainArea}>
                {/* Sidebar Controls */}
                {(!isMobile || activeTab === 'sidebar') && (
                    <div className={styles.sidebar}>
                        <div className={styles.sidebarHeader}>
                             <h2 className={styles.sidebarTitle}>قالب: خبر Instagram</h2>
                        </div>

                        <div className={styles.controlGroup}>
                            <button className={styles.smartFillButton} onClick={() => setIsFillerOpen(true)}>
                                <SparklesIcon width={20} height={20} />
                                <span>الملء الذكي</span>
                            </button>
                            
                            <div className={styles.downloadGroup}>
                                <button className={styles.downloadButton} onClick={() => handleDownload('jpeg', 0.9)} disabled={isExporting}>
                                    <DownloadIcon />
                                    <span style={{ marginRight: '0.8rem' }}>تحميل 4K (JPG)</span>
                                </button>
                                <button className={styles.dropdownTrigger} onClick={() => setIsExportMenuOpen(!isExportMenuOpen)} disabled={isExporting}>
                                    <motion.div animate={{ rotate: isExportMenuOpen ? 180 : 0 }}>
                                        <ChevronDownIcon />
                                    </motion.div>
                                </button>
                            </div>
                             <AnimatePresence>
                                {isExportMenuOpen && (
                                    <motion.div className={styles.dropdownMenu} initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}>
                                        <button className={styles.dropdownItem} onClick={() => handleDownload('png')}>تحميل 4K (PNG)</button>
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>

                        <div className={styles.controlGroup}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                <label className={styles.label}>الشرائح (Slides)</label>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <button className="icon-button outline-button" onClick={handleAddSlide} title="إضافة" style={{ padding: '0.5rem 1rem', height: 'auto', display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '1.2rem', fontWeight: 600 }}>
                                        <PlusIcon />
                                        <span>إضافة</span>
                                    </button>
                                    {slides.length > 1 && (
                                        <button className="icon-button outline-button" onClick={handleDeleteSlide} title="حذف" style={{ padding: '0.5rem', height: 'auto', color: '#DC2626', borderColor: '#DC2626' }}>
                                            <TrashIcon />
                                        </button>
                                    )}
                                </div>
                            </div>
                            
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', background: 'var(--bg-primary)', padding: '0.5rem', borderRadius: '6px', border: '1px solid var(--border-color)' }}>
                                <button className="icon-button" onClick={() => setCurrentSlideIndex(Math.max(0, currentSlideIndex - 1))} disabled={currentSlideIndex === 0} style={{ opacity: currentSlideIndex === 0 ? 0.3 : 1 }}>
                                    <ArrowRightIcon />
                                </button>
                                <span style={{ fontSize: '1.4rem', fontWeight: 600 }}>{currentSlideIndex + 1} / {slides.length}</span>
                                <button className="icon-button" onClick={() => setCurrentSlideIndex(Math.min(slides.length - 1, currentSlideIndex + 1))} disabled={currentSlideIndex === slides.length - 1} style={{ opacity: currentSlideIndex === slides.length - 1 ? 0.3 : 1 }}>
                                    <ArrowLeftIcon />
                                </button>
                            </div>
                        </div>

                        <div className={styles.controlGroup}>
                            <label className={styles.label}>التصنيف</label>
                            <div className={styles.typeGrid}>
                                {['official', 'rumor', 'leak'].map(t => (
                                    <button key={t} className={`${styles.typeButton} ${currentSlide.type === t ? styles.active : ''}`} onClick={() => updateCurrentSlide({ type: t as any })} data-type={t}>
                                        {t === 'official' ? 'رسمي' : t === 'rumor' ? 'إشاعة' : 'تسريب'}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>العنوان الرئيسي</label>
                            <input className={styles.input} value={currentSlide.titleTop} onChange={e => updateCurrentSlide({ titleTop: e.target.value })} />
                        </div>
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>العنوان الفرعي</label>
                            <input className={styles.input} value={currentSlide.titleBottom} onChange={e => updateCurrentSlide({ titleBottom: e.target.value })} />
                        </div>
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>النص (محرر ذكي متاح في المعاينة)</label>
                            {/* NOTE: Text area removed here since editing is done in-canvas */}
                            <div className={styles.input} style={{opacity: 0.7, fontSize: '1.2rem'}}>اضغط على النص في التصميم للتعديل</div>
                        </div>
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>المصدر</label>
                            <input className={styles.input} value={currentSlide.source} onChange={e => updateCurrentSlide({ source: e.target.value })} />
                        </div>
                    </div>
                )}

                {/* Main Canvas Area */}
                {(!isMobile || activeTab === 'canvas') && (
                    <div className={styles.canvasWrapper} ref={canvasWrapperRef}>
                        <InstagramNewsCanvas 
                            data={currentSlide}
                            onDataChange={updateCurrentSlide}
                            scale={scale} 
                            currentSlide={currentSlideIndex}
                            totalSlides={slides.length}
                        />
                    </div>
                )}
            </div>

            {/* Mobile Tabs */}
            {isMobile && (
                <div className={styles.mobileToggleBar}>
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'sidebar' ? styles.active : ''}`} onClick={() => setActiveTab('sidebar')}>
                        <SettingsIcon />
                        <span>الإعدادات</span>
                    </button>
                    <div className={styles.mobileDivider} />
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'canvas' ? styles.active : ''}`} onClick={() => setActiveTab('canvas')}>
                        <CanvasIcon />
                        <span>التصميم</span>
                    </button>
                </div>
            )}

            <SmartFiller isOpen={isFillerOpen} onClose={() => setIsFillerOpen(false)} onSelect={handleSmartSelect} />
        </div>
    );
}




--- END OF FILE app/studio/social-templates/instagram-news/page.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/monthly-games/actions.ts ---

// app/studio/social-templates/monthly-games/actions.ts
'use server';

import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

export interface SmartFillRelease {
    _id: string;
    title: string;
    releaseDate: string;
    platforms: string[];
    imageUrl: string;
    price?: string;
    onGamePass?: boolean;
    onPSPlus?: boolean;
}

export async function getReleasesForMonthAction(dateString: string): Promise<SmartFillRelease[]> {
    // dateString format "YYYY-MM"
    if (!dateString) return [];

    const [yearStr, monthStr] = dateString.split('-');
    const year = parseInt(yearStr, 10);
    const month = parseInt(monthStr, 10) - 1; // JS months are 0-indexed

    // Calculate start and end dates for the query
    const startDate = new Date(Date.UTC(year, month, 1));
    const endDate = new Date(Date.UTC(year, month + 1, 0)); // Last day of month

    const startIso = startDate.toISOString().split('T')[0];
    const endIso = endDate.toISOString().split('T')[0];

    const query = groq`
        *[_type == "gameRelease" && releaseDate >= $startIso && releaseDate <= $endIso] | order(releaseDate asc) {
            _id,
            title,
            releaseDate,
            platforms,
            // UPDATED: Prioritize vertical image, fallback to standard mainImage
            "imageUrl": coalesce(mainImageVertical.asset->url, mainImage.asset->url),
            price,
            "onGamePass": coalesce(onGamePass, false),
            "onPSPlus": coalesce(onPSPlus, false)
        }
    `;

    try {
        const results = await client.fetch(query, { startIso, endIso });
        return results;
    } catch (error) {
        console.error("Failed to fetch releases:", error);
        return [];
    }
}

--- END OF FILE app/studio/social-templates/monthly-games/actions.ts ---

================================================================================

--- START OF FILE app/studio/social-templates/monthly-games/page.tsx ---

// app/studio/social-templates/monthly-games/page.tsx
'use client';

import { useState, useRef, useEffect, useTransition } from 'react';
import MonthlyGamesCanvas from '@/components/studio/social/monthly-games/MonthlyGamesCanvas';
import { MonthlyGamesTemplateData, GameSlotData } from '@/components/studio/social/monthly-games/types';
import styles from '@/components/studio/social/SocialEditor.module.css';
import { useToast } from '@/lib/toastStore';
import { downloadElementAsImage } from '@/lib/image-export';
import { useBodyClass } from '@/hooks/useBodyClass';
import { SparklesIcon } from '@/components/icons';
import SmartFillerMonthly from '@/components/studio/social/monthly-games/SmartFillerMonthly';
import { SmartFillRelease } from '@/app/studio/social-templates/monthly-games/actions';
import { motion, AnimatePresence } from 'framer-motion';

const DownloadIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const ChevronDownIcon = () => (<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9l6 6 6-6"/></svg>);

const createEmptySlot = (id: number): GameSlotData => ({
    id,
    title: 'عنوان اللعبة',
    day: '01',
    image: 'https://images.unsplash.com/photo-1518709268805-4e9042af9f23?q=80&w=600&auto=format&fit=crop',
    platforms: { PC: true, PS5: false, XSX: false, NSW: false },
    badges: { 
        gamePass: false, 
        psPlus: false, 
        exclusive: false, 
        price: { active: false, text: '$70' } 
    },
    imageSettings: { x: 0, y: 0, scale: 1 }
});

const DEFAULT_DATA: MonthlyGamesTemplateData = {
    month: 'شهر نوفمبر',
    slots: Array.from({ length: 9 }).map((_, i) => createEmptySlot(i)),
    vibrance: 100 // Default to 100% (Normal)
};

export default function MonthlyGamesEditor() {
    useBodyClass('editor-active');
    
    const [data, setData] = useState<MonthlyGamesTemplateData>(DEFAULT_DATA);
    const [scale, setScale] = useState(0.4);
    const [isExporting, startExport] = useTransition();
    const [isFillerOpen, setIsFillerOpen] = useState(false);
    const canvasWrapperRef = useRef<HTMLDivElement>(null);
    const toast = useToast();
    const [isMobile, setIsMobile] = useState(false);
    
    // Dropdown state for download options
    const [isExportMenuOpen, setIsExportMenuOpen] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (!canvasWrapperRef.current) return;
        const updateScale = () => {
            if (!canvasWrapperRef.current) return;
            const { width, height } = canvasWrapperRef.current.getBoundingClientRect();
            const padding = 40; 
            const availableWidth = width - padding;
            const availableHeight = height - padding;
            const scaleX = availableWidth / 1080;
            const scaleY = availableHeight / 1350;
            const cap = isMobile ? 1 : 0.95;
            const newScale = Math.min(scaleX, scaleY, cap);
            setScale(newScale);
        };
        const resizeObserver = new ResizeObserver(() => requestAnimationFrame(updateScale));
        resizeObserver.observe(canvasWrapperRef.current);
        updateScale(); 
        return () => resizeObserver.disconnect();
    }, [isMobile]);

    const updateData = (newData: Partial<MonthlyGamesTemplateData>) => {
        setData(prev => ({ ...prev, ...newData }));
    };

    const handleDownload = (format: 'png' | 'jpeg', quality: number = 0.9) => {
        setIsExportMenuOpen(false);
        startExport(async () => {
            try {
                // MODIFIED: Pass scale: 2 for 4K (2160x2700) and quality
                await downloadElementAsImage('monthly-games-canvas', `monthly-games-${Date.now()}`, format, 2, quality);
                toast.success(`تم التنزيل (${format.toUpperCase()}) - 4K`);
            } catch (e) {
                console.error(e);
                toast.error("فشل التصدير.");
            }
        });
    };

    const handleSmartFillApply = (selectedReleases: SmartFillRelease[], monthName: string) => {
        const newSlots = [...data.slots];

        selectedReleases.forEach((release, index) => {
            if (index < 9) {
                const day = release.releaseDate.split('-')[2];
                const platforms = release.platforms || [];
                
                newSlots[index] = {
                    ...newSlots[index],
                    title: release.title,
                    day: day,
                    image: release.imageUrl,
                    platforms: {
                        PC: platforms.includes('PC'),
                        PS5: platforms.some(p => p.includes('PlayStation')),
                        XSX: platforms.some(p => p.includes('Xbox')),
                        NSW: platforms.some(p => p.includes('Switch')),
                    },
                    badges: {
                        gamePass: release.onGamePass || false,
                        psPlus: release.onPSPlus || false,
                        exclusive: false, // Default false, requires manual set
                        price: {
                            active: !!release.price,
                            text: release.price || '$70'
                        }
                    },
                    imageSettings: { x: 0, y: 0, scale: 1 }
                };
            }
        });

        setData({
            ...data,
            month: monthName,
            slots: newSlots
        });
        
        toast.success(`تم ملء ${selectedReleases.length} ألعاب.`);
    };

    return (
        <div className={styles.editorContainer}>
            <div className={styles.mainArea}>
                <div className={styles.sidebar}>
                    <div className={styles.sidebarHeader}>
                        <h2 className={styles.sidebarTitle}>قالب: ألعاب الشهر</h2>
                        <p style={{ color: 'var(--text-secondary)', fontSize: '1.4rem', margin: 0 }}>اضغط على العناصر في التصميم لتعديلها.</p>
                    </div>

                    <div className={styles.controlGroup}>
                        <button className={styles.smartFillButton} onClick={() => setIsFillerOpen(true)}>
                            <SparklesIcon width={20} height={20} />
                            <span>الملء الذكي</span>
                        </button>

                        <div className={styles.downloadGroup}>
                            {/* Primary Action: 4K JPG */}
                            <button className={styles.downloadButton} onClick={() => handleDownload('jpeg', 0.9)} disabled={isExporting}>
                                <DownloadIcon />
                                <span style={{ marginRight: '0.8rem' }}>تحميل 4K (JPG)</span>
                            </button>
                            {/* Dropdown Trigger */}
                            <button className={styles.dropdownTrigger} onClick={() => setIsExportMenuOpen(!isExportMenuOpen)} disabled={isExporting}>
                                <motion.div animate={{ rotate: isExportMenuOpen ? 180 : 0 }}>
                                    <ChevronDownIcon />
                                </motion.div>
                            </button>
                        </div>
                        {/* Dropdown Menu */}
                        <AnimatePresence>
                            {isExportMenuOpen && (
                                <motion.div className={styles.dropdownMenu} initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}>
                                    <button className={styles.dropdownItem} onClick={() => handleDownload('png')}>تحميل 4K (PNG)</button>
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </div>

                    <div className={styles.controlGroup}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <label className={styles.label}>تشبع الألوان (Vibrance)</label>
                            <span style={{ fontSize: '1.2rem', color: 'var(--text-secondary)', fontFamily: 'monospace' }}>{data.vibrance}%</span>
                        </div>
                        <input
                            type="range"
                            min="0"
                            max="200"
                            value={data.vibrance || 100}
                            onChange={(e) => updateData({ vibrance: parseInt(e.target.value) })}
                            style={{ 
                                width: '100%', 
                                cursor: 'pointer',
                                accentColor: 'var(--accent)'
                            }}
                        />
                    </div>
                </div>

                <div className={styles.canvasWrapper} ref={canvasWrapperRef}>
                    <div id="monthly-games-canvas-wrapper" style={{ width: 'fit-content', height: 'fit-content' }}>
                         <MonthlyGamesCanvas 
                            data={data} 
                            onDataChange={updateData} 
                            scale={scale}
                        />
                    </div>
                </div>
            </div>

            <SmartFillerMonthly 
                isOpen={isFillerOpen} 
                onClose={() => setIsFillerOpen(false)} 
                onApply={handleSmartFillApply} 
            />
        </div>
    );
}

--- END OF FILE app/studio/social-templates/monthly-games/page.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/review-card/page.tsx ---

// app/studio/social-templates/review-card/page.tsx
'use client';

import { useState, useRef, useEffect, useTransition } from 'react';
import ReviewCardCanvas from '@/components/studio/social/review-card/ReviewCardCanvas';
import { ReviewTemplateData } from '@/components/studio/social/review-card/types';
import SmartFiller from '@/components/studio/social/SmartFiller';
import styles from '@/components/studio/social/SocialEditor.module.css';
import { motion, AnimatePresence } from 'framer-motion';
import { downloadElementAsImage } from '@/lib/image-export';
import { useToast } from '@/lib/toastStore';
import { SparklesIcon } from '@/components/icons';
import { useBodyClass } from '@/hooks/useBodyClass';
import { stripHtml } from '@/components/studio/social/shared/canvas-utils';

// Default Data State
const DEFAULT_DATA: ReviewTemplateData = {
    id: 'default',
    gameTitleAr: 'اسم اللعبة',
    gameTitleEnTop: 'GAME',
    gameTitleEnBottom: 'TITLE',
    score: '0.0',
    rank: 'PENDING',
    status: 'مراجعة',
    verdict: 'اكتب ملخص المراجعة هنا...',
    pros: ['نقطة إيجابية 1', 'نقطة إيجابية 2', 'نقطة إيجابية 3'],
    cons: ['نقطة سلبية 1', 'نقطة سلبية 2'],
    platforms: { PC: true, PS5: false, XSX: false, NSW: false },
    techSpecs: { res: 'RES: 4K', fps: 'FPS: 60', hdr: 'HDR: ON' },
    image: 'https://images.unsplash.com/photo-1614145121029-83a9f7cafd8e?q=80&w=1080&auto=format&fit=crop',
    imageSettings: { x: 0, y: 0, scale: 1 },
    vibrance: 100,
    tintStrength: 20,
    creditsOpacity: 100, // Default Full Opacity
    gradientSettings: {
        active: true,
        x: 0,
        y: 0,
        opacity: 50,
        scale: 1.5
    }
};

const ChevronDownIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9l6 6 6-6"/></svg>;
const SettingsIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;
const CanvasIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>;
const DownloadIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const PlusIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
const TrashIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const MoveIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 9l-3 3 3 3M9 5l3-3 3 3M19 9l3 3-3 3M9 19l3 3 3-3"/><path d="M2 12h20M12 2v20"/></svg>;
const ImageIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>;

export default function ReviewCardEditor() {
    useBodyClass('editor-active');

    const [data, setData] = useState<ReviewTemplateData>(DEFAULT_DATA);
    const [scale, setScale] = useState(0.4);
    const [isFillerOpen, setIsFillerOpen] = useState(false);
    const [isExportMenuOpen, setIsExportMenuOpen] = useState(false);
    const [isExporting, startExport] = useTransition();
    const canvasWrapperRef = useRef<HTMLDivElement>(null);
    const toast = useToast();
    
    // NEW: Editing Mode State (Image or Gradient)
    const [editMode, setEditMode] = useState<'image' | 'gradient'>('image');
    
    const [activeTab, setActiveTab] = useState<'sidebar' | 'canvas'>('canvas');
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (!canvasWrapperRef.current) return;
        const updateScale = () => {
            if (!canvasWrapperRef.current) return;
            const { width, height } = canvasWrapperRef.current.getBoundingClientRect();
            const padding = 40; 
            const availableWidth = width - padding;
            const availableHeight = height - padding;
            const scaleX = availableWidth / 1080;
            const scaleY = availableHeight / 1350;
            const cap = isMobile ? 1 : 0.95;
            const newScale = Math.min(scaleX, scaleY, cap);
            setScale(newScale);
        };
        const resizeObserver = new ResizeObserver(() => requestAnimationFrame(updateScale));
        resizeObserver.observe(canvasWrapperRef.current);
        updateScale(); 
        return () => resizeObserver.disconnect();
    }, [isMobile]);

    const handleSmartSelect = (item: any) => {
        const arTitle = item.title; 
        let enTop = "GAME"; 
        let enBottom = "TITLE";
        
        const newData: Partial<ReviewTemplateData> = {
            gameTitleAr: arTitle,
            gameTitleEnTop: enTop,
            gameTitleEnBottom: enBottom,
            score: item.score?.toString() || '0.0',
            verdict: item.verdict || 'لا يوجد ملخص...',
            pros: item.pros && item.pros.length > 0 ? item.pros : DEFAULT_DATA.pros,
            cons: item.cons && item.cons.length > 0 ? item.cons : DEFAULT_DATA.cons,
            image: item.imageUrl || DEFAULT_DATA.image,
            imageSettings: { x: 0, y: 0, scale: 1 },
            rank: item.score >= 9 ? 'S-RANK' : (item.score >= 8 ? 'A-RANK' : 'B-RANK'),
            status: item.score >= 9 ? 'أسطوري' : (item.score >= 8 ? 'ممتاز' : 'جيد'),
        };

        setData(prev => ({ ...prev, ...newData }));
        toast.success('تم ملء البيانات.');
        if (isMobile) setActiveTab('canvas');
    };

    const updateData = (newData: Partial<ReviewTemplateData>) => {
        setData(prev => ({ ...prev, ...newData }));
    };

    const handleAddItem = (type: 'pros' | 'cons') => {
        updateData({ [type]: [...data[type], type === 'pros' ? 'إيجابية جديدة' : 'سلبية جديدة'] });
    };

    const handleRemoveItem = (type: 'pros' | 'cons', index: number) => {
        const newList = data[type].filter((_, i) => i !== index);
        updateData({ [type]: newList });
    };

    const handleItemChange = (type: 'pros' | 'cons', index: number, value: string) => {
        const newList = [...data[type]];
        newList[index] = value;
        updateData({ [type]: newList });
    };

    const handleDownload = (format: 'png' | 'jpeg', quality: number = 0.9) => {
        setIsExportMenuOpen(false);
        startExport(async () => {
            try {
                // MODIFIED: 2x Scale for 4K
                await downloadElementAsImage('review-card-canvas', `review-card-${Date.now()}`, format, 2, quality);
                toast.success(`تم التنزيل (${format.toUpperCase()}) - 4K`);
            } catch (e) {
                console.error(e);
                toast.error("فشل التصدير.");
            }
        });
    };

    return (
        <div className={styles.editorContainer}>
            <div className={styles.mainArea}>
                {/* Sidebar */}
                {(!isMobile || activeTab === 'sidebar') && (
                    <div className={styles.sidebar}>
                        <div className={styles.sidebarHeader}>
                             <h2 className={styles.sidebarTitle}>قالب: بطاقة المراجعة</h2>
                        </div>

                        <div className={styles.controlGroup}>
                            <button className={styles.smartFillButton} onClick={() => setIsFillerOpen(true)}>
                                <SparklesIcon width={20} height={20} />
                                <span>الملء الذكي</span>
                            </button>
                            
                            <div className={styles.downloadGroup}>
                                <button className={styles.downloadButton} onClick={() => handleDownload('jpeg', 0.9)} disabled={isExporting}>
                                    <DownloadIcon />
                                    <span style={{ marginRight: '0.8rem' }}>تحميل 4K (JPG)</span>
                                </button>
                                <button className={styles.dropdownTrigger} onClick={() => setIsExportMenuOpen(!isExportMenuOpen)} disabled={isExporting}>
                                    <motion.div animate={{ rotate: isExportMenuOpen ? 180 : 0 }}>
                                        <ChevronDownIcon />
                                    </motion.div>
                                </button>
                            </div>
                             <AnimatePresence>
                                {isExportMenuOpen && (
                                    <motion.div className={styles.dropdownMenu} initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}>
                                        <button className={styles.dropdownItem} onClick={() => handleDownload('png')}>تحميل 4K (PNG)</button>
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>

                        {/* VISUAL SETTINGS */}
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>تحسين الصورة (Visuals)</label>
                            
                            {/* VIBRANCE */}
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                <span style={{fontSize: '1.2rem', color: '#ccc'}}>التشبع (Vibrance)</span>
                                <span style={{ fontSize: '1.2rem', color: 'var(--accent)', fontFamily: 'monospace' }}>{data.vibrance ?? 100}%</span>
                            </div>
                            <input
                                type="range"
                                min="0"
                                max="200"
                                value={data.vibrance ?? 100}
                                onChange={(e) => updateData({ vibrance: parseInt(e.target.value) })}
                                style={{ width: '100%', cursor: 'pointer', accentColor: 'var(--accent)' }}
                            />

                            {/* TINT (Global) */}
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem', marginBottom: '0.5rem' }}>
                                <span style={{fontSize: '1.2rem', color: '#ccc'}}>تشبع السيان (Global Tint)</span>
                                <span style={{ fontSize: '1.2rem', color: 'var(--accent)', fontFamily: 'monospace' }}>{data.tintStrength ?? 0}%</span>
                            </div>
                            <input
                                type="range"
                                min="0"
                                max="100"
                                value={data.tintStrength ?? 0}
                                onChange={(e) => updateData({ tintStrength: parseInt(e.target.value) })}
                                style={{ width: '100%', cursor: 'pointer', accentColor: 'var(--accent)' }}
                            />
                            
                             {/* CREDITS OPACITY (NEW) */}
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '1rem', marginBottom: '0.5rem' }}>
                                <span style={{fontSize: '1.2rem', color: '#ccc'}}>شفافية الحقوق (Credits)</span>
                                <span style={{ fontSize: '1.2rem', color: 'var(--accent)', fontFamily: 'monospace' }}>{data.creditsOpacity ?? 100}%</span>
                            </div>
                            <input
                                type="range"
                                min="0"
                                max="100"
                                value={data.creditsOpacity ?? 100}
                                onChange={(e) => updateData({ creditsOpacity: parseInt(e.target.value) })}
                                style={{ width: '100%', cursor: 'pointer', accentColor: 'var(--accent)' }}
                            />
                            
                            {/* NEW: GRADIENT SETTINGS */}
                            <div style={{ marginTop: '1.5rem', borderTop: '1px solid var(--border-color)', paddingTop: '1.5rem' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                    <label className={styles.label} style={{ margin: 0 }}>إضاءة السيان (Spotlight)</label>
                                    <div className={styles.typeGrid} style={{ gridTemplateColumns: '1fr 1fr', width: 'auto' }}>
                                         <button 
                                            className={`${styles.typeButton} ${editMode === 'image' ? styles.active : ''}`}
                                            onClick={() => setEditMode('image')}
                                            title="تحريك الصورة"
                                            style={{ padding: '0.5rem', display: 'flex', justifyContent: 'center' }}
                                        >
                                            <ImageIcon />
                                        </button>
                                        <button 
                                            className={`${styles.typeButton} ${editMode === 'gradient' ? styles.active : ''}`}
                                            onClick={() => setEditMode('gradient')}
                                            title="تحريك الإضاءة"
                                            style={{ padding: '0.5rem', display: 'flex', justifyContent: 'center' }}
                                        >
                                            <MoveIcon />
                                        </button>
                                    </div>
                                </div>
                                
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                    <span style={{fontSize: '1.2rem', color: '#ccc'}}>كثافة الإضاءة</span>
                                    <span style={{ fontSize: '1.2rem', color: 'var(--accent)', fontFamily: 'monospace' }}>{data.gradientSettings?.opacity ?? 50}%</span>
                                </div>
                                <input
                                    type="range"
                                    min="0"
                                    max="100"
                                    value={data.gradientSettings?.opacity ?? 50}
                                    onChange={(e) => updateData({ 
                                        gradientSettings: { ...data.gradientSettings!, opacity: parseInt(e.target.value) } 
                                    })}
                                    style={{ width: '100%', cursor: 'pointer', accentColor: 'var(--accent)' }}
                                />
                                
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '0.8rem', marginBottom: '0.5rem' }}>
                                    <span style={{fontSize: '1.2rem', color: '#ccc'}}>حجم الإضاءة</span>
                                    <span style={{ fontSize: '1.2rem', color: 'var(--accent)', fontFamily: 'monospace' }}>{data.gradientSettings?.scale ?? 1.5}x</span>
                                </div>
                                <input
                                    type="range"
                                    min="0.5"
                                    max="3"
                                    step="0.1"
                                    value={data.gradientSettings?.scale ?? 1.5}
                                    onChange={(e) => updateData({ 
                                        gradientSettings: { ...data.gradientSettings!, scale: parseFloat(e.target.value) } 
                                    })}
                                    style={{ width: '100%', cursor: 'pointer', accentColor: 'var(--accent)' }}
                                />
                            </div>
                        </div>

                        <div className={styles.controlGroup}>
                            <label className={styles.label}>العناوين</label>
                            <input className={styles.input} value={stripHtml(data.gameTitleAr)} onChange={e => updateData({ gameTitleAr: e.target.value })} placeholder="الاسم بالعربية" />
                            <input className={styles.input} value={stripHtml(data.gameTitleEnTop)} onChange={e => updateData({ gameTitleEnTop: e.target.value })} placeholder="English Top" style={{direction: 'ltr', textAlign: 'left'}} />
                            <input className={styles.input} value={stripHtml(data.gameTitleEnBottom)} onChange={e => updateData({ gameTitleEnBottom: e.target.value })} placeholder="English Bottom" style={{direction: 'ltr', textAlign: 'left'}} />
                        </div>

                        <div className={styles.controlGroup}>
                            <label className={styles.label}>التقييم</label>
                            <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem'}}>
                                <input className={styles.input} value={stripHtml(data.score)} onChange={e => updateData({ score: e.target.value })} placeholder="9.5" />
                                <input className={styles.input} value={stripHtml(data.rank)} onChange={e => updateData({ rank: e.target.value })} placeholder="S-RANK" />
                            </div>
                            <input className={styles.input} value={stripHtml(data.status)} onChange={e => updateData({ status: e.target.value })} placeholder="الحالة (مثال: أسطوري)" />
                        </div>

                        <div className={styles.controlGroup}>
                            <label className={styles.label}>الملخص</label>
                            <textarea className={`${styles.input} ${styles.textarea}`} value={stripHtml(data.verdict)} onChange={e => updateData({ verdict: e.target.value })} />
                        </div>
                        
                        <div className={styles.controlGroup}>
                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                                <label className={styles.label}>الإيجابيات</label>
                                <button type="button" onClick={() => handleAddItem('pros')} className="icon-button outline-button" style={{padding: '0.2rem 0.5rem', height: 'auto', fontSize: '1.2rem'}}>
                                    <PlusIcon />
                                </button>
                            </div>
                            {data.pros.map((pro, i) => (
                                <div key={`pro-input-${i}`} style={{display: 'flex', gap: '0.5rem'}}>
                                    <input className={styles.input} value={stripHtml(pro)} onChange={e => handleItemChange('pros', i, e.target.value)} />
                                    <button onClick={() => handleRemoveItem('pros', i)} className="icon-button outline-button" style={{color: '#DC2626', borderColor: '#DC2626', height: 'auto'}}>
                                        <TrashIcon />
                                    </button>
                                </div>
                            ))}
                        </div>

                        <div className={styles.controlGroup}>
                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                                <label className={styles.label}>السلبيات</label>
                                <button type="button" onClick={() => handleAddItem('cons')} className="icon-button outline-button" style={{padding: '0.2rem 0.5rem', height: 'auto', fontSize: '1.2rem'}}>
                                    <PlusIcon />
                                </button>
                            </div>
                            {data.cons.map((con, i) => (
                                <div key={`con-input-${i}`} style={{display: 'flex', gap: '0.5rem'}}>
                                    <input className={styles.input} value={stripHtml(con)} onChange={e => handleItemChange('cons', i, e.target.value)} />
                                    <button onClick={() => handleRemoveItem('cons', i)} className="icon-button outline-button" style={{color: '#DC2626', borderColor: '#DC2626', height: 'auto'}}>
                                        <TrashIcon />
                                    </button>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {/* Canvas */}
                {(!isMobile || activeTab === 'canvas') && (
                    <div className={styles.canvasWrapper} ref={canvasWrapperRef}>
                        <div id="review-card-canvas" style={{ width: 'fit-content', height: 'fit-content' }}>
                             <ReviewCardCanvas 
                                data={data} 
                                onDataChange={updateData} 
                                scale={scale}
                                editMode={editMode}
                            />
                        </div>
                    </div>
                )}
            </div>

            {/* Mobile Tabs */}
            {isMobile && (
                <div className={styles.mobileToggleBar}>
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'sidebar' ? styles.active : ''}`} onClick={() => setActiveTab('sidebar')}>
                        <SettingsIcon />
                        <span>الإعدادات</span>
                    </button>
                    <div className={styles.mobileDivider} />
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'canvas' ? styles.active : ''}`} onClick={() => setActiveTab('canvas')}>
                        <CanvasIcon />
                        <span>التصميم</span>
                    </button>
                </div>
            )}

            <SmartFiller isOpen={isFillerOpen} onClose={() => setIsFillerOpen(false)} onSelect={handleSmartSelect} />
        </div>
    );
}

--- END OF FILE app/studio/social-templates/review-card/page.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/weekly-news/actions.tsx ---

// app/studio/social-templates/weekly-news/actions.ts
'use server';

import { client } from '@/lib/sanity.client';
import { groq } from 'next-sanity';

export interface SmartFillRelease {
    _id: string;
    title: string;
    releaseDate: string;
    platforms: string[];
    imageUrl: string;
    price?: string;
    onGamePass?: boolean;
    onPSPlus?: boolean;
}

export interface WeeklyNewsItem {
    _id: string;
    title: string;
    publishedAt: string;
    imageUrl: string;
    category?: string;
    newsType?: 'official' | 'rumor' | 'leak'; // ADDED THIS
}

export interface WeekOption {
    label: string;
    weekNum: number;
    year: number;
    startDate: string;
    endDate: string;
}

export async function getRecentWeeksAction(): Promise<WeekOption[]> {
    const weeks: WeekOption[] = [];
    const today = new Date();
    
    // Go back 12 weeks
    for (let i = 0; i < 12; i++) {
        const d = new Date(today);
        d.setDate(d.getDate() - (i * 7));
        
        // Calculate Week Number (ISO)
        const date = new Date(d.getTime());
        date.setHours(0, 0, 0, 0);
        date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
        const week1 = new Date(date.getFullYear(), 0, 4);
        const weekNum = 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        
        // Calculate Start/End of that week (assuming Sunday start for visual convenience or Monday)
        // Let's use Monday start for standard ISO
        const day = d.getDay();
        const diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday
        const monday = new Date(d.setDate(diff));
        const sunday = new Date(d.setDate(diff + 6));

        weeks.push({
            label: `الأسبوع ${weekNum} (${monday.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })} - ${sunday.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })})`,
            weekNum,
            year: monday.getFullYear(),
            startDate: monday.toISOString().split('T')[0],
            endDate: sunday.toISOString().split('T')[0]
        });
    }
    return weeks;
}

export async function getNewsForWeekAction(startDate: string, endDate: string): Promise<WeeklyNewsItem[]> {
    const query = groq`
        *[_type == "news" && publishedAt >= $startDate && publishedAt <= $endDate] | order(publishedAt desc) {
            _id,
            title,
            publishedAt,
            "imageUrl": mainImage.asset->url,
            "category": category->title,
            newsType // ADDED THIS
        }
    `;

    try {
        // End date needs to cover the full day, so we might want to extend it or rely on date comparison
        // Sanity date comparison is string based for ISO. 
        // We'll pass the raw YYYY-MM-DD.
        const results = await client.fetch(query, { startDate, endDate });
        return results;
    } catch (error) {
        console.error("Failed to fetch weekly news:", error);
        return [];
    }
}

--- END OF FILE app/studio/social-templates/weekly-news/actions.tsx ---

================================================================================

--- START OF FILE app/studio/social-templates/weekly-news/page.tsx ---

// app/studio/social-templates/weekly-news/page.tsx
'use client';

import { useState, useRef, useEffect, useTransition } from 'react';
import { useToast } from '@/lib/toastStore';
import { useBodyClass } from '@/hooks/useBodyClass';
import { downloadElementAsImage } from '@/lib/image-export';
import { motion, AnimatePresence } from 'framer-motion';
import WeeklyNewsCanvas from '@/components/studio/social/weekly-news/WeeklyNewsCanvas';
import { WeeklyNewsTemplateData } from '@/components/studio/social/weekly-news/types';
import styles from '@/components/studio/social/SocialEditor.module.css';
import SmartFillerWeekly from '@/components/studio/social/weekly-news/SmartFillerWeekly';
import { SparklesIcon } from '@/components/icons';

const DownloadIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const ChevronDownIcon = () => (<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 9l6 6 6-6"/></svg>);
const CanvasIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>;
const SettingsIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33-1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;

// UPDATED: Empty Default Data
const DEFAULT_DATA: WeeklyNewsTemplateData = {
    weekNumber: `الأسبوع 00`,
    year: `2025`,
    hero: {
        tag: 'خبر عاجل',
        title: '',
        image: '',
        imageSettings: { x: 0, y: 0, scale: 1 },
        badges: { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false }
    },
    cards: [
        { 
            id: 1, 
            title: '', 
            image: '', 
            imageSettings: { x: 0, y: 0, scale: 1 },
            badges: { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false }
        },
        { 
            id: 2, 
            title: '', 
            image: '', 
            imageSettings: { x: 0, y: 0, scale: 1 },
            badges: { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false }
        },
        { 
            id: 3, 
            title: '', 
            image: '', 
            imageSettings: { x: 0, y: 0, scale: 1 },
            badges: { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false }
        }
    ],
    newsList: Array.from({ length: 12 }).map((_, i) => ({
        id: i + 5,
        number: (i + 5).toString().padStart(2, '0'),
        text: '',
        type: 'official',
        isImportant: false
    })),
    vibrance: 100, // ADDED
};

export default function WeeklyNewsEditor() {
    useBodyClass('editor-active');
    
    const [data, setData] = useState<WeeklyNewsTemplateData>(DEFAULT_DATA);
    const [scale, setScale] = useState(0.4);
    const [isExporting, startExport] = useTransition();
    const [isExportMenuOpen, setIsExportMenuOpen] = useState(false);
    const [isFillerOpen, setIsFillerOpen] = useState(false);
    const canvasWrapperRef = useRef<HTMLDivElement>(null);
    const toast = useToast();
    
    const [activeTab, setActiveTab] = useState<'sidebar' | 'canvas'>('canvas');
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useEffect(() => {
        if (!canvasWrapperRef.current) return;
        const updateScale = () => {
            if (!canvasWrapperRef.current) return;
            const { width, height } = canvasWrapperRef.current.getBoundingClientRect();
            const padding = 40; 
            const availableWidth = width - padding;
            const availableHeight = height - padding;
            const scaleX = availableWidth / 1080;
            const scaleY = availableHeight / 1350;
            const cap = isMobile ? 1 : 0.95;
            const newScale = Math.min(scaleX, scaleY, cap);
            setScale(newScale);
        };
        const resizeObserver = new ResizeObserver(() => requestAnimationFrame(updateScale));
        resizeObserver.observe(canvasWrapperRef.current);
        updateScale(); 
        return () => resizeObserver.disconnect();
    }, [isMobile]);

    const handleDownload = (format: 'png' | 'jpeg', quality: number = 0.9) => {
        setIsExportMenuOpen(false);
        startExport(async () => {
            try {
                await downloadElementAsImage('weekly-news-canvas', `weekly-news-${Date.now()}`, format, 2, quality);
                toast.success(`تم التنزيل (${format.toUpperCase()}) - 4K`);
            } catch (e) {
                console.error(e);
                toast.error("فشل التصدير.");
            }
        });
    };

    const handleSmartFill = (newData: Partial<WeeklyNewsTemplateData>) => {
        setData(prev => ({ ...prev, ...newData }));
        toast.success("تم تطبيق البيانات بنجاح!");
    };

    return (
        <div className={styles.editorContainer}>
            <div className={styles.mainArea}>
                {(!isMobile || activeTab === 'sidebar') && (
                    <div className={styles.sidebar}>
                        <div className={styles.sidebarHeader}>
                            <h2 className={styles.sidebarTitle}>قالب: النشرة الأسبوعية</h2>
                        </div>
                        
                        <div className={styles.controlGroup}>
                            {/* SMART FILL BUTTON */}
                            <button className={styles.smartFillButton} onClick={() => setIsFillerOpen(true)}>
                                <SparklesIcon width={20} height={20} />
                                <span>الملء الذكي</span>
                            </button>

                            <div className={styles.downloadGroup}>
                                <button className={styles.downloadButton} onClick={() => handleDownload('jpeg', 0.9)} disabled={isExporting}>
                                    <DownloadIcon />
                                    <span style={{ marginRight: '0.8rem' }}>تحميل 4K (JPG)</span>
                                </button>
                                <button className={styles.dropdownTrigger} onClick={() => setIsExportMenuOpen(!isExportMenuOpen)} disabled={isExporting}>
                                    <motion.div animate={{ rotate: isExportMenuOpen ? 180 : 0 }}>
                                        <ChevronDownIcon />
                                    </motion.div>
                                </button>
                            </div>
                            <AnimatePresence>
                                {isExportMenuOpen && (
                                    <motion.div className={styles.dropdownMenu} initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}>
                                        <button className={styles.dropdownItem} onClick={() => handleDownload('png')}>تحميل 4K (PNG)</button>
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>
                        
                        <div className={styles.controlGroup}>
                            <label className={styles.label}>الأسبوع / السنة</label>
                            <div style={{ display: 'flex', gap: '1rem' }}>
                                <input className={styles.input} value={data.weekNumber} onChange={(e) => setData({ ...data, weekNumber: e.target.value })} />
                                <input className={styles.input} value={data.year} onChange={(e) => setData({ ...data, year: e.target.value })} style={{ width: '80px' }} />
                            </div>
                        </div>

                        {/* VIBRANCE SLIDER ADDED */}
                        <div className={styles.controlGroup}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <label className={styles.label}>تشبع الألوان (Vibrance)</label>
                                <span style={{ fontSize: '1.2rem', color: 'var(--text-secondary)', fontFamily: 'monospace' }}>{data.vibrance}%</span>
                            </div>
                            <input
                                type="range"
                                min="0"
                                max="200"
                                value={data.vibrance || 100}
                                onChange={(e) => setData({ ...data, vibrance: parseInt(e.target.value) })}
                                style={{ 
                                    width: '100%', 
                                    cursor: 'pointer',
                                    accentColor: 'var(--accent)'
                                }}
                            />
                        </div>

                         <div className={styles.controlGroup} style={{ marginTop: 'auto', opacity: 0.5 }}>
                            <p style={{ fontSize: '1.2rem', textAlign: 'center' }}>التحرير المباشر مفعل على جميع العناصر.</p>
                        </div>
                    </div>
                )}

                {(!isMobile || activeTab === 'canvas') && (
                    <div className={styles.canvasWrapper} ref={canvasWrapperRef}>
                        <div id="weekly-news-canvas-wrapper" style={{ width: 'fit-content', height: 'fit-content' }}>
                             <WeeklyNewsCanvas 
                                data={data} 
                                onChange={(newData) => setData(prev => ({...prev, ...newData}))} 
                                scale={scale}
                            />
                        </div>
                    </div>
                )}
            </div>

            {isMobile && (
                <div className={styles.mobileToggleBar}>
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'sidebar' ? styles.active : ''}`} onClick={() => setActiveTab('sidebar')}>
                        <SettingsIcon />
                        <span>الإعدادات</span>
                    </button>
                    <div className={styles.mobileDivider} />
                    <button className={`${styles.mobileToggleButton} ${activeTab === 'canvas' ? styles.active : ''}`} onClick={() => setActiveTab('canvas')}>
                        <CanvasIcon />
                        <span>التصميم</span>
                    </button>
                </div>
            )}
            
            <SmartFillerWeekly 
                isOpen={isFillerOpen} 
                onClose={() => setIsFillerOpen(false)} 
                onApply={handleSmartFill} 
                currentData={data}
            />
        </div>
    );
}

--- END OF FILE app/studio/social-templates/weekly-news/page.tsx ---

================================================================================

--- START OF FILE app/studio/utils/portableTextToTiptap.ts ---

// app/studio/utils/portableTextToTiptap.ts

import {PortableTextBlock} from '@portabletext/types'
import type {SanityImageObject as SanityImage} from '@sanity/image-url/lib/types/types'
import { projectId, dataset } from '@/lib/sanity.env'

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
  type: string
  attrs?: Record<string, any>
  content?: TiptapNode[]
  text?: string
  marks?: {type: string; attrs?: Record<string, any>}[]
}

// Helper to reconstruct Sanity CDN URL from an Asset ID/Ref
// Format: image-AssetID-WidthxHeight-Format
const buildSanityUrl = (ref?: string): string | null => {
  if (!ref) return null;
  const parts = ref.split('-');
  // We expect 4 parts: ["image", "id", "dimensions", "format"]
  if (parts.length !== 4) return null;
  const id = parts[1];
  const dimensions = parts[2];
  const format = parts[3];
  return `https://cdn.sanity.io/images/${projectId}/${dataset}/${id}-${dimensions}.${format}`;
}

const resolveImageAttrs = (sanityImageObj: any) => {
  const asset = sanityImageObj?.asset;
  const assetId = asset?._id || asset?._ref;
  let url = asset?.url;

  if (!url && assetId) {
    url = buildSanityUrl(assetId);
  }

  return { assetId, url };
}

/**
 * Converts a Sanity Portable Text array to Tiptap's JSON format.
 * @param blocks The array of Portable Text blocks from Sanity.
 * @returns A Tiptap-compatible JSON object representing the document content.
 */
export function portableTextToTiptap(blocks: PortableTextBlock[] = []): Record<string, any> {
  const content: TiptapNode[] = []
  let currentList: TiptapNode | null = null

  const validBlocks = (blocks || []).filter(Boolean)

  validBlocks.forEach((block: any) => {
    // --- HANDLE LIST ITEMS ---
    if (block._type === 'block' && block.listItem === 'bullet') {
      if (!currentList) {
        currentList = {type: 'bulletList', content: []}
      }
      const listItemContent = processBlockChildren(block)
      currentList.content?.push({
        type: 'listItem',
        content: [{type: 'paragraph', content: listItemContent}],
      })
      return
    }

    if (currentList) {
      content.push(currentList)
      currentList = null
    }

    // --- HANDLE CUSTOM BLOCKS ---
    if (block._type === 'youtube') {
      content.push({
        type: 'youtube',
        attrs: {
          src: block.url,
        },
      })
      return
    }
    if (block._type === 'gameDetails') {
      content.push({
        type: 'gameDetails',
        attrs: {
          details: block.details || [],
        },
      })
      return
    }
    if (block._type === 'table') {
      const tableContent: TiptapNode[] = []
      ;(block.rows || []).forEach((row: any) => {
        const rowContent: TiptapNode[] = []
        ;(row.cells || []).forEach((cell: any) => {
          const cellType = cell.isHeader ? 'tableHeader' : 'tableCell'
          const cellContent = portableTextToTiptap(cell.content || []).content
          rowContent.push({type: cellType, content: cellContent})
        })
        tableContent.push({type: 'tableRow', content: rowContent})
      })
      content.push({type: 'table', content: tableContent})
      return
    }
    
    if (block._type === 'imageCompare') {
      const {image1, image2, size} = block as any
      const img1 = resolveImageAttrs(image1);
      const img2 = resolveImageAttrs(image2);
      
      content.push({
        type: 'imageCompare',
        attrs: {
          src1: img1.url,
          assetId1: img1.assetId,
          src2: img2.url,
          assetId2: img2.assetId,
          'data-size': size || 'large',
        },
      })
      return
    }
    
    if (block._type === 'twoImageGrid') {
      const {image1, image2} = block as any
      const img1 = resolveImageAttrs(image1);
      const img2 = resolveImageAttrs(image2);

      content.push({
        type: 'twoImageGrid',
        attrs: {
          src1: img1.url,
          assetId1: img1.assetId,
          src2: img2.url,
          assetId2: img2.assetId,
        },
      })
      return
    }
    
    if (block._type === 'fourImageGrid') {
      const {image1, image2, image3, image4} = block as any
      const img1 = resolveImageAttrs(image1);
      const img2 = resolveImageAttrs(image2);
      const img3 = resolveImageAttrs(image3);
      const img4 = resolveImageAttrs(image4);

      content.push({
        type: 'fourImageGrid',
        attrs: {
          src1: img1.url,
          assetId1: img1.assetId,
          src2: img2.url,
          assetId2: img2.assetId,
          src3: img3.url,
          assetId3: img3.assetId,
          src4: img4.url,
          assetId4: img4.assetId,
        },
      })
      return
    }
    
    if (block._type === 'image') {
      const img = resolveImageAttrs(block);
      if (img.assetId && img.url) {
        content.push({
          type: 'image',
          attrs: {
            src: img.url,
            assetId: img.assetId,
          },
        })
      }
      return
    }

    // --- HANDLE TEXT BLOCKS ---
    if (block._type === 'block' && block.style) {
      const children = processBlockChildren(block)

      const isEffectivelyEmpty = children.length === 1 && children[0].text === ''
      const nodeContent = isEffectivelyEmpty ? {} : {content: children}

      switch (block.style) {
        case 'h1':
          content.push({type: 'heading', attrs: {level: 1}, ...nodeContent})
          break
        case 'h2':
          content.push({type: 'heading', attrs: {level: 2}, ...nodeContent})
          break
        case 'h3':
          content.push({type: 'heading', attrs: {level: 3}, ...nodeContent})
          break
        case 'blockquote':
          content.push({type: 'blockquote', content: [{type: 'paragraph', ...nodeContent}]})
          break
        default:
          content.push({type: 'paragraph', ...nodeContent})
      }
    }
  })

  if (currentList) {
    content.push(currentList)
  }

  return {type: 'doc', content}
}

function processBlockChildren(block: PortableTextBlock): TiptapNode[] {
  const children = Array.isArray(block.children) ? block.children : []

  const processedChildren = children
    .filter((span) => span && span._type === 'span')
    .map((span) => {
      const marks = (Array.isArray(span.marks) ? span.marks : []).map((mark) => {
          const markDefs = Array.isArray(block.markDefs) ? block.markDefs : []
          const markDef = markDefs.find((def) => def._key === mark)
          if (markDef?._type === 'link') {
            return {type: 'link', attrs: {href: (markDef as any).href}}
          }
          if (markDef?._type === 'color') {
            return {type: 'textStyle', attrs: {color: (markDef as any).hex}}
          }
          if (mark === 'strong') return {type: 'bold'}
          if (mark === 'em') return {type: 'italic'}
          return null
        })
        .filter(Boolean) as {type: string; attrs?: any}[]

      return {
        type: 'text',
        text: span.text ?? '',
        marks,
      }
    })

  return processedChildren
}




--- END OF FILE app/studio/utils/portableTextToTiptap.ts ---

================================================================================

--- START OF FILE app/studio/utils/tiptapToPortableText.ts ---

// app/studio/utils/tiptapToPortableText.ts

import {v4 as uuidv4} from 'uuid'

// Type definitions for Tiptap's JSON structure
interface TiptapNode {
  type: string
  attrs?: Record<string, any>
  content?: TiptapNode[]
  text?: string
  marks?: {type: string; attrs?: Record<string, any>}[]
}

/**
 * Converts a Tiptap JSON object to a Sanity Portable Text array.
 * @param tiptapJSON The Tiptap JSON object.
 * @returns An array of Portable Text blocks.
 */
export function tiptapToPortableText(tiptapJSON: TiptapNode): any[] {
  if (!tiptapJSON || tiptapJSON.type !== 'doc' || !tiptapJSON.content) {
    return []
  }

  const portableTextBlocks: any[] = []

  tiptapJSON.content.forEach((node) => {
    // --- YOUTUBE ---
    if (node.type === 'youtube') {
      const {src} = node.attrs || {}
      if (src) {
        portableTextBlocks.push({
          _type: 'youtube',
          _key: uuidv4(),
          url: src,
        })
      }
      return
    }

    // --- IMAGE COMPARE ---
    if (node.type === 'imageCompare') {
      const {assetId1, assetId2, 'data-size': size} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'imageCompare',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
        size: size || 'large',
      })
      return
    }

    // --- TWO IMAGE GRID ---
    if (node.type === 'twoImageGrid') {
      const {assetId1, assetId2} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'twoImageGrid',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
      })
      return
    }

    // --- FOUR IMAGE GRID ---
    if (node.type === 'fourImageGrid') {
      const {assetId1, assetId2, assetId3, assetId4} = node.attrs || {}
      portableTextBlocks.push({
        _type: 'fourImageGrid',
        _key: uuidv4(),
        image1: assetId1 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId1}} : undefined,
        image2: assetId2 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId2}} : undefined,
        image3: assetId3 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId3}} : undefined,
        image4: assetId4 ? {_type: 'image', asset: {_type: 'reference', _ref: assetId4}} : undefined,
      })
      return
    }

    // --- GAME DETAILS ---
    if (node.type === 'gameDetails') {
      portableTextBlocks.push({
        _type: 'gameDetails',
        _key: uuidv4(),
        details: node.attrs?.details || [],
      })
      return
    }

    // --- TABLE (THE DEFINITIVE FIX) ---
    if (node.type === 'table') {
      const tableRows: any[] = []
      // Tiptap's table content is an array of 'tableRow' nodes.
      ;(node.content || []).forEach((rowNode: TiptapNode) => {
        const tableCells: any[] = []
        ;(rowNode.content || []).forEach((cellNode: TiptapNode) => {
          tableCells.push({
            _key: uuidv4(),
            _type: 'cell',
            isHeader: cellNode.type === 'tableHeader',
            // Recursively convert the cell's content.
            content: tiptapToPortableText({type: 'doc', content: cellNode.content || []}),
          })
        })
        tableRows.push({_key: uuidv4(), _type: 'row', cells: tableCells})
      })
      portableTextBlocks.push({_type: 'table', _key: uuidv4(), rows: tableRows})
      return
    }

    // --- IMAGE (DEFINITIVE FIX) ---
    if (node.type === 'image') {
      const assetId = node.attrs?.assetId
      if (assetId) {
        portableTextBlocks.push({
          _type: 'image',
          _key: uuidv4(),
          asset: {_type: 'reference', _ref: assetId},
        })
      } else if (node.attrs?.src) {
        // [FIX] Handle pure src without assetId (e.g. pasted from external source if we supported it, or old content)
        // Extract ID from Sanity URL if possible
        const matches = node.attrs.src.match(/image-([a-fA-F0-9]+-[0-9]+x[0-9]+-[a-z]+)/)
        if (matches && matches[1]) {
          const parsedId = `image-${matches[1]}`
          portableTextBlocks.push({
            _type: 'image',
            _key: uuidv4(),
            asset: {_type: 'reference', _ref: parsedId},
          })
        }
        // If we can't resolve an ID, we SKIP the image block to prevent broken references in Sanity.
        // This is safer than creating a broken block.
      }
      return
    }

    // --- BULLET LISTS ---
    if (node.type === 'bulletList') {
      node.content?.forEach((listItem) => {
        const paragraph = listItem.content?.[0]
        if (paragraph && paragraph.type === 'paragraph') {
          const block = processTextBlock(paragraph)
          if (block) {
            block.level = 1
            block.listItem = 'bullet'
            portableTextBlocks.push(block)
          }
        }
      })
      return
    }

    // --- STANDARD TEXT BLOCKS ---
    const block = processTextBlock(node)
    if (block) {
      portableTextBlocks.push(block)
    }
  })

  return portableTextBlocks
}

// Helper function to process paragraphs, headings, blockquotes
function processTextBlock(node: TiptapNode): any | null {
  const block: any = {
    _type: 'block',
    _key: uuidv4(),
    children: [],
    markDefs: [],
  }

  switch (node.type) {
    case 'heading':
      block.style = `h${node.attrs?.level || 2}`
      break
    case 'blockquote':
      // [FIX] Handle blockquote content. Tiptap blockquote contains paragraphs. Sanity blockquote is a style.
      // We extract text from the first paragraph child.
      if (node.content && node.content.length > 0) {
        const blockquoteParagraph = processTextBlock({type: 'paragraph', content: node.content[0].content}) // Use inner content
        if (blockquoteParagraph) {
          blockquoteParagraph.style = 'blockquote'
          return blockquoteParagraph
        }
      }
      // If empty or complex, fallback to standard paragraph logic below (which returns null if empty)
      // Actually, if it's empty, we might want to skip it.
      if (!node.content || node.content.length === 0) return null;
      // Fallthrough to standard processing if structure is weird, but usually blockquotes in Tiptap wrap paragraphs.
      // The recursive call above handles the common case.
      break; 
    default:
      block.style = 'normal'
  }
  
  // Ensure we processed the right node for blockquotes (we did via recursion above).
  // For standard nodes:

  if (node.type !== 'blockquote') {
      ;(node.content || []).forEach((span) => {
        if (span.type !== 'text' || typeof span.text === 'undefined') return

        const spanMarks: string[] = []
        span.marks?.forEach((mark) => {
          if (mark.type === 'bold') spanMarks.push('strong')
          if (mark.type === 'italic') spanMarks.push('em')
          if (mark.type === 'link') {
            const markDef = {_key: uuidv4(), _type: 'link', href: mark.attrs?.href}
            block.markDefs.push(markDef)
            spanMarks.push(markDef._key)
          }
          if (mark.type === 'textStyle' && mark.attrs?.color) {
            const markDef = {_key: uuidv4(), _type: 'color', hex: mark.attrs.color}
            block.markDefs.push(markDef)
            spanMarks.push(markDef._key)
          }
        })

        block.children.push({
          _type: 'span',
          _key: uuidv4(),
          text: span.text,
          marks: spanMarks,
        })
      })
  }

  // If block has no children (empty paragraph), add empty span to make it valid Sanity block
  if (block.children.length === 0) {
      // Only for non-blockquote types (blockquote handled above)
      if (node.type !== 'blockquote') {
         block.children.push({_type: 'span', _key: uuidv4(), text: '', marks: []})
      }
  }

  // [FIX] Don't return blocks with 0 children unless they are empty paragraphs meant to be breaks.
  // But Sanity usually cleans empty blocks. Tiptap uses <p></p> for newlines.
  // We keep them.

  return block
}

--- END OF FILE app/studio/utils/tiptapToPortableText.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

/* app/studio/[contentType]/[id]/BlockToolbar.module.css */

.blockToolbarContainer {
    position: fixed; /* THE FIX: Lock to viewport */
    bottom: 1rem;
    left: 10rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.5rem;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}

.optionButtonWrapper {
    position: relative;
}

.optionButton {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 46px;
    height: 46px;
}

.optionTooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 0.75rem;
    padding: 0.4rem 0.8rem;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 1.3rem;
    font-weight: 500;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    transform-origin: bottom center;
}
@media (hover: hover) {@media (hover: hover) {
  
  .optionButtonWrapper:hover .optionTooltip  {
    opacity: 1;
    transform: translateY(-5px) translateX(-50%);
}
}

  .optionButtonWrapper:active .optionTooltip  {
    opacity: 1;
    transform: translateY(-5px) translateX(-50%);
}
}
.optionButtonWrapper:active .optionTooltip {
    opacity: 1;
    transform: translateY(-5px) translateX(-50%);
}


@media (max-width: 1024px) {
    .blockToolbarContainer {
        left: 50%;
        transform: translateX(-50%);
        bottom: 2rem;
    }
}




--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

// app/studio/[contentType]/[id]/BlockToolbar.tsx
'use client'

import {Editor} from '@tiptap/react'
import {motion} from 'framer-motion'
import {
  CompareIcon,
  TwoImageIcon,
  FourImageIcon,
  SingleImageIcon,
  GameDetailsIcon,
  YoutubeIcon,
} from '../../StudioIcons'
import {QualityToggle} from './editor-components/QualityToggle'
import {UploadQuality} from '@/lib/image-optimizer'
import styles from './BlockToolbar.module.css'
import bubbleStyles from './Editor.module.css'

interface BlockToolbarProps {
  editor: Editor | null
  onFileUpload: (file: File) => void
  uploadQuality: UploadQuality
  onUploadQualityChange: (quality: UploadQuality) => void
}

const TooltipButton = ({
  onClick,
  title,
  children,
  disabled,
}: {
  onClick: () => void
  title: string
  children: React.ReactNode
  disabled?: boolean
}) => (
  <div className={styles.optionButtonWrapper}>
    <motion.button
      onClick={onClick}
      className={`${bubbleStyles.bubbleMenuButton} ${styles.optionButton}`}
      whileHover={{scale: 1.1}}
      whileTap={{scale: 0.9}}
      title={title}
      disabled={disabled}
    >
      {children}
    </motion.button>
    <div className={styles.optionTooltip}>{title}</div>
  </div>
)

export function BlockToolbar({
  editor,
  onFileUpload,
  uploadQuality,
  onUploadQualityChange,
}: BlockToolbarProps) {
  const addBlock = (
    type: 'image' | 'imageCompare' | 'twoImageGrid' | 'fourImageGrid' | 'gameDetails' | 'youtube',
  ) => {
    if (!editor) return
    if (type === 'image') {
      const input = document.createElement('input')
      input.type = 'file'
      input.accept = 'image/*'
      input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0]
        if (file) {
          onFileUpload(file)
        }
      }
      input.click()
    } else {
      editor.chain().focus().insertContent({type}).run()
    }
  }

  return (
    <motion.div
      className={styles.blockToolbarContainer}
      initial={{opacity: 0, y: 20}}
      animate={{opacity: 1, y: 0}}
      exit={{opacity: 0, y: 20}}
      transition={{type: 'spring' as const, stiffness: 300, damping: 25}}
    >
      <TooltipButton onClick={() => addBlock('gameDetails')} title="تفاصيل اللعبة" disabled={!editor}>
        <GameDetailsIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('youtube')} title="فيديو يوتيوب" disabled={!editor}>
        <YoutubeIcon />
      </TooltipButton>
      <div className={bubbleStyles.toolbarDivider} />
      <TooltipButton onClick={() => addBlock('image')} title="صورة مفردة" disabled={!editor}>
        <SingleImageIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('imageCompare')} title="مضاهاة صورتين" disabled={!editor}>
        <CompareIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('twoImageGrid')} title="شبكة صورتين" disabled={!editor}>
        <TwoImageIcon />
      </TooltipButton>
      <TooltipButton onClick={() => addBlock('fourImageGrid')} title="شبكة 4 صور" disabled={!editor}>
        <FourImageIcon />
      </TooltipButton>
      <div className={bubbleStyles.toolbarDivider} />
      <QualityToggle currentQuality={uploadQuality} onQualityChange={onUploadQualityChange} />
    </motion.div>
  )
}




--- END OF FILE app/studio/[contentType]/[id]/BlockToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ColorPicker.module.css ---

/* app/studio/[contentType]/[id]/ColorPicker.module.css */

.colorPickerPopover {
    position: absolute;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    box-shadow: 0 5px 25px rgba(0,0,0,0.15);
    width: 320px; /* FIXED: Increased from 300px to prevent grid overlap */
}

.categoryGrid {
    display: grid;
    grid-template-columns: repeat(8, 1fr); /* 8 categories */
    gap: 0.75rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.categoryButton {
    position: relative;
    width: 28px;
    height: 28px;
    border-radius: 8px; /* Square tabs */
    border: none;
    cursor: pointer;
    transition: transform 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .categoryButton:hover  {
    transform: scale(1.1);
}
}

  .categoryButton:active  {
    transform: scale(1.1);
}
}
.categoryButton:active {
    transform: scale(1.1);
}


.activeCategoryHighlight {
    position: absolute;
    inset: -3px; /* Creates an outer border effect */
    border: 2px solid var(--accent);
    border-radius: 10px; /* Slightly more rounded than the button */
    pointer-events: none;
}

.swatchGrid {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 0.5rem;
}

.swatchButton {
    position: relative;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid var(--border-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
}

.activeIndicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    box-shadow: 0 0 2px rgba(0,0,0,0.5);
}

.customColorSection {
    border-top: 1px solid var(--border-color);
    padding-top: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sectionTitle {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.customColorButton {
    position: relative;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid var(--border-color);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.customColorInput {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 50%;
    left: 50%;
}




--- END OF FILE app/studio/[contentType]/[id]/ColorPicker.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ColorPicker.tsx ---

// app/studio/[contentType]/[id]/ColorPicker.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useRef, useState } from 'react';
import styles from './ColorPicker.module.css';

// Only one middle gray as requested to avoid black/white conflicts
const COLOR_PALETTE = [
    { title: 'Grays', representative: '#9CA3AF', colors: ['#9CA3AF'] },
    { title: 'Reds', representative: '#F87171', colors: ['#FEF2F2', '#FEE2E2', '#FECACA', '#F87171', '#EF4444', '#DC2626', '#B91C1C', '#991B1B', '#7F1D1D', '#450A0A'] },
    { title: 'Oranges', representative: '#FB923C', colors: ['#FFF7ED', '#FFEDD5', '#FED7AA', '#FB923C', '#F97316', '#EA580C', '#C2410C', '#9A3412', '#7C2D12', '#431407'] },
    { title: 'Yellows', representative: '#FACC15', colors: ['#FEFCE8', '#FEF9C3', '#FEF08A', '#FACC15', '#EAB308', '#CA8A04', '#A16207', '#854D0E', '#713F12', '#422006'] },
    { title: 'Greens', representative: '#4ADE80', colors: ['#F0FDF4', '#DCFCE7', '#BBF7D0', '#4ADE80', '#22C55E', '#16A34A', '#15803D', '#166534', '#14532D', '#052e16'] },
    { title: 'Cyans', representative: '#22D3EE', colors: ['#ECFEFF', '#CFFAFE', '#A5F3FC', '#22D3EE', '#06B6D4', '#0891B2', '#0E7490', '#155E75', '#164E63', '#083344'] },
    { title: 'Blues', representative: '#60A5FA', colors: ['#EFF6FF', '#DBEAFE', '#BFDBFE', '#60A5FA', '#3B82F6', '#2563EB', '#1D4ED8', '#1E40AF', '#1E3A8A', '#172554'] },
    { title: 'Purples', representative: '#A78BFA', colors: ['#F5F3FF', '#EDE9FE', '#DDD6FE', '#A78BFA', '#8B5CF6', '#7C3AED', '#6D28D9', '#5B21B6', '#4C1D95', '#2E1065'] },
];

const PlusIcon = () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
);

const Swatch = ({ color, isActive, onClick, className = '' }: { color: string, isActive: boolean, onClick: () => void, className?: string }) => (
    <motion.button
        type="button"
        onClick={onClick}
        className={`${styles.swatchButton} ${className}`}
        style={{ backgroundColor: color }}
        animate={{ scale: isActive ? 1.2 : 1, zIndex: isActive ? 1 : 0 }}
        whileHover={{ scale: 1.3, zIndex: 2 }}
        transition={{ type: 'spring', stiffness: 500, damping: 20 }}
    >
        {isActive && <motion.div className={styles.activeIndicator} layoutId="color-picker-active-swatch" />}
    </motion.button>
);

// Helper to calculate contrast color for the icon (black or white)
const getContrastColor = (hex: string) => {
    if (!hex || !hex.startsWith('#') || hex.length < 7) return 'var(--text-primary)';
    
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    // Calculate brightness
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    
    // Return black for light colors, white for dark colors
    return (yiq >= 128) ? '#000000' : '#FFFFFF';
};

export function ColorPicker({ editor, popoverStyle }: { editor: Editor, popoverStyle: React.CSSProperties }) {
    const colorInputRef = useRef<HTMLInputElement>(null);
    const [activeTab, setActiveTab] = useState(COLOR_PALETTE[0].title);

    const currentColor = editor.getAttributes('textStyle').color || '#FFFFFF';
    const activePalette = COLOR_PALETTE.find(p => p.title === activeTab);
    const isCustomColor = !COLOR_PALETTE.flatMap(s => s.colors).some(c => c.toLowerCase() === currentColor.toLowerCase());

    const handleSetColor = (color: string) => {
        if (color === '#FFFFFF') {
            editor.chain().focus().unsetColor().run();
        } else {
            editor.chain().focus().setColor(color).run();
        }
    };

    const handleCustomColorChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        editor.chain().focus().setColor(event.target.value).run();
    };

    const iconColor = isCustomColor ? getContrastColor(currentColor) : 'var(--text-secondary)';

    return (
        <motion.div
            className={styles.colorPickerPopover}
            style={{ ...popoverStyle, left: '50%', transform: 'translateX(-50%)' }}
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
        >
            <div className={styles.categoryGrid}>
                {COLOR_PALETTE.map(section => (
                    <button
                        key={section.title}
                        onClick={() => setActiveTab(section.title)}
                        className={styles.categoryButton}
                        style={{ backgroundColor: section.representative }}
                        aria-label={`Select ${section.title} colors`}
                    >
                        {activeTab === section.title && (
                            <motion.div className={styles.activeCategoryHighlight} layoutId="color-picker-active-category" />
                        )}
                    </button>
                ))}
            </div>

            <AnimatePresence mode="wait">
                <motion.div
                    key={activeTab}
                    className={styles.swatchGrid}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.15 }}
                >
                    {activePalette?.colors.map(color => (
                        <Swatch
                            key={color}
                            color={color}
                            isActive={!isCustomColor && currentColor.toLowerCase() === color.toLowerCase()}
                            onClick={() => handleSetColor(color)}
                        />
                    ))}
                </motion.div>
            </AnimatePresence>

            <div className={styles.customColorSection}>
                <p className={styles.sectionTitle}>Custom Color</p>
                <div style={{ position: 'relative' }}>
                    <motion.button
                        type="button"
                        onClick={() => colorInputRef.current?.click()}
                        className={styles.customColorButton}
                        style={{ 
                            background: isCustomColor ? currentColor : 'var(--bg-primary)', 
                            color: iconColor 
                        }}
                        whileHover={{ scale: 1.1 }}
                        transition={{ type: 'spring', stiffness: 500, damping: 20 }}
                    >
                        <PlusIcon />
                    </motion.button>
                    <input
                        ref={colorInputRef}
                        type="color"
                        onInput={handleCustomColorChange}
                        value={currentColor}
                        className={styles.customColorInput}
                    />
                </div>
            </div>
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/ColorPicker.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

/* app/studio/[contentType]/[id]/Editor.module.css (COMPLETE AND CORRECTED) */

.editorHeader { position: relative; z-index: 10; height: 60px; background-color: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; width: 100%; flex-shrink: 0; }
.headerLeft, .headerRight { display: flex; align-items: center; gap: 1.5rem; }
.headerTitle { font-family: var(--font-main); color: var(--text-primary); margin: 0; font-size: 1.6rem; font-weight: 600; white-space: nowrap; }
.documentStatus { font-family: var(--font-main); font-size: 1.4rem; padding: 0.4rem 1rem; border-radius: 999px; font-weight: 500; }
.statusDraft { background-color: color-mix(in srgb, var(--text-secondary) 15%, transparent); color: var(--text-secondary); }
.statusPublished { background-color: color-mix(in srgb, #16A34A 15%, transparent); color: #16A34A; }
.statusScheduled { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); }
.headerIconGroup { display: flex; align-items: center; gap: 0.5rem; }
.iconButton { display: flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 50%; color: var(--text-secondary); background-color: transparent; border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-out; }
@media (hover: hover) {@media (hover: hover) {
  
  .iconButton:hover:not(:disabled)  { color: var(--accent); background-color: var(--bg-primary); border-color: var(--border-color); }
}

  .iconButton:active:not(:disabled)  { color: var(--accent); background-color: var(--bg-primary); border-color: var(--border-color); }
}
.iconButton:active:not(:disabled) { color: var(--accent); background-color: var(--bg-primary); border-color: var(--border-color); }

.iconButtonDisabled { pointer-events: none; color: var(--border-color); }
.mobileHeaderIcons { display: none; } /* Hidden by default */
.sanctumContainer { position: fixed; top: var(--nav-height-scrolled); right: 0; bottom: 0; left: 0; z-index: 1060; background-color: var(--bg-primary); overflow: hidden; display: flex; flex-direction: column; --sidebar-width: 380px; }
.sanctumMain { display: flex; flex-grow: 1; height: 100%; }
.sanctumSidebar { background-color: var(--bg-secondary); border-left: 1px solid var(--border-color); flex-shrink: 0; height: 100%; overflow-y: auto; display: flex; flex-direction: column; width: var(--sidebar-width); }
.sanctumSidebar fieldset { border: none; padding: 0; margin: 0; display: contents; }
.sanctumSidebar fieldset:disabled { opacity: 0.6; pointer-events: none; }
.sidebarContent { padding: 1.5rem; border-bottom: 1px solid var(--border-color); }
.sidebarTitle { font-family: var(--font-main); font-size: 2rem; margin: 0; color: var(--text-primary); }
.sidebarSubtitle { font-family: var(--font-main); color: var(--text-secondary); margin-top: 0.25rem; font-size: 1.4rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.sidebarSection { padding: 1.5rem; }
.sidebarLabel { display: block; font-family: var(--font-main); font-size: 1.3rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; }
.sidebarInput { width: 100%; background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.8rem 1rem; font-family: var(--font-main); font-size: 1.5rem; color: var(--text-primary); transition: border-color 0.2s ease, box-shadow 0.2s ease; }
.sidebarInput:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent); }
.sidebarFooter { margin-top: auto; padding: 1.5rem; border-top: 1px solid var(--border-color); background-color: var(--bg-secondary); display: flex; justify-content: center; align-items: center; }
.sanctumCanvas { flex-grow: 1; height: 100%; overflow-y: auto; background-color: var(--bg-primary); min-width: 0; }
.canvasContent { max-width: 960px; margin: 0 auto; padding: 4rem 2rem 8rem 2rem; }
.canvasTitleInput { font-family: var(--font-main); font-size: 2.8rem; font-weight: 800; line-height: 1.3; color: var(--text-primary); border: none; background: none; outline: none; width: 100%; padding: 0; margin-bottom: 3rem; text-align: right; resize: none; overflow: hidden; }
.canvasTitleInput::placeholder { color: var(--border-color); }
.canvasTitleInput:focus { box-shadow: 0 2px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent); border-radius: 4px; }
.canvasEditorWrapper { position: relative; padding: 3rem; border: 1px solid var(--border-color); border-radius: 12px; background-color: var(--bg-secondary); box-shadow: 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); transition: border-color 0.3s ease, box-shadow 0.3s ease; }
.canvasEditorWrapper:focus-within { border-color: var(--accent); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent), 0 10px 30px -15px color-mix(in srgb, var(--text-primary) 10%, transparent); }

/* THE FIX: Enforce wrapping and prevent overflow */
.tiptap { 
    outline: none; 
    text-align: right; 
    overflow-wrap: break-word; 
    word-break: break-word;
    word-wrap: break-word;
    white-space: pre-wrap;
    max-width: 100%;
}

.tiptap > * + * { margin-top: 1.25em; }
.tiptap h2 { font-family: var(--font-main), sans-serif; font-size: 2.8rem; line-height: 1.2; margin: 4rem 0 2rem 0; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
.tiptap p.is-editor-empty:first-child::before { content: attr(data-placeholder); float: right; color: var(--text-secondary); opacity: 0.7; pointer-events: none; height: 0; }

/* --- TABLE STYLES --- */
/* This is the outer wrapper for the custom node view */
.tiptap .imageGridContainer table {
    min-width: 100%; /* Ensure the table inside our custom component takes full width */
    border-collapse: collapse;
}

/* This targets the default tiptap table rendering, which is now HIDDEN */
.tiptap > table {
    display: none;
}

/* New styling for content inside our custom table component cells */
.tiptap .imageGridContainer th,
.tiptap .imageGridContainer td {
    position: relative;
}

.tiptap .imageGridContainer th:not(:last-child)::after,
.tiptap .imageGridContainer td:not(:last-child)::after {
    content: '';
    position: absolute;
    top: 25%;
    bottom: 25%;
    left: 0;
    width: 2px;
    background-color: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
}

.tiptap .imageGridContainer tr:not(:last-child) {
    border-bottom: 1px solid var(--border-color);
}


.tiptap .imageGridContainer th p,
.tiptap .imageGridContainer td p {
    margin: 0;
    padding: 1.5rem 2rem;
    font-size: 1.6rem;
    outline: none;
}
.tiptap .imageGridContainer th p {
    color: var(--accent);
    font-weight: 700;
}
.tiptap .imageGridContainer td p {
    color: var(--text-primary);
}


.formattingToolbar { 
    display: flex; 
    align-items: center;
    background-color: var(--bg-secondary); 
    border: 1px solid var(--border-color); 
    border-radius: 8px; 
    box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--text-primary) 15%, transparent); 
    padding: 0.4rem; 
    z-index: 10; 
}
.formattingToolbar.docked {
    position: fixed !important;
    top: calc(var(--nav-height-scrolled) + 1rem) !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: max-content;
    max-width: calc(100vw - 2rem);
    animation: slideInDown 0.3s ease-out;
}
@keyframes slideInDown {
    from { transform: translate(-50%, -20px); opacity: 0; }
    to { transform: translate(-50%, 0); opacity: 1; }
}


.toolbarDivider { width: 1px; height: 20px; background-color: var(--border-color); margin: 0 0.4rem; }
.dragHandle { cursor: grab; color: var(--text-secondary); padding: 0.4rem; display: flex; align-items: center; border-right: 1px solid var(--border-color); margin-right: -0.4rem; }
.dragHandle:active { cursor: grabbing; }

.bubbleMenuButton { display: flex; align-items: center; justify-content: center; height: 36px; padding: 0 0.8rem; border-radius: 6px; background-color: transparent; border: none; cursor: pointer; color: var(--text-secondary); transition: background-color 0.15s ease-out, color 0.15s ease-out; font-family: var(--font-main); font-weight: 500; font-size: 1.4rem; }
@media (hover: hover) {@media (hover: hover) {
  
  .bubbleMenuButton:hover  { background-color: var(--bg-primary); color: var(--accent); }
}

  .bubbleMenuButton:active  { background-color: var(--bg-primary); color: var(--accent); }
}
.bubbleMenuButton:active { background-color: var(--bg-primary); color: var(--accent); }

.bubbleMenuButton.active { background-color: color-mix(in srgb, var(--accent) 15%, transparent); color: var(--accent); font-weight: 600; }
.tiptap .image-node-container, .tiptap .image-compare-container, .tiptap .image-grid-container { position: relative; }
.image-node-menu { position: absolute; top: 0.75rem; right: 0.75rem; z-index: 5; display: flex; gap: 0.5rem; background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent); backdrop-filter: blur(4px); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.4rem; }
@media (hover: hover) {@media (hover: hover) {
  
  .deleteButton:hover  { background-color: color-mix(in srgb, #DC2626 15%, transparent); color: #DC2626; }
}

  .deleteButton:active  { background-color: color-mix(in srgb, #DC2626 15%, transparent); color: #DC2626; }
}
.deleteButton:active { background-color: color-mix(in srgb, #DC2626 15%, transparent); color: #DC2626; }

.tiptap .image-node-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-node-container { box-shadow: 0 0 0 3px var(--accent); }
.tiptap img { max-width: 100%; height: auto; border-radius: 8px; display: block; }
.tiptap .image-compare-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; display: block; }
.tiptap .ProseMirror-selectednode .image-compare-container { box-shadow: 0 0 0 3px var(--accent); }
.image-compare-container[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.image-compare-container[data-size="large"] { max-width: 100%; }
.image-grid-container { margin: 2rem 0; border-radius: 12px; transition: box-shadow 0.2s ease-out; padding: 1rem; border: 1px solid var(--border-color); background: var(--bg-primary); }
.tiptap .ProseMirror-selectednode .image-grid-container { box-shadow: 0 0 0 3px var(--accent); }

@media (max-width: 1024px) {
    .sanctumMain { position: relative; overflow: hidden; height: calc(100% - 60px); }
    .sanctumSidebar { 
        position: absolute; 
        top: 0; 
        right: 0; 
        width: 100%; 
        max-width: none; 
        z-index: 10; 
        border-left: none; 
        height: 100%;
        padding-bottom: 80px;
    }
    .canvasContent { padding: 3rem 1.5rem 10rem 1.5rem; }
    .canvasTitleInput { font-size: 2.4rem; }
    .canvasEditorWrapper { padding: 1.5rem; }
    .headerRight { display: none; }
    .headerLeft { flex-grow: 1; justify-content: space-between; }
    .mobileHeaderIcons { display: flex; align-items: center; gap: 1rem; }
}




--- END OF FILE app/studio/[contentType]/[id]/Editor.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

// app/studio/[contentType]/[id]/EditorCanvas.tsx
'use client';

import { motion } from 'framer-motion';
import dynamic from 'next/dynamic';
import { Editor } from '@tiptap/react';
import React, { useRef, useLayoutEffect } from 'react';
import styles from './Editor.module.css';
import { SaveStatusIcons, SaveStatus } from './SaveStatusIcons';

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
}

const RichTextEditor = dynamic(() => import('./RichTextEditor'), { ssr: false, loading: () => <div className={styles.canvasBodyPlaceholder}><p>جارٍ تحميل المحرر...</p></div> });

interface EditorCanvasProps { 
    document: any; 
    title: string; 
    onTitleChange: (newTitle: string) => void; 
    onEditorCreated: (editor: Editor) => void; 
    editor: Editor | null;
    colorDictionary: ColorMapping[];
    clientSaveStatus?: SaveStatus;
    serverSaveStatus?: SaveStatus;
    // NEW PROPS
    isAutoSaveEnabled: boolean;
    onToggleAutoSave: () => void;
}

export function EditorCanvas({ 
    document, 
    title, 
    onTitleChange, 
    onEditorCreated, 
    editor, 
    colorDictionary,
    clientSaveStatus = 'saved',
    serverSaveStatus = 'saved',
    isAutoSaveEnabled,
    onToggleAutoSave
}: EditorCanvasProps) {
    const isRelease = document._type === 'gameRelease';
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    useLayoutEffect(() => {
        const textarea = textareaRef.current;
        if (textarea) {
            textarea.style.height = 'auto'; 
            textarea.style.height = `${textarea.scrollHeight}px`; 
        }
    }, [title]);

    return (
        <motion.div className={styles.sanctumCanvas} style={{position: 'relative'}} transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}>
            <div className={styles.canvasContent}>
                {/* Passed new props to SaveStatusIcons */}
                <SaveStatusIcons 
                    clientState={clientSaveStatus} 
                    serverState={serverSaveStatus} 
                    isAutoSaveEnabled={isAutoSaveEnabled}
                    onToggleAutoSave={onToggleAutoSave}
                />
                
                <textarea
                    ref={textareaRef}
                    value={title}
                    onChange={(e) => onTitleChange(e.target.value)}
                    placeholder="عنوان بلا عنوان"
                    className={styles.canvasTitleInput}
                    rows={1}
                />
                
                <div className={styles.canvasEditorWrapper}>
                    {isRelease ? (
                        <div style={{ minHeight: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', textAlign: 'center' }}>
                            <p>لا نصَّ للإصدارات.<br />تُحرَّرُ البياناتُ من الشريط الجانبي.</p>
                        </div>
                    ) : (
                        <RichTextEditor onEditorCreated={onEditorCreated} initialContent={document.tiptapContent} colorDictionary={colorDictionary} />
                    )}
                </div>
            </div>
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/EditorCanvas.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

// app/studio/[contentType]/[id]/EditorClient.tsx

'use client';
import { useState, useMemo, useEffect, useReducer, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { EditorSidebar } from './EditorSidebar';
import { EditorCanvas } from './EditorCanvas';
import { BlockToolbar } from './BlockToolbar';
import { MobileViewToggle } from './editor-components/MobileViewToggle';
import { MobileBlockCreator } from './editor-components/MobileBlockCreator';
import { Editor } from '@tiptap/react';
import { updateDocumentAction, publishDocumentAction, validateSlugAction } from '../../actions';
import { useToast } from '@/lib/toastStore';
import { useDebounce } from '@/hooks/useDebounce';
import { useBodyClass } from '@/hooks/useBodyClass';
import { uploadFile } from './RichTextEditor';
import { UploadQuality } from '@/lib/image-optimizer';
import { tiptapToPortableText } from '../../utils/tiptapToPortableText';
import { useEditorStore } from '@/lib/editorStore';
import { useContentStore } from '@/lib/contentStore'; 
import styles from './Editor.module.css';
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';
import type { SaveStatus } from './SaveStatusIcons';

type EditorDocument = {
    _id: string; 
    _type: string; 
    _updatedAt: string; 
    title: string; 
    slug?: string | { current: string } | null;
    score?: number; 
    verdict?: string; 
    pros?: string[]; 
    cons?: string[]; 
    game?: { _id: string; title: string } | null; 
    publishedAt?: string | null; 
    mainImage?: { asset?: { _ref?: string }; _ref?: string; url?: string | null; metadata?: any }; 
    mainImageVertical?: { asset?: { _ref?: string }; _ref?: string; url?: string | null; metadata?: any }; 
    authors?: any[]; reporters?: any[]; designers?: any[]; tags?: any[]; 
    releaseDate?: string; platforms?: string[]; synopsis?: string; 
    tiptapContent?: any; content?: any; 
    category?: { _id: string; title: string } | null;
    newsType?: 'official' | 'rumor' | 'leak';
    price?: string; 
    developer?: { _id: string, title: string } | null; 
    publisher?: { _id: string, title: string } | null; 
    isTBA?: boolean; 
    trailer?: string; 
    isPinned?: boolean; 
    onGamePass?: boolean; 
    onPSPlus?: boolean; 
    datePrecision?: 'day' | 'month' | 'year';
};

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
}

const clientSlugify = (text: string): string => { if (!text) return ''; return text.toLowerCase().trim().replace(/[^a-z0-9\s-]/g, '').replace(/[\s-]+/g, '-'); };

const getId = (item: any): string | null => {
    if (!item) return null;
    if (typeof item === 'string') return item;
    return item._id || item._ref || null;
};

const getSlugString = (slug: any): string => {
    if (!slug) return '';
    if (typeof slug === 'string') return slug;
    if (typeof slug === 'object' && slug.current) return slug.current;
    return '';
};

const cleanForComparison = (val: any): any => {
    if (val === null || val === undefined) return undefined;
    if (val === '') return undefined;
    if (val === false) return undefined; 
    if (Array.isArray(val) && val.length === 0) return undefined;
    
    if (typeof val === 'number') return val;
    if (val === true) return true;
    if (typeof val === 'string') return val;

    if (Array.isArray(val)) {
        const cleaned = val.map(item => {
            const id = getId(item);
            if (id) return id; 
            return cleanForComparison(item);
        }).filter(v => v !== undefined);
        return cleaned.length > 0 ? cleaned : undefined;
    }

    if (typeof val === 'object') {
        if (val._type === 'image' || (val.asset && (val.asset._ref || val.asset._id))) {
            return val.asset?._ref || val.asset?._id || val._ref || undefined;
        }
        if (val._type === 'slug' && val.current) return val.current;
        if (val._type === 'reference' && val._ref) return val._ref;

        const newObj: any = {};
        const keys = Object.keys(val).sort();
        
        for (const key of keys) {
            if (['_key', '_type', '_weak', '_strengthenOnPublish', '_createdAt', '_updatedAt', '_rev', 'markDefs', 'asset'].includes(key)) continue;
            const cleanedVal = cleanForComparison(val[key]);
            if (cleanedVal !== undefined) {
                newObj[key] = cleanedVal;
            }
        }
        
        if (Object.keys(newObj).length === 0) return undefined;
        return newObj;
    }

    return val;
};

const isEquivalent = (a: any, b: any) => {
    const cleanA = JSON.stringify(cleanForComparison(a));
    const cleanB = JSON.stringify(cleanForComparison(b));
    return cleanA === cleanB;
};

const getInitialEditorState = (doc: EditorDocument) => {
    const currentSlug = getSlugString(doc.slug);
    
    const getMainImageRef = (img: any) => img?.asset?._ref || img?._ref || null;
    const getMainImageUrl = (img: any) => img?.url || (img?.asset?.url) || null;

    return {
        _id: doc._id,
        _type: doc._type,
        _updatedAt: doc._updatedAt,
        title: doc.title ?? '',
        slug: currentSlug,
        isSlugManual: !!currentSlug,
        score: doc.score ?? 0,
        verdict: doc.verdict ?? '',
        pros: doc.pros ?? [],
        cons: doc.cons ?? [],
        game: doc.game || null,
        publishedAt: doc.publishedAt || null,
        mainImage: {
            assetId: getMainImageRef(doc.mainImage),
            assetUrl: getMainImageUrl(doc.mainImage)
        },
        mainImageVertical: {
            assetId: getMainImageRef(doc.mainImageVertical),
            assetUrl: getMainImageUrl(doc.mainImageVertical)
        },
        authors: (doc.authors || []).filter(Boolean),
        reporters: (doc.reporters || []).filter(Boolean),
        designers: (doc.designers || []).filter(Boolean),
        tags: (doc.tags || []).filter(Boolean),
        releaseDate: doc.releaseDate || '',
        platforms: doc.platforms || [],
        synopsis: doc.synopsis || '',
        category: doc.category || null,
        newsType: doc.newsType || 'official',
        price: doc.price || '', 
        developer: doc.developer || null,
        publisher: doc.publisher || null, 
        isTBA: doc.isTBA || false, 
        trailer: doc.trailer || '', 
        isPinned: doc.isPinned || false, 
        onGamePass: doc.onGamePass || false, 
        onPSPlus: doc.onPSPlus || false,
        datePrecision: doc.datePrecision || 'day'
    };
};

function editorReducer(state: any, action: { type: string; payload: any }) {
    switch (action.type) {
        case 'INITIALIZE_STATE': return { ...state, ...action.payload, isSlugManual: !!action.payload.slug };
        case 'UPDATE_FIELD': return { ...state, [action.payload.field]: action.payload.value };
        case 'UPDATE_SLUG': return { ...state, slug: clientSlugify(action.payload.slug), isManual: action.payload.isManual };
        default: throw new Error(`Unhandled action type: ${action.type}`);
    }
}

// Updated Diff Generator: Handles null initialContentJson
const generateDiffPatch = (currentState: any, sourceOfTruth: any, editorContentJson: string, initialContentJson: string | null) => {
    const patch: Record<string, any> = {};

    const check = (key: string, stateVal: any, sotVal: any) => {
        if (!isEquivalent(stateVal, sotVal)) {
            if (key === 'slug' && stateVal) patch[key] = { _type: 'slug', current: stateVal };
            else if (key === 'category' && stateVal) patch[key] = { _type: 'reference', _ref: getId(stateVal) };
            else if (['game', 'developer', 'publisher'].includes(key) && stateVal) patch[key] = { _type: 'reference', _ref: getId(stateVal) };
            else if (['tags', 'authors', 'reporters', 'designers'].includes(key)) {
                patch[key] = (stateVal || []).map((i: any) => ({ _type: 'reference', _ref: getId(i), _key: getId(i) }));
            }
            else if (['mainImage', 'mainImageVertical'].includes(key)) {
                if (stateVal?.assetId) patch[key] = { _type: 'image', asset: { _type: 'reference', _ref: stateVal.assetId } };
                else patch[key] = undefined; 
            }
            else {
                patch[key] = stateVal;
            }
        }
    };

    check('title', currentState.title, sourceOfTruth.title);
    
    if (sourceOfTruth._type !== 'gameRelease') {
        check('slug', currentState.slug, getSlugString(sourceOfTruth.slug));
    }
    
    check('score', currentState.score, sourceOfTruth.score);
    check('verdict', currentState.verdict, sourceOfTruth.verdict);
    check('pros', currentState.pros, sourceOfTruth.pros);
    check('cons', currentState.cons, sourceOfTruth.cons);
    
    check('releaseDate', currentState.releaseDate, sourceOfTruth.releaseDate);
    check('datePrecision', currentState.datePrecision, sourceOfTruth.datePrecision);
    check('synopsis', currentState.synopsis, sourceOfTruth.synopsis);
    check('newsType', currentState.newsType, sourceOfTruth.newsType);
    check('price', currentState.price, sourceOfTruth.price);
    check('trailer', currentState.trailer, sourceOfTruth.trailer);
    check('isTBA', currentState.isTBA, sourceOfTruth.isTBA);
    check('isPinned', currentState.isPinned, sourceOfTruth.isPinned);
    check('onGamePass', currentState.onGamePass, sourceOfTruth.onGamePass);
    check('onPSPlus', currentState.onPSPlus, sourceOfTruth.onPSPlus);
    check('platforms', currentState.platforms, sourceOfTruth.platforms);

    check('category', currentState.category, sourceOfTruth.category);
    check('game', currentState.game, sourceOfTruth.game);
    check('developer', currentState.developer, sourceOfTruth.developer);
    check('publisher', currentState.publisher, sourceOfTruth.publisher);
    
    check('tags', currentState.tags, sourceOfTruth.tags);
    check('authors', currentState.authors, sourceOfTruth.authors);
    check('reporters', currentState.reporters, sourceOfTruth.reporters);
    check('designers', currentState.designers, sourceOfTruth.designers);

    const sotMainImageState = { assetId: getId(sourceOfTruth.mainImage?.asset || sourceOfTruth.mainImage) };
    const sotVertImageState = { assetId: getId(sourceOfTruth.mainImageVertical?.asset || sourceOfTruth.mainImageVertical) };
    
    if (currentState.mainImage.assetId !== sotMainImageState.assetId) {
        check('mainImage', currentState.mainImage, null); 
    }
    if (currentState.mainImageVertical.assetId !== sotVertImageState.assetId) {
        check('mainImageVertical', currentState.mainImageVertical, null);
    }

    // CONTENT CHECK: Compare Tiptap JSON Strings
    if (sourceOfTruth._type !== 'gameRelease') {
        // FIX: If initialContentJson is null, we assume the editor is initializing, so no changes yet.
        if (initialContentJson !== null && editorContentJson !== initialContentJson) {
            const currentContentPortableText = tiptapToPortableText(JSON.parse(editorContentJson));
            patch.content = currentContentPortableText;
        }
    }

    return patch;
};

export function EditorClient({ 
    document: initialDocument, 
    colorDictionary: initialColorDictionary,
    studioMetadata 
}: { 
    document: EditorDocument, 
    colorDictionary: ColorMapping[],
    studioMetadata: any 
}) {
    const { isOverlayOpen } = useContentStore();

    const [sourceOfTruth, setSourceOfTruth] = useState<EditorDocument>(initialDocument);
    const [state, dispatch] = useReducer(editorReducer, getInitialEditorState(initialDocument));
    const { title, slug, isSlugManual } = state;
    const toast = useToast();
    const [isSidebarOpen, setIsSidebarOpen] = useState(false);
    const [isMobile, setIsMobile] = useState(false);
    const [editorInstance, setEditorInstance] = useState<Editor | null>(null);
    const [mainImageUploadQuality, setMainImageUploadQuality] = useState<UploadQuality>('1080p');
    const { blockUploadQuality, setBlockUploadQuality, setEditorActive, setLiveUrl } = useEditorStore();

    const initialSlug = getSlugString(initialDocument.slug);
    const [slugValidationStatus, setSlugValidationStatus] = useState<'pending' | 'valid' | 'invalid'>(
        initialSlug ? 'valid' : 'pending'
    );
    const [slugValidationMessage, setSlugValidationMessage] = useState(
        initialSlug ? 'المُعرِّفُ صالح.' : 'جارٍ التحقق...'
    );

    const debouncedSlug = useDebounce(slug, 500);
    
    // CONTENT STATE
    // FIX: Initialize to null to indicate "not yet synchronized with Tiptap"
    const [initialContentJson, setInitialContentJson] = useState<string | null>(null);
    const [editorContentJson, setEditorContentJson] = useState<string>('');
    
    const [colorDictionary, setColorDictionary] = useState<ColorMapping[]>(initialColorDictionary);
    
    const [clientSaveStatus, setClientSaveStatus] = useState<SaveStatus>('saved');
    const [serverSaveStatus, setServerSaveStatus] = useState<SaveStatus>('saved');
    const serverSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const [hasHydratedFromLocal, setHasHydratedFromLocal] = useState(false);
    const [isAutoSaveEnabled, setIsAutoSaveEnabled] = useState(false);
    
    const justSavedRef = useRef(false);

    const stateRef = useRef(state);
    const contentJsonRef = useRef(editorContentJson);
    const needsClientSaveRef = useRef(false);

    useBodyClass('sidebar-open', isSidebarOpen && isMobile);
    
    useEffect(() => {
        setEditorActive(true);
        document.body.classList.add('editor-active');
        return () => {
            const isStillEditor = window.location.pathname.match(/^\/studio\/(reviews|articles|news|releases)\//);
            if (!isStillEditor) {
                setEditorActive(false);
                setLiveUrl(null);
                document.body.classList.remove('editor-active');
            }
        };
    }, [setEditorActive, setLiveUrl]);

    useEffect(() => {
        const docSlug = getSlugString(sourceOfTruth.slug);
        const { _type, publishedAt } = sourceOfTruth;
        const isPublished = publishedAt && new Date(publishedAt) <= new Date();
        
        if (isPublished && docSlug && _type !== 'gameRelease') {
            const contentTypePlural = _type === 'review' ? 'reviews' : _type === 'article' ? 'articles' : 'news';
            const url = `/${contentTypePlural}/${docSlug}`;
            setLiveUrl(url);
        } else {
            setLiveUrl(null);
        }
    }, [sourceOfTruth, setLiveUrl]);
    
    useEffect(() => {
        const viewport = document.querySelector('meta[name="viewport"]');
        if (viewport) {
            const originalContent = viewport.getAttribute('content');
            viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            return () => { if (originalContent) { viewport.setAttribute('content', originalContent); } };
        }
    }, []);

    useEffect(() => { const handleResize = () => { const mobile = window.innerWidth <= 1024; setIsMobile(mobile); if (!mobile) setIsSidebarOpen(true); }; handleResize(); window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize); }, []);
    
    // --- SAFE HYDRATION ---
    useEffect(() => {
        if (!editorInstance || hasHydratedFromLocal) return;

        const key = `eternal-draft-${initialDocument._id}`;
        const saved = localStorage.getItem(key);

        if (saved) {
            try {
                const localData = JSON.parse(saved);
                
                const serverTime = new Date(initialDocument._updatedAt).getTime();
                const localTime = localData.updatedAt ? new Date(localData.updatedAt).getTime() : 0;
                
                if (localTime > serverTime) {
                    if (localData.state && localData.contentJson) {
                        dispatch({ type: 'INITIALIZE_STATE', payload: localData.state });
                        setEditorContentJson(localData.contentJson);
                        // Force editor update
                        const contentObj = JSON.parse(localData.contentJson);
                        editorInstance.commands.setContent(contentObj, false); 
                        // Set initial to match local so no immediate diff
                        setInitialContentJson(localData.contentJson);
                        toast.info('تم استعادة مسودة غير محفوظة من جهازك.', 'left');
                    }
                } else {
                    localStorage.removeItem(key);
                }
            } catch (e) {
                localStorage.removeItem(key);
            }
        }
        setHasHydratedFromLocal(true);
    }, [editorInstance, initialDocument._id, initialDocument._updatedAt, hasHydratedFromLocal, toast]);

    const patch = useMemo(() => generateDiffPatch(state, sourceOfTruth, editorContentJson, initialContentJson), [state, sourceOfTruth, editorContentJson, initialContentJson]);
    const hasChanges = Object.keys(patch).length > 0;

    useEffect(() => {
        stateRef.current = state;
        contentJsonRef.current = editorContentJson;
        
        if (hasChanges) {
            needsClientSaveRef.current = true;
            setClientSaveStatus('saving'); 
            setServerSaveStatus('pending'); 
        } else {
            needsClientSaveRef.current = false;
            setClientSaveStatus('saved');
            setServerSaveStatus('saved');
        }
    }, [state, editorContentJson, hasChanges]);

    useEffect(() => {
        const intervalId = setInterval(() => {
            if (needsClientSaveRef.current) {
                const key = `eternal-draft-${sourceOfTruth._id}`;
                const payload = {
                    state: stateRef.current,
                    contentJson: contentJsonRef.current,
                    updatedAt: new Date().toISOString()
                };
                localStorage.setItem(key, JSON.stringify(payload));
                needsClientSaveRef.current = false;
                setClientSaveStatus('saved');
            }
        }, 300);

        return () => clearInterval(intervalId);
    }, [sourceOfTruth._id]);

    useEffect(() => { if (editorInstance) editorInstance.storage.uploadQuality = blockUploadQuality; }, [blockUploadQuality, editorInstance]);
    
    // --- SOURCE OF TRUTH UPDATES ---
    useEffect(() => { 
        if (sourceOfTruth._updatedAt !== state._updatedAt) {
            // If we just saved locally, we TRUST our local state.
            if (justSavedRef.current) {
                dispatch({ type: 'UPDATE_FIELD', payload: { field: '_updatedAt', value: sourceOfTruth._updatedAt } });
                justSavedRef.current = false;
                return;
            }

            const newState = getInitialEditorState(sourceOfTruth);
            dispatch({ type: 'INITIALIZE_STATE', payload: newState }); 
            
            // Sync content from SOT
            const freshTiptapContent = portableTextToTiptap(sourceOfTruth.content || []);
            const freshJsonStr = JSON.stringify(freshTiptapContent);
            
            setInitialContentJson(freshJsonStr);
            
            if (editorInstance) { 
                 if (!hasChanges) { 
                    editorInstance.commands.setContent(freshTiptapContent, false); 
                    setEditorContentJson(freshJsonStr);
                 } 
            }
        }
    }, [sourceOfTruth._updatedAt, editorInstance]); 

    // --- TIPTAP UPDATE HANDLER ---
    useEffect(() => { 
        if (editorInstance) { 
            const updateJson = () => {
                const json = JSON.stringify(editorInstance.getJSON());
                setEditorContentJson(json);
                // FIX: On first valid update (mount/normalization), set initial if null
                setInitialContentJson((prev) => prev === null ? json : prev);
            };
            
            // Initial call to set state immediately on mount
            updateJson();
            
            editorInstance.on('update', updateJson); 
            return () => { editorInstance.off('update', updateJson); }; 
        } 
    }, [editorInstance]);
    
    useEffect(() => { 
        if (!isSlugManual && title !== sourceOfTruth.title) { 
            dispatch({ type: 'UPDATE_SLUG', payload: { slug: clientSlugify(title), isManual: false } }); 
        } 
    }, [title, isSlugManual, sourceOfTruth.title]);
    
    useEffect(() => {
        if (state._type === 'gameRelease') { setSlugValidationStatus('valid'); setSlugValidationMessage(''); return; }
        if (!state._id || !debouncedSlug) { 
             if (debouncedSlug === '') {
                 setSlugValidationStatus('invalid'); 
                 setSlugValidationMessage('لا يكُن المُعرِّفُ خاويًا.');
             }
             return; 
        } 
        
        const sotSlugStr = getSlugString(sourceOfTruth.slug);
        if (debouncedSlug === sotSlugStr) {
            setSlugValidationStatus('valid');
            setSlugValidationMessage('المُعرِّفُ صالح.');
            return;
        }
        
        setSlugValidationStatus('pending'); 
        setSlugValidationMessage('جارٍ التحقق...'); 
        const checkSlug = async () => { 
            const result = await validateSlugAction(debouncedSlug, state._id); 
            setSlugValidationStatus(result.isValid ? 'valid' : 'invalid'); 
            setSlugValidationMessage(result.message); 
        }; 
        checkSlug();
    }, [debouncedSlug, state._id, state._type, sourceOfTruth.slug]);

    const isDocumentValid = useMemo(() => { const { title, slug, mainImage, game, score, verdict, authors, reporters, releaseDate, platforms, synopsis, category, isTBA } = state; const type = sourceOfTruth._type; const baseValid = title.trim() && mainImage.assetId; if (!baseValid) return false; if (type !== 'gameRelease' && !slug.trim()) return false; if (type === 'review') return game?._id && (authors || []).length > 0 && score > 0 && verdict.trim(); if (type === 'article') return game?._id && (authors || []).length > 0; if (type === 'news') return (reporters || []).length > 0 && category; if (type === 'gameRelease') return game?._id && (isTBA || releaseDate.trim()) && synopsis.trim() && (platforms || []).length > 0; return false; }, [state, sourceOfTruth._type]);
    
    const saveWorkingCopy = useCallback(async (): Promise<boolean> => { 
        const currentPatch = generateDiffPatch(state, sourceOfTruth, editorContentJson, initialContentJson);
        const currentHasChanges = Object.keys(currentPatch).length > 0;

        if (!currentHasChanges) {
             needsClientSaveRef.current = false;
             setClientSaveStatus('saved');
             return true; 
        }

        if (sourceOfTruth._type !== 'gameRelease' && slugValidationStatus !== 'valid') { 
            toast.error('لا يمكن الحفظ بمُعرِّف غير صالح.', 'left'); 
            return false; 
        } 

        const result = await updateDocumentAction(sourceOfTruth._id, currentPatch); 
        
        if (result.success && result.updatedDocument) { 
            justSavedRef.current = true;
            
            // FIX: Force synchronization of initial content state with current state
            setInitialContentJson(editorContentJson);
            
            dispatch({ type: 'UPDATE_FIELD', payload: { field: '_updatedAt', value: result.updatedDocument._updatedAt } });

            setSourceOfTruth(result.updatedDocument);
            
            const key = `eternal-draft-${sourceOfTruth._id}`;
            localStorage.removeItem(key);
            
            return true; 
        } else { 
            toast.error(result.message || 'أخفق حفظ التغييرات.', 'left'); 
            return false; 
        } 
    }, [state, sourceOfTruth, editorContentJson, initialContentJson, slugValidationStatus, toast]);
    
    useEffect(() => {
        if (hasChanges && isAutoSaveEnabled) {
            if (serverSaveTimeoutRef.current) clearTimeout(serverSaveTimeoutRef.current);
            serverSaveTimeoutRef.current = setTimeout(async () => {
                setServerSaveStatus('saving');
                await saveWorkingCopy();
                setServerSaveStatus('saved'); 
            }, 10000); 
        }
    }, [hasChanges, saveWorkingCopy, isAutoSaveEnabled]); 

    const handlePublish = async (publishTime?: string | null): Promise<boolean> => { 
        if (!isDocumentValid) {
            toast.error('يرجى ملء الحقول الإلزامية قبل النشر.', 'left');
            return false;
        }
        const didSave = await saveWorkingCopy(); 
        if (!didSave) return false; 
        
        const result = await publishDocumentAction(sourceOfTruth._id, publishTime); 
        if (result.success && result.updatedDocument) { 
            justSavedRef.current = true;
            
            setSourceOfTruth(prev => ({
                ...result.updatedDocument,
                content: prev.content, 
                tiptapContent: prev.tiptapContent
            })); 
            
            toast.success(result.message || 'تجددت حالة النشر!', 'left'); 
            return true; 
        } else { 
            toast.error(result.message || 'أخفق تحديث الحالة.', 'left'); 
            return false; 
        } 
    };

    useEffect(() => { if (hasChanges) { document.title = `*لم يُحفظ* ${title || 'بلا عنوان'}`; window.onbeforeunload = () => "أَتَغادرُ وما كتبت لم يُحفظ؟"; } else { document.title = title || "EternalGames الديوان"; window.onbeforeunload = null; } return () => { window.onbeforeunload = null; }; }, [hasChanges, title]);
    
    const isRelease = initialDocument._type === 'gameRelease';
    if (isOverlayOpen) return null;

    return (
        <div className={styles.sanctumContainer}>
            <div className={styles.sanctumMain}>
                <motion.div
                    style={{ position: isMobile ? 'absolute' : 'relative', top: 0, right: 0, bottom: 0, width: isMobile ? '100%' : 'auto', pointerEvents: isMobile && !isSidebarOpen ? 'none' : 'auto' }}
                    animate={{ x: isMobile ? (isSidebarOpen ? '0%' : '100%') : '0%' }}
                    transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}
                >
                    <EditorSidebar 
                        document={sourceOfTruth} 
                        isOpen={isSidebarOpen} 
                        documentState={state} 
                        dispatch={dispatch} 
                        onSave={saveWorkingCopy} 
                        hasChanges={hasChanges} 
                        onPublish={handlePublish} 
                        slugValidationStatus={slugValidationStatus} 
                        slugValidationMessage={slugValidationMessage} 
                        isDocumentValid={isDocumentValid} 
                        mainImageUploadQuality={mainImageUploadQuality} 
                        onMainImageUploadQualityChange={setMainImageUploadQuality} 
                        colorDictionary={colorDictionary}
                        onColorDictionaryUpdate={setColorDictionary}
                        studioMetadata={studioMetadata} 
                    />
                </motion.div>
                <motion.div
                    style={{ position: isMobile ? 'absolute' : 'relative', top: 0, left: 0, bottom: 0, width: '100%', pointerEvents: isMobile && isSidebarOpen ? 'none' : 'auto' }}
                    animate={{ x: isMobile ? (isSidebarOpen ? '-100%' : '0%') : '0%' }}
                    transition={{ duration: 0.5, ease: [0.4, 0, 0.2, 1] }}
                >
                    <EditorCanvas 
                        document={sourceOfTruth} 
                        title={title} 
                        onTitleChange={(newTitle) => dispatch({ type: 'UPDATE_FIELD', payload: { field: 'title', value: newTitle } })} 
                        onEditorCreated={setEditorInstance} 
                        editor={editorInstance} 
                        colorDictionary={colorDictionary}
                        clientSaveStatus={clientSaveStatus}
                        serverSaveStatus={serverSaveStatus}
                        isAutoSaveEnabled={isAutoSaveEnabled}
                        onToggleAutoSave={() => setIsAutoSaveEnabled(prev => !prev)}
                    />
                </motion.div>
            </div>
            
            <AnimatePresence>
                {!isRelease && !isMobile && (
                    <BlockToolbar key="block-toolbar-desktop" editor={editorInstance} onFileUpload={(file) => { if (editorInstance) { uploadFile(file, editorInstance, toast, blockUploadQuality); } }} uploadQuality={blockUploadQuality} onUploadQualityChange={setBlockUploadQuality} />
                )}
                {!isRelease && isMobile && !isSidebarOpen && (
                    <MobileBlockCreator key="block-creator-mobile" editor={editorInstance} onFileUpload={(file) => { if (editorInstance) { uploadFile(file, editorInstance, toast, blockUploadQuality); } }} />
                )}
            </AnimatePresence>
             {isMobile && (
                <MobileViewToggle isSidebarOpen={isSidebarOpen} setIsSidebarOpen={setIsSidebarOpen} />
            )}
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/EditorClient.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

// components/studio/[contentType]/[id]/EditorSidebar.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { useState, useMemo, useTransition, useEffect } from 'react';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { ProsConsInput } from './metadata/ProsConsInput';
import { GameInput } from './metadata/GameInput';
import { TagInput } from './metadata/TagInput';
import { MainImageInput } from './metadata/MainImageInput';
import { CreatorInput } from './metadata/CreatorInput';
import { PlatformInput } from './metadata/PlatformInput';
import { SlugInput } from './metadata/SlugInput';
import { NewsTypeInput } from './metadata/NewsTypeInput'; 
import { DeveloperInput } from './metadata/DeveloperInput'; 
import { PublisherInput } from './metadata/PublisherInput'; 
import ColorDictionaryManager from './metadata/color-dictionary/ColorDictionaryManager';
import VerticalImageEditor from './metadata/VerticalImageEditor'; // IMPORTED
import { UploadQuality } from '@/lib/image-optimizer';
import styles from './Editor.module.css';

const sidebarVariants = { hidden: { opacity: 0, x: 50 }, visible: { opacity: 1, x: 0, transition: { type: 'spring' as const, stiffness: 400, damping: 40 } }, exit: { opacity: 0, x: 50, transition: { duration: 0.2, ease: 'easeInOut' as const } } };
const itemVariants = { hidden: { opacity: 0, y: 10 }, visible: { opacity: 1, y: 0 } };
const ToggleSwitch = ({ checked, onChange, name }: { checked: boolean, onChange: (checked: boolean) => void, name?: string }) => ( <button type="button" role="switch" aria-checked={checked} onClick={() => onChange(!checked)} className={`toggle ${checked ? 'active' : ''}`}> <motion.div className="toggle-handle" layout transition={{ type: 'spring' as const, stiffness: 700, damping: 30 }} /> {name && <input type="checkbox" name={name} checked={checked} readOnly style={{ display: 'none' }} />} </button> );

export function EditorSidebar({ 
    document, isOpen, documentState, dispatch, onSave, hasChanges, onPublish, 
    slugValidationStatus, slugValidationMessage, isDocumentValid, 
    mainImageUploadQuality, onMainImageUploadQualityChange,
    colorDictionary,
    studioMetadata 
}: any) {
    const { title, slug, score, verdict, pros, cons, game, tags, mainImage, mainImageVertical, authors, reporters, designers, releaseDate, platforms, synopsis, category, isSlugManual, newsType, price, developer, publisher, isTBA, trailer, isPinned, onGamePass, onPSPlus, datePrecision } = documentState;
    const [scheduledDateTime, setScheduledDateTime] = useState('');
    const [isSaving, startSaveTransition] = useTransition();
    const [isPublishing, startPublishTransition] = useTransition();
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success'>('idle');

    const publishedAt = document.publishedAt;
    const isReview = document._type === 'review';
    const isArticle = document._type === 'article';
    const isNews = document._type === 'news';
    const isRelease = document._type === 'gameRelease';

    const primaryCreatorConfig = useMemo(() => {
        if (isReview) return { label: 'المراجعون', sanityType: 'REVIEWER', field: 'authors' };
        if (isArticle) return { label: 'الكتّاب', sanityType: 'AUTHOR', field: 'authors' };
        if (isNews) return { label: 'المراسلون', sanityType: 'REPORTER', field: 'reporters' };
        return { label: 'المنشئون', sanityType: 'AUTHOR', field: 'authors' };
    }, [isReview, isArticle, isNews]);

    const handleSave = () => { startSaveTransition(async () => { setSaveStatus('saving'); const success = await onSave(); setSaveStatus(success ? 'success' : 'idle'); if(success) setTimeout(() => setSaveStatus('idle'), 2000); }); };
    
    const isPublished = useMemo(() => publishedAt && new Date(publishedAt) <= new Date(), [publishedAt]);
    const isScheduled = useMemo(() => publishedAt && new Date(publishedAt) > new Date(), [publishedAt]);
    const isSlugValid = slugValidationStatus === 'valid';
    const isSlugPending = slugValidationStatus === 'pending';

    const handlePublishClick = () => { 
        startPublishTransition(async () => { 
            const publishDate = isRelease ? '' : (scheduledDateTime || ''); 
            let success = false;
            if (hasChanges) { 
                const saveSuccess = await onSave(); 
                if (saveSuccess) { 
                    success = await onPublish(publishDate); 
                } 
            } else { 
                success = await onPublish(publishDate); 
            } 
            if (success) { setScheduledDateTime(''); }
        }); 
    };
    
    const publishButtonText = useMemo(() => {
        if (isRelease) { return "تحديث الإصدار"; }
        if (scheduledDateTime) return hasChanges ? "حفظ وجدولة" : "جدولة";
        if (isPublished) return hasChanges ? "حفظ وتحديث" : "تحديث";
        return hasChanges ? "حفظ ونشر" : "نشر";
    }, [isRelease, isPublished, scheduledDateTime, hasChanges]);

    const canPerformPublishAction = useMemo(() => {
        if (hasChanges) return true;
        if (isRelease) return false;
        if (!publishedAt) return true;
        if (isScheduled) return true;
        if (isPublished) { if (scheduledDateTime) return true; return false; }
        return true;
    }, [hasChanges, isRelease, publishedAt, isScheduled, isPublished, scheduledDateTime]);

    const isSaveDisabled = isSaving || !hasChanges || !isSlugValid || isSlugPending || isPublishing;
    const isPublishDisabled = isPublishing || !isDocumentValid || !isSlugValid || isSlugPending || isSaving || !canPerformPublishAction;
    const isUnpublishDisabled = isPublishing || !isSlugValid || isSlugPending || isSaving;
    const handleFieldChange = (field: string, value: any) => { dispatch({ type: 'UPDATE_FIELD', payload: { field, value } }); };

    // --- Date Component Logic ---
    const [year, setYear] = useState<string>('');
    const [month, setMonth] = useState<string>('');
    const [day, setDay] = useState<string>('');
    const [initializedDate, setInitializedDate] = useState(false);

    // One-time initialization from document state
    useEffect(() => {
        if (releaseDate && !initializedDate) {
            const d = new Date(releaseDate);
            if (!isNaN(d.getTime())) {
                setYear(d.getFullYear().toString());
                if (datePrecision === 'month' || datePrecision === 'day') {
                    setMonth((d.getMonth() + 1).toString().padStart(2, '0'));
                }
                if (datePrecision === 'day') {
                    setDay(d.getDate().toString().padStart(2, '0'));
                }
            }
            setInitializedDate(true);
        }
    }, [releaseDate, datePrecision, initializedDate]);

    // Handle Manual Changes to Date Parts
    const updateReleaseDate = (newYear: string, newMonth: string, newDay: string) => {
        setYear(newYear);
        setMonth(newMonth);
        const effectiveDay = newMonth ? newDay : ''; 
        setDay(effectiveDay);

        let newPrecision = 'year';
        const y = newYear || new Date().getFullYear().toString();
        let m = '12';
        let d = '31';

        if (newMonth) {
            m = newMonth;
            if (effectiveDay) {
                 newPrecision = 'day';
                 d = effectiveDay;
            } else {
                 newPrecision = 'month';
                 const lastDay = new Date(parseInt(y), parseInt(m), 0).getDate();
                 d = lastDay.toString();
            }
        } else {
            newPrecision = 'year';
        }

        const mStr = m.padStart(2, '0');
        const dStr = d.padStart(2, '0');
        const newDateStr = `${y}-${mStr}-${dStr}`;

        if (newDateStr !== releaseDate) handleFieldChange('releaseDate', newDateStr);
        if (newPrecision !== datePrecision) handleFieldChange('datePrecision', newPrecision);
    };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.aside className={styles.sanctumSidebar} variants={sidebarVariants} initial="hidden" animate="visible" exit="exit">
                    <motion.div variants={itemVariants} className={styles.sidebarContent}>
                        <h2 className={styles.sidebarTitle}>منصة التحرير</h2>
                        <p className={styles.sidebarSubtitle}>تحرير: {title}</p>
                    </motion.div>
                    
                    <motion.div className={styles.sidebarSection} variants={itemVariants}>
                        {!isRelease && ( <> <label className={styles.sidebarLabel} style={{ marginBottom: '0.75rem' }}>جدولة (اختياري)</label> <input type="datetime-local" value={scheduledDateTime} onChange={(e) => setScheduledDateTime(e.target.value)} className={styles.sidebarInput} disabled={isPublishing || isSaving} /> </> )}
                        <motion.button onClick={handlePublishClick} className="primary-button" style={{ width: '100%', marginTop: '1rem', height: '44px', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} disabled={isPublishDisabled} animate={{ width: isPublishing ? '44px' : '100%', borderRadius: isPublishing ? '50%' : '5px', paddingLeft: isPublishing ? 0 : '2.4rem', paddingRight: isPublishing ? 0 : '2.4rem' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                            <AnimatePresence mode="wait">{isPublishing ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}} style={{whiteSpace: 'nowrap'}}>{publishButtonText}</motion.span>}</AnimatePresence>
                        </motion.button>
                        {!isRelease && (isPublished || isScheduled) && (<motion.button onClick={() => onPublish(null)} className="outline-button" style={{ width: '100%', marginTop: '0.5rem', color: '#DC2626', borderColor: '#DC2626' }} disabled={isUnpublishDisabled}>إلغاء النشر</motion.button>)}
                        <p style={{ marginTop: '0.5rem', color: 'var(--text-secondary)', fontSize: '1.4rem', textAlign: 'right' }}> {!isDocumentValid && <span style={{ color: '#DC2626' }}>الحقول الإلزامية ناقصة.</span>}</p>
                    </motion.div>

                    <fieldset disabled={isSaving || isPublishing} style={{border: 'none', padding: 0, margin: 0, minWidth: 0}}>
                        <motion.div className={styles.sidebarSection} variants={itemVariants}>
                            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem'}}>
                                <label className={styles.sidebarLabel} style={{marginBottom: 0}}>الصور</label>
                                <div style={{display: 'flex', alignItems: 'center', gap: '1rem', fontFamily: 'var(--font-main)', fontSize: '1.4rem'}}>
                                    <span>1080p</span>
                                    <ToggleSwitch checked={mainImageUploadQuality === '4k'} onChange={(isChecked) => onMainImageUploadQualityChange(isChecked ? '4k' : '1080p')} />
                                    <span>4K</span>
                                </div>
                            </div>
                            
                            {/* Horizontal Main Image */}
                            <label className={styles.sidebarLabel} style={{fontSize: '1.2rem', marginTop: '0.5rem'}}>رئيسية (أفقية)</label>
                            <MainImageInput 
                                currentAssetId={mainImage.assetId} 
                                currentAssetUrl={mainImage.assetUrl} 
                                onImageChange={(assetId, assetUrl) => handleFieldChange('mainImage', { assetId, assetUrl })} 
                                uploadQuality={mainImageUploadQuality} 
                            />

                            {/* Vertical Vanguard Image - REPLACED WITH NEW EDITOR */}
                            <div style={{ marginTop: '2.5rem' }}>
                                <label className={styles.sidebarLabel} style={{fontSize: '1.2rem'}}>Vanguard (عمودية - 4:5)</label>
                                <VerticalImageEditor 
                                    currentImageUrl={mainImageVertical.assetUrl} 
                                    onImageChange={(assetId, assetUrl) => handleFieldChange('mainImageVertical', { assetId, assetUrl })} 
                                    uploadQuality={mainImageUploadQuality} 
                                />
                            </div>
                        </motion.div>
                        
                        {!isRelease && (
                            <SlugInput 
                                slug={slug} title={title} docId={document._id} isSlugManual={isSlugManual}
                                slugValidationStatus={slugValidationStatus} slugValidationMessage={slugValidationMessage} dispatch={dispatch}
                            />
                        )}
                        
                        {isRelease ? ( <> 
                            <motion.div variants={itemVariants}><GameInput allGames={studioMetadata?.games || []} selectedGame={game} onGameSelect={(g: any) => handleFieldChange('game', g)} /></motion.div>
                            
                            <motion.div className={styles.sidebarSection} variants={itemVariants}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                    <label className={styles.sidebarLabel} style={{marginBottom: 0}}>تثبيت في المقدمة</label>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <ToggleSwitch name="isPinned" checked={isPinned} onChange={(val) => handleFieldChange('isPinned', val)} />
                                    </div>
                                </div>
                                <label className={styles.sidebarLabel}>رابط العرض الدعائي (YouTube)</label>
                                <input type="url" value={trailer || ''} onChange={(e) => handleFieldChange('trailer', e.target.value)} placeholder="https://youtube.com/..." className={styles.sidebarInput} dir="ltr"/>
                            </motion.div>

                            <motion.div className={styles.sidebarSection} variants={itemVariants}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                    <label className={styles.sidebarLabel}>تاريخ الإصدار</label>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <span style={{ fontSize: '1.2rem', color: 'var(--text-secondary)' }}>TBA</span>
                                        <ToggleSwitch name="isTBA" checked={isTBA} onChange={(val) => handleFieldChange('isTBA', val)} />
                                    </div>
                                </div>

                                {!isTBA && (
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        {/* Year Input (Required) */}
                                        <div style={{ flex: 1 }}>
                                            <input 
                                                type="number" 
                                                placeholder="السنة (YYYY)" 
                                                value={year} 
                                                onChange={(e) => updateReleaseDate(e.target.value, month, day)} 
                                                className={styles.sidebarInput} 
                                                min="2000" max="2100"
                                            />
                                        </div>
                                        
                                        {/* Month Input (Optional) */}
                                        <div style={{ flex: 1 }}>
                                            <select 
                                                value={month} 
                                                onChange={(e) => updateReleaseDate(year, e.target.value, day)}
                                                className={styles.sidebarInput}
                                                style={{ paddingRight: '0.5rem' }}
                                            >
                                                <option value="">الشهر (اختياري)</option>
                                                {Array.from({ length: 12 }).map((_, i) => (
                                                    <option key={i} value={String(i + 1).padStart(2, '0')}>
                                                        {new Date(0, i).toLocaleString('ar-EG', { month: 'short' })}
                                                    </option>
                                                ))}
                                            </select>
                                        </div>

                                        {/* Day Input (Optional, disabled if no month) */}
                                        <div style={{ flex: 0.6 }}>
                                            <input 
                                                type="number" 
                                                placeholder="اليوم" 
                                                min="1" max="31"
                                                value={day} 
                                                onChange={(e) => updateReleaseDate(year, month, e.target.value)} 
                                                className={styles.sidebarInput}
                                                disabled={!month}
                                                style={{ opacity: !month ? 0.5 : 1 }}
                                            />
                                        </div>
                                    </div>
                                )}
                            </motion.div> 
                            
                            <motion.div className={styles.sidebarSection} variants={itemVariants}>
                                <label className={styles.sidebarLabel}>السعر</label>
                                <input type="text" placeholder="$69.99 أو Free" value={price || ''} onChange={(e) => handleFieldChange('price', e.target.value)} className={styles.sidebarInput} />
                            </motion.div>

                            <motion.div className={styles.sidebarSection} variants={itemVariants}>
                                <label className={styles.sidebarLabel} style={{marginBottom: '1rem'}}>خدمات الاشتراك</label>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <span style={{ fontSize: '1.4rem', color: 'var(--text-primary)' }}>Game Pass</span>
                                        <ToggleSwitch name="onGamePass" checked={onGamePass} onChange={(val) => handleFieldChange('onGamePass', val)} />
                                    </div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <span style={{ fontSize: '1.4rem', color: 'var(--text-primary)' }}>PlayStation Plus</span>
                                        <ToggleSwitch name="onPSPlus" checked={onPSPlus} onChange={(val) => handleFieldChange('onPSPlus', val)} />
                                    </div>
                                </div>
                            </motion.div>

                            <motion.div variants={itemVariants}><DeveloperInput allDevelopers={studioMetadata?.developers || []} selectedDeveloper={developer} onDeveloperSelect={(dev) => handleFieldChange('developer', dev)} /></motion.div>
                            <motion.div variants={itemVariants}><PublisherInput allPublishers={studioMetadata?.publishers || []} selectedPublisher={publisher} onPublisherSelect={(pub) => handleFieldChange('publisher', pub)} /></motion.div>
                            <motion.div variants={itemVariants}><PlatformInput selectedPlatforms={platforms} onPlatformsChange={(p: any) => handleFieldChange('platforms', p)} /></motion.div>
                            <motion.div variants={itemVariants}><TagInput allTags={studioMetadata?.tags || []} label="الوسوم (Genres)" placeholder="ابحث أو أنشئ وسمًا..." selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game" /></motion.div>
                            <motion.div variants={itemVariants}><CreatorInput allCreators={studioMetadata?.creators || []} role="DESIGNER" label="المصممون (اختياري)" selectedCreators={designers} onCreatorsChange={(c: any) => handleFieldChange('designers', c)} /></motion.div>
                            <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>نبذة</label> <textarea value={synopsis} onChange={(e) => handleFieldChange('synopsis', e.target.value)} className={styles.sidebarInput} rows={5} /> </motion.div> 
                        </> ) : ( <> 
                             <div><CreatorInput allCreators={studioMetadata?.creators || []} role={primaryCreatorConfig.sanityType as any} label={primaryCreatorConfig.label} selectedCreators={documentState[primaryCreatorConfig.field]} onCreatorsChange={(c: any) => handleFieldChange(primaryCreatorConfig.field, c)} /></div> 
                             <div><GameInput allGames={studioMetadata?.games || []} selectedGame={game} onGameSelect={(g: any) => handleFieldChange('game', g)} /></div> 
                             {isNews && ( <> <motion.div variants={itemVariants}><TagInput allTags={studioMetadata?.tags || []} label="التصنيف" placeholder="اختر تصنيف الخبر..." selectedTags={category ? [category] : []} onTagsChange={(newCategoryArr: any) => handleFieldChange('category', newCategoryArr[0] || null)} singleSelection={true} categoryForCreation="News" /></motion.div> <motion.div variants={itemVariants}><NewsTypeInput value={newsType || 'official'} onChange={(val) => handleFieldChange('newsType', val)} /></motion.div> </> )}
                             {isArticle && ( <> <div><TagInput allTags={studioMetadata?.tags || []} label="نوع المقال" placeholder="اختر نوع المقال..." selectedTags={category ? [category] : []} onTagsChange={(newCategoryArr: any) => handleFieldChange('category', newCategoryArr[0] || null)} singleSelection={true} categoryForCreation="Article" /></div> <div><TagInput allTags={studioMetadata?.tags || []} label="الوسوم" placeholder="ابحث أو أنشئ وسمًا..." selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game" /></div> </> )}
                             {isReview && ( <div><TagInput allTags={studioMetadata?.tags || []} label="الوسوم" placeholder="ابحث أو أنشئ وسمًا..." selectedTags={tags} onTagsChange={(t: any) => handleFieldChange('tags', t)} categoryForCreation="Game"/></div> )}
                             <div><CreatorInput allCreators={studioMetadata?.creators || []} role="DESIGNER" label="المصممون (اختياري)" selectedCreators={designers} onCreatorsChange={(c: any) => handleFieldChange('designers', c)} /></div>
                        </> )}
                        
                        {isReview && (<> <motion.hr variants={itemVariants} style={{ border: 'none', borderTop: '1px solid var(--border-color)', margin: '1rem 0' }} /> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>التقييم (0-10) {score <= 0 && <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>}</label> <input type="number" value={score} onChange={(e) => handleFieldChange('score', parseFloat(e.target.value) || 0)} className={styles.sidebarInput} min="0" max="10" step="0.1" /> </motion.div> <motion.div className={styles.sidebarSection} variants={itemVariants}> <label className={styles.sidebarLabel}>الخلاصة {!verdict.trim() && <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>}</label> <textarea value={verdict} onChange={(e) => handleFieldChange('verdict', e.target.value)} className={styles.sidebarInput} rows={3} /> </motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المحاسن" items={pros} setItems={(p: any) => handleFieldChange('pros', p)} /></motion.div> <motion.div variants={itemVariants}><ProsConsInput label="المساوئ" items={cons} setItems={(c: any) => handleFieldChange('cons', c)} /></motion.div> </>)}
                    </fieldset>

                    <ColorDictionaryManager initialMappings={colorDictionary || []} />
                    
                    <div className={styles.sidebarFooter}>
                        <motion.button onClick={handleSave} disabled={isSaveDisabled} className="primary-button" style={{ width: '100%', height: '44px', display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} title={isSaveDisabled ? (hasChanges ? 'المُعرّف غير صالح' : 'لا تغييرات للحفظ') : 'حفظ التغييرات'} animate={{ backgroundColor: saveStatus === 'success' ? '#16A34A' : 'var(--accent)', color: saveStatus === 'success' ? '#fff' : 'inherit', width: isSaving ? '44px' : '100%', borderRadius: isSaving ? '50%' : '5px', paddingLeft: isSaving ? 0 : '2.4rem', paddingRight: isSaving ? 0 : '2.4rem' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                            <AnimatePresence mode="wait">
                                {isSaving && <ButtonLoader key="loader" />}
                                {saveStatus === 'success' && <motion.span key="success" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>حُفِظ!</motion.span>}
                                {saveStatus === 'idle' && <motion.span key="idle" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}} style={{whiteSpace: 'nowrap'}}>حفظ التغييرات</motion.span>}
                            </AnimatePresence>
                        </motion.button>
                    </div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/EditorSidebar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/EditorStateSync.tsx ---

// app/studio/[contentType]/[id]/EditorStateSync.tsx
'use client';

import { useLayoutEffect } from 'react';
import { useEditorStore } from '@/lib/editorStore';

export function EditorStateSync() {

    useLayoutEffect(() => {

        document.body.classList.add('editor-active');
        

        useEditorStore.setState({ isEditorActive: true });

        return () => {
            document.body.classList.remove('editor-active');
            useEditorStore.setState({ isEditorActive: false, liveUrl: null });
        };
    }, []);

    return null;
}




--- END OF FILE app/studio/[contentType]/[id]/EditorStateSync.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

// app/studio/[contentType]/[id]/FormattingToolbar.tsx
'use client';

import { Editor } from '@tiptap/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useState, useRef, useLayoutEffect, RefObject } from 'react';
import { useClickOutside } from '@/hooks/useClickOutside';
import styles from './Editor.module.css';
import { ColorPicker } from './ColorPicker';

// --- Icon Components (with new DragIcon) ---
const DragIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="20" viewBox="0 0 24 24" fill="none" {...props}>
        <path d="M20.964 4H16.9719M20.964 4C20.964 4.56018 19.4727 5.60678 18.9679 6M20.964 4C20.964 3.43982 19.4727 2.39322 18.9679 2" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M2.99921 4H6.99136M2.99921 4C2.99921 3.43982 4.49058 2.39322 4.99529 2M2.99921 4C2.99921 4.56018 4.49058 5.60678 4.99529 6" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M9.81505 22.0006V21.0595C9.81505 20.4116 9.60526 19.781 9.21707 19.2622L5.39435 14.1534C5.07668 13.7288 4.83978 13.2141 4.98565 12.7043C5.34585 11.4454 6.76792 10.3261 8.35901 12.2974L9.95917 14.0049V3.59381C10.0573 1.76459 13.1325 1.18685 13.4504 3.59381V9.52698C14.933 9.33608 21.9162 10.378 20.9003 14.7917C20.8517 15.0026 20.8032 15.2167 20.7557 15.4279C20.5493 16.346 19.9407 17.98 19.2696 18.9355C18.5705 19.9309 18.897 21.5353 18.8172 22.0019" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
);
const BoldIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>;
const ItalicIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>;
const LinkIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>;
const ListIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>;
const QuoteIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"><path d="M22 11.5667C22 16.8499 17.5222 21.1334 12 21.1334C11.3507 21.1343 10.7032 21.0742 10.0654 20.9545C9.60633 20.8682 9.37678 20.8251 9.21653 20.8496C9.05627 20.8741 8.82918 20.9948 8.37499 21.2364C7.09014 21.9197 5.59195 22.161 4.15111 21.893C4.69874 21.2194 5.07275 20.4112 5.23778 19.5448C5.33778 19.0148 5.09 18.5 4.71889 18.1231C3.03333 16.4115 2 14.1051 2 11.5667C2 6.28357 6.47778 2 12 2C17.5222 2 22 6.28357 22 11.5667Z" /><path d="M10.7456 10C10.7456 9.05719 10.7456 8.58579 10.4347 8.29289C10.1239 8 9.62351 8 8.62281 8C7.62211 8 7.12176 8 6.81088 8.29289C6.5 8.58579 6.5 9.05719 6.5 10C6.5 10.9428 6.5 11.4142 6.81088 11.7071C7.12176 12 7.62211 12 8.62281 12C9.62351 12 10.1239 12 10.4347 11.7071C10.7456 11.4142 10.7456 10.9428 10.7456 10ZM10.7456 10L10.7456 12.0687C10.7456 13.9022 9.41052 15.4571 7.5614 16M17.5 10C17.5 9.05719 17.5 8.58579 17.1891 8.29289C16.8782 8 16.3779 8 15.3772 8C14.3765 8 13.8761 8 13.5653 8.29289C13.2544 8.58579 13.2544 9.05719 13.2544 10C13.2544 10.9428 13.2544 11.4142 13.5653 11.7071C13.8761 12 14.3765 12 15.3772 12C16.3779 12 16.8782 12 17.1891 11.7071C17.5 11.4142 17.5 10.9428 17.5 10ZM17.5 10V12.0687C17.5 13.9022 16.1649 15.4571 14.3158 16" strokeLinecap="round" /></svg>;
const HeadingIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M5 20V4H7V20H5Z" /><path fillRule="evenodd" clipRule="evenodd" d="M17 20V4H19V20H17Z" /><path fillRule="evenodd" clipRule="evenodd" d="M18 13H6V11H18V13Z" /></svg>;
const H1Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2.74996 19V5H4.74996V19H2.74996Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12.75 19V5H14.75V19H12.75Z" /><path fillRule="evenodd" clipRule="evenodd" d="M18.3358 9H20.25V17H21.25V19H17.25V17H18.25V11.9142L17.9572 12.2071L16.5429 10.7929L18.3358 9Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13.75 13L3.74996 13L3.74996 11L13.75 11V13Z" /></svg>;
const H2Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2 19V5H4V19H2Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12 19V5H14V19H12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M16 12C16 10.3431 17.3431 9 19 9C20.6569 9 22 10.3431 22 12V12.214C22 13.1191 21.6184 13.982 20.9494 14.5909L18.443 17H22V19H16V16.5742L19.5859 13.1273L19.5981 13.1163C19.8539 12.8861 20 12.5581 20 12.214V12C20 11.4477 19.5523 11 19 11C18.4477 11 18 11.4477 18 12V12.4H16V12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13 13L3 13L3 11L13 11V13Z" /></svg>;
const H3Icon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor"><path fillRule="evenodd" clipRule="evenodd" d="M2 19V5H4V19H2Z" /><path fillRule="evenodd" clipRule="evenodd" d="M12 19V5H14V19H12Z" /><path fillRule="evenodd" clipRule="evenodd" d="M19 11C18.4477 11 18 11.4477 18 12H16C16 10.3431 17.3431 9 19 9C20.6569 9 22 10.3431 22 12C22 12.7684 21.7111 13.4692 21.2361 14C21.7111 14.5308 22 15.2316 22 16C22 17.6569 20.6569 19 19 19C17.3431 19 16 17.6569 16 16H18C18 16.5523 18.4477 17 19 17C19.5523 17 20 16.5523 20 16C20 15.4477 19.5523 15 19 15H18V13H19C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11Z" /><path fillRule="evenodd" clipRule="evenodd" d="M13 13L3 13L3 11L13 11L13 13Z" /></svg>;
const ColorPickerIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M21.1353 8.18318L20.7826 8.53589L21.5396 9.29289C21.9302 9.68342 21.9302 10.3166 21.5396 10.7071C21.1491 11.0976 20.5159 11.0976 20.1254 10.7071L13.2929 3.87458C12.9024 3.48405 12.9024 2.85089 13.2929 2.46036C13.6834 2.06984 14.3166 2.06984 14.7071 2.46036L15.4641 3.21737L15.8168 2.86467C16.9697 1.71178 18.8389 1.71178 19.9918 2.86466L21.1353 4.00821C22.2882 5.1611 22.2882 7.0303 21.1353 8.18318Z" /><path d="M13.7071 7.70711C14.0976 7.31658 14.0976 6.68342 13.7071 6.29289C13.3166 5.90237 12.6834 5.90237 12.2929 6.29289L1.87868 16.7071C1.31607 17.2697 1 18.0328 1 18.8284V22C1 22.5523 1.44772 23 2 23H5.17157C5.96722 23 6.73028 22.6839 7.29289 22.1213L17.7071 11.7071C18.0976 11.3166 18.0976 10.6834 17.7071 10.2929C17.3166 9.90237 16.6834 9.90237 16.2929 10.2929L13.5858 13H8.41421L13.7071 7.70711Z" /></svg>;

const headingOptions = [
    { level: 3, icon: <H3Icon /> },
    { level: 2, icon: <H2Icon /> },
    { level: 1, icon: <H1Icon /> },
];

interface FormattingToolbarProps { editor: Editor; onLinkClick: () => void; platform: 'ios' | 'android' | 'desktop' }

export function FormattingToolbar({ editor, onLinkClick, platform }: FormattingToolbarProps) {
    const [isHeadingMenuOpen, setIsHeadingMenuOpen] = useState(false);
    const [isColorMenuOpen, setIsColorMenuOpen] = useState(false);
    const toolbarRef = useRef<HTMLDivElement>(null); 
    const headingMenuRef = useRef<HTMLDivElement>(null);
    const colorMenuRef = useRef<HTMLDivElement>(null);
    const [popoverStyle, setPopoverStyle] = useState<React.CSSProperties>({});

    useClickOutside(headingMenuRef, () => setIsHeadingMenuOpen(false));
    useClickOutside(colorMenuRef, () => setIsColorMenuOpen(false));
    
    const calculatePopoverPosition = (parentRef: RefObject<HTMLDivElement | null>, popoverWidth: number, popoverHeight: number) => {
        if (parentRef.current && toolbarRef.current) { 
            const parentRect = parentRef.current.getBoundingClientRect();
            const toolbarRect = toolbarRef.current.getBoundingClientRect(); 
            const spaceAbove = parentRect.top;
            const spaceBelow = window.innerHeight - parentRect.bottom;
            
            let finalStyle: React.CSSProperties = {};

            // --- Vertical Positioning ---
            let openUp = platform !== 'android';
            if (openUp && spaceAbove < popoverHeight && spaceBelow > popoverHeight) {
                openUp = false;
            } else if (!openUp && spaceBelow < popoverHeight && spaceAbove > popoverHeight) {
                openUp = true;
            }

            if (openUp) {
                finalStyle.bottom = '100%';
                finalStyle.marginBottom = '0.5rem';
            } else {
                finalStyle.top = '100%';
                finalStyle.marginTop = '0.5rem';
            }

            // --- Horizontal Positioning ---
            const triggerCenter = parentRect.left + parentRect.width / 2;
            const spaceLeft = triggerCenter;
            const spaceRight = window.innerWidth - triggerCenter;

            if (spaceLeft > popoverWidth / 2 && spaceRight > popoverWidth / 2) {
                finalStyle.left = '50%';
                finalStyle.transform = 'translateX(-50%)';
            } else if (spaceLeft < popoverWidth / 2) {
                finalStyle.left = 0;
            } else {
                finalStyle.right = 0;
            }

            setPopoverStyle(finalStyle);
        }
    };

    useLayoutEffect(() => {
        if (isHeadingMenuOpen) calculatePopoverPosition(headingMenuRef, 150, 60);
        if (isColorMenuOpen) calculatePopoverPosition(colorMenuRef, 300, 260);
    }, [isHeadingMenuOpen, isColorMenuOpen]);


    const isAnyHeadingActive = editor.isActive('heading', { level: 1 }) || editor.isActive('heading', { level: 2 }) || editor.isActive('heading', { level: 3 });
    const isAnyColorActive = !!editor.getAttributes('textStyle').color;

    return (
        <motion.div
            drag
            dragMomentum={false}
            className={styles.formattingToolbar}
            ref={toolbarRef}
            onMouseDown={(e) => e.preventDefault()}
        >
            <div className={styles.dragHandle}>
                <DragIcon />
            </div>
            <div ref={headingMenuRef} style={{ position: 'relative' }}>
                <motion.button onClick={() => setIsHeadingMenuOpen(prev => !prev)} className={`${styles.bubbleMenuButton} ${isAnyHeadingActive ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
                    <HeadingIcon />
                </motion.button>
                <AnimatePresence>
                    {isHeadingMenuOpen && (
                        <motion.div
                            style={{ 
                                position: 'absolute', 
                                display: 'flex', 
                                gap: '0.2rem', 
                                background: 'var(--bg-secondary)', 
                                padding: '0.4rem', 
                                borderRadius: '8px', 
                                border: '1px solid var(--border-color)', 
                                ...popoverStyle 
                            }}
                            initial={{ opacity: 0, y: 10 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: 10 }}
                        >
                            {headingOptions.map(({ level, icon }) => (
                                <motion.button
                                    key={level}
                                    onClick={() => {
                                        editor.chain().focus().toggleHeading({ level: level as 1 | 2 | 3 }).run();
                                        setIsHeadingMenuOpen(false);
                                    }}
                                    className={`${styles.bubbleMenuButton} ${editor.isActive('heading', { level }) ? styles.active : ''}`}
                                    whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}
                                >
                                    {icon}
                                </motion.button>
                            ))}
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
            <motion.button onClick={() => editor.chain().focus().toggleBold().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bold') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><BoldIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleItalic().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('italic') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ItalicIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBulletList().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('bulletList') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><ListIcon /></motion.button>
            <motion.button onClick={() => editor.chain().focus().toggleBlockquote().run()} className={`${styles.bubbleMenuButton} ${editor.isActive('blockquote') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} title="اقتباس"><QuoteIcon /></motion.button>
            <motion.button onClick={onLinkClick} className={`${styles.bubbleMenuButton} ${editor.isActive('link') ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}><LinkIcon /></motion.button>
            <div ref={colorMenuRef} style={{ position: 'relative', display: 'flex' }}>
                <motion.button onClick={() => setIsColorMenuOpen(prev => !prev)} className={`${styles.bubbleMenuButton} ${isAnyColorActive ? styles.active : ''}`} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }}>
                    <ColorPickerIcon />
                </motion.button>
                <AnimatePresence>
                    {isColorMenuOpen && <ColorPicker editor={editor} popoverStyle={popoverStyle} />}
                </AnimatePresence>
            </div>
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/FormattingToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

// app/studio/[contentType]/[id]/ImageCompareComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { useState, useRef, useCallback } from 'react';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../actions';
import { useToast } from '@/lib/toastStore';
import styles from '@/components/ImageCompare.module.css';
import editorStyles from './Editor.module.css';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader'; // <-- IMPORT ADDED

const UploadIcon = () => <svg className={styles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg>;
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const SizeSmallIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="6" rx="1"/><rect x="3" y="15" width="18" height="6" rx="1"/></svg>;
const SizeMediumIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="10" rx="1"/><rect x="3" y="17" width="18" height="4" rx="1"/></svg>;
const SizeLargeIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="1"/></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: 'left' | 'right', src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) { onUpload(file); } }; 
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); }; 
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); }; 
    
    return ( 
        <div className={`${styles.dropzone} ${isDragging ? styles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}> 
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} /> 
            {src && (
                <Image 
                    loader={sanityLoader} // <-- LOADER ADDED (Safely handles blob URLs too)
                    src={src} 
                    alt={`Image ${side}`} 
                    fill 
                    className={styles.imagePreview} 
                />
            )} 
            <div className={styles.dropzoneContent}> 
                <UploadIcon /> 
                <span>{src ? `تغيير الصورة ${side === 'left' ? 1 : 2}` : `أفلت صورةً أو انقر للرفع`}</span> 
            </div> 
        </div> 
    ); 
};

export const ImageCompareComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, side: 'left' | 'right') => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
            
            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({
                    [side === 'left' ? 'src1' : 'src2']: result.asset.url,
                    [side === 'left' ? 'assetId1' : 'assetId2']: result.asset._id,
                });
                toast.success('رُفِعت الصورة.', 'left');
            } else {
                throw new Error(result.error || 'أخفق رفع أصل الصورة.');
            }
        } catch (error: any) {
            toast.error(error.message || 'أخفقت معالجة الصورة.', 'left');
        }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();
    const handleSizeChange = (size: 'small' | 'medium' | 'large') => updateAttributes({ 'data-size': size });
    const currentSize = node.attrs['data-size'] || 'large';

    return (
        <NodeViewWrapper as="div" className={editorStyles.imageCompareContainer} data-size={currentSize} data-drag-handle>
            {(node.attrs.src1 && node.attrs.src2) ? (
                <div className={styles.compareWrapper}>
                    <ReactCompareSlider itemOne={<ReactCompareSliderImage src={node.attrs.src1} alt="Image 1" />} itemTwo={<ReactCompareSliderImage src={node.attrs.src2} alt="Image 2" />} />
                </div>
            ) : (
                <div className={styles.compareWrapper}>
                    <div className={styles.placeholder}>
                        <Dropzone side="left" src={node.attrs.src1} onUpload={(file) => handleUpload(file, 'left')} />
                        <Dropzone side="right" src={node.attrs.src2} onUpload={(file) => handleUpload(file, 'right')} />
                    </div>
                </div>
            )}
             <div className={editorStyles.imageNodeMenu} contentEditable={false}>
                <button onClick={() => handleSizeChange('small')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'small' ? editorStyles.active : ''}`}><SizeSmallIcon /></button>
                <button onClick={() => handleSizeChange('medium')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'medium' ? editorStyles.active : ''}`}><SizeMediumIcon /></button>
                <button onClick={() => handleSizeChange('large')} className={`${editorStyles.bubbleMenuButton} ${currentSize === 'large' ? editorStyles.active : ''}`}><SizeLargeIcon /></button>
                <div style={{width: '1px', height: '24px', backgroundColor: 'var(--border-color)', margin: '0 0.4rem'}} />
                <button onClick={handleDelete} className={`${editorStyles.bubbleMenuButton} ${editorStyles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/ImageCompareComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

// app/studio/[contentType]/[id]/ImageResizeComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import styles from './Editor.module.css';

const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export const ImageResizeComponent = ({ editor, node, updateAttributes, getPos }: NodeViewProps) => {
    
    const handleDelete = () => {
        editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run()
    }

    // Removed data-size and assetId from props to be passed down
    const { assetId, 'data-size': dataSize, ...imgAttributes } = node.attrs;

    return (
        <NodeViewWrapper 
            className={styles.imageNodeContainer} 
            data-drag-handle
        >
            <img {...imgAttributes} alt={imgAttributes.alt || ''} />

            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`}><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/ImageResizeComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

// app/studio/[contentType]/[id]/LinkEditorModal.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import editorStyles from './Editor.module.css'; // <-- IMPORTED for input styles
import modalStyles from '@/components/modals/Modals.module.css'; // <-- IMPORTED for modal layout

interface LinkEditorModalProps { isOpen: boolean; onClose: () => void; onSubmit: (url: string) => void; onRemove: () => void; initialUrl?: string; }
const modalVariants = { hidden: { opacity: 0, scale: 0.9, y: 20 }, visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring' as const, damping: 20, stiffness: 250 } }, exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } }, };

export function LinkEditorModal({ isOpen, onClose, onSubmit, onRemove, initialUrl }: LinkEditorModalProps) {
    const [url, setUrl] = useState('');

    useEffect(() => { if (isOpen) { setUrl(initialUrl || ''); } }, [isOpen, initialUrl]);
    const handleSubmit = (e: React.FormEvent) => { e.preventDefault(); if (url.trim()) { onSubmit(url); } };

    return (
        <AnimatePresence>
            {isOpen && (
                <motion.div onMouseDown={(e) => e.preventDefault()} className={modalStyles.modalOverlay} style={{ zIndex: 5001, backgroundColor: 'transparent', backdropFilter: 'none' }} onClick={onClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={modalStyles.modalContent} style={{ padding: '2rem', maxWidth: '400px' }} variants={modalVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
                        <form onSubmit={handleSubmit}>
                            <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-ui)' }}>تعديل الرابط</h3>
                            <input type="url" value={url} onChange={(e) => setUrl(e.target.value)} placeholder="https://example.com" className={editorStyles.sidebarInput} autoFocus style={{ marginBottom: '1.5rem' }} />
                            <div className={modalStyles.modalActions} style={{ justifyContent: 'space-between' }}>
                                {initialUrl && (<button type="button" onClick={onRemove} className="outline-button" style={{ borderColor: '#DC2626', color: '#DC2626' }}>إزالة الرابط</button>)}
                                <div style={{ display: 'flex', gap: '1rem', marginLeft: 'auto' }}>
                                    <button type="button" onClick={onClose} className="outline-button">إلغاء</button>
                                    <button type="submit" className="primary-button">تطبيق</button>
                                </div>
                            </div>
                        </form>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/LinkEditorModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

// app/studio/[contentType]/[id]/RichTextEditor.tsx
'use client'

import {
  useEditor,
  EditorContent,
  Editor,
  ReactNodeViewRenderer,
  BubbleMenu,
} from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Placeholder from '@tiptap/extension-placeholder'
import Link from '@tiptap/extension-link'
import Heading from '@tiptap/extension-heading'
import BulletList from '@tiptap/extension-bullet-list'
import ListItem from '@tiptap/extension-list-item'
import Bold from '@tiptap/extension-bold'
import Blockquote from '@tiptap/extension-blockquote'
import TextStyle from '@tiptap/extension-text-style'
import {Color} from '@tiptap/extension-color'
import {InputRule, Node, mergeAttributes, Extension} from '@tiptap/core'
import {Plugin, PluginKey} from '@tiptap/pm/state'
import {slugify} from 'transliteration'
import {useState, useEffect, useCallback, useRef} from 'react'
import React from 'react'
import {motion, AnimatePresence} from 'framer-motion'
import {useToast} from '@/lib/toastStore'
import {optimizeImageForUpload, UploadQuality} from '@/lib/image-optimizer'
import {uploadSanityAssetAction} from '../../actions'
import {FormattingToolbar} from './FormattingToolbar'
import {LinkEditorModal} from './LinkEditorModal'
import {ImageResizeComponent} from './ImageResizeComponent'
import {ImageCompareComponent} from './ImageCompareComponent'
import {TwoImageGridComponent} from './editor-components/TwoImageGridComponent'
import {FourImageGridComponent} from './editor-components/FourImageGridComponent'
import {GameDetailsNode} from './extensions/GameDetailsNode'
import Table from '@tiptap/extension-table'
import TableRow from '@tiptap/extension-table-row'
import TableCell from '@tiptap/extension-table-cell'
import TableHeader from '@tiptap/extension-table-header'
import {TableComponent} from './editor-components/TableComponent'
import {AutoColorExtension} from './extensions/AutoColorExtension'
import {AutoBoldEnglishExtension} from './extensions/AutoBoldEnglishExtension' // <-- IMPORT ADDED
import {YoutubeNode} from './extensions/YoutubeNode'
import { DeactivateMarksExtension } from './extensions/DeactivateMarksExtension'; 
import styles from './Editor.module.css'

const DragIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" fill="none" {...props}>
    <path
      d="M20.964 4H16.9719M20.964 4C20.964 4.56018 19.4727 5.60678 18.9679 6M20.964 4C20.964 3.43982 19.4727 2.39322 18.9679 2"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
    <path
      d="M2.99921 4H6.99136M2.99921 4C2.99921 3.43982 4.49058 2.39322 4.99529 2M2.99921 4C2.99921 4.56018 4.49058 5.60678 4.99529 6"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
    <path
      d="M9.81505 22.0006V21.0595C9.81505 20.4116 9.60526 19.781 9.21707 19.2622L5.39435 14.1534C5.07668 13.7288 4.83978 13.2141 4.98565 12.7043C5.34585 11.4454 6.76792 10.3261 8.35901 12.2974L9.95917 14.0049V3.59381C10.0573 1.76459 13.1325 1.18685 13.4504 3.59381V9.52698C14.933 9.33608 21.9162 10.378 20.9003 14.7917C20.8517 15.0026 20.8032 15.2167 20.7557 15.4279C20.5493 16.346 19.9407 17.98 19.2696 18.9355C18.5705 19.9309 18.897 21.5353 18.8172 22.0019"
      stroke="currentColor"
      strokeWidth="1.5"
      strokeLinecap="round"
      strokeLinejoin="round"
    ></path>
  </svg>
)

const formatFileSize = (bytes: number): string => {
  if (bytes < 1024) return `${bytes} B`
  const kb = bytes / 1024
  if (kb < 1024) return `${kb.toFixed(1)} KB`
  const mb = kb / 1024
  return `${mb.toFixed(2)} MB`
}

export const uploadFile = async (
  file: File,
  editor: Editor,
  toast: ReturnType<typeof useToast>,
  quality: UploadQuality,
) => {
  try {
    toast.info('جارٍ تهيئة الصورة للرفع...', 'left')
    const {file: optimizedFile, finalQuality} = await optimizeImageForUpload(file, quality)

    const reader = new FileReader()
    reader.readAsDataURL(optimizedFile)
    reader.onload = async () => {
      const {tr} = editor.state
      const node = editor.state.schema.nodes.image.create({src: reader.result as string})
      const transaction = tr.replaceSelectionWith(node)
      editor.view.dispatch(transaction)

      toast.info(
        `جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(
          finalQuality * 100,
        )}%)...`,
        'left',
      )

      const formData = new FormData()
      formData.append('file', optimizedFile)
      const result = await uploadSanityAssetAction(formData)

      let imagePos: number | null = null
      editor.state.doc.descendants((node, pos) => {
        if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
          imagePos = pos
          return false
        }
        return true
      })

      if (imagePos !== null) {
        if (result.success && result.asset) {
          const finalTransaction = editor.state.tr.setNodeMarkup(imagePos, undefined, {
            ...editor.state.doc.nodeAt(imagePos)?.attrs,
            src: result.asset.url,
            assetId: result.asset._id,
          })
          editor.view.dispatch(finalTransaction)
          toast.success('رُفِعت الصورة.', 'left')
        } else {
          throw new Error(result.error || 'أخفق رفع أصل الصورة.')
        }
      }
    }
  } catch (error: any) {
    toast.error(error.message || 'أخفق رفع الصورة.', 'left')
    let imagePos: number | null = null
    editor.state.doc.descendants((node, pos) => {
      if (node.type.name === 'image' && node.attrs.src.startsWith('data:')) {
        imagePos = pos
        return false
      }
      return true
    })
    if (imagePos !== null) {
      const failedTransaction = editor.state.tr.delete(imagePos, imagePos + 1)
      editor.view.dispatch(failedTransaction)
    }
  }
}

const TrailingNode = Extension.create({
  name: 'trailingNode',
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('trailingNode'),
        appendTransaction: (transactions, oldState, newState) => {
          const {doc, tr} = newState
          const shouldInsertNodeAtEnd = transactions.some((transaction) => transaction.docChanged)
          if (!shouldInsertNodeAtEnd) return

          const endPosition = doc.content.size
          const lastNode = doc.lastChild

          const nodeTypesThatNeedTrailingNode = [
            'image',
            'imageCompare',
            'twoImageGrid',
            'fourImageGrid',
            'gameDetails',
            'heading',
            'blockquote',
            'table',
            'youtube',
          ]

          if (lastNode && nodeTypesThatNeedTrailingNode.includes(lastNode.type.name)) {
            const paragraph = newState.schema.nodes.paragraph.create()
            return tr.insert(endPosition, paragraph)
          }
          return
        },
      }),
    ]
  },
})

const ImageCompareNode = Node.create({
  name: 'imageCompare',
  group: 'block',
  atom: true,
  addAttributes() {
    return {
      src1: {default: null},
      assetId1: {default: null},
      src2: {default: null},
      assetId2: {default: null},
      'data-size': {default: 'large'},
    }
  },
  parseHTML() {
    return [{tag: 'div[data-type="image-compare"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'image-compare'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(ImageCompareComponent)
  },
})
const CustomImage = Node.create({
  name: 'image',
  group: 'block',
  atom: true,
  draggable: true,
  addAttributes() {
    return {
      src: {default: null},
      alt: {default: null},
      title: {default: null},
      assetId: {default: null},
    }
  },
  parseHTML() {
    return [{tag: 'img[src]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', {'data-type': 'custom-image'}, ['img', HTMLAttributes]]
  },
  addNodeView() {
    return ReactNodeViewRenderer(ImageResizeComponent)
  },
})
const TwoImageGridNode = Node.create({
  name: 'twoImageGrid',
  group: 'block',
  atom: true,
  addAttributes() {
    return {src1: null, assetId1: null, src2: null, assetId2: null}
  },
  parseHTML() {
    return [{tag: 'div[data-type="two-image-grid"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'two-image-grid'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(TwoImageGridComponent)
  },
})
const FourImageGridNode = Node.create({
  name: 'fourImageGrid',
  group: 'block',
  atom: true,
  addAttributes() {
    return {
      src1: null,
      assetId1: null,
      src2: null,
      assetId2: null,
      src3: null,
      assetId3: null,
      src4: null,
      assetId4: null,
    }
  },
  parseHTML() {
    return [{tag: 'div[data-type="four-image-grid"]'}]
  },
  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-type': 'four-image-grid'}, HTMLAttributes)]
  },
  addNodeView() {
    return ReactNodeViewRenderer(FourImageGridComponent)
  },
})

interface RichTextEditorProps {
  onEditorCreated: (editor: Editor) => void
  initialContent?: any
  colorDictionary?: {word: string; color: string}[]
}

export default function RichTextEditor({
  onEditorCreated,
  initialContent,
  colorDictionary = [],
}: RichTextEditorProps) {
  const toast = useToast()
  const [isLinkModalOpen, setIsLinkModalOpen] = useState(false)
  const [currentLinkUrl, setCurrentLinkUrl] = useState<string | undefined>(undefined)
  const [isMobile, setIsMobile] = useState(false)
  const [platform, setPlatform] = useState<'ios' | 'android' | 'desktop'>('desktop')
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false)
  const bubbleMenuRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth <= 768)
    checkMobile()
    window.addEventListener('resize', checkMobile)

    const ua = navigator.userAgent
    if (/iPad|iPhone|iPod/.test(ua)) setPlatform('ios')
    else if (/Android/.test(ua)) setPlatform('android')
    else setPlatform('desktop')

    const visualViewport = window.visualViewport
    if (visualViewport) {
      const handleViewportChange = () => {
        const isKeyboardVisible = visualViewport.height < window.innerHeight * 0.9
        setIsKeyboardOpen(isKeyboardVisible)
      }
      visualViewport.addEventListener('resize', handleViewportChange)
      return () => visualViewport.removeEventListener('resize', handleViewportChange)
    }
  }, [])

  const editor = useEditor(
    {
      extensions: [
        StarterKit.configure({heading: false, bulletList: false, listItem: false, bold: false, blockquote: false}),
        TextStyle,
        Color,
        AutoColorExtension.configure({
          colorMappings: colorDictionary,
        }),
        AutoBoldEnglishExtension, // <-- ENABLE EXTENSION
        DeactivateMarksExtension, 
        Bold.extend({
          addInputRules() {
            return [
              new InputRule({
                find: /(?:^|\s)(\*\*(?!\s+\*\*).+\*\*(?!\s+\*\*))$/,
                handler: ({state, range, match}) => {
                  const {tr} = state
                  const text = match[1]
                  const start = range.from
                  const end = range.to
                  tr.delete(start, end)
                  tr.insertText(text.slice(2, -2), start)
                  tr.addMark(start, start + text.length - 4, this.type.create())
                },
              }),
            ]
          },
        }),
        Heading.configure({levels: [1, 2, 3]}).extend({
          onCreate() {
            const editor = this.editor
            const transaction = editor.state.tr
            editor.state.doc.descendants((node, pos) => {
              if (node.type.name === 'heading' && !node.attrs.id) {
                const id = slugify(node.textContent)
                transaction.setNodeMarkup(pos, undefined, {...node.attrs, id})
              }
            })
            transaction.setMeta('addToHistory', false)
            editor.view.dispatch(transaction)
          },
          addAttributes() {
            return {
              ...this.parent?.(),
              id: {
                default: null,
                parseHTML: (element) => element.getAttribute('id'),
                renderHTML: (attributes) => {
                  if (!attributes.id) {
                    return {}
                  }
                  return {id: attributes.id}
                },
              },
            }
          },
        }),
        Link.configure({
          openOnClick: false,
          autolink: true,
          HTMLAttributes: {class: 'editor-link'},
        }),
        Placeholder.configure({placeholder: 'خُطَّ ما في نفسِكَ هنا...'}),
        CustomImage,
        BulletList,
        ListItem,
        ImageCompareNode,
        TwoImageGridNode,
        FourImageGridNode,
        GameDetailsNode,
        Blockquote,
        TrailingNode,
        Table.configure({resizable: false, cellMinWidth: 100}).extend({
          addNodeView() {
            return ReactNodeViewRenderer(TableComponent)
          },
        }),
        TableRow,
        TableHeader,
        TableCell,
        YoutubeNode,
      ],
      editorProps: {
        attributes: {class: styles.tiptap},
        handlePaste(view, event, slice) {
          if (!editor) return false
          const text = event.clipboardData?.getData('text/plain')
          if (text) {
            const youtubeRegex = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
            const match = text.match(youtubeRegex)
            if (match && match[2].length === 11) {
              editor.chain().focus().setYoutubeVideo({src: text}).run()
              return true
            }
          }

          const items = Array.from(event.clipboardData?.items || [])
          const imageItem = items.find((item) => item.type.startsWith('image/'))
          if (imageItem) {
            const file = imageItem.getAsFile()
            if (file) {
              uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p')
              return true
            }
          }
          return false
        },
        handleDrop(view, event, slice, moved) {
          if (!editor || moved) return false
          const file = event.dataTransfer?.files[0]
          if (file && file.type.startsWith('image/')) {
            uploadFile(file, editor, toast, editor.storage.uploadQuality || '1080p')
            return true
          }
          return false
        },
      },
      immediatelyRender: false,
      content: initialContent || '',
      onSelectionUpdate: ({editor}) => {
        if (editor.isActive('link')) {
          setCurrentLinkUrl(editor.getAttributes('link').href)
        } else {
          setCurrentLinkUrl(undefined)
        }
      },
    },
    [colorDictionary],
  ) 

  const handleOpenLinkModal = useCallback(() => {
    setIsLinkModalOpen(true)
  }, [])
  const handleCloseLinkModal = useCallback(() => {
    setIsLinkModalOpen(false)
    setCurrentLinkUrl(undefined)
    editor?.chain().focus().run()
  }, [editor])
  const handleSetLink = useCallback(
    (url: string) => {
      if (editor) {
        editor.chain().focus().extendMarkRange('link').setLink({href: url}).run()
      }
      handleCloseLinkModal()
    },
    [editor, handleCloseLinkModal],
  )
  const handleRemoveLink = useCallback(() => {
    if (editor) {
      editor.chain().focus().extendMarkRange('link').unsetLink().run()
    }
    handleCloseLinkModal()
  }, [editor, handleCloseLinkModal])
  useEffect(() => {
    if (editor) {
      onEditorCreated(editor)
    }
  }, [editor, onEditorCreated])
  if (!editor) {
    return null
  }

  return (
    <div
      onClick={(e) => {
        const target = e.target as HTMLElement
        if (target.tagName === 'A' && target.classList.contains('editor-link')) {
          e.preventDefault()
        }
      }}
    >
      <style jsx global>{`
        .tiptap a.editor-link {
          color: var(--accent);
          text-decoration: underline;
          text-decoration-color: color-mix(in srgb, var(--accent) 50%, transparent);
          cursor: default;
        }
        .tiptap h1 {
          font-family: var(--font-main), sans-serif;
          font-size: 3.6rem;
          line-height: 1.2;
          margin: 4rem 0 2rem 0;
          padding-bottom: 0.5rem;
          border-bottom: 1px solid var(--border-color);
        }
        .tiptap h2 {
          font-family: var(--font-main), sans-serif;
          font-size: 2.8rem;
          line-height: 1.2;
          margin: 4rem 0 2rem 0;
          padding-bottom: 0.5rem;
          border-bottom: 1px solid var(--border-color);
        }
        .tiptap h3 {
          font-family: var(--font-main), sans-serif;
          font-size: 2.2rem;
          line-height: 1.2;
          margin: 3rem 0 1.5rem 0;
        }
        .tiptap blockquote {
          margin: 2rem 0;
          padding-right: 1.5rem;
          border-right: 3px solid var(--accent);
          font-style: italic;
          color: var(--text-secondary);
        }
        .tiptap p.is-empty::before {
          content: '';
          display: inline-block;
        }
        .tiptap p.is-empty {
          min-height: 1rem;
        }
      `}</style>

      <BubbleMenu
        editor={editor}
        tippyOptions={{
          duration: 100,
          placement: platform === 'android' ? 'bottom' : 'top',
          offset: [0, 8],
          appendTo: () => document.body,
        }}
        shouldShow={({editor, state}) => {
          const {from, to} = state.selection
          const isTextSelection = from !== to
          return isTextSelection
        }}
      >
        <div ref={bubbleMenuRef} className={isKeyboardOpen && isMobile ? styles.docked : ''}>
          <FormattingToolbar editor={editor} onLinkClick={handleOpenLinkModal} platform={platform} />
        </div>
      </BubbleMenu>

      <LinkEditorModal
        isOpen={isLinkModalOpen}
        onClose={handleCloseLinkModal}
        onSubmit={handleSetLink}
        onRemove={handleRemoveLink}
        initialUrl={currentLinkUrl}
      />
      <EditorContent editor={editor} />
    </div>
  )
}




--- END OF FILE app/studio/[contentType]/[id]/RichTextEditor.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/SaveStatusIcons.module.css ---

.container {
    display: flex;
    align-items: center;
    gap: 1.2rem;
    margin-bottom: 1.5rem;
    justify-content: flex-end;
    padding: 0 4rem;
}

.iconWrapper {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    transition: color 0.3s ease, transform 0.2s ease;
}

/* New class for button reset */
.iconButton {
    background: none;
    border: none;
    cursor: pointer;
    padding: 0;
}
@media (hover: hover) {@media (hover: hover) {
  
  .iconButton:hover  {
    transform: scale(1.1);
}
}

  .iconButton:active  {
    transform: scale(1.1);
}
}
.iconButton:active {
    transform: scale(1.1);
}


.iconWrapper svg {
    width: 100%;
    height: 100%;
}

/* Status Colors */
.saved {
    color: var(--accent); /* Cyan */
}

.pending,
.saving {
    color: var(--text-secondary); /* Gray */
}

/* Paused State (Amber/Yellow) */
.paused {
    color: #F59E0B; 
}

/* Data Flow Animation (Bobbing Arrow) */
@keyframes flow {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-1px); }
}

.saving .arrow {
    animation: flow 1s ease-in-out infinite;
}

.tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--bg-secondary);
    color: var(--text-primary);
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    font-size: 1.2rem;
    white-space: nowrap;
    border: 1px solid var(--border-color);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease, transform 0.2s ease;
    margin-bottom: 5px;
    z-index: 10;
}
@media (hover: hover) {@media (hover: hover) {
  
  .iconWrapper:hover .tooltip  {
    opacity: 1;
    transform: translateX(-50%) translateY(-3px);
}
}

  .iconWrapper:active .tooltip  {
    opacity: 1;
    transform: translateX(-50%) translateY(-3px);
}
}
.iconWrapper:active .tooltip {
    opacity: 1;
    transform: translateX(-50%) translateY(-3px);
}


/* Mobile responsiveness */
@media (max-width: 768px) {
    .container {
        padding: 0 1.5rem;
        margin-bottom: 1rem;
        gap: 0.8rem;
    }
    .iconWrapper {
        width: 25px;
        height: 25px;
    }
}




--- END OF FILE app/studio/[contentType]/[id]/SaveStatusIcons.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/SaveStatusIcons.tsx ---

// app/studio/[contentType]/[id]/SaveStatusIcons.tsx
'use client';

import React from 'react';
import styles from './SaveStatusIcons.module.css';

export type SaveStatus = 'saved' | 'pending' | 'saving';

// --- Client Icons ---

const ClientLoadingIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" role="img" color="currentColor">
        <g>
            <path d="M14 21H16M14 21C13.1716 21 12.5 20.3284 12.5 19.5V17L12 17M14 21H10M10 21H8M10 21C10.8284 21 11.5 20.3284 11.5 19.5V17L12 17M12 17V21" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
            <path d="M20 3H4C2.89543 3 2 3.89543 2 5V15C2 16.1046 2.89543 17 4 17H20C21.1046 17 22 16.1046 22 15V5C22 3.89543 21.1046 3 20 3Z" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
            <path className={styles.arrow} d="M9 10L12 13L15 10M12 12.5V7" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        </g>
    </svg>
);

const ClientSavedIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" role="img" color="currentColor">
        <path d="M14 21H16M14 21C13.1716 21 12.5 20.3284 12.5 19.5V17L12 17M14 21H10M10 21H8M10 21C10.8284 21 11.5 20.3284 11.5 19.5V17L12 17M12 17V21" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M20 3H4C2.89543 3 2 3.89543 2 5V15C2 16.1046 2.89543 17 4 17H20C21.1046 17 22 16.1046 22 15V5C22 3.89543 21.1046 3 20 3Z" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M8.5 10.5L10.5 12.5L15.5 7.5" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
);

// --- Server Icons ---

const ServerLoadingIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" role="img" color="currentColor">
        <g>
            <path d="M17.4776 9.01106C17.485 9.01102 17.4925 9.01101 17.5 9.01101C19.9853 9.01101 22 11.0294 22 13.5193C22 15.8398 20.25 17.7508 18 18M17.4776 9.01106C17.4924 8.84606 17.5 8.67896 17.5 8.51009C17.5 5.46695 15.0376 3 12 3C9.12324 3 6.76233 5.21267 6.52042 8.03192M17.4776 9.01106C17.3753 10.1476 16.9286 11.1846 16.2428 12.0165M6.52042 8.03192C3.98398 8.27373 2 10.4139 2 13.0183C2 15.4417 3.71776 17.4632 6 17.9273M6.52042 8.03192C6.67826 8.01687 6.83823 8.00917 7 8.00917C8.12582 8.00917 9.16474 8.38194 10.0005 9.01101" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
            <path className={styles.arrow} d="M9.5 18.5L12 21L14.5 18.5M12 13.5V20.3912" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        </g>
    </svg>
);

const ServerSavedIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" role="img" color="currentColor">
        <path d="M17.4776 9.00005C17.4924 8.83536 17.5 8.66856 17.5 8.5C17.5 5.46243 15.0376 3 12 3C9.12324 3 6.76233 5.20862 6.52042 8.0227M17.4776 9.00005C17.3753 10.1345 16.9286 11.1696 16.2428 12M17.4776 9.00005C19.9675 8.98791 22 11.0072 22 13.5C22 15.8163 20.25 17.7513 18 18M6.52042 8.0227C3.98398 8.26407 2 10.4003 2 13C2 15.5927 3.97334 17.7491 6.5 18M6.52042 8.0227C6.67826 8.00768 6.83823 8 7 8C8.12582 8 9.16474 8.37209 10.0005 9" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        <path d="M9 19L11 21L15.5 16" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
);

// NEW ICON: Server Paused
const ServerPausedIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" role="img" color="currentColor">
        <path d="M17.4776 9.01106C17.485 9.01102 17.4925 9.01101 17.5 9.01101C19.9853 9.01101 22 11.0294 22 13.5193C22 15.8398 20.25 17.7508 18 18M17.4776 9.01106C17.4924 8.84606 17.5 8.67896 17.5 8.51009C17.5 5.46695 15.0376 3 12 3C9.12324 3 6.76233 5.21267 6.52042 8.03192M17.4776 9.01106C17.3753 10.1476 16.9286 11.1846 16.2428 12.0165M6.52042 8.03192C3.98398 8.27373 2 10.4139 2 13.0183C2 15.4417 3.71776 17.4632 6 17.9273M6.52042 8.03192C6.67826 8.01687 6.83823 8.00917 7 8.00917C8.12582 8.00917 9.16474 8.38194 10.0005 9.01101" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
        {/* Play Triangle */}
        <path d="M13.5 17L10.5 18.5V15.5L13.5 17Z" fill="currentColor" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path> 
    </svg>
);

interface SaveStatusIconsProps {
    clientState: SaveStatus;
    serverState: SaveStatus;
    isAutoSaveEnabled: boolean;
    onToggleAutoSave: () => void;
}

export const SaveStatusIcons = ({ clientState, serverState, isAutoSaveEnabled, onToggleAutoSave }: SaveStatusIconsProps) => {
    const clientClass = styles[clientState];
    const serverClass = isAutoSaveEnabled ? styles[serverState] : styles.paused;

    const renderServerIcon = () => {
        if (!isAutoSaveEnabled) return <ServerPausedIcon />;
        return serverState === 'saved' ? <ServerSavedIcon /> : <ServerLoadingIcon />;
    };

    const serverTooltipText = !isAutoSaveEnabled 
        ? 'الحفظ التلقائي متوقف (انقر للتفعيل)' 
        : (serverState === 'saved' ? 'تم الحفظ في السحابة' : (serverState === 'saving' ? 'جارٍ الحفظ في السحابة...' : 'بانتظار الحفظ التلقائي'));

    return (
        <div className={styles.container}>
            <div className={`${styles.iconWrapper} ${clientClass}`}>
                {clientState === 'saved' ? <ClientSavedIcon /> : <ClientLoadingIcon />}
                <div className={styles.tooltip}>
                    {clientState === 'saved' ? 'المسودة المحلية متزامنة' : 'جارٍ المزامنة محليًا...'}
                </div>
            </div>
            {/* Made server icon a button */}
            <button 
                onClick={onToggleAutoSave} 
                className={`${styles.iconWrapper} ${styles.iconButton} ${serverClass}`}
                aria-label={isAutoSaveEnabled ? "Pause Auto-save" : "Enable Auto-save"}
            >
                {renderServerIcon()}
                <div className={styles.tooltip}>
                    {serverTooltipText}
                </div>
            </button>
        </div>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/SaveStatusIcons.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

// app/studio/[contentType]/[id]/StatefulSaveButton.tsx
'use client';

import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from '@/components/ui/StatefulButton.module.css';

const SaveIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>;
const CheckIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>;

type SaveStatus = 'idle' | 'saving' | 'success' | 'error';

export function StatefulSaveButton({ onSave, hasChanges }: { onSave: () => Promise<boolean>; hasChanges: boolean }) {
    const [saveStatus, setSaveStatus] = useState<SaveStatus>('idle');
    const toast = useToast();

    const handleSave = async () => {
        if (saveStatus === 'saving') return;
        setSaveStatus('saving');
        const success = await onSave();
        if (success) {
            setSaveStatus('success');
            toast.success('حُفظت التغييرات!', 'left'); // Position toast on the left for studio
            setTimeout(() => setSaveStatus('idle'), 2000);
        } else {
            setSaveStatus('error');
            toast.error('أخفق حفظ التغييرات.', 'left');
            setTimeout(() => setSaveStatus('idle'), 3000);
        }
    };

    const isSaving = saveStatus === 'saving';

    return (
        <motion.button
            onClick={handleSave}
            className={`primary-button ${styles.statefulButton} ${styles.saveButton} ${styles[saveStatus]}`}
            disabled={isSaving || !hasChanges}
            animate={{
                width: isSaving || saveStatus === 'success' ? '48px' : '100%',
                height: '48px',
                borderRadius: isSaving || saveStatus === 'success' ? '50%' : '5px',
            }}
            transition={{ type: 'spring', stiffness: 300, damping: 20 }}
        >
            <AnimatePresence mode="wait">
                {saveStatus === 'saving' && <ButtonLoader key="loader" />}
                {saveStatus === 'success' && <motion.div key="success" initial={{ scale: 0 }} animate={{ scale: 1 }} exit={{ scale: 0 }}><CheckIcon /></motion.div>}
                {saveStatus === 'idle' && <motion.span key="idle" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
                {saveStatus === 'error' && <motion.span key="error" className={styles.saveButtonContent} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}><SaveIcon /><span>حفظ التغييرات</span></motion.span>}
            </AnimatePresence>
        </motion.button>
    );
}













--- END OF FILE app/studio/[contentType]/[id]/StatefulSaveButton.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/TableControlMenu.tsx ---




--- END OF FILE app/studio/[contentType]/[id]/TableControlMenu.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/page.tsx ---

// app/studio/[contentType]/[id]/page.tsx
import { sanityWriteClient } from '@/lib/sanity.server';
import { editorDataQuery } from '@/lib/sanity.queries'; 
import { EditorClient } from "./EditorClient";
import { portableTextToTiptap } from '../../utils/portableTextToTiptap';
import { notFound } from 'next/navigation';

// FORCE DYNAMIC: Ensure this page never statically generates
export const dynamic = 'force-dynamic';
export const revalidate = 0;

export default async function EditorPage({ params: paramsPromise }: { params: Promise<{ contentType: string; id: string }> }) {
    const params = await paramsPromise;
    
    if (!params || !params.id) {
        notFound();
    }
    
    // We strip 'drafts.' to ensure we have the base ID, but the query handles looking up the draft.
    const publicId = params.id.replace('drafts.', '');
    
    try {
        // CRITICAL FIX: Added 'perspective' and 'cache: no-store'
        const { document, dictionary, metadata } = await sanityWriteClient.fetch(
            editorDataQuery, 
            { id: publicId },
            { 
                cache: 'no-store',
                perspective: 'previewDrafts', // Explicitly request drafts
                next: { revalidate: 0 } 
            }
        );
        
        if (!document) {
            notFound();
        }
        
        const tiptapContent = portableTextToTiptap(document.content ?? []);
        
        const documentWithTiptapContent = { 
            ...document, 
            tiptapContent 
        };
        
        return (
            <EditorClient 
                document={documentWithTiptapContent} 
                colorDictionary={dictionary?.autoColors || []}
                studioMetadata={metadata} 
            />
        );
    } catch (err: any) {
        console.error("Failed to load editor data:", err);
        return (
            <div className="container page-container" style={{ textAlign: 'center' }}>
                <h1 className="page-title">Error Loading Editor</h1>
                <p style={{color: 'var(--text-secondary)'}}>Failed to load editor data. Please check the deployment logs for details.</p>
            </div>
        );
    }
}

--- END OF FILE app/studio/[contentType]/[id]/page.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';
import { sanityLoader } from '@/lib/sanity.loader'; // <-- IMPORT ADDED

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };
    
    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && (
                <Image 
                    loader={sanityLoader} // <-- LOADER ADDED
                    src={src} 
                    alt={`Image ${side}`} 
                    fill 
                    className={compareStyles.imagePreview} 
                />
            )}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة ${side}` : `أفلت صورةً أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const FourImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2 | 3 | 4) => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({ [`src${slot}`]: result.asset.url, [`assetId${slot}`]: result.asset._id });
                toast.success('رُفِعت الصورة.', 'left');
            } else { throw new Error(result.error || 'فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);
    
    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.fourImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
                <Dropzone side={3} src={node.attrs.src3} onUpload={(file) => handleUpload(file, 3)} />
                <Dropzone side={4} src={node.attrs.src4} onUpload={(file) => handleUpload(file, 4)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                 <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="حذف الشبكة"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/editor-components/FourImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css ---

/* app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css */
.buttonContainer {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
}

.actionButton {
    /* Inherits from global .outline-button but allows for overrides */
    flex-shrink: 0;
}

@media (max-width: 768px) {
    .actionButton {
        padding: 0.6rem 1.2rem;
        font-size: 1.3rem;
    }
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import editorStyles from '../Editor.module.css';
import gameDetailsStyles from '@/components/content/GameDetails.module.css';
import componentStyles from './GameDetailsComponent.module.css'; // MODIFIED: Import new CSS module

const isRTL = (s: string) => {
  if (!s) return true;
  const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
  return rtlChars.test(s);
};

export const GameDetailsComponent = ({ node, updateAttributes, deleteNode }: NodeViewProps) => {
  const details = Array.isArray(node.attrs.details) ? node.attrs.details : [];

  const handleValueChange = (index: number, value: string) => {
    const newDetails = [...details];
    newDetails[index] = { ...newDetails[index], value };
    updateAttributes({ details: newDetails });
  };

  const handleLabelChange = (index: number, label: string) => {
    const newDetails = [...details];
    newDetails[index] = { ...newDetails[index], label };
    updateAttributes({ details: newDetails });
  };

  const addRow = () => {
    updateAttributes({ details: [...details, { label: '', value: '' }] });
  };

  const removeRow = (index: number) => {
    const newDetails = details.filter((_: any, i: number) => i !== index);
    updateAttributes({ details: newDetails });
  };

  return (
    <NodeViewWrapper as="div" className={editorStyles.imageGridContainer} data-drag-handle>
      <div className={gameDetailsStyles.detailsContainer}>
        {details.map((detail: { label: string; value: string }, index: number) => (
          <div key={index} className={gameDetailsStyles.detailRow}>
            <input
              type="text"
              value={detail.label}
              onChange={(e) => handleLabelChange(index, e.target.value)}
              placeholder="التصنيف (مثال: الناشر)"
              className={`${gameDetailsStyles.detailLabel} ${editorStyles.sidebarInput}`}
              style={{
                background: 'transparent',
                border: 'none',
                boxShadow: 'none',
                padding: '1.5rem 2rem',
                fontSize: '1.6rem',
                color: 'var(--accent)',
              }}
            />
            <input
              type="text"
              value={detail.value}
              onChange={(e) => handleValueChange(index, e.target.value)}
              placeholder="القيمة (مثال: Sony)"
              className={`${gameDetailsStyles.detailValue} ${editorStyles.sidebarInput}`}
              dir={isRTL(detail.value) ? 'rtl' : 'ltr'}
              style={{
                background: 'transparent',
                border: 'none',
                boxShadow: 'none',
                padding: '1.5rem 2rem',
                fontSize: '1.6rem',
              }}
            />
            <button
              onClick={() => removeRow(index)}
              style={{
                position: 'absolute',
                top: '50%',
                left: '10px',
                transform: 'translateY(-50%)',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                color: 'var(--text-secondary)',
              }}
            >
              <svg width="16" height="16" viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
            </button>
          </div>
        ))}
      </div>
      {/* MODIFIED: Translated text and applied responsive styling */}
      <div className={componentStyles.buttonContainer}>
        <button onClick={addRow} className={`outline-button ${componentStyles.actionButton}`}>
          + إضافة صف
        </button>
        <button onClick={deleteNode} className={`outline-button ${componentStyles.actionButton}`} style={{ borderColor: '#DC2626', color: '#DC2626' }}>
          حذف الجدول
        </button>
      </div>
    </NodeViewWrapper>
  );
};




--- END OF FILE app/studio/[contentType]/[id]/editor-components/GameDetailsComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css ---

/* app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css */

.creatorContainer {
    position: fixed;
    bottom: 8rem; /* Position above the MobileViewToggle */
    left: 2rem;
    right: auto;
    z-index: 2001;
}

.creatorOrb {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: var(--accent);
    color: white;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 122;
    position: relative;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

.creatorOrb.open {
    background-color: #DC2626;
    box-shadow: 0 8px 25px -5px rgba(220, 38, 38, 0.5);
}


[data-theme="dark"] .creatorOrb {
    color: var(--bg-primary);
}

.iconContainer {
    display: flex;
    align-items: center;
    justify-content: center;
}

.creatorSatellites {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 150px;
    height: 150px;
    z-index: 121;
    pointer-events: none;
}

.satelliteWrapper {
    position: absolute;
    bottom: 0;
    left: 0;
    pointer-events: auto;
    display: flex; 
    align-items: center;
    justify-content: center;
}

.satelliteOrb {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease-out;
    box-shadow: 0 5px 15px rgba(0,0,0,0.15);
}
@media (hover: hover) {@media (hover: hover) {
  
  .satelliteOrb:hover  {
    border-color: var(--accent);
    color: var(--accent);
    transform: scale(1.1);
}
}

  .satelliteOrb:active  {
    border-color: var(--accent);
    color: var(--accent);
    transform: scale(1.1);
}
}
.satelliteOrb:active {
    border-color: var(--accent);
    color: var(--accent);
    transform: scale(1.1);
}


.satelliteLabel {
    display: none;
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx ---

// app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx
'use client'

import {useState, useEffect} from 'react'
import {Editor} from '@tiptap/react'
import {motion, AnimatePresence} from 'framer-motion'
import {
  CompareIcon,
  TwoImageIcon,
  FourImageIcon,
  SingleImageIcon,
  GameDetailsIcon,
  YoutubeIcon,
} from '../../../StudioIcons'
import styles from './MobileBlockCreator.module.css'

interface MobileBlockCreatorProps {
  editor: Editor | null
  onFileUpload: (file: File) => void
}

type MenuState = 'root' | 'image'

type MenuAction = {type: 'submenu'; state: MenuState} | {type: 'command'; command: string}

const menuConfig: Record<
  MenuState,
  {id: string; title: string; icon: React.ReactNode; action: MenuAction}[]
> = {
  root: [
    {id: 'image', title: 'صورة', icon: <SingleImageIcon />, action: {type: 'submenu', state: 'image'}},
    {id: 'youtube', title: 'يوتيوب', icon: <YoutubeIcon />, action: {type: 'command', command: 'youtube'}},
    {id: 'gameDetails', title: 'تفاصيل', icon: <GameDetailsIcon />, action: {type: 'command', command: 'gameDetails'}},
    {id: 'compare', title: 'مقارنة', icon: <CompareIcon />, action: {type: 'command', command: 'imageCompare'}},
  ],
  image: [
    {id: 'singleImage', title: 'صورة مفردة', icon: <SingleImageIcon />, action: {type: 'command', command: 'image'}},
    {id: 'twoImageGrid', title: 'شبكة ثنائية', icon: <TwoImageIcon />, action: {type: 'command', command: 'twoImageGrid'}},
    {id: 'fourImageGrid', title: 'شبكة رباعية', icon: <FourImageIcon />, action: {type: 'command', command: 'fourImageGrid'}},
  ],
}

const PlusIcon = () => (
  <svg
    width="28"
    height="28"
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    strokeWidth="2.5"
    strokeLinecap="round"
    strokeLinejoin="round"
  >
    {' '}
    <line x1="12" y1="5" x2="12" y2="19"></line> <line x1="5" y1="12" x2="19" y2="12"></line>{' '}
  </svg>
)

const orbContainerVariants = {
  hidden: {opacity: 0},
  visible: {opacity: 1, transition: {staggerChildren: 0.06, delayChildren: 0.1}},
  exit: {opacity: 0, transition: {staggerChildren: 0.04, staggerDirection: -1}},
}
const satelliteVariants = {
  hidden: (isRoot: boolean) => ({scale: 0, opacity: 0, x: isRoot ? 0 : -30}),
  visible: (custom: {x: number; y: number}) => ({
    scale: 1,
    opacity: 1,
    x: custom.x,
    y: custom.y,
    transition: {type: 'spring' as const, stiffness: 400, damping: 20},
  }),
  exit: (isRoot: boolean) => ({scale: 0, opacity: 0, x: isRoot ? 0 : -30, transition: {duration: 0.15}}),
}

export function MobileBlockCreator({editor, onFileUpload}: MobileBlockCreatorProps) {
  const [isOpen, setIsOpen] = useState(false)
  const [menuState, setMenuState] = useState<MenuState>('root')

  const handleAction = (action: MenuAction) => {
    if (!editor) return

    if (action.type === 'submenu' && action.state) {
      setMenuState(action.state)
    } else if (action.type === 'command' && action.command) {
      const cmd = action.command
      if (cmd === 'image') {
        const input = document.createElement('input')
        input.type = 'file'
        input.accept = 'image/*'
        input.onchange = (e) => {
          const file = (e.target as HTMLInputElement).files?.[0]
          if (file) {
            onFileUpload(file)
          }
        }
        input.click()
      } else if (cmd === 'table') {
        editor.chain().focus().insertTable({rows: 2, cols: 2, withHeaderRow: true}).run()
      } else {
        editor.chain().focus().insertContent({type: cmd}).run()
      }
      setIsOpen(false)
    }
  }

  const handleMainOrbClick = () => {
    if (!isOpen) {
      setIsOpen(true)
      setMenuState('root')
    } else {
      setIsOpen(false)
    }
  }

  useEffect(() => {
    if (!isOpen) {
      const timer = setTimeout(() => setMenuState('root'), 200)
      return () => clearTimeout(timer)
    }
  }, [isOpen])

  const currentMenuItems = menuConfig[menuState]

  return (
    <div className={styles.creatorContainer}>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            key={menuState}
            className={styles.creatorSatellites}
            variants={orbContainerVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
          >
            {currentMenuItems.map((item, i) => {
              const numItems = currentMenuItems.length
              const angleIncrement = 90 / (numItems > 1 ? numItems - 1 : 1)
              const angleInDegrees = -90 + i * angleIncrement
              const angleInRadians = angleInDegrees * (Math.PI / 180)
              const radius = 85
              const x = Math.cos(angleInRadians) * radius
              const y = Math.sin(angleInRadians) * radius
              return (
                <motion.div
                  key={item.id}
                  className={styles.satelliteWrapper}
                  custom={{x, y}}
                  variants={satelliteVariants}
                  custom-isRoot={menuState === 'root'}
                >
                  <button
                    className={styles.satelliteOrb}
                    onClick={() => handleAction(item.action)}
                    disabled={!editor}
                    title={item.title}
                  >
                    {item.icon}
                  </button>
                </motion.div>
              )
            })}
          </motion.div>
        )}
      </AnimatePresence>
      <motion.button
        onClick={handleMainOrbClick}
        className={`${styles.creatorOrb} ${isOpen ? styles.open : ''}`}
        whileHover={{scale: 1.1}}
        whileTap={{scale: 0.95}}
        transition={{type: 'spring' as const, stiffness: 400, damping: 20}}
      >
        <motion.div animate={{rotate: isOpen ? 45 : 0}} className={styles.iconContainer}>
          <PlusIcon />
        </motion.div>
      </motion.button>
    </div>
  )
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileBlockCreator.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileFormattingToolbar.tsx ---




--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileFormattingToolbar.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css ---

/* app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css */

.toggleContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background-color: var(--bg-secondary);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-around;
    align-items: center;
    z-index: 150; /* Above editor, below sidebar overlay */
}

.toggleButton {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    height: 100%;
    background: none;
    border: none;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-secondary);
    transition: color 0.2s ease, background-color 0.2s ease;
}

.toggleButton.active {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.divider {
    width: 1px;
    height: 24px;
    background-color: var(--border-color);
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx ---

// components/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './MobileViewToggle.module.css';

interface MobileViewToggleProps {
    isSidebarOpen: boolean;
    setIsSidebarOpen: (isOpen: boolean) => void;
}

const PenIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>;
const SettingsIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;

export function MobileViewToggle({ isSidebarOpen, setIsSidebarOpen }: MobileViewToggleProps) {
    return (
        <motion.div 
            className={styles.toggleContainer}
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: 'spring', stiffness: 400, damping: 30 }}
        >
            <button className={`${styles.toggleButton} ${isSidebarOpen ? styles.active : ''}`} onClick={() => setIsSidebarOpen(true)}>
                <SettingsIcon />
                <span>الشريط الجانبي</span>
            </button>
            <div className={styles.divider}></div>
            <button className={`${styles.toggleButton} ${!isSidebarOpen ? styles.active : ''}`} onClick={() => setIsSidebarOpen(false)}>
                <PenIcon />
                <span>المحتوى</span>
            </button>
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/MobileViewToggle.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

// app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx
'use client';

import { UploadQuality } from '@/lib/image-optimizer';
import styles from '../BlockToolbar.module.css';
import bubbleStyles from '../Editor.module.css';
import editorStyles from '../Editor.module.css';

interface QualityToggleProps {
    currentQuality: UploadQuality;
    onQualityChange: (quality: UploadQuality) => void;
    isMobile?: boolean;
}

const qualityCycle: UploadQuality[] = ['1080p', '4k', '8k'];
const qualityLabels: Record<UploadQuality, string> = {
    '1080p': 'FHD',
    '4k': '4K',
    '8k': '8K'
};
const qualityTooltips: Record<UploadQuality, string> = {
    '1080p': 'Full HD (1080p)',
    '4k': 'Ultra HD (4K)',
    '8k': 'Full Ultra HD (8K)'
};

export function QualityToggle({ currentQuality, onQualityChange, isMobile = false }: QualityToggleProps) {
    
    const cycleQuality = () => {
        const currentIndex = qualityCycle.indexOf(currentQuality);
        const nextIndex = (currentIndex + 1) % qualityCycle.length;
        onQualityChange(qualityCycle[nextIndex]);
    };

    if (isMobile) {
        return (
             <button
                onClick={cycleQuality}
                className={editorStyles.iconButton}
                style={{ width: '36px', height: '36px' }}
                title={`جودة الرفع: ${qualityTooltips[currentQuality]}`}
            >
                <span style={{ fontSize: '12px', fontWeight: 700, color: 'var(--accent)' }}>
                    {qualityLabels[currentQuality]}
                </span>
            </button>
        );
    }

    return (
        <div className={styles.optionButtonWrapper}>
            <button
                onClick={cycleQuality}
                className={bubbleStyles.bubbleMenuButton}
                title={`Cycle upload quality`}
            >
                <span style={{ fontSize: '13px', fontWeight: 700, color: 'var(--accent)' }}>
                    {qualityLabels[currentQuality]}
                </span>
            </button>
            <div className={styles.optionTooltip}>
                جودة الرفع: {qualityTooltips[currentQuality]}
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/QualityToggle.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.module.css ---




--- END OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/TableComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps, NodeViewContent } from '@tiptap/react';
import styles from '../Editor.module.css';
import gameDetailsStyles from '@/components/content/GameDetails.module.css';

export const TableComponent = ({ editor, getPos, deleteNode }: NodeViewProps) => {
    
    const addColumn = () => {
        editor.chain().focus().addColumnAfter().run();
    };

    const deleteColumn = () => {
        editor.chain().focus().deleteColumn().run();
    };

    const addRow = () => {
        editor.chain().focus().addRowAfter().run();
    };

    return (
        <NodeViewWrapper as="div" className={`${styles.imageGridContainer} imageGridContainer`} data-drag-handle>
            <div className={gameDetailsStyles.detailsContainer}>
                {/* NodeViewContent will render the table's `tbody` content here */}
                <NodeViewContent as="table" />
            </div>
            <div style={{ display: 'flex', justifyContent: 'center', gap: '1rem', marginTop: '1rem' }}>
                <button onClick={addRow} className="outline-button">
                    + Add Row
                </button>
                <button onClick={addColumn} className="outline-button">
                    + Add Column
                </button>
                <button onClick={deleteColumn} className="outline-button">
                    - Delete Column
                </button>
                <button onClick={deleteNode} className="outline-button" style={{ borderColor: '#DC2626', color: '#DC2626' }}>
                    Delete Block
                </button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/editor-components/TableComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx
'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import { useState, useRef, useCallback } from 'react';
import Image from 'next/image';
import styles from '../Editor.module.css';
import compareStyles from '@/components/ImageCompare.module.css';
import { sanityLoader } from '@/lib/sanity.loader'; // <-- IMPORT ADDED

const UploadIcon = () => ( <svg className={compareStyles.uploadIcon} fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75M17.25 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" /></svg> );
const DeleteIcon = () => <svg width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

const Dropzone = ({ side, src, onUpload }: { side: number, src: string | null, onUpload: (file: File) => void }) => {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);
    const handleFile = (file: File | null | undefined) => { if (file) onUpload(file); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFile(e.dataTransfer.files?.[0]); };
    const handleDrag = (e: React.DragEvent<HTMLDivElement>, isActive: boolean) => { e.preventDefault(); e.stopPropagation(); setIsDragging(isActive); };

    return (
        <div className={`${compareStyles.dropzone} ${isDragging ? compareStyles.active : ''}`} onDrop={handleDrop} onDragEnter={(e) => handleDrag(e, true)} onDragOver={(e) => handleDrag(e, true)} onDragLeave={(e) => handleDrag(e, false)} onClick={() => inputRef.current?.click()}>
            <input ref={inputRef} type="file" style={{ display: 'none' }} accept="image/*" onChange={(e) => handleFile(e.target.files?.[0])} />
            {src && (
                <Image 
                    loader={sanityLoader} // <-- LOADER ADDED
                    src={src} 
                    alt={`Image ${side}`} 
                    fill 
                    className={compareStyles.imagePreview} 
                />
            )}
            <div className={compareStyles.dropzoneContent} style={{fontSize: '1.4rem'}}>
                <UploadIcon />
                <span>{src ? `تغيير الصورة` : `أفلت صورةً أو انقر للرفع`}</span>
            </div>
        </div>
    );
};

export const TwoImageGridComponent = ({ node, updateAttributes, editor, getPos }: NodeViewProps) => {
    const toast = useToast();
    const handleUpload = useCallback(async (file: File, slot: 1 | 2) => {
        try {
            toast.info('جارٍ تهيئة الصورة للرفع...', 'left');
            const quality = editor.storage.uploadQuality || '1080p';
            const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, quality);

            toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');

            const formData = new FormData();
            formData.append('file', optimizedFile);
            const result = await uploadSanityAssetAction(formData);

            if (result.success && result.asset) {
                updateAttributes({ [`src${slot}`]: result.asset.url, [`assetId${slot}`]: result.asset._id });
                toast.success('رُفِعت الصورة.', 'left');
            } else { throw new Error(result.error || 'فشل الرفع'); }
        } catch (error: any) { toast.error(error.message, 'left'); }
    }, [updateAttributes, toast, editor.storage.uploadQuality]);

    const handleDelete = () => editor.chain().deleteRange({ from: getPos(), to: getPos() + 1 }).focus().run();

    return (
        <NodeViewWrapper as="div" className={styles.imageGridContainer} data-drag-handle>
            <div className={compareStyles.twoImageGrid}>
                <Dropzone side={1} src={node.attrs.src1} onUpload={(file) => handleUpload(file, 1)} />
                <Dropzone side={2} src={node.attrs.src2} onUpload={(file) => handleUpload(file, 2)} />
            </div>
            <div className={styles.imageNodeMenu} contentEditable={false}>
                <button onClick={handleDelete} className={`${styles.bubbleMenuButton} ${styles.deleteButton}`} title="حذف الشبكة"><DeleteIcon /></button>
            </div>
        </NodeViewWrapper>
    );
};




--- END OF FILE app/studio/[contentType]/[id]/editor-components/TwoImageGridComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css ---

/* app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css */
.youtubeContainer {
  position: relative;
  margin: 2rem 0;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  padding: 1rem;
  background-color: var(--bg-primary);
  transition: box-shadow 0.2s ease-out;
}

.ProseMirror-selectednode .youtubeContainer {
  box-shadow: 0 0 0 3px var(--accent);
}

.urlInputContainer {
  padding: 2rem;
}

.iframeContainer {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  border-radius: 8px;
  overflow: hidden;
}

.iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border: none;
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx ---

// app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx
'use client'

import {NodeViewWrapper, NodeViewProps} from '@tiptap/react'
import {useState} from 'react'
import styles from './YoutubeComponent.module.css'
import editorStyles from '../Editor.module.css'

const getYouTubeId = (url: string): string | null => {
  if (!url) return null
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
  const match = url.match(regExp)
  return match && match[2].length === 11 ? match[2] : null
}

export const YoutubeComponent = ({
  node,
  updateAttributes,
  deleteNode,
}: NodeViewProps) => {
  const [urlInput, setUrlInput] = useState(node.attrs.src || '')
  const videoId = getYouTubeId(node.attrs.src)

  const handleUrlChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setUrlInput(e.target.value)
  }

  const handleUpdate = () => {
    updateAttributes({src: urlInput})
  }

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleUpdate()
    }
  }

  return (
    <NodeViewWrapper as="div" className={styles.youtubeContainer} data-drag-handle>
      {!videoId ? (
        <div className={styles.urlInputContainer}>
          <input
            type="text"
            value={urlInput}
            onChange={handleUrlChange}
            onKeyDown={handleKeyDown}
            onBlur={handleUpdate}
            placeholder="ألصق رابط يوتيوب هنا ثم اضغط إدخال"
            className={editorStyles.sidebarInput}
            autoFocus
          />
        </div>
      ) : (
        <div className={styles.iframeContainer}>
          <iframe
            src={`https://www.youtube.com/embed/${videoId}`}
            title="YouTube video player"
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            className={styles.iframe}
          ></iframe>
        </div>
      )}

      <div className={editorStyles.imageNodeMenu} contentEditable={false}>
        <button
          onClick={deleteNode}
          className={`${editorStyles.bubbleMenuButton} ${editorStyles.deleteButton}`}
          title="Delete Video"
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>
        </button>
      </div>
    </NodeViewWrapper>
  )
}




--- END OF FILE app/studio/[contentType]/[id]/editor-components/YoutubeComponent.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/AutoBoldEnglishExtension.ts ---

// app/studio/[contentType]/[id]/extensions/AutoBoldEnglishExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';

export const AutoBoldEnglishExtension = Extension.create({
  name: 'autoBoldEnglish',

  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey('autoBoldEnglish'),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanged = transactions.some(transaction => transaction.docChanged);
          if (!docChanged) {
            return null;
          }

          const tr = newState.tr;
          let modified = false;
          const boldMark = this.editor.schema.marks.bold;

          if (!boldMark) return null;

          // Regex to find English words (Latin alphabet sequences)
          // Includes handling for apostrophes (e.g., "don't", "user's")
          const englishRegex = /\b[a-zA-Z]+(?:['’][a-zA-Z]+)?\b/g;

          newState.doc.descendants((node, pos) => {
            if (!node.isText) return;
            
            // Optimization: If the entire text node is already bold, we skip regex scanning
            if (boldMark.isInSet(node.marks)) return;

            const text = node.text;
            if (!text) return;

            let match;
            englishRegex.lastIndex = 0; // Reset regex state

            while ((match = englishRegex.exec(text)) !== null) {
              const start = pos + match.index;
              const end = start + match[0].length;

              // Apply bold mark to the English word range
              tr.addMark(start, end, boldMark.create());
              modified = true;
            }
          });

          if (!modified) {
            return null;
          }

          return tr;
        },
      }),
    ];
  },
});




--- END OF FILE app/studio/[contentType]/[id]/extensions/AutoBoldEnglishExtension.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts ---

// app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';

type ColorMapping = {
  word: string;
  color: string;
};

export interface AutoColorOptions {
  colorMappings: ColorMapping[];
}

function escapeRegExp(string: string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

export const AutoColorExtension = Extension.create<AutoColorOptions>({
  name: 'autoColor',

  addOptions() {
    return {
      colorMappings: [],
    };
  },

  addProseMirrorPlugins() {
    const { colorMappings } = this.options;
    
    return [
      new Plugin({
        key: new PluginKey('autoColorApply'),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanged = transactions.some(transaction => transaction.docChanged);
          if (!docChanged || colorMappings.length === 0) {
            return null;
          }

          const tr = newState.tr;
          let modified = false;

          // Prepare regex and color map
          const sortedMappings = [...colorMappings].sort((a, b) => b.word.length - a.word.length);
          const wordsToFind = sortedMappings.map(m => escapeRegExp(m.word)).join('|');
          const searchRegex = new RegExp(`\\b(${wordsToFind})\\b`, 'gi');
          
          const colorMap = new Map<string, string>();
          colorMappings.forEach(m => colorMap.set(m.word.toLowerCase(), m.color));
          
          const textStyleMark = this.editor.schema.marks.textStyle;

          newState.doc.forEach((node, pos) => {
            if (!node.isTextblock) return;

            const text = node.textContent;
            if (!text) return;

            // 1. Calculate Desired Matches
            const matches: {start: number, end: number, color: string}[] = [];
            let match;
            searchRegex.lastIndex = 0;
            
            while ((match = searchRegex.exec(text)) !== null) {
                const word = match[0];
                const color = colorMap.get(word.toLowerCase());
                if (color) {
                    matches.push({
                        start: pos + 1 + match.index,
                        end: pos + 1 + match.index + word.length,
                        color
                    });
                }
            }

            // 2. Apply Matches ONLY
            // FIX: We removed the aggressive "Cleanup" loop that was stripping all managed colors from the block.
            // Now we only ADD colors to matching words. This prevents the extension from fighting against
            // manual color selections that happen to use the same hex codes as the dictionary.
            
            matches.forEach(m => {
                // We add the mark. If it already exists, Prosemirror handles the merge efficiently.
                tr.addMark(m.start, m.end, textStyleMark.create({ color: m.color }));
                modified = true;
            });
          });

          if (!modified) {
            return null;
          }

          return tr;
        },
      }),
    ];
  },
});




--- END OF FILE app/studio/[contentType]/[id]/extensions/AutoColorExtension.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts ---

// app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { EditorView } from 'prosemirror-view';

export const DeactivateMarksExtension = Extension.create({
    name: 'deactivateMarks',

    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('deactivateMarks'),
                props: {
                    handleTextInput: (view: EditorView, from: number, to: number, text: string) => {
                        // Detect when the user types a Space
                        if (text === ' ' && view.state.selection.empty) {
                            // Check for ANY active marks at the current cursor position.
                            // 'storedMarks' are marks toggled on but not typed yet (e.g., clicking 'B' button).
                            // '$from.marks()' are marks on the character immediately preceding the cursor.
                            const currentMarks = view.state.storedMarks || view.state.selection.$from.marks();

                            if (currentMarks && currentMarks.length > 0) {
                                // 1. Insert the space. The space itself will inherit the previous marks (keeping the word visually intact).
                                const tr = view.state.tr.insertText(text, from, to);
                                
                                // 2. Forcefully clear the "stored marks" for the NEXT character to be typed.
                                // This ensures the user "steps out" of Bold/Italic/Color immediately after the space.
                                tr.setStoredMarks([]);
                                
                                view.dispatch(tr);
                                return true; // Tell the editor we handled this input manually.
                            }
                        }
                        return false; // Let the editor handle non-space inputs normally.
                    },
                },
            }),
        ];
    },
});




--- END OF FILE app/studio/[contentType]/[id]/extensions/DeactivateMarksExtension.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts ---

// app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts
import { Node, mergeAttributes } from '@tiptap/core';
import { ReactNodeViewRenderer } from '@tiptap/react';
import { GameDetailsComponent } from '../editor-components/GameDetailsComponent';

export const GameDetailsNode = Node.create({
  name: 'gameDetails',
  group: 'block',
  atom: true,
  draggable: true,

  addAttributes() {
    return {
      details: {
        default: [{ label: 'الناشر', value: '' }],
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-type="game-details"]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', mergeAttributes({ 'data-type': 'game-details' }, HTMLAttributes)];
  },

  addNodeView() {
    return ReactNodeViewRenderer(GameDetailsComponent);
  },
});




--- END OF FILE app/studio/[contentType]/[id]/extensions/GameDetailsNode.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/extensions/YoutubeNode.ts ---

// app/studio/[contentType]/[id]/extensions/YoutubeNode.ts
import {Node, mergeAttributes} from '@tiptap/core'
import {ReactNodeViewRenderer} from '@tiptap/react'
import {YoutubeComponent} from '../editor-components/YoutubeComponent'

export interface YoutubeOptions {
    src: string;
}

declare module '@tiptap/core' {
    interface Commands<ReturnType> {
        youtube: {
            setYoutubeVideo: (options: YoutubeOptions) => ReturnType,
        }
    }
}

export const YoutubeNode = Node.create({
  name: 'youtube',
  group: 'block',
  atom: true,
  draggable: true,

  addAttributes() {
    return {
      src: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-youtube-video]',
        getAttrs: (dom) => {
          const iframe = (dom as HTMLElement).querySelector('iframe')
          return {src: iframe?.src}
        },
      },
    ]
  },

  renderHTML({HTMLAttributes}) {
    return ['div', mergeAttributes({'data-youtube-video': ''}, HTMLAttributes)]
  },

  addNodeView() {
    return ReactNodeViewRenderer(YoutubeComponent)
  },

  addCommands() {
    return {
      setYoutubeVideo: (options: YoutubeOptions) => ({ commands }) => {
          return commands.insertContent({
            type: this.name,
            attrs: options,
          })
        },
    }
  },
})




--- END OF FILE app/studio/[contentType]/[id]/extensions/YoutubeNode.ts ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddDeveloperModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddDeveloperModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';

interface AddDeveloperModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddDeveloperModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddDeveloperModalProps) {
    const [devTitle, setDevTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setDevTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (devTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(devTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
             <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إضافة مطور جديد</h3>
                <input
                    type="text"
                    value={devTitle}
                    onChange={(e) => setDevTitle(e.target.value)}
                    placeholder="مثال: FromSoftware"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !devTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/AddDeveloperModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddGameModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from '@/components/modals/Modals.module.css';

interface AddGameModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddGameModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddGameModalProps) {
    const [gameTitle, setGameTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setGameTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (gameTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(gameTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
             <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إنشاء لعبة جديدة</h3>
                <input
                    type="text"
                    value={gameTitle}
                    onChange={(e) => setGameTitle(e.target.value)}
                    placeholder="مثال: Elden Ring"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !gameTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/AddGameModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddPublisherModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddPublisherModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';

interface AddPublisherModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddPublisherModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddPublisherModalProps) {
    const [pubTitle, setPubTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setPubTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (pubTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(pubTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
             <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إضافة ناشر جديد</h3>
                <input
                    type="text"
                    value={pubTitle}
                    onChange={(e) => setPubTitle(e.target.value)}
                    placeholder="مثال: Bandai Namco"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !pubTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/AddPublisherModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

// app/studio/[contentType]/[id]/metadata/AddTagModal.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from '@/components/modals/Modals.module.css';

interface AddTagModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (title: string) => Promise<void>;
    initialValue?: string;
}

export function AddTagModal({ isOpen, onClose, onSubmit, initialValue = '' }: AddTagModalProps) {
    const [tagTitle, setTagTitle] = useState('');
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen) {
            setTagTitle(initialValue);
        }
    }, [isOpen, initialValue]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (tagTitle.trim() && !isPending) {
            startTransition(async () => {
                await onSubmit(tagTitle);
            });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '400px' }}>
            <form onSubmit={handleSubmit}>
                <h3 style={{ marginTop: 0, marginBottom: '1.5rem', fontFamily: 'var(--font-main)' }}>إضافة وسم جديد</h3>
                <input
                    type="text"
                    value={tagTitle}
                    onChange={(e) => setTagTitle(e.target.value)}
                    placeholder="مثال: RPG"
                    className="profile-input"
                    autoFocus
                    style={{ marginBottom: '1.5rem' }}
                    disabled={isPending}
                />
                <div className={modalStyles.modalActions}>
                    <button type="button" onClick={onClose} className="outline-button" disabled={isPending}>إلغاء</button>
                    <button type="submit" className="primary-button" disabled={isPending || !tagTitle.trim()}>
                        {isPending ? 'جار الإنشاء...' : 'إنشاء'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/AddTagModal.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

// app/studio/[contentType]/[id]/metadata/CreatorInput.tsx
'use client';

import { useState, useEffect, useRef, useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Creator = { _id: string; name: string, _type?: string };
interface CreatorInputProps { 
    label: string; 
    allCreators: Creator[]; 
    selectedCreators: Creator[]; 
    onCreatorsChange: (creators: Creator[]) => void; 
    role: 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER';
}

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};

const CreatorChip = ({ creator, onRemove }: { creator: Creator, onRemove: (creatorId: string) => void }) => {
    return (
        <motion.div 
            // FIX: Use onMouseDown instead of onClick to fire before blur/unmount logic
            onMouseDown={(e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                onRemove(creator._id); 
            }} 
            layout 
            variants={{ initial: { opacity: 0, scale: 0.5 }, visible: { opacity: 1, scale: 1 }, exiting: { opacity: 0, scale: 0.6 } }} 
            initial="initial" 
            animate="visible" 
            exit="exiting" 
            style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 2, cursor: 'pointer' }} 
            title={`Click to remove "${creator.name}"`} 
            whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}
        >
            <span>{creator.name}</span>
            <svg width="12" height="12" viewBox="0 0 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function CreatorInput({ label, allCreators, selectedCreators = [], onCreatorsChange, role }: CreatorInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const validSelectedCreators = (selectedCreators || []).filter(Boolean);

    const roleMap = { 'REVIEWER': 'reviewer', 'AUTHOR': 'author', 'REPORTER': 'reporter', 'DESIGNER': 'designer' };
    const sanityType = roleMap[role];

    const filteredCreators = useMemo(() => {
        let relevant = allCreators.filter(c => c._type === sanityType);
        relevant = relevant.filter(c => !validSelectedCreators.some(sel => sel._id === c._id));
        if (!searchTerm) return relevant;
        const lowerSearch = searchTerm.toLowerCase();
        return relevant.filter(c => c.name.toLowerCase().includes(lowerSearch));
    }, [allCreators, searchTerm, sanityType, validSelectedCreators]);
    
    useEffect(() => { 
        if (isPopoverOpen) { setTimeout(() => inputRef.current?.focus(), 100); } else { setSearchTerm(''); } 
    }, [isPopoverOpen]);

    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { 
            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } 
        }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const addCreator = (creator: Creator) => {
        if (!validSelectedCreators.some(c => c._id === creator._id)) {
            onCreatorsChange([...validSelectedCreators, creator]);
        }
        setSearchTerm('');
        // Re-focus input after selection to keep typing flow
        setTimeout(() => inputRef.current?.focus(), 0);
    };
    
    const removeCreator = (creatorIdToRemove: string) => {
        onCreatorsChange(validSelectedCreators.filter(c => c._id !== creatorIdToRemove));
    };

    return (
        <div className={styles.sidebarSection} ref={wrapperRef}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                <div 
                    className={styles.sidebarInput} 
                    style={{ display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text' }} 
                    onClick={() => {
                        // Only open if we aren't clicking a chip (handled by stopPropagation)
                        setIsPopoverOpen(true);
                    }}
                >
                    <AnimatePresence>
                        {validSelectedCreators.map(creator => (<CreatorChip key={creator._id} creator={creator} onRemove={removeCreator} />))}
                    </AnimatePresence>
                    
                    {validSelectedCreators.length === 0 && !isPopoverOpen && (
                        <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>{`انقر لإضافة ${label.toLowerCase()}`}</span>
                    )}
                </div>
                
                <AnimatePresence>
                    {isPopoverOpen && (
                        <motion.div 
                            // Prevent clicks inside the popover from bubbling up and toggling anything
                            onClick={(e) => e.stopPropagation()}
                            variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                            style={{ 
                                position: 'absolute', top: '100%', left: 0, 
                                width: '100%',
                                background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                borderRadius: '6px', zIndex: 100, 
                                padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.2)', marginTop: '0.5rem'
                            }}
                        >
                            <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder={`ابحث بالاسم...`} className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                            <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                {filteredCreators.length > 0 ? (
                                    filteredCreators.map(creator => ( 
                                        <button 
                                            type="button" 
                                            key={creator._id} 
                                            // FIX: Use onMouseDown for reliable event handling
                                            onMouseDown={(e) => { 
                                                e.preventDefault(); 
                                                e.stopPropagation(); 
                                                addCreator(creator); 
                                            }}
                                            style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} 
                                            className={styles.popoverItemButton}
                                        > 
                                            {creator.name} 
                                        </button> 
                                    ))
                                ) : (
                                    <div style={{padding: '1rem', color: 'var(--text-secondary)'}}>لا يوجد نتائج.</div>
                                )}
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/CreatorInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/DeveloperInput.tsx ---

// app/studio/[contentType]/[id]/metadata/DeveloperInput.tsx
'use client';

import { useState, useEffect, useRef, useMemo, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createDeveloperAction, deleteMetadataAction } from '../../../actions';
import { AddDeveloperModal } from './AddDeveloperModal';
import ActionButton from '@/components/ActionButton';
import { useToast } from '@/lib/toastStore';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Developer = { _id: string; title: string };
interface DeveloperInputProps { 
    allDevelopers: Developer[]; 
    selectedDeveloper: Developer | null; 
    onDeveloperSelect: (dev: Developer | null) => void; 
}

const popoverVariants = { hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, };
const TrashIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export function DeveloperInput({ allDevelopers, selectedDeveloper, onDeveloperSelect }: DeveloperInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddModalOpen, setIsAddModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [isDeleting, startDeleteTransition] = useTransition();
    const toast = useToast();
    
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const filteredDevs = useMemo(() => {
        if (!searchTerm) return allDevelopers;
        const lowerSearch = searchTerm.toLowerCase();
        return allDevelopers.filter(d => d.title.toLowerCase().includes(lowerSearch));
    }, [allDevelopers, searchTerm]);

    useEffect(() => { 
        if (isPopoverOpen) { 
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else {
            setSearchTerm('');
        }
    }, [isPopoverOpen]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const handleSelect = (dev: Developer) => { 
        onDeveloperSelect(dev); 
        setIsPopoverOpen(false); 
    };

    const handleDelete = async (e: React.MouseEvent, dev: Developer) => {
        e.stopPropagation();
        e.preventDefault();
        
        if (window.confirm(`هل أنت متأكد من حذف المطور "${dev.title}"؟`)) {
            startDeleteTransition(async () => {
                const result = await deleteMetadataAction(dev._id);
                if (result.success) {
                    toast.success('تم حذف المطور.');
                    if (selectedDeveloper?._id === dev._id) {
                        onDeveloperSelect(null);
                    }
                } else {
                    toast.error(result.message || 'فشل الحذف.');
                }
            });
        }
    };
    
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddModalOpen(true); };
    const handleCreate = async (title: string) => { const newDev = await createDeveloperAction(title); if (newDev) { onDeveloperSelect(newDev); } setIsAddModalOpen(false); setSearchTerm(''); };
    
    return (
        <>
            <AddDeveloperModal isOpen={isAddModalOpen} onClose={() => setIsAddModalOpen(false)} onSubmit={handleCreate} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>المطور (Developer)</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', justifyContent: 'space-between', 
                            cursor: selectedDeveloper ? 'default' : 'text',
                            paddingRight: '0.5rem',
                        }} 
                        onClick={() => {if (!selectedDeveloper) setIsPopoverOpen(true)}}
                    >
                        <span>{selectedDeveloper ? selectedDeveloper.title : 'ابحث عن مطور...'}</span>
                    </div>
                    
                    {selectedDeveloper ? (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); onDeveloperSelect(null); }} aria-label="Remove selected developer">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </ActionButton>
                    ) : (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); handleOpenModal(); }} aria-label="إضافة مطور جديد">
                             <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </ActionButton>
                    )}
                    
                    <AnimatePresence>
                        {isPopoverOpen && !selectedDeveloper && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()}
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, right: 0,
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 100, marginTop: '0.5rem',
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.2)'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="ابحث..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredDevs.length > 0 ? filteredDevs.map(dev => (
                                        <div key={dev._id} style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                                            <button 
                                                type="button" 
                                                onMouseDown={(e) => { 
                                                    e.preventDefault(); 
                                                    e.stopPropagation();
                                                    handleSelect(dev); 
                                                }}
                                                style={{ flexGrow: 1, textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)' }} 
                                                className={styles.popoverItemButton}
                                            >
                                                {dev.title}
                                            </button>
                                            <button
                                                type="button"
                                                onMouseDown={(e) => handleDelete(e, dev)}
                                                disabled={isDeleting}
                                                style={{ padding: '0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: '#DC2626', opacity: 0.6 }}
                                                title="حذف المطور"
                                                className={styles.popoverItemButton}
                                            >
                                                <TrashIcon />
                                            </button>
                                        </div>
                                    ))
                                     : searchTerm.length > 1 && <p style={{padding:'0.5rem', color:'var(--text-secondary)'}}>لا نتائج.</p>
                                    }
                                    
                                    {searchTerm.length > 1 && (
                                        <button 
                                            type="button" 
                                            onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); handleOpenModal(); }}
                                            style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic', borderTop: '1px solid var(--border-color)' }}
                                        >
                                            + إنشاء جديد: "{searchTerm.trim()}"
                                        </button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/DeveloperInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

// app/studio/[contentType]/[id]/metadata/GameInput.tsx
'use client';

import { useState, useEffect, useRef, useMemo, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createGameAction, deleteMetadataAction } from '../../../actions';
import { AddGameModal } from './AddGameModal';
import ActionButton from '@/components/ActionButton';
import { useToast } from '@/lib/toastStore';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Game = { _id: string; title: string };
interface GameInputProps { 
    allGames: Game[]; 
    selectedGame: Game | null; 
    onGameSelect: (game: Game | null) => void; 
}

const popoverVariants = { hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, };
const TrashIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export function GameInput({ allGames, selectedGame, onGameSelect }: GameInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddGameModalOpen, setIsAddGameModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [isDeleting, startDeleteTransition] = useTransition();
    const toast = useToast();
    
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const filteredGames = useMemo(() => {
        if (!searchTerm) return allGames;
        const lowerSearch = searchTerm.toLowerCase();
        return allGames.filter(g => g.title.toLowerCase().includes(lowerSearch));
    }, [allGames, searchTerm]);

    useEffect(() => { 
        if (isPopoverOpen) { 
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else {
            setSearchTerm('');
        }
    }, [isPopoverOpen]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const handleSelect = (game: Game) => { 
        onGameSelect(game); 
        setIsPopoverOpen(false); 
    };
    
    const handleDelete = async (e: React.MouseEvent, game: Game) => {
        e.stopPropagation();
        e.preventDefault();
        
        if (window.confirm(`هل أنت متأكد من حذف اللعبة "${game.title}"؟ قد يؤثر هذا على المحتوى المرتبط بها.`)) {
            startDeleteTransition(async () => {
                const result = await deleteMetadataAction(game._id);
                if (result.success) {
                    toast.success('تم حذف اللعبة.');
                    // If the deleted game was selected, clear selection
                    if (selectedGame?._id === game._id) {
                        onGameSelect(null);
                    }
                } else {
                    toast.error(result.message || 'فشل الحذف.');
                }
            });
        }
    };
    
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddGameModalOpen(true); };
    const handleCreateGame = async (title: string) => { const newGame = await createGameAction(title); if (newGame) { onGameSelect(newGame); } setIsAddGameModalOpen(false); setSearchTerm(''); };
    
    return (
        <>
            <AddGameModal isOpen={isAddGameModalOpen} onClose={() => setIsAddGameModalOpen(false)} onSubmit={handleCreateGame} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>اللعبة</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', justifyContent: 'space-between', 
                            cursor: selectedGame ? 'default' : 'text',
                            paddingRight: '0.5rem',
                        }} 
                        onClick={() => {if (!selectedGame) setIsPopoverOpen(true)}}
                    >
                        <span>{selectedGame ? selectedGame.title : 'ابحث عن لعبة...'}</span>
                    </div>
                    
                    {selectedGame ? (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); onGameSelect(null); }} aria-label="Remove selected game">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </ActionButton>
                    ) : (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); handleOpenModal(); }} aria-label="إضافة لعبة جديدة">
                             <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </ActionButton>
                    )}
                    
                    <AnimatePresence>
                        {isPopoverOpen && !selectedGame && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()}
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, right: 0,
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 100, marginTop: '0.5rem',
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.2)'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="ابحث..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredGames.length > 0 ? filteredGames.map(game => (
                                        <div 
                                            key={game._id}
                                            style={{ display: 'flex', alignItems: 'center', width: '100%' }}
                                        >
                                            <button 
                                                type="button" 
                                                onMouseDown={(e) => { 
                                                    e.preventDefault(); 
                                                    e.stopPropagation();
                                                    handleSelect(game); 
                                                }}
                                                style={{ flexGrow: 1, textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)' }} 
                                                className={styles.popoverItemButton}
                                            >
                                                {game.title}
                                            </button>
                                            <button
                                                type="button"
                                                onMouseDown={(e) => handleDelete(e, game)}
                                                disabled={isDeleting}
                                                style={{ padding: '0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: '#DC2626', opacity: 0.6 }}
                                                title="حذف اللعبة"
                                                className={styles.popoverItemButton}
                                            >
                                                <TrashIcon />
                                            </button>
                                        </div>
                                    ))
                                     : searchTerm.length > 1 && <p style={{padding:'0.5rem', color:'var(--text-secondary)'}}>لا نتائج.</p>
                                    }
                                    
                                    {searchTerm.length > 1 && (
                                        <button 
                                            type="button" 
                                            // FIX: Use onMouseDown here as well
                                            onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); handleOpenModal(); }}
                                            style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic', borderTop: '1px solid var(--border-color)' }}
                                        >
                                            + إنشاء جديد: "{searchTerm.trim()}"
                                        </button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/GameInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

// app/studio/[contentType]/[id]/metadata/MainImageInput.tsx
'use client';

import { useState, useRef, useTransition, useCallback, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { useToast } from '@/lib/toastStore';
import { optimizeImageForUpload, UploadQuality } from '@/lib/image-optimizer';
import { uploadSanityAssetAction } from '../../../actions';
import avatarStyles from '../../../../components/ProfileEditForm.module.css';
import { sanityLoader } from '@/lib/sanity.loader';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} B`;
    const kb = bytes / 1024;
    if (kb < 1024) return `${kb.toFixed(1)} KB`;
    const mb = kb / 1024;
    return `${mb.toFixed(2)} MB`;
};

export function MainImageInput({ currentAssetId, currentAssetUrl, onImageChange, uploadQuality }: {
    currentAssetId: string | null;
    currentAssetUrl: string | null;
    onImageChange: (assetId: string | null, url: string | null) => void;
    uploadQuality: UploadQuality;
}) {
    const [isDragging, setIsDragging] = useState(false);
    const [previewUrl, setPreviewUrl] = useState<string | null>(currentAssetUrl);
    const [isUploading, startUpload] = useTransition();
    const fileInputRef = useRef<HTMLInputElement>(null);
    const toast = useToast();

    // --- FIX: MEMORY LEAK CLEANUP ---
    // Track blob URLs to revoke them when component unmounts or preview changes
    useEffect(() => {
        return () => {
            if (previewUrl && previewUrl.startsWith('blob:')) {
                URL.revokeObjectURL(previewUrl);
            }
        };
    }, [previewUrl]);

    useEffect(() => {
        setPreviewUrl(currentAssetUrl);
    }, [currentAssetUrl]);

    const handleFile = useCallback(async (file: File) => {
        if (!file.type.startsWith('image/')) {
            toast.error('نوع ملف غير صالح. يرجى رفع صورة.', 'left');
            return;
        }

        startUpload(async () => {
            try {
                toast.info('جارٍ تهيئة الصورة...', 'left');
                const { file: optimizedFile, finalQuality } = await optimizeImageForUpload(file, uploadQuality);
                
                // Clean up previous blob if exists
                if (previewUrl && previewUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(previewUrl);
                }

                const localUrl = URL.createObjectURL(optimizedFile);
                setPreviewUrl(localUrl);

                toast.info(`جارٍ رفع الصورة (${formatFileSize(optimizedFile.size)} @ ${Math.round(finalQuality * 100)}%)...`, 'left');
                
                const formData = new FormData();
                formData.append('file', optimizedFile);
                const result = await uploadSanityAssetAction(formData);
                
                if (result.success && result.asset) {
                    onImageChange(result.asset._id, result.asset.url);
                    // We don't revoke localUrl here immediately to prevent flicker, 
                    // but it will be cleaned up by the useEffect when currentAssetUrl updates and triggers a prop change
                    toast.success('رُفِعت الصورة الرئيسية.', 'left');
                } else {
                    throw new Error(result.error || 'فشل رفع الصورة إلى Sanity.');
                }
            } catch (error: any) {
                setPreviewUrl(currentAssetUrl);
                onImageChange(currentAssetId, currentAssetUrl);
                toast.error(error.message || 'أخفقت تهيئة الصورة.', 'left');
            }
        });
    }, [onImageChange, toast, currentAssetUrl, currentAssetId, uploadQuality, previewUrl]);
    
    const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        setIsDragging(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            handleFile(e.dataTransfer.files[0]);
        }
    }, [handleFile]);

    const handleClear = () => {
        if (previewUrl && previewUrl.startsWith('blob:')) {
            URL.revokeObjectURL(previewUrl);
        }
        setPreviewUrl(null);
        onImageChange(null, null);
        if (fileInputRef.current) fileInputRef.current.value = '';
        toast.info('أُزيلت الصورة الرئيسية.', 'left');
    };

    return (
        <>
            <input type="file" ref={fileInputRef} onChange={(e) => e.target.files && handleFile(e.target.files[0])} accept="image/*" style={{ display: 'none' }} disabled={isUploading} />
            <motion.div
                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                onDragLeave={() => setIsDragging(false)}
                onDrop={handleDrop}
                onClick={() => !isUploading && fileInputRef.current?.click()}
                style={{
                    aspectRatio: '16/9',
                    border: `2px dashed ${isDragging ? 'var(--accent)' : 'var(--border-color)'}`,
                    backgroundColor: isDragging ? 'color-mix(in srgb, var(--accent) 10%, transparent)' : 'var(--bg-primary)',
                    borderRadius: '8px',
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center',
                    cursor: isUploading ? 'progress' : 'pointer',
                    position: 'relative',
                    overflow: 'hidden',
                    transition: 'all 0.2s ease',
                }}
            >
                <AnimatePresence>
                    {previewUrl ? (
                        <motion.div key="image" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ width: '100%', height: '100%' }}>
                            <Image 
                                loader={sanityLoader} // <-- LOADER ADDED
                                src={previewUrl} 
                                alt="معاينة الصورة المصغرة" 
                                fill 
                                sizes="300px" 
                                style={{ objectFit: 'cover' }} 
                            />
                            {isUploading && <div style={{ position: 'absolute', inset: 0, backgroundColor: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center' }}><div className="spinner" style={{ width: '30px', height: '30px' }}/></div>}
                        </motion.div>
                    ) : (
                        <motion.div key="placeholder" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                            {isUploading ? ( <div className="spinner" /> ) : (
                                <>
                                    <p style={{ margin: 0 }}>أفلت أو انقر للرفع</p>
                                    <p style={{ fontSize: '1.2rem', margin: '0.5rem 0 0 0' }}>الصورُ الكبيرةُ تُهَيَّأُ تلقائيًا</p>
                                </>
                            )}
                        </motion.div>
                    )}
                </AnimatePresence>
            </motion.div>

            {previewUrl && (
                <button type="button" onClick={handleClear} className="outline-button" style={{ width: '100%', marginTop: '1rem', color: '#DC2626', borderColor: '#DC2626' }}>
                    إزالة الصورة
                </button>
            )}
        </>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/MainImageInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

/* app/studio/[contentType]/[id]/metadata/Metadata.module.css */

.inputWrapper {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.inputWrapper > input,
.inputWrapper > div[class*="sidebarInput"] {
    flex-grow: 1;
}










--- END OF FILE app/studio/[contentType]/[id]/metadata/Metadata.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/NewsTypeInput.tsx ---

// app/studio/[contentType]/[id]/metadata/NewsTypeInput.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Editor.module.css';

type NewsType = 'official' | 'rumor' | 'leak';

interface NewsTypeInputProps {
    value: NewsType;
    onChange: (type: NewsType) => void;
}

const options: { label: string; value: NewsType; color: string }[] = [
    { label: 'رسمي', value: 'official', color: 'var(--accent)' },
    { label: 'إشاعة', value: 'rumor', color: '#F59E0B' }, // Amber
    { label: 'تسريب', value: 'leak', color: '#DC2626' }   // Red
];

export function NewsTypeInput({ value, onChange }: NewsTypeInputProps) {
    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>تصنيف الخبر</label>
            <div style={{ 
                display: 'grid', 
                gridTemplateColumns: '1fr 1fr 1fr', 
                gap: '0.5rem', 
                background: 'var(--bg-primary)', 
                padding: '0.5rem', 
                borderRadius: '8px',
                border: '1px solid var(--border-color)'
            }}>
                {options.map((option) => {
                    const isActive = value === option.value;
                    return (
                        <motion.button
                            key={option.value}
                            type="button"
                            onClick={() => onChange(option.value)}
                            className={styles.sidebarInput} // Reuse base input styles for font/reset
                            style={{
                                height: '36px',
                                padding: '0',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                cursor: 'pointer',
                                backgroundColor: isActive ? option.color : 'transparent',
                                color: isActive ? '#fff' : 'var(--text-secondary)',
                                borderColor: isActive ? option.color : 'transparent',
                                fontWeight: isActive ? 700 : 500,
                                fontSize: '1.3rem',
                                transition: 'all 0.2s ease',
                                boxShadow: isActive ? `0 0 10px ${option.color}40` : 'none'
                            }}
                            whileHover={{ scale: 1.02 }}
                            whileTap={{ scale: 0.95 }}
                        >
                            {option.label}
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/NewsTypeInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

// app/studio/[contentType]/[id]/metadata/PlatformInput.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Editor.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

const PLATFORMS = ['PC', 'PlayStation 5', 'Xbox', 'Switch'];

interface PlatformInputProps {
    selectedPlatforms: string[];
    onPlatformsChange: (platforms: string[]) => void;
}

export function PlatformInput({ selectedPlatforms = [], onPlatformsChange }: PlatformInputProps) {
    
    const handleToggle = (platform: string) => {
        const newSelection = selectedPlatforms.includes(platform)
            ? selectedPlatforms.filter(p => p !== platform)
            : [...selectedPlatforms, platform];
        onPlatformsChange(newSelection);
    };

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>المنصات</label>
            <div className={filterStyles.filterButtonsGroup}>
                {PLATFORMS.map(platform => {
                    const isActive = selectedPlatforms.includes(platform);
                    return (
                        <motion.button
                            key={platform}
                            type="button"
                            onClick={() => handleToggle(platform)}
                            className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`}
                        >
                            {platform}
                            {isActive && <motion.div layoutId="platform-highlight" className={filterStyles.filterHighlight} />}
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
}










--- END OF FILE app/studio/[contentType]/[id]/metadata/PlatformInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

// app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from '@/components/ActionButton';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

interface ProsConsInputProps { label: 'المحاسن' | 'المساوئ'; items: string[]; setItems: (newItems: string[]) => void; }
const itemVariants = { hidden: { opacity: 0, x: 20 }, visible: { opacity: 1, x: 0 }, exit: { opacity: 0, x: -20, transition: { duration: 0.2 } }, };
const RemoveIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

export function ProsConsInput({ label, items, setItems }: ProsConsInputProps) {
    const handleAddItem = () => { setItems([...items, '']); };
    const handleRemoveItem = (index: number) => { setItems(items.filter((_, i) => i !== index)); };
    const handleItemChange = (index: number, value: string) => { const newItems = [...items]; newItems[index] = value; setItems(newItems); };

    const buttonText = label === 'المحاسن' ? '+ إضافة حَسَنة' : '+ إضافة سيئة';
    const ariaLabel = label === 'المحاسن' ? 'إزالة المحسن' : 'إزالة المأخذ';

    return (
        <div className={styles.sidebarSection}>
            <label className={styles.sidebarLabel}>{label}</label>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                <AnimatePresence>
                    {items.map((item, index) => (
                        <motion.div key={index} layout variants={itemVariants} initial="hidden" animate="visible" exit="exit" transition={{ type: 'spring' as const, stiffness: 400, damping: 25 }} className={metadataStyles.inputWrapper}>
                            <ActionButton type="button" onClick={() => handleRemoveItem(index)} aria-label={ariaLabel}>
                                <RemoveIcon />
                            </ActionButton>
                            <input type="text" value={item} onChange={(e) => handleItemChange(index, e.target.value)} className={styles.sidebarInput} />
                        </motion.div>
                    ))}
                </AnimatePresence>
            </div>
            <button type="button" onClick={handleAddItem} className="outline-button" style={{ width: '100%', marginTop: '1rem' }}>
                {buttonText}
            </button>
        </div>
    );
}







--- END OF FILE app/studio/[contentType]/[id]/metadata/ProsConsInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/PublisherInput.tsx ---

// app/studio/[contentType]/[id]/metadata/PublisherInput.tsx
'use client';

import { useState, useEffect, useRef, useMemo, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createPublisherAction, deleteMetadataAction } from '../../../actions';
import { AddPublisherModal } from './AddPublisherModal';
import ActionButton from '@/components/ActionButton';
import { useToast } from '@/lib/toastStore';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Publisher = { _id: string; title: string };
interface PublisherInputProps { 
    allPublishers: Publisher[]; 
    selectedPublisher: Publisher | null; 
    onPublisherSelect: (pub: Publisher | null) => void; 
}

const popoverVariants = { hidden: { opacity: 0, y: -10 }, visible: { opacity: 1, y: 0 }, exit: { opacity: 0, y: -10 }, };
const TrashIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

export function PublisherInput({ allPublishers, selectedPublisher, onPublisherSelect }: PublisherInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddModalOpen, setIsAddModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [isDeleting, startDeleteTransition] = useTransition();
    const toast = useToast();
    
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const filteredPubs = useMemo(() => {
        if (!searchTerm) return allPublishers;
        const lowerSearch = searchTerm.toLowerCase();
        return allPublishers.filter(p => p.title.toLowerCase().includes(lowerSearch));
    }, [allPublishers, searchTerm]);

    useEffect(() => { 
        if (isPopoverOpen) { 
            setTimeout(() => inputRef.current?.focus(), 100); 
        } else {
            setSearchTerm('');
        }
    }, [isPopoverOpen]);
    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);

    const handleSelect = (pub: Publisher) => { 
        onPublisherSelect(pub); 
        setIsPopoverOpen(false); 
    };
    
    const handleDelete = async (e: React.MouseEvent, pub: Publisher) => {
        e.stopPropagation();
        e.preventDefault();
        
        if (window.confirm(`هل أنت متأكد من حذف الناشر "${pub.title}"؟`)) {
            startDeleteTransition(async () => {
                const result = await deleteMetadataAction(pub._id);
                if (result.success) {
                    toast.success('تم حذف الناشر.');
                    if (selectedPublisher?._id === pub._id) {
                        onPublisherSelect(null);
                    }
                } else {
                    toast.error(result.message || 'فشل الحذف.');
                }
            });
        }
    };

    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddModalOpen(true); };
    const handleCreate = async (title: string) => { const newPub = await createPublisherAction(title); if (newPub) { onPublisherSelect(newPub); } setIsAddModalOpen(false); setSearchTerm(''); };
    
    return (
        <>
            <AddPublisherModal isOpen={isAddModalOpen} onClose={() => setIsAddModalOpen(false)} onSubmit={handleCreate} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>الناشر (Publisher)</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', justifyContent: 'space-between', 
                            cursor: selectedPublisher ? 'default' : 'text',
                            paddingRight: '0.5rem',
                        }} 
                        onClick={() => {if (!selectedPublisher) setIsPopoverOpen(true)}}
                    >
                        <span>{selectedPublisher ? selectedPublisher.title : 'ابحث عن ناشر...'}</span>
                    </div>
                    
                    {selectedPublisher ? (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); onPublisherSelect(null); }} aria-label="Remove selected publisher">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </ActionButton>
                    ) : (
                        <ActionButton type="button" onClick={(e) => { e.preventDefault(); handleOpenModal(); }} aria-label="إضافة ناشر جديد">
                             <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                        </ActionButton>
                    )}
                    
                    <AnimatePresence>
                        {isPopoverOpen && !selectedPublisher && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()}
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, right: 0,
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 100, marginTop: '0.5rem',
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.2)'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder="ابحث..." className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredPubs.length > 0 ? filteredPubs.map(pub => (
                                        <div key={pub._id} style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                                            <button 
                                                type="button" 
                                                onMouseDown={(e) => { 
                                                    e.preventDefault(); 
                                                    e.stopPropagation();
                                                    handleSelect(pub); 
                                                }}
                                                style={{ flexGrow: 1, textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)' }} 
                                                className={styles.popoverItemButton}
                                            >
                                                {pub.title}
                                            </button>
                                            <button
                                                type="button"
                                                onMouseDown={(e) => handleDelete(e, pub)}
                                                disabled={isDeleting}
                                                style={{ padding: '0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: '#DC2626', opacity: 0.6 }}
                                                title="حذف الناشر"
                                                className={styles.popoverItemButton}
                                            >
                                                <TrashIcon />
                                            </button>
                                        </div>
                                    ))
                                     : searchTerm.length > 1 && <p style={{padding:'0.5rem', color:'var(--text-secondary)'}}>لا نتائج.</p>
                                    }
                                    
                                    {searchTerm.length > 1 && (
                                        <button 
                                            type="button" 
                                            onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); handleOpenModal(); }}
                                            style={{ display: 'block', width: '100%', textAlign: 'left', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic', borderTop: '1px solid var(--border-color)' }}
                                        >
                                            + إنشاء جديد: "{searchTerm.trim()}"
                                        </button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/PublisherInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/SlugInput.tsx ---

// app/studio/[contentType]/[id]/metadata/SlugInput.tsx
'use client';

import { useState, useEffect, useTransition, useCallback } from 'react';
import { useDebounce } from '@/hooks/useDebounce';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../Editor.module.css';

// THE DEFINITIVE FIX: Added `overflow: 'visible'` to the SVG style.
const AnimatedLockIcon = ({ isLocked }: { isLocked: boolean }) => (
    <svg 
        width="18" 
        height="18" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="2.5" 
        strokeLinecap="round" 
        strokeLinejoin="round" 
        style={{ overflow: 'visible' }}
    >
        {/* Lock Body - Static */}
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
        {/* Shackle - Animated */}
        <motion.path
            d="M7 11V7a5 5 0 0 1 10 0v4"
            initial={false}
            animate={{
                rotate: isLocked ? 0 : -25,
                y: isLocked ? 0 : -2,
            }}
            style={{ transformOrigin: '7px 11px' }} // Pivot around the left base of the shackle
            transition={{ type: 'spring', stiffness: 400, damping: 18 }}
        />
    </svg>
);

const AlertIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#DC2626" strokeWidth="2.5"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
const CheckIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#16A34A" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ClockIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="var(--text-secondary)" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>;

interface SlugInputProps {
    slug: string;
    title: string;
    docId: string;
    isSlugManual: boolean;
    slugValidationStatus: 'pending' | 'valid' | 'invalid';
    slugValidationMessage: string;
    dispatch: (action: { type: string; payload: any }) => void;
}

export function SlugInput({
    slug, title, docId, isSlugManual,
    slugValidationStatus, slugValidationMessage, dispatch
}: SlugInputProps) {
    const [isTranslating, startTranslation] = useTransition();
    const debouncedTitle = useDebounce(title, 800);

    const translateAndSetSlug = useCallback(async (currentTitle: string) => {
        if (!currentTitle.trim()) return;
        startTranslation(async () => {
            try {
                const response = await fetch('/api/translate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: currentTitle }),
                });
                if (!response.ok) throw new Error('Translation failed');
                const data = await response.json();
                dispatch({ type: 'UPDATE_SLUG', payload: { slug: data.slug, isManual: false } });
            } catch (error) {
                console.error("Translation error:", error);
            }
        });
    }, [dispatch]);

    useEffect(() => {
        if (!isSlugManual && debouncedTitle) {
            translateAndSetSlug(debouncedTitle);
        }
    }, [debouncedTitle, isSlugManual, translateAndSetSlug]);

    const handleLockToggle = () => {
        const currentlyManual = !isSlugManual;
        dispatch({ type: 'UPDATE_FIELD', payload: { field: 'isSlugManual', value: currentlyManual } });
        // If we are locking it back, re-translate immediately
        if (!currentlyManual) {
            translateAndSetSlug(title);
        }
    };

    const isSlugValid = slugValidationStatus === 'valid';
    const isSlugPending = slugValidationStatus === 'pending';

    const getSlugIcon = () => {
        if (isTranslating || isSlugPending) return <ClockIcon />;
        if (isSlugValid) return <CheckIcon />;
        return <AlertIcon />;
    };

    return (
        <motion.div className={styles.sidebarSection} layout>
            <label className={styles.sidebarLabel}>
                المُعرِّف (Slug)
            </label>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                <motion.button
                    type="button"
                    onClick={handleLockToggle}
                    className={styles.iconButton}
                    style={{ flexShrink: 0, width: '42px', height: '42px' }}
                    aria-label={isSlugManual ? "Lock to auto-translate" : "Unlock to enable manual editing"}
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.9 }}
                >
                    <AnimatedLockIcon isLocked={!isSlugManual} />
                </motion.button>
                <input
                    type="text"
                    value={slug}
                    onChange={(e) => dispatch({ type: 'UPDATE_SLUG', payload: { slug: e.target.value, isManual: true } })}
                    className={styles.sidebarInput}
                    style={{
                        flexGrow: 1,
                        borderColor: isSlugValid && !isSlugPending ? '#16A34A' : isSlugPending ? 'var(--border-color)' : '#DC2626',
                        direction: 'ltr',
                        textAlign: 'left',
                        backgroundColor: isSlugManual ? 'var(--bg-primary)' : 'var(--bg-secondary)'
                    }}
                    readOnly={!isSlugManual}
                />
            </div>
            <AnimatePresence>
                {(slugValidationMessage && (slugValidationStatus !== 'valid' || isTranslating)) && (
                    <motion.p
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        style={{
                            display: 'flex', alignItems: 'center', gap: '0.5rem',
                            color: isTranslating || isSlugPending ? 'var(--text-secondary)' : '#DC2626',
                            fontSize: '1.2rem', marginTop: '0.5rem', textAlign: 'right'
                        }}
                    >
                        {getSlugIcon()}
                        <span>{isTranslating ? 'جارٍ الترجمة...' : slugValidationMessage}</span>
                    </motion.p>
                )}
            </AnimatePresence>
        </motion.div>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/SlugInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

// app/studio/[contentType]/[id]/metadata/TagInput.tsx
'use client';

import { useState, useEffect, useRef, useMemo, useTransition } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { createTagAction, deleteMetadataAction } from '../../../actions';
import { AddTagModal } from './AddTagModal';
import ActionButton from '@/components/ActionButton';
import { translateTag } from '@/lib/translations';
import { useToast } from '@/lib/toastStore';
import styles from '../Editor.module.css';
import metadataStyles from './Metadata.module.css';

type Tag = { _id: string; title: string, category?: string };
interface TagInputProps { 
    label: string; 
    allTags: Tag[]; 
    selectedTags: Tag[]; 
    onTagsChange: (tags: any) => void;
    placeholder?: string;
    singleSelection?: boolean;
    categoryForCreation: 'Game' | 'Article' | 'News';
}

const popoverVariants = { 
    hidden: { opacity: 0, y: -10, scale: 0.95 }, 
    visible: { opacity: 1, y: 0, scale: 1 }, 
    exit: { opacity: 0, y: -10, scale: 0.95, transition: { duration: 0.1 } }, 
};
const TrashIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;

const AnimatedTag = ({ tag, onRemove }: { tag: Tag, onRemove: (tagId: string) => void }) => {
    if (!tag || typeof tag.title !== 'string') return null;
    return (
        <motion.div 
            layout 
            initial={{ opacity: 0, scale: 0.5 }} 
            animate={{ opacity: 1, scale: 1 }} 
            exit={{ opacity: 0, scale: 0.6 }} 
            // FIX: Use onMouseDown for chip removal
            onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); onRemove(tag._id); }} 
            style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--bg-primary)', padding: '0.25rem 0.75rem', borderRadius: '4px', zIndex: 1, cursor: 'pointer' }} 
            title={`Click to remove "${translateTag(tag.title)}"`} 
            whileHover={{ backgroundColor: 'color-mix(in srgb, #DC2626 15%, transparent)' }}
        >
            <span>{translateTag(tag.title)}</span>
            <svg width="12" height="12" viewBox="0 0 24" style={{ flexShrink: 0 }}><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </motion.div>
    );
};

export function TagInput({ label, allTags, selectedTags = [], onTagsChange, placeholder = "ابحث...", singleSelection = false, categoryForCreation }: TagInputProps) {
    const [isPopoverOpen, setIsPopoverOpen] = useState(false);
    const [isAddTagModalOpen, setIsAddTagModalOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [isDeleting, startDeleteTransition] = useTransition();
    const toast = useToast();
    
    const wrapperRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const safeSelectedTags = (selectedTags || []).filter(Boolean);

    const filteredTags = useMemo(() => {
        let available = allTags.filter(t => {
            const cleanId = t._id.replace('drafts.', '');
            return !safeSelectedTags.some(st => st._id.replace('drafts.', '') === cleanId);
        });
        
        if (categoryForCreation) {
            available = available.filter(t => t.category === categoryForCreation);
        }

        if (searchTerm) {
            const lowerSearch = searchTerm.toLowerCase();
            available = available.filter(t => 
                t.title.toLowerCase().includes(lowerSearch) || 
                translateTag(t.title).toLowerCase().includes(lowerSearch)
            );
        }

        const seenNames = new Set<string>();
        const uniqueTags: Tag[] = [];

        for (const tag of available) {
            const displayName = translateTag(tag.title);
            if (!seenNames.has(displayName)) {
                seenNames.add(displayName);
                uniqueTags.push(tag);
            }
        }

        return uniqueTags;
    }, [allTags, safeSelectedTags, searchTerm, categoryForCreation]);

    
    useEffect(() => { 
        const handleClickOutside = (event: MouseEvent) => { 
            if (wrapperRef.current && !wrapperRef.current.contains(event.target as Node)) { setIsPopoverOpen(false); } 
        }; 
        document.addEventListener('mousedown', handleClickOutside); 
        return () => document.removeEventListener('mousedown', handleClickOutside); 
    }, []);
    
    useEffect(() => { 
        if (isPopoverOpen) { setTimeout(() => inputRef.current?.focus(), 100); } 
        else { setSearchTerm(''); } 
    }, [isPopoverOpen]);

    const handleSelectTag = (tag: Tag) => {
        if (singleSelection) {
            onTagsChange([tag]);
            setIsPopoverOpen(false);
        } else {
            if (!safeSelectedTags.some(t => t._id === tag._id)) {
                onTagsChange([...safeSelectedTags, tag]);
            }
        }
        setSearchTerm('');
        if (inputRef.current) inputRef.current.focus();
    };
    
    const handleRemoveTag = (tagIdToRemove: string) => {
        if (singleSelection) { onTagsChange([]); } 
        else { onTagsChange(safeSelectedTags.filter(tag => tag._id !== tagIdToRemove)); }
    };
    
    const handleDeleteTag = async (e: React.MouseEvent, tag: Tag) => {
        e.stopPropagation();
        e.preventDefault();
        
        if (window.confirm(`هل أنت متأكد من حذف الوسم "${translateTag(tag.title)}"?`)) {
            startDeleteTransition(async () => {
                const result = await deleteMetadataAction(tag._id);
                if (result.success) {
                    toast.success('تم حذف الوسم.');
                    // If deleted tag was selected, remove it
                    if (safeSelectedTags.some(t => t._id === tag._id)) {
                        onTagsChange(safeSelectedTags.filter(t => t._id !== tag._id));
                    }
                } else {
                    toast.error(result.message || 'فشل الحذف.');
                }
            });
        }
    };
    
    const handleOpenModal = () => { setIsPopoverOpen(false); setIsAddTagModalOpen(true); };
    const handleCreateTag = async (title: string) => { 
        const newTag = await createTagAction(title, categoryForCreation); 
        if (newTag) { handleSelectTag(newTag); } 
        setIsAddTagModalOpen(false); 
        setSearchTerm(''); 
    };
    
    const hasSelection = safeSelectedTags.length > 0;

    return (
        <>
            <AddTagModal isOpen={isAddTagModalOpen} onClose={() => setIsAddTagModalOpen(false)} onSubmit={handleCreateTag} initialValue={searchTerm} />
            <div className={styles.sidebarSection} ref={wrapperRef}>
                <label className={styles.sidebarLabel}>{label}</label>
                <div className={metadataStyles.inputWrapper} style={{ position: 'relative' }}>
                    <div 
                        className={styles.sidebarInput} 
                        style={{ 
                            display: 'flex', alignItems: 'center', flexWrap: 'wrap', gap: '0.5rem', 
                            minHeight: '42px', height: 'auto', padding: '0.5rem', cursor: 'text',
                        }} 
                        onClick={() => setIsPopoverOpen(true)}
                    >
                        <AnimatePresence>
                            {safeSelectedTags.map(tag => (
                                tag && tag._id ? <AnimatedTag key={tag._id} tag={tag} onRemove={handleRemoveTag} /> : null
                            ))}
                        </AnimatePresence>
                        {!hasSelection && !isPopoverOpen && (
                            <span style={{ color: 'var(--text-secondary)', position: 'absolute', right: '1rem', left: 'auto', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none' }}>{placeholder}</span>
                        )}
                    </div>
                     <ActionButton type="button" onMouseDown={(e) => { e.preventDefault(); handleOpenModal(); }} aria-label="Add new tag or category">
                        <svg width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                    </ActionButton>
                    
                    <AnimatePresence>
                        {isPopoverOpen && (
                            <motion.div 
                                onClick={(e) => e.stopPropagation()}
                                variants={popoverVariants} initial="hidden" animate="visible" exit="exit" 
                                style={{ 
                                    position: 'absolute', top: '100%', left: 0, 
                                    width: '100%',
                                    background: 'var(--bg-secondary)', border: '1px solid var(--border-color)',
                                    borderRadius: '6px', zIndex: 100, 
                                    padding: '0.5rem', boxShadow: '0 5px 15px rgba(0,0,0,0.2)', marginTop: '0.5rem'
                                }}
                            >
                                <input ref={inputRef} type="text" value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} placeholder={placeholder} className={styles.sidebarInput} style={{ marginBottom: '0.5rem' }} />
                                <div style={{ maxHeight: '180px', overflowY: 'auto' }}>
                                    {filteredTags.length > 0 ? filteredTags.map(tag => ( 
                                        <div key={tag._id} style={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                                            <button 
                                                type="button" 
                                                // FIX: Use onMouseDown for reliable selection
                                                onMouseDown={(e) => { 
                                                    e.preventDefault(); 
                                                    e.stopPropagation();
                                                    handleSelectTag(tag); 
                                                }}
                                                style={{ flexGrow: 1, textAlign: 'right', padding: '0.6rem 0.8rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', borderRadius: '4px' }} 
                                                className={styles.popoverItemButton}
                                            > 
                                                {translateTag(tag.title)} 
                                            </button> 
                                            <button
                                                type="button"
                                                onMouseDown={(e) => handleDeleteTag(e, tag)}
                                                disabled={isDeleting}
                                                style={{ padding: '0.6rem', background: 'none', border: 'none', cursor: 'pointer', color: '#DC2626', opacity: 0.6 }}
                                                title="حذف الوسم"
                                                className={styles.popoverItemButton}
                                            >
                                                <TrashIcon />
                                            </button>
                                        </div>
                                    ))
                                     : <div style={{padding:'0.5rem'}}>لا نتائج.</div>
                                    }
                                    
                                    {searchTerm.length > 1 && (
                                        <button 
                                            type="button" 
                                            onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); handleOpenModal(); }}
                                            style={{ display: 'block', width: '100%', textAlign: 'right', padding: '0.8rem 1rem', background: 'none', border: 'none', cursor: 'pointer', color: 'var(--text-primary)', fontStyle: 'italic', borderTop: '1px solid var(--border-color)' }} 
                                            className={styles.popoverItemButton}
                                        >
                                            + إنشاء جديد: "{searchTerm.trim()}"
                                        </button>
                                    )}
                                </div>
                            </motion.div>
                        )}
                    </AnimatePresence>
                </div>
            </div>
        </>
    );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/TagInput.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/VerticalImageEditor.module.css ---

/* app/studio/[contentType]/[id]/metadata/VerticalImageEditor.module.css */

.container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 100%;
}

.editorFrame {
    position: relative;
    width: 100%;
    /* Aspect Ratio 4:5 (Matches Vanguard Center Card 800x1000) */
    aspect-ratio: 4 / 5;
    background-color: var(--bg-primary);
    border: 2px dashed var(--border-color);
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    transition: all 0.2s ease;
    /* Ensure the frame establishes a positioning context */
    z-index: 1;
}

.editorFrame.dragOver {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 15%, transparent);
}

.editorFrame.active {
    border-style: solid;
    border-color: var(--accent);
    /* Remove generic pointer cursor when active to allow specific tool cursors */
    cursor: default;
}

/* This overlay handles drag/drop events when not editing */
.dropOverlay {
    position: absolute;
    inset: 0;
    z-index: 10;
    cursor: pointer;
}

/* Specific interaction area for image manipulation */
.manipulationLayer {
    position: absolute;
    inset: 0;
    z-index: 5;
    cursor: grab;
    touch-action: none; /* Prevent browser scrolling while manipulating */
}

.manipulationLayer:active {
    cursor: grabbing;
}

.placeholder {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--text-secondary);
    gap: 1rem;
    pointer-events: none; /* Let clicks pass through to dropOverlay */
    z-index: 2;
}

.previewImage {
    position: absolute;
    /* Centering is handled by JS transform to allow unbound movement */
    top: 50%;
    left: 50%;
    will-change: transform;
    user-select: none;
    pointer-events: none; /* Visual only */
    max-width: none; /* Allow image to exceed container for zooming */
    max-height: none;
}

.overlayControls {
    position: absolute;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 1rem;
    z-index: 20;
    background-color: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    padding: 0.5rem;
    border-radius: 99px;
    border: 1px solid rgba(255,255,255,0.1);
    pointer-events: auto;
}

.controlButton {
    background: none;
    border: none;
    color: white;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: background-color 0.2s;
}

.controlButton:hover {
    background-color: var(--accent);
    color: black;
}

.controlButton.save {
    background-color: var(--accent);
    color: black;
    width: auto;
    padding: 0 1.2rem;
    font-weight: 700;
    font-family: var(--font-main);
    font-size: 1.4rem;
}

.controlButton.save:hover {
    background-color: white;
}

.zoomBadge {
    position: absolute;
    top: 1rem;
    left: 1rem;
    background-color: rgba(0,0,0,0.6);
    color: white;
    padding: 0.2rem 0.6rem;
    border-radius: 4px;
    font-family: monospace;
    font-size: 1.2rem;
    pointer-events: none;
    z-index: 20;
}

.loadingOverlay {
    position: absolute;
    inset: 0;
    background-color: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
    backdrop-filter: blur(4px);
    color: white;
    font-weight: 600;
}

.changeImageBtn {
    width: 100%;
    font-size: 1.2rem;
    margin-top: 0.5rem;
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/VerticalImageEditor.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/VerticalImageEditor.tsx ---

// app/studio/[contentType]/[id]/metadata/VerticalImageEditor.tsx
'use client';

import React, { useState, useRef, useEffect, useTransition, useLayoutEffect } from 'react';
import { useToast } from '@/lib/toastStore';
import { uploadSanityAssetAction } from '../../../actions';
import { optimizeImageForUpload, UploadQuality } from '@/lib/image-optimizer';
import styles from './VerticalImageEditor.module.css';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader';

const UploadIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>;
const CheckIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ResetIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>;
const CloseIcon = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

interface VerticalImageEditorProps {
    currentImageUrl: string | null;
    onImageChange: (assetId: string | null, url: string | null) => void;
    uploadQuality: UploadQuality;
}

export default function VerticalImageEditor({ currentImageUrl, onImageChange, uploadQuality }: VerticalImageEditorProps) {
    // Local state for the editing session
    const [localImageSrc, setLocalImageSrc] = useState<string | null>(null);
    const [isEditing, setIsEditing] = useState(false);
    
    // Transform State (Virtual 800x1000 Space)
    const [transform, setTransform] = useState({ x: 0, y: 0, scale: 1 });
    const [baseScale, setBaseScale] = useState(1);
    const [imgDims, setImgDims] = useState({ width: 0, height: 0 });
    
    // Responsive Scaling State
    const [containerWidth, setContainerWidth] = useState(1);
    
    const [isUploading, startUpload] = useTransition();
    
    const containerRef = useRef<HTMLDivElement>(null);
    const fileInputRef = useRef<HTMLInputElement>(null);
    
    // Drag Logic refs
    const dragStart = useRef({ x: 0, y: 0 });
    const initialPos = useRef({ x: 0, y: 0 });
    const [isDragging, setIsDragging] = useState(false);
    
    // Visual Drag Drop State
    const [isDragOver, setIsDragOver] = useState(false);
    
    const toast = useToast();

    // Measure container for responsive scaling
    useLayoutEffect(() => {
        const updateWidth = () => {
            if (containerRef.current) {
                setContainerWidth(containerRef.current.offsetWidth);
            }
        };
        updateWidth();
        window.addEventListener('resize', updateWidth);
        return () => window.removeEventListener('resize', updateWidth);
    }, []);

    // Initialize with current image if available
    useEffect(() => {
        if (currentImageUrl && !localImageSrc) {
            // Viewing existing saved image
        }
    }, [currentImageUrl, localImageSrc]);

    const loadImage = (src: string) => {
        const img = new window.Image();
        
        // --- FIX: ALLOW CROSS-ORIGIN CANVAS ACCESS ---
        img.crossOrigin = "anonymous";
        
        img.src = src;
        img.onload = () => {
            const w = img.naturalWidth;
            const h = img.naturalHeight;
            setImgDims({ width: w, height: h });
            
            // Calculate base scale to cover 800x1000 virtual space
            const targetW = 800;
            const targetH = 1000;
            
            const scaleW = targetW / w;
            const scaleH = targetH / h;
            
            // "Cover" fit
            const newBaseScale = Math.max(scaleW, scaleH);
            
            setBaseScale(newBaseScale);
            setTransform({ x: 0, y: 0, scale: 1 });
            setLocalImageSrc(src);
            setIsEditing(true);
        };
        
        img.onerror = () => {
            toast.error("تعذر تحميل الصورة. قد تكون هناك مشكلة في المصدر.");
        };
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if (ev.target?.result) {
                    loadImage(ev.target.result as string);
                }
            };
            reader.readAsDataURL(file);
            e.target.value = ''; // Reset
        }
    };

    // --- Drag & Drop for File Upload ---
    const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        setIsDragOver(true);
    };
    const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        setIsDragOver(false);
    };
    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        setIsDragOver(true);
    };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        setIsDragOver(false);

        const file = e.dataTransfer.files?.[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if (ev.target?.result) {
                    loadImage(ev.target.result as string);
                }
            };
            reader.readAsDataURL(file);
        } else {
            toast.error('يرجى إفلات ملف صورة صالح.');
        }
    };

    // --- Interaction Handlers (Pan & Zoom) ---
    const handleMouseDown = (e: React.MouseEvent) => {
        if (!isEditing) return;
        e.preventDefault(); e.stopPropagation();
        setIsDragging(true);
        dragStart.current = { x: e.clientX, y: e.clientY };
        initialPos.current = { x: transform.x, y: transform.y };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging || !isEditing) return;
        e.preventDefault();
        
        // Map visual drag to virtual 800px space
        // If container is 400px, 1px mouse = 2px virtual
        const visualRatio = 800 / containerWidth; 
        
        const dx = (e.clientX - dragStart.current.x) * visualRatio;
        const dy = (e.clientY - dragStart.current.y) * visualRatio;
        
        setTransform(prev => ({ ...prev, x: initialPos.current.x + dx, y: initialPos.current.y + dy }));
    };

    const handleMouseUp = () => setIsDragging(false);
    const handleMouseLeave = () => {
        setIsDragging(false);
        setIsDragOver(false);
    };

    const handleWheel = (e: React.WheelEvent) => {
        if (!isEditing) return;
        e.stopPropagation();
        e.preventDefault();
        setTransform(prev => {
            const newScale = Math.max(0.1, Math.min(5, prev.scale - e.deltaY * 0.001));
            return { ...prev, scale: newScale };
        });
    };

    // --- Save & Process ---
    const handleSave = async () => {
        if (!localImageSrc) return;
        
        startUpload(async () => {
            try {
                const canvas = document.createElement('canvas');
                // Output Resolution: 1600x2000 (Vanguard High Quality - 2x Virtual)
                const targetW = 1600; 
                const targetH = 2000;
                
                canvas.width = targetW;
                canvas.height = targetH;
                const ctx = canvas.getContext('2d');
                if (!ctx) throw new Error("Canvas context failed");

                const img = new window.Image();
                // --- FIX: CORS ---
                img.crossOrigin = "anonymous";
                img.src = localImageSrc;
                
                await new Promise((resolve, reject) => { 
                    img.onload = resolve;
                    img.onerror = reject;
                });

                // Fill background
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, targetW, targetH);

                // Mapping from Virtual (800x1000) to Target (1600x2000)
                const renderRatio = targetW / 800; // = 2
                
                const effectiveScale = baseScale * transform.scale * renderRatio;
                
                // 1. Center of Canvas
                const centerX = targetW / 2;
                const centerY = targetH / 2;
                
                // 2. Translate to center + user offset (scaled)
                ctx.translate(centerX + (transform.x * renderRatio), centerY + (transform.y * renderRatio));
                
                // 3. Scale
                ctx.scale(effectiveScale, effectiveScale);

                // 4. Draw Image centered on origin
                ctx.drawImage(img, -imgDims.width / 2, -imgDims.height / 2);
                
                // Convert to Blob
                const blob = await new Promise<Blob | null>(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                if (!blob) throw new Error("Blob creation failed");

                const rawFile = new File([blob], "vertical-vanguard-crop.jpg", { type: "image/jpeg" });
                
                // Use built-in optimizer for safety
                const { file: optimizedFile } = await optimizeImageForUpload(rawFile, uploadQuality);
                
                const formData = new FormData();
                formData.append('file', optimizedFile);
                
                const result = await uploadSanityAssetAction(formData);
                
                if (result.success && result.asset) {
                    onImageChange(result.asset._id, result.asset.url);
                    setIsEditing(false);
                    setLocalImageSrc(null); 
                    toast.success("تم حفظ الصورة العمودية");
                } else {
                    throw new Error(result.error);
                }

            } catch (error) {
                console.error(error);
                toast.error("فشل حفظ الصورة - تحقق من الصلاحيات.");
            }
        });
    };

    const handleCancel = () => {
        setIsEditing(false);
        setLocalImageSrc(null);
        setTransform({ x: 0, y: 0, scale: 1 });
    };

    const displayImageSrc = isEditing ? localImageSrc : currentImageUrl;
    
    const responsiveScale = containerWidth / 800;
    
    const previewTransform = isEditing 
        ? `translate(-50%, -50%) translate(${transform.x * responsiveScale}px, ${transform.y * responsiveScale}px) scale(${baseScale * transform.scale * responsiveScale})`
        : `translate(-50%, -50%) scale(1)`; 

    return (
        <div className={styles.container}>
            <input 
                type="file" 
                ref={fileInputRef} 
                onChange={handleFileChange} 
                accept="image/*" 
                style={{ display: 'none' }} 
            />

            <div 
                ref={containerRef}
                className={`${styles.editorFrame} ${isEditing ? styles.active : ''} ${isDragOver ? styles.dragOver : ''} ${isDragging ? styles.editing : ''}`}
                // Drag & Drop Handlers on Container
                onDragEnter={handleDragEnter}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
            >
                {displayImageSrc ? (
                    <>
                        {/* 
                           INTERACTIVE LAYER
                           This layer captures mouse events for panning ONLY when editing.
                           It sits on top of the image visually but is transparent.
                        */}
                        {isEditing && (
                            <div 
                                className={styles.manipulationLayer}
                                onMouseDown={handleMouseDown}
                                onMouseMove={handleMouseMove}
                                onMouseUp={handleMouseUp}
                                onMouseLeave={handleMouseLeave}
                                onWheel={handleWheel}
                            />
                        )}

                        <div style={{ width: '100%', height: '100%', position: 'relative', overflow: 'hidden', backgroundColor: '#000', pointerEvents: 'none' }}>
                            <img 
                                src={displayImageSrc} 
                                alt="Vertical Preview" 
                                className={styles.previewImage}
                                draggable={false}
                                style={{
                                    transform: previewTransform,
                                    left: '50%',
                                    top: '50%',
                                    objectFit: isEditing ? undefined : 'cover',
                                    width: isEditing ? imgDims.width : '100%',
                                    height: isEditing ? imgDims.height : '100%',
                                }}
                            />
                            
                            {isEditing && (
                                <div className={styles.overlayControls}>
                                    <button className={styles.controlButton} onClick={() => setTransform({x:0, y:0, scale: 1})} title="إعادة تعيين">
                                        <ResetIcon />
                                    </button>
                                    <button className={`${styles.controlButton} ${styles.save}`} onClick={handleSave} title="حفظ وقص">
                                        <CheckIcon />
                                        <span>حفظ</span>
                                    </button>
                                    <button className={styles.controlButton} onClick={handleCancel} title="إلغاء">
                                        <CloseIcon />
                                    </button>
                                </div>
                            )}
                            
                            {isEditing && (
                                <div className={styles.zoomBadge}>
                                    {(transform.scale * 100).toFixed(0)}%
                                </div>
                            )}
                        </div>
                    </>
                ) : (
                    /* Drop Overlay for Initial Upload */
                    <div 
                        className={styles.dropOverlay} 
                        onClick={() => fileInputRef.current?.click()}
                    >
                         <div className={styles.placeholder}>
                            <UploadIcon />
                            <span>اضغط أو أفلت لرفع صورة عمودية</span>
                            <span style={{fontSize: '0.8rem', opacity: 0.7}}>4:5 Aspect Ratio</span>
                        </div>
                    </div>
                )}

                {isUploading && (
                    <div className={styles.loadingOverlay}>
                        <div className="spinner" />
                        <span style={{marginTop: '1rem'}}>جاري المعالجة والرفع...</span>
                    </div>
                )}
            </div>

            {/* Helper button to change image when not in edit mode */}
            {!isEditing && displayImageSrc && (
                <button 
                    className={`outline-button ${styles.changeImageBtn}`}
                    onClick={() => fileInputRef.current?.click()}
                >
                    تغيير الصورة
                </button>
            )}
        </div>
    );
}

--- END OF FILE app/studio/[contentType]/[id]/metadata/VerticalImageEditor.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css ---

/* app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css */
.managerContainer {
  border-top: 1px solid var(--border-color);
}

.toggleHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 1.5rem;
  background: none;
  border: none;
  cursor: pointer;
  text-align: right;
  color: var(--text-primary);
}

.headerTitle {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  font-weight: 600;
}

.collapsibleContent {
  overflow: visible; /* THE DEFINITIVE FIX: Allow popover to display outside bounds */
}

.addForm {
  display: grid;
  grid-template-columns: auto auto 1fr; /* MODIFIED GRID LAYOUT */
  gap: 1rem;
  padding: 0 1.5rem 1.5rem 1.5rem;
  border-bottom: 1px solid var(--border-color);
}

.addForm .primary-button {
  padding: 0 1.5rem;
}

.colorPickerTriggerContainer { /* ADDED */
  position: relative;
}

.colorInputWrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 90px;
  height: 42px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  overflow: hidden;
  cursor: pointer; /* ADDED */
  transition: border-color 0.2s ease; /* ADDED */
}
@media (hover: hover) {@media (hover: hover) {
  
  .colorInputWrapper:hover  { /* ADDED */
  border-color: var(--accent);
}
}

  .colorInputWrapper:active  { /* ADDED */
  border-color: var(--accent);
}
}
.colorInputWrapper:active { /* ADDED */
  border-color: var(--accent);
}



.colorInput {
  position: absolute;
  inset: -5px; /* Make it larger to hide borders */
  width: 150%;
  height: 150%;
  cursor: pointer;
  border: none;
  background: none;
  padding: 0;
}

.colorInputText {
  font-family: monospace;
  font-size: 1.3rem;
  color: var(--text-secondary);
  pointer-events: none;
  mix-blend-mode: difference;
  filter: invert(1) grayscale(1);
}

.mappingsList {
  max-height: 250px;
  overflow-y: auto;
  padding: 1rem 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.mappingItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--bg-primary);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
}

.itemInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-weight: 500;
}

.itemColorPreview {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid var(--border-color);
}

.removeButton {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s, background-color 0.2s;
}
@media (hover: hover) {@media (hover: hover) {
  
  .removeButton:hover  {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}
}

  .removeButton:active  {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}
}
.removeButton:active {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}





--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx ---

// app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx
'use client'

import React, { useState } from 'react';
import { ColorWheelIcon } from '@sanity/icons';
import ColorDictionaryModal from './ColorDictionaryModal'; // Import the new modal
import styles from './ColorDictionaryManager.module.css';

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
};

interface ColorDictionaryManagerProps {
  initialMappings: ColorMapping[];
}

export default function ColorDictionaryManager({ initialMappings }: ColorDictionaryManagerProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [mappings, setMappings] = useState<ColorMapping[]>(initialMappings);

  const handleUpdateMappings = (newMappings: ColorMapping[]) => {
    setMappings(newMappings);
    // Here you could also trigger a re-render of the Tiptap editor if needed,
    // for example by updating its extensions config, though it's complex.
    // For now, updating the local state is sufficient.
  };

  return (
    <>
      <div className={styles.managerContainer}>
        <button className={styles.toggleHeader} onClick={() => setIsModalOpen(true)}>
          <div className={styles.headerTitle}>
            <ColorWheelIcon />
            <span>ألوان الكلمات التلقائية</span>
          </div>
          <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <span style={{ fontSize: '1.4rem', color: 'var(--text-secondary)' }}>{mappings.length} words</span>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </div>
        </button>
      </div>

      <ColorDictionaryModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        initialMappings={mappings}
        onUpdate={handleUpdateMappings}
      />
    </>
  );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryManager.tsx ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css ---

/* app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css */
.addForm {
  display: grid;
  grid-template-columns: auto auto 1fr;
  gap: 1rem;
  padding-bottom: 2rem;
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--border-color);
}

.addForm .primary-button {
  padding: 0 1.5rem;
}

.colorPickerTriggerContainer {
  position: relative;
}

.colorInputWrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 90px;
  height: 42px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  overflow: hidden;
  cursor: pointer;
  transition: border-color 0.2s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .colorInputWrapper:hover  {
  border-color: var(--accent);
}
}

  .colorInputWrapper:active  {
  border-color: var(--accent);
}
}
.colorInputWrapper:active {
  border-color: var(--accent);
}


.colorInputText {
  font-family: monospace;
  font-size: 1.3rem;
  color: var(--text-secondary);
  pointer-events: none;
  mix-blend-mode: difference;
  filter: invert(1) grayscale(1);
}

.collapsibleSection {
  /* This outer container is no longer needed for styling, but kept for structure */
}

.collapsibleHeader {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  padding: 1.2rem 1.5rem;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  cursor: pointer;
  font-family: var(--font-main);
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-primary);
  transition: background-color 0.2s ease-out, border-radius 0.2s ease-out, border-color 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .collapsibleHeader:hover  {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
}
}

  .collapsibleHeader:active  {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
}
}
.collapsibleHeader:active {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
}


.collapsibleHeader.open {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  background-color: var(--bg-secondary);
  border-bottom-color: transparent;
}


.headerInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.arrowIcon {
  transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}

.collapsibleContent {
  overflow: hidden;
  border: 1px solid var(--border-color);
  border-top: none;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  background-color: var(--bg-primary);
}

.mappingsList {
  max-height: 35vh;
  overflow-y: auto;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.mappingItem {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--bg-secondary);
  padding: 0.75rem 1rem;
  border-radius: 6px;
  border: 1px solid var(--border-color);
}

.itemInfo {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-family: var(--font-main);
  font-weight: 500;
}

.itemColorPreview {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid var(--border-color);
}

.removeButton {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s, background-color 0.2s;
}
@media (hover: hover) {@media (hover: hover) {
  
  .removeButton:hover  {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}
}

  .removeButton:active  {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}
}
.removeButton:active {
  color: #dc2626;
  background-color: color-mix(in srgb, #dc2626 15%, transparent);
}





--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.module.css ---

================================================================================

--- START OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx ---

// app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx
'use client';

import React, { useState, useTransition, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { addOrUpdateColorDictionaryAction, removeColorDictionaryAction } from '@/app/studio/actions';
import { useToast } from '@/lib/toastStore';
import { useClickOutside } from '@/hooks/useClickOutside';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { ColorPicker } from '../../ColorPicker';
import styles from './ColorDictionaryModal.module.css';
import editorStyles from '../../Editor.module.css';

type ColorMapping = {
  _key?: string;
  word: string;
  color: string;
};

interface ColorDictionaryModalProps {
  isOpen: boolean;
  onClose: () => void;
  initialMappings: ColorMapping[];
  onUpdate: (updatedMappings: ColorMapping[]) => void;
}

const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: 20, transition: { duration: 0.2 } },
};

export default function ColorDictionaryModal({ isOpen, onClose, initialMappings, onUpdate }: ColorDictionaryModalProps) {
  const [mappings, setMappings] = useState<ColorMapping[]>(initialMappings);
  const [newWord, setNewWord] = useState('');
  const [newColor, setNewColor] = useState('#00E5FF');
  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);
  const [isListOpen, setIsListOpen] = useState(true); // State for the new accordion
  const [isPending, startTransition] = useTransition();
  const toast = useToast();
  const colorPickerRef = useRef<HTMLDivElement>(null);

  useClickOutside(colorPickerRef, () => setIsColorPickerOpen(false));

  useEffect(() => {
    if (isOpen) {
        setMappings(initialMappings);
    }
  }, [isOpen, initialMappings]);

  const handleAdd = () => {
    if (!newWord.trim() || !newColor.trim()) {
      toast.error('الكلمة واللون مطلوبان.', 'left');
      return;
    }

    startTransition(async () => {
      const newMapping = { word: newWord, color: newColor };
      const result = await addOrUpdateColorDictionaryAction(newMapping);
      if (result.success && result.updatedDictionary) {
        const newMappings = result.updatedDictionary.autoColors || [];
        setMappings(newMappings);
        onUpdate(newMappings);
        setNewWord('');
        toast.success(`أضيفت '${newWord}' إلى القاموس.`, 'left');
      } else {
        toast.error(result.message || 'فشلت إضافة الكلمة.', 'left');
      }
    });
  };

  const handleRemove = (key: string) => {
    startTransition(async () => {
      const removedWord = mappings.find((m) => m._key === key)?.word;
      const result = await removeColorDictionaryAction(key);
      if (result.success && result.updatedDictionary) {
        const newMappings = result.updatedDictionary.autoColors || [];
        setMappings(newMappings);
        onUpdate(newMappings);
        toast.info(`أزيلت '${removedWord}' من القاموس.`, 'left');
      } else {
        toast.error(result.message || 'فشلت إزالة الكلمة.', 'left');
      }
    });
  };
  
  const dummyEditor = {
    chain: () => ({
      focus: () => ({
        setColor: (color: string) => {
          setNewColor(color);
          setIsColorPickerOpen(false);
          return { run: () => {} };
        },
        unsetColor: () => {
          setNewColor('#FFFFFF');
          setIsColorPickerOpen(false);
          return { run: () => {} };
        }
      })
    }),
    getAttributes: () => ({ color: newColor }),
  } as any;

  return (
    <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '500px' }}>
        <h3 style={{ marginTop: 0 }}>إدارة ألوان الكلمات التلقائية</h3>
        <p style={{ color: 'var(--text-secondary)', marginTop: '-1rem', marginBottom: '2rem' }}>
            عرّف الكلمات التي يجب تلوينها تلقائيًا عند كتابتها في المحرر.
        </p>
        
        <div className={styles.addForm}>
            <button onClick={handleAdd} className="primary-button" disabled={isPending}>إضافة</button>
            <div ref={colorPickerRef} className={styles.colorPickerTriggerContainer}>
                <button 
                type="button" 
                onClick={() => setIsColorPickerOpen(prev => !prev)} 
                className={styles.colorInputWrapper}
                style={{ backgroundColor: newColor }}
                >
                <span className={styles.colorInputText}>{newColor.toUpperCase()}</span>
                </button>
                <AnimatePresence>
                    {isColorPickerOpen && (
                        <ColorPicker editor={dummyEditor} popoverStyle={{ bottom: 'calc(100% + 8px)', right: '50%', transform: 'translateX(50%)', zIndex: 5001 }} />
                    )}
                </AnimatePresence>
            </div>
            <input
                type="text"
                placeholder="كلمة (مثال: Xbox)"
                value={newWord}
                onChange={(e) => setNewWord(e.target.value)}
                className={editorStyles.sidebarInput}
                disabled={isPending}
            />
        </div>

        <div className={styles.collapsibleSection}>
            <button className={`${styles.collapsibleHeader} ${isListOpen ? styles.open : ''}`} onClick={() => setIsListOpen(!isListOpen)}>
                <div className={styles.headerInfo}>
                    <span>الكلمات الحالية</span>
                    <span style={{color: 'var(--text-secondary)'}}>({mappings.length})</span>
                </div>
                <motion.div animate={{ rotate: isListOpen ? 90 : 0 }} className={styles.arrowIcon}>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </motion.div>
            </button>
            <AnimatePresence initial={false}>
                {isListOpen && (
                    <motion.div
                        key="content"
                        className={styles.collapsibleContent}
                        initial="collapsed"
                        animate="open"
                        exit="collapsed"
                        variants={{
                            open: { opacity: 1, height: 'auto' },
                            collapsed: { opacity: 0, height: 0 }
                        }}
                        transition={{ duration: 0.3, ease: [0.04, 0.62, 0.23, 0.98] }}
                    >
                        <div className={styles.mappingsList}>
                            {mappings.length > 0 ? mappings.map((mapping) => (
                                mapping._key && (
                                    <motion.div
                                        key={mapping._key}
                                        className={styles.mappingItem}
                                        variants={itemVariants}
                                        initial="hidden"
                                        animate="visible"
                                        exit="exit"
                                        layout
                                    >
                                        <div className={styles.itemInfo}>
                                            <div className={styles.itemColorPreview} style={{ backgroundColor: mapping.color }} />
                                            <span>{mapping.word}</span>
                                        </div>
                                        <button
                                            className={styles.removeButton}
                                            onClick={() => mapping._key && handleRemove(mapping._key)}
                                            disabled={isPending}
                                            aria-label={`Remove ${mapping.word}`}
                                        >
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                                        </button>
                                    </motion.div>
                                )
                            )) : <p style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '1rem 0'}}>لا توجد كلمات مُعرفة.</p>}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
      
        <div className={modalStyles.modalActions} style={{marginTop: '2rem'}}>
            <button onClick={onClose} className="outline-button">إغلاق</button>
        </div>
    </Modal>
  );
}




--- END OF FILE app/studio/[contentType]/[id]/metadata/color-dictionary/ColorDictionaryModal.tsx ---

================================================================================

--- START OF FILE app/tags/[tag]/page.tsx ---

// app/tags/[tag]/page.tsx
import { notFound } from 'next/navigation';
import HubPageClient from '@/components/HubPageClient';
import { translateTag } from '@/lib/translations';
import type { Metadata } from 'next';
import { urlFor } from '@/sanity/lib/image';
import { getCachedTagPageData } from '@/lib/sanity.fetch';
import { client } from '@/lib/sanity.client'; 
import { enrichContentList } from '@/lib/enrichment'; 
import { unstable_cache } from 'next/cache';
import BreadcrumbJsonLd from '@/components/seo/BreadcrumbJsonLd'; // ADDED

export const dynamicParams = true;

type Props = {
  params: Promise<{ tag: string }>;
};

const getEnrichedTagData = unstable_cache(
    async (slug: string) => {
        const data = await getCachedTagPageData(slug);
        if (!data) return null;
        
        const enrichedItems = await enrichContentList(data.items || []);
        return { ...data, items: enrichedItems };
    },
    ['enriched-tag-data'], 
    { tags: ['tag', 'content'] }
);

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const { tag } = await params;
  const tagSlug = decodeURIComponent(tag);

  const data = await getEnrichedTagData(tagSlug);

  if (!data) return {};

  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  const translatedTitle = translateTag(data.title); 
  const title = `وسم: ${translatedTitle}`;
  const description = `تصفح كل المحتوى الموسوم بـ "${translatedTitle}" على EternalGames واكتشف أحدث المقالات والمراجعات.`;
  
  const latestItem = data.items && data.items.length > 0 ? data.items[0] : null;
  const ogImageUrl = latestItem?.mainImageRef
    ? urlFor(latestItem.mainImageRef).width(1200).height(630).fit('crop').format('jpg').url()
    : `${siteUrl}/og.png`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      url: `${siteUrl}/tags/${tagSlug}`,
      images: [{ url: ogImageUrl, width: 1200, height: 630, alt: title }],
      type: 'website',
    },
  };
}

export async function generateStaticParams() {
    try {
        const slugs = await client.fetch<string[]>(`*[_type == "tag" && defined(slug.current)][].slug.current`);
        return slugs.map((slug) => ({
            tag: slug,
        }));
    } catch (error) {
        return [];
    }
}

export default async function TagPage({ params }: { params: Promise<{ tag: string }> }) {
    const { tag } = await params;
    const tagSlug = decodeURIComponent(tag);

    const data = await getEnrichedTagData(tagSlug);

    if (!data) {
        notFound();
    }

    const { title: tagTitle, items: allItems } = data;
    const translatedTitle = translateTag(tagTitle);

    if (!allItems || allItems.length === 0) {
        return (
            <div className="container page-container">
                <h1 className="page-title">وسم: &quot;{translatedTitle}&quot;</h1>
                <p style={{textAlign: 'center', color: 'var(--text-secondary)'}}>لم يُنشر عملٌ بهذا الوسم بعد.</p>
            </div>
        );
    }

    const breadcrumbItems = [
        { name: 'الرئيسية', item: '/' },
        { name: 'الوسوم', item: '#' },
        { name: translatedTitle, item: `/tags/${tagSlug}` }
    ];
    
    return (
        <>
            <BreadcrumbJsonLd items={breadcrumbItems} />
            <HubPageClient
                initialItems={allItems}
                hubTitle={translatedTitle}
                hubType="وسم"
            />
        </>
    );
}

--- END OF FILE app/tags/[tag]/page.tsx ---

================================================================================

--- START OF FILE app/terms-of-service/page.tsx ---

// app/terms-of-service/page.tsx
import { Metadata } from 'next';
import { ContentBlock } from '@/components/ContentBlock';

export const metadata: Metadata = {
    title: 'شروط الخدمة',
    description: 'الشروط والأحكام لاستخدام منصة EternalGames.',
};

export default function TermsOfServicePage() {
    return (
        <div className="container page-container">
            <h1 className="page-title">شروط الخدمة</h1>

            <ContentBlock title="قبول الشروط">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    بوصولك واستخدامك لمنصة EternalGames، فإنك تقر بقبولك لهذه الشروط. إذا كنت لا توافق على أي جزء منها، يرجى عدم استخدام الموقع.
                </p>
            </ContentBlock>

            <ContentBlock title="سلوك المستخدم">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    نحن مجتمع مبني على الشغف والاحترام. يُحظر تمامًا:
                </p>
                <ul style={{ listStyle: 'disc', paddingRight: '2rem', fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8, marginTop: '1rem' }}>
                    <li>خطاب الكراهية، التنمر، أو المضايقة في التعليقات.</li>
                    <li>نشر محتوى غير لائق أو روابط ضارة.</li>
                    <li>محاولة اختراق الموقع أو جمع بيانات المستخدمين.</li>
                </ul>
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8, marginTop: '1rem' }}>
                    تحتفظ الإدارة بحق حظر أي حساب يخالف هذه القواعد دون سابق إنذار.
                </p>
            </ContentBlock>

            <ContentBlock title="الملكية الفكرية">
                <p style={{ fontSize: '1.6rem', color: 'var(--text-secondary)', lineHeight: 1.8 }}>
                    جميع المحتويات المنشورة من قبل فريق التحرير (مقالات، مراجعات، تصاميم) هي ملكية حصرية لـ EternalGames. لا يجوز نسخها أو إعادة نشرها دون إذن كتابي. المحتوى الذي ينشره المستخدمون (التعليقات) يظل ملكاً لهم، لكنهم يمنحوننا رخصة لعرضه.
                </p>
            </ContentBlock>
        </div>
    );
}

--- END OF FILE app/terms-of-service/page.tsx ---

================================================================================

--- START OF FILE app/tools/upscaler/page.tsx ---

// app/tools/upscaler/page.tsx
import UpscalerClient from '@/components/upscaler/UpscalerClient';
import { ContentBlock } from '@/components/ContentBlock';
import { SparklesIcon } from '@/components/icons/index';
import { Metadata } from 'next';

export const metadata: Metadata = {
    title: 'المسبك البصري | AI Upscaler',
    description: 'أداة رفع دقة الصور باستخدام الذكاء الاصطناعي مباشرة في متصفحك. خصوصية تامة وأداء عالٍ.',
};

export default function UpscalerPage() {
    return (
        <div className="container page-container">
            <div style={{ textAlign: 'center', marginBottom: '6rem' }}>
                <h1 className="page-title">المسبك البصري</h1>
                <p style={{ fontSize: '1.8rem', color: 'var(--text-secondary)', maxWidth: '600px', margin: '0 auto' }}>
                    تقنية تحسين الصور بالذكاء الاصطناعي (Swin2SR). تعمل كلياً على جهازك لضمان الخصوصية والسرعة. مثالية للقطات الألعاب الفنية.
                </p>
            </div>
            
            <ContentBlock title="محطة المعالجة" Icon={SparklesIcon}>
                <UpscalerClient />
            </ContentBlock>
        </div>
    );
}




--- END OF FILE app/tools/upscaler/page.tsx ---

================================================================================

--- START OF FILE app/welcome/WelcomePageClient.tsx ---

// app/welcome/WelcomePageClient.tsx
'use client';

import { useState, useTransition, useEffect, useMemo } from 'react';
import { completeOnboardingAction, checkUsernameAvailability } from '@/app/actions/userActions';
import { useSession } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useAsyncValidation } from '@/hooks/useAsyncValidation';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useToast } from '@/lib/toastStore';
import { countries } from '@/lib/countries';
import Link from 'next/link';
import { sanitizeRedirectUrl } from '@/lib/security'; // SECURITY IMPORT

const InfoTooltip = ({ text }: { text: string }) => (
    <div style={{ position: 'relative', display: 'inline-flex', alignItems: 'center', marginLeft: '0.5rem', cursor: 'pointer' }} className="info-tooltip-container">
        <svg width="16" height="16" viewBox="0 0 20 20" fill="var(--text-secondary)"><path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" /></svg>
        <div className="info-tooltip-text">{text}</div>
    </div>
);

export default function WelcomePageClient() {
    const { data: session, status: sessionStatus, update } = useSession();
    const router = useRouter();
    const searchParams = useSearchParams();
    const toast = useToast();

    const [fullName, setFullName] = useState('');
    const [username, setUsername] = useState('');
    const [age, setAge] = useState('');
    const [country, setCountry] = useState('');
    const [countrySearch, setCountrySearch] = useState('');
    const [isCountryDropdownOpen, setIsCountryDropdownOpen] = useState(false);
    const [termsAccepted, setTermsAccepted] = useState(false);

    const [isPending, startTransition] = useTransition();

    const hasInitialUsername = !!(session?.user as any)?.username;

    const usernameValidation = useAsyncValidation(username, checkUsernameAvailability, (session?.user as any)?.username ?? undefined);
    
    const filteredCountries = useMemo(() => 
        countries.filter(c => c.toLowerCase().includes(countrySearch.toLowerCase())),
    [countrySearch]);
    
    useEffect(() => {
        if (sessionStatus === 'authenticated') {
            if (!(session as any)?.needsOnboarding) {
                // SECURITY: Sanitize callback URL to prevent open redirects
                const rawCallback = searchParams.get('callbackUrl');
                const safeCallback = sanitizeRedirectUrl(rawCallback);
                router.replace(safeCallback);
                return;
            }
            setFullName(session.user?.name ?? '');
            if ((session.user as any)?.username) {
                setUsername((session.user as any).username);
            }
        }
    }, [sessionStatus, session, router, searchParams]);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (isButtonDisabled) return;

        const formData = new FormData(e.target as HTMLFormElement);
        startTransition(async () => {
            const result = await completeOnboardingAction(formData);
            if (result.success) {
                toast.success('اكتمل ملفك. أهلًا بك في EternalGames.');
                await update(); 
                
                // SECURITY: Sanitize callback URL
                const rawCallback = searchParams.get('callbackUrl');
                const safeCallback = sanitizeRedirectUrl(rawCallback);
                
                router.push(safeCallback);
            } else {
                toast.error(result.message || 'أخفق إكمال الملف.');
            }
        });
    };

    if (sessionStatus === 'loading' || !session || (sessionStatus === 'authenticated' && !(session as any)?.needsOnboarding)) {
        return (
            <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
                <div className="spinner" />
            </div>
        );
    }
    
    const isButtonDisabled = isPending || (!hasInitialUsername && usernameValidation.type !== 'valid') || !fullName || !termsAccepted;

    return (
        <div className="container page-container" style={{ display: 'flex', justifyContent: 'center', alignItems: 'flex-start', paddingTop: '10vh' }}>
            <motion.div 
                style={{ maxWidth: '500px', width: '100%', textAlign: 'center' }}
                initial={{ opacity: 0, y: -20 }}
                animate={{ opacity: 1, y: 0 }}
            >
                <h1 className="page-title">أهلاً بك في رحاب EternalGames!</h1>
                <p style={{ color: 'var(--text-secondary)', fontSize: '1.8rem', marginTop: '-2rem', marginBottom: '3rem' }}>خطوةٌ أخيرة تفصلك. أكمل ملفك الشخصي لتدخل مَعيَّتنا.</p>
                <form onSubmit={handleSubmit} style={{ textAlign: 'left' }}>
                    <div className="profile-form-group">
                        <input id="fullName" name="fullName" type="text" value={fullName} onChange={(e) => setFullName(e.target.value)} className="profile-input" placeholder=" " required />
                        <label htmlFor="fullName" className="profile-form-label">الاسم الكامل</label>
                    </div>

                    {!hasInitialUsername && (
                        <div className="profile-form-group">
                            <input id="username" name="username" type="text" value={username} onChange={(e) => setUsername(e.target.value.toLowerCase())} className="profile-input" placeholder=" " autoFocus required />
                            <label htmlFor="username" className="profile-form-label">اختر اسمًا للمستخدم</label>
                            <AnimatePresence>
                                {usernameValidation.type !== 'idle' && <motion.p initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} style={{ fontSize: '1.4rem', margin: '0.5rem 0 0 0', color: usernameValidation.type === 'invalid' ? '#DC2626' : (usernameValidation.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameValidation.message}</motion.p>}
                            </AnimatePresence>
                        </div>
                    )}
                    
                    {hasInitialUsername && (
                        <input type="hidden" name="username" value={username} />
                    )}

                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem' }}>
                        <div className="profile-form-group">
                            <input 
                                id="age" 
                                name="age" 
                                type="text"
                                inputMode="numeric"
                                pattern="[0-9]*"
                                value={age} 
                                onChange={(e) => {
                                    if (e.target.value === '' || /^[0-9]+$/.test(e.target.value)) {
                                        setAge(e.target.value);
                                    }
                                }} 
                                className="profile-input" 
                                placeholder=" " 
                            />
                            <label htmlFor="age" className="profile-form-label">العمر (اختياري)<InfoTooltip text="عمرك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                        </div>
                        <div className="profile-form-group" style={{ position: 'relative' }}>
                            <input id="country" name="country" type="text" value={country} onFocus={() => setIsCountryDropdownOpen(true)} onBlur={() => setTimeout(() => setIsCountryDropdownOpen(false), 150)} onChange={(e) => { setCountry(e.target.value); setCountrySearch(e.target.value); }} className="profile-input" placeholder=" " autoComplete="off" />
                            <label htmlFor="country" className="profile-form-label">البلد (اختياري)<InfoTooltip text="بلدك سيُعرض علنًا. يمكنك إخفاؤه لاحقًا من الإعدادات." /></label>
                            {isCountryDropdownOpen && (
                                <div style={{ position: 'absolute', top: '100%', left: 0, right: 0, maxHeight: '200px', overflowY: 'auto', background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', borderRadius: '8px', zIndex: 10, marginTop: '0.5rem' }}>
                                    {filteredCountries.map(c => 
                                        <button type="button" key={c} onMouseDown={() => { setCountry(c); setIsCountryDropdownOpen(false); }} 
                                        className="country-picker-button">
                                            {c}
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="profile-form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                        <input type="checkbox" id="terms" name="terms" checked={termsAccepted} onChange={(e) => setTermsAccepted(e.target.checked)} style={{ width: '1.6rem', height: '1.6rem' }}/>
                        <label htmlFor="terms" style={{ fontSize: '1.4rem', color: 'var(--text-secondary)' }}>أوافق على<Link href="/terms-of-service" target="_blank">شروط الخدمة</Link>.
                        </label>
                    </div>

                    <motion.button type="submit" className="primary-button" style={{ width: '100%', marginTop: '1rem', height: '48px' }} disabled={isButtonDisabled} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '5px' }} transition={{ type: 'spring' as const, stiffness: 400, damping: 25 }}>
                        <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إكمال الملف الشخصي</motion.span>}</AnimatePresence>
                    </motion.button>
                </form>
            </motion.div>
        </div>
    );
}

--- END OF FILE app/welcome/WelcomePageClient.tsx ---

================================================================================

--- START OF FILE app/welcome/page.tsx ---

// app/welcome/page.tsx
import { Suspense } from 'react';
import WelcomePageClient from './WelcomePageClient';

// A simple fallback component to show while the client component loads
const WelcomePageFallback = () => {
    return (
        <div className="container page-container" style={{display: 'flex', alignItems:'center', justifyContent: 'center'}}>
            <div className="spinner" />
        </div>
    );
};

export default function WelcomePage() {
    return (
        <Suspense fallback={<WelcomePageFallback />}>
            <WelcomePageClient />
        </Suspense>
    );
}







--- END OF FILE app/welcome/page.tsx ---

================================================================================

--- START OF FILE components/ActionButton.module.css ---

/* components/ActionButton.module.css */

.actionButton {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    width: 36px;
    height: 36px;
    aspect-ratio: 1 / 1;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-secondary);
    transition: background-color 0.2s ease-out, border-color 0.2s ease-out, color 0.2s ease-out, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    z-index: 10;
}
@media (hover: hover) {@media (hover: hover) {
  
  .actionButton:hover:not(:disabled)  {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
    transform: scale(1.15);
}
}

  .actionButton:active:not(:disabled)  {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
    transform: scale(1.15);
}
}
.actionButton:active:not(:disabled) {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
    transform: scale(1.15);
}

@media (hover: hover) {@media (hover: hover) {
  
  [data-theme="dark"] .actionButton:hover:not(:disabled)  {
    color: var(--bg-primary);
}
}

  [data-theme="dark"] .actionButton:active:not(:disabled)  {
    color: var(--bg-primary);
}
}
[data-theme="dark"] .actionButton:active:not(:disabled) {
    color: var(--bg-primary);
}





--- END OF FILE components/ActionButton.module.css ---

================================================================================

--- START OF FILE components/ActionButton.tsx ---

// components/ActionButton.tsx
'use client';

import { motion } from 'framer-motion';
import React, { useState } from 'react';
import styles from './ActionButton.module.css';

// THE DEFINITIVE FIX: Create a more precise props type that omits conflicting properties.
type ConflictingProps = 'onAnimationStart' | 'onDragStart' | 'onDragEnd' | 'onDrag';
interface ActionButtonProps extends Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, ConflictingProps> {
    children: React.ReactNode;
    'aria-label': string;
}

const ActionButton = ({ children, ...props }: ActionButtonProps) => {
    const [isHovered, setIsHovered] = useState(false);

    return (
        <motion.button
            className={styles.actionButton}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            animate={{ scale: isHovered ? 1.15 : 1 }}
            whileTap={{ scale: 0.9, y: 0 }}
            transition={{ type: 'spring', stiffness: 400, damping: 15 }}
            {...props}
        >
            {children}
        </motion.button>
    );
};

export default ActionButton;




--- END OF FILE components/ActionButton.tsx ---

================================================================================

--- START OF FILE components/AnimatedGridBackground.module.css ---

/* components/AnimatedGridBackground.module.css */
@keyframes gridScroll {
  from { transform: translateY(0) translateX(0); }
  to { transform: translateY(60px) translateX(60px); } /* Matches grid size */
}

.animatedGrid {
  position: fixed;
  top: -60px; /* Offset to allow movement without showing edges */
  left: -60px;
  /* Make element larger than viewport to prevent clipping during movement */
  width: calc(100vw + 120px);
  height: calc(100vh + 120px);
  z-index: -1;
  --grid-size: 60px;
  --grid-color: rgba(125, 128, 140, 0.1);
  background-image:
    linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
    linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
  background-size: var(--grid-size) var(--grid-size);
  
  /* OPTIMIZATION: Use transform instead of background-position */
  animation: gridScroll 10s linear infinite;
  
  /* Hint browser to promote to GPU layer */
  will-change: transform;
  transform: translateZ(0); 
  pointer-events: none;
}




--- END OF FILE components/AnimatedGridBackground.module.css ---

================================================================================

--- START OF FILE components/AnimatedGridBackground.tsx ---

// components/AnimatedGridBackground.tsx
'use client';
import styles from './AnimatedGridBackground.module.css';

export default function AnimatedGridBackground() {
  return <div className={styles.animatedGrid} />;
}




--- END OF FILE components/AnimatedGridBackground.tsx ---

================================================================================

--- START OF FILE components/AnimatedNumber.tsx ---

// components/AnimatedNumber.tsx
'use client';

import { motion, useAnimate } from 'framer-motion';
import { useEffect } from 'react';

const DIGIT_MAP: { [key: string]: number } = { '0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, };

const Digit = ({ digit, isInView }: { digit: string; isInView: boolean }) => {
    const [scope, animate] = useAnimate();
    const digitHeight = 90;

    useEffect(() => {
        if (isInView) {
            animate(scope.current, { y: -DIGIT_MAP[digit] * digitHeight }, { duration: 1.5, ease: [0.22, 1, 0.36, 1] as const });
        }
    }, [digit, isInView, animate, scope, digitHeight]);

    return (
        <div style={{ height: `${digitHeight}px`, overflow: 'hidden' }}>
            <motion.div ref={scope} style={{ y: 0 }}>
                {Object.keys(DIGIT_MAP).map(d => <div key={d} style={{ height: `${digitHeight}px` }}>{d}</div>)}
            </motion.div>
        </div>
    );
};

export const AnimatedNumber = ({ value, isInView, className }: { value: number; isInView: boolean; className: string; }) => {
    const [scope, animate] = useAnimate();

    useEffect(() => {
        if (isInView) {
            const popAnimation = animate(scope.current, { scale: [1, 1.15, 1], }, { duration: 0.4, delay: 1.5, ease: "easeOut" as const, });
            return () => { popAnimation.stop(); };
        }
    }, [isInView, animate, scope]);

    const stringValue = value.toFixed(1);
    const [integerPart, decimalPart] = stringValue.split('.');
    const integerDigits = Array.from(integerPart);

    return (
        // --- THE DEFINITIVE FIX ---
        // Numbers are always displayed Left-to-Right, even in an RTL context.
        // By adding `direction: 'ltr'`, we isolate the number component from the global
        // RTL styling, ensuring its parts (integer, decimal) are laid out correctly.
        // We then write the JSX in the natural LTR order.
        <div ref={scope} className={className} style={{ display: 'flex', justifyContent: 'center', direction: 'ltr' }}>
            {integerDigits.map((digit, i) => <Digit key={i} digit={digit} isInView={isInView} />)}
            <div style={{ lineHeight: '8rem' }}>.</div>
            <Digit digit={decimalPart} isInView={isInView} />
        </div>
    );
};







--- END OF FILE components/AnimatedNumber.tsx ---

================================================================================

--- START OF FILE components/AnimatedReleases.tsx ---

// components/AnimatedReleases.tsx
'use client';

import KineticReleaseTimeline from '@/components/KineticReleaseTimeline';

// MODIFIED: Accept credits
export default function AnimatedReleases({ releases, credits }: { releases: any[], credits?: any[] }) {
    return (
        <div>
            <KineticReleaseTimeline releases={releases} credits={credits} />
        </div>
    );
}




--- END OF FILE components/AnimatedReleases.tsx ---

================================================================================

--- START OF FILE components/ArticleCard.module.css ---

/* components/ArticleCard.module.css */

/* THE ANCHOR */
.livingCardWrapper {
    width: 100%;
    position: relative;
    z-index: 1;
    overflow: visible !important; 
    display: flex;
    flex-direction: column;
    margin-bottom: 0; 
    background: transparent !important;
    -webkit-tap-highlight-color: transparent;

    /* OPTIMIZATION: Isolate layout calculations */
    contain: layout style;
}

.livingCardWrapper.activeState {
    z-index: 500;
}

.cardOverlayLink {
    position: absolute;
    inset: 0;
    z-index: 40; 
    cursor: pointer;
    background: transparent;
    transform: translateZ(1px); 
}

/* THE MONOLITH FRAME */
.monolithFrame {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 10; 
    min-height: 180px; 
    border-radius: 16px;
    overflow: visible; 
    
    background-color: var(--bg-secondary);
    
    transform-style: preserve-3d;
    transform: translateZ(0px);
    
    /* GPU FIX: Removed will-change */
    
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), border-color 0.3s ease;

    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5);
    
    isolation: isolate; 
    pointer-events: none; 
}

/* GPU FIX: Apply will-change only when needed */
.livingCardWrapper:hover .monolithFrame,
.livingCardWrapper.activeState .monolithFrame {
    will-change: transform;
}

.monolithFrame::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    box-shadow: 
        0 35px 70px -15px rgba(0,0,0,0.8),
        0 0 0 1px color-mix(in srgb, var(--accent) 30%, transparent);
    opacity: 0;
    transition: opacity 0.4s ease; 
    z-index: -1;
    pointer-events: none;
}

.cyberCorner {
    position: absolute;
    top: -1px;
    left: -1px;
    width: 40px;
    height: 40px;
    border-top: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-left: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-top-left-radius: 16px;
    transition: all 0.3s ease;
    z-index: 20; 
    pointer-events: none;
    /* GPU FIX: Removed will-change */
}

/* GPU FIX: Only hint GPU on hover/active */
.livingCardWrapper:hover .cyberCorner,
.livingCardWrapper.activeState .cyberCorner {
    will-change: width, height, border-color;
}

.innerClippingFrame {
    position: absolute;
    inset: 0;
    border-radius: 16px; 
    overflow: hidden; 
    z-index: 5;
    transform: translateZ(0); 
    background-color: var(--bg-secondary);
}

:global(.noCornerAnimation) .cyberCorner {
    display: none !important;
}

.livingCardWrapper.activeState .monolithFrame {
    transform: translateZ(20px);
    border-color: var(--accent);
}
.livingCardWrapper.activeState .monolithFrame::after {
    opacity: 1; 
}

.livingCardWrapper.activeState .cyberCorner {
    width: calc(100% + 2px);
    height: calc(100% + 2px);
    border-radius: 16px; 
    border-color: var(--accent);
    filter: drop-shadow(0 0 4px var(--accent));
    border-right: none;
    border-bottom: none;
}

.livingCardWrapper.activeState .cardImage { transform: scale(1.1); }
.livingCardWrapper.activeState .holoSpotlight { opacity: 1; }
.livingCardWrapper.activeState .scanLine { opacity: 1; animation: scan 2.5s cubic-bezier(0.45, 0.05, 0.55, 0.95) infinite; }
.livingCardWrapper.activeState .cardTitle { color: var(--accent); text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 60%, transparent); }
.livingCardWrapper.activeState .scoreBadge { background-color: var(--accent); color: var(--bg-primary); }
.livingCardWrapper.activeState .creditCapsule { border-color: var(--accent); background-color: var(--accent); }
.livingCardWrapper.activeState .capsuleIcon { background-color: var(--bg-primary); color: var(--accent); }
.livingCardWrapper.activeState .creditCapsule :global(span) { color: var(--bg-primary); }
.livingCardWrapper.activeState .techDot { background-color: var(--accent); animation: pulse-dot 1.2s infinite ease-in-out; }
.livingCardWrapper.activeState .techDot:nth-child(2) { animation-delay: 0.2s; }
.livingCardWrapper.activeState .techDot:nth-child(3) { animation-delay: 0.4s; }

@media (hover: hover) {
    .livingCardWrapper:hover { z-index: 500; }
    .livingCardWrapper:hover .monolithFrame {
        transform: translateZ(20px);
        border-color: var(--accent);
    }
    .livingCardWrapper:hover .monolithFrame::after {
        opacity: 1;
    }

    .livingCardWrapper:hover .cyberCorner {
        width: calc(100% + 2px);
        height: calc(100% + 2px);
        border-radius: 16px;
        border-color: var(--accent);
        filter: drop-shadow(0 0 4px var(--accent));
        border-right: none;
        border-bottom: none;
    }
    .livingCardWrapper:hover .cardImage { transform: scale(1.1); }
    .livingCardWrapper:hover .holoSpotlight { opacity: 1; }
    .livingCardWrapper:hover .scanLine { opacity: 1; animation: scan 2.5s cubic-bezier(0.45, 0.05, 0.55, 0.95) infinite; }
    .livingCardWrapper:hover .cardTitle { color: var(--accent); text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 60%, transparent); }
    .livingCardWrapper:hover .scoreBadge { background-color: var(--accent); color: var(--bg-primary); }
    .livingCardWrapper:hover .creditCapsule { border-color: var(--accent); background-color: var(--accent); }
    .livingCardWrapper:hover .capsuleIcon { background-color: var(--bg-primary); color: var(--accent); }
    .livingCardWrapper:hover .creditCapsule :global(span) { color: var(--bg-primary); }
    .livingCardWrapper:hover .techDot { background-color: var(--accent); animation: pulse-dot 1.2s infinite ease-in-out; }
    .livingCardWrapper:hover .techDot:nth-child(2) { animation-delay: 0.2s; }
    .livingCardWrapper:hover .techDot:nth-child(3) { animation-delay: 0.4s; }
}

.imageWrapper {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    transform: translateZ(0); 
    pointer-events: none;
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1);
    scale: 1.02;
    backface-visibility: hidden;
}

.holoSpotlight {
    position: absolute;
    width: 150px; 
    height: 150px;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 15;
    opacity: 0;
    transition: opacity 0.2s ease;
    background: radial-gradient(circle, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0.1) 60%, transparent 70%);
    mix-blend-mode: overlay; 
    border-radius: 50%;
}

.scanLine {
    position: absolute;
    top: -50%;
    left: 0;
    width: 100%;
    height: 30%;
    background: linear-gradient(to bottom, transparent, rgba(0, 255, 240, 0.4) 50%, transparent);
    z-index: 10;
    pointer-events: none;
    mix-blend-mode: overlay;
    opacity: 0;
    transition: opacity 0.3s ease;
}

@keyframes scan {
    0% { top: -30%; }
    100% { top: 130%; }
}

.titleOverlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    padding: 6rem 1.5rem 5.5rem 1.5rem; 
    background: linear-gradient(to top, rgba(5,6,8,0.98) 25%, rgba(5,6,8,0.7) 65%, transparent 100%);
    display: flex;
    flex-direction: column;
    justify-content: flex-end; 
    align-items: flex-start;
    text-align: right;
    pointer-events: none;
    z-index: 25;
    transform: translateZ(10px); 
}

/* Light Mode Override: Remove Shadow Gradient */
:global([data-theme="light"]) .titleOverlay {
    background: none !important;
}

.titleMaskWrapper {
    width: 100%;
    overflow: hidden; 
    display: flex;
    flex-direction: column;
    justify-content: flex-start; 
}

.cardTitle {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    font-weight: 800;
    line-height: 1.35;
    color: #fff;
    margin: 0;
    text-shadow: 0 4px 20px rgba(0,0,0,0.7);
    white-space: normal;
    direction: rtl;
    width: 100%;
    pointer-events: none;
    transition: color 0.3s ease;
    
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.cardTitle.expanded {
    -webkit-line-clamp: unset;
    display: block; 
}

.scoreBadge {
    position: absolute;
    top: 1rem;
    left: 1rem;
    width: 48px;
    height: 48px;
    background-color: var(--bg-secondary);
    backdrop-filter: blur(16px);
    border: 2px solid var(--accent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--accent);
    font-family: var(--font-heading);
    font-weight: 900;
    font-size: 1.8rem;
    letter-spacing: -1px;
    z-index: 30;
    box-shadow: 0 8px 30px rgba(0,0,0,0.3);
    transition: color 0.4s ease, background-color 0.4s ease, transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    pointer-events: none;
}

.hudContainer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: auto;
    display: flex;
    align-items: center;
    justify-content: space-between; 
    padding: 0 1rem 1rem 1rem;
    z-index: 50; 
    pointer-events: none; 
}
.hudContainer > * {
    pointer-events: auto;
}

a.creditCapsule { display: inline-flex; align-items: center; gap: 0.8rem; background: rgba(10, 11, 15, 0.8); border: 1px solid rgba(255,255,255,0.1); padding: 0; border-radius: 999px; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); height: 32px; backdrop-filter: blur(8px); text-decoration: none; cursor: pointer; position: relative; z-index: 51; }
div.creditCapsule { display: inline-flex; align-items: center; gap: 0.8rem; background: rgba(10, 11, 15, 0.8); border: 1px solid rgba(255,255,255,0.1); padding: 0; border-radius: 999px; height: 32px; backdrop-filter: blur(8px); pointer-events: none; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
@media (hover: hover) { a.creditCapsule:hover { transform: translateY(-4px) scale(1.05); box-shadow: 0 10px 20px -5px color-mix(in srgb, var(--accent) 50%, transparent); z-index: 100; } }
a.creditCapsule:active { transform: scale(0.95); }
.capsuleIcon { width: 32px; height: 32px; border-radius: 50%; background-color: var(--accent); color: #000; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: color 0.4s ease, background-color 0.4s ease, box-shadow 0.4s ease; }
.capsuleIcon svg { width: 14px; height: 14px; }
.creditCapsule :global(span) { font-size: 1.2rem; font-weight: 700; color: #fff; max-width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 1.2rem; padding-right: 0.8rem; transition: color 0.4s ease; }
.satelliteField { position: absolute; inset: -100px; pointer-events: none; z-index: 100; overflow: visible; transform-style: preserve-3d; }
.satelliteShard { position: absolute; padding: 0; background: transparent; pointer-events: none; display: flex; align-items: center; justify-content: center; transform-style: preserve-3d; }

.satelliteShardLink { 
    display: flex; align-items: center; justify-content: center; 
    padding: 0.4rem 1rem; background: #000; border: 2px solid var(--accent); 
    color: var(--accent); font-family: var(--font-ui); font-size: 1.2rem; 
    font-weight: 800; border-radius: 6px; white-space: nowrap; 
    box-shadow: 0 15px 40px rgba(0,0,0,0.8); filter: drop-shadow(0 0 10px rgba(0,255,240,0.3)); 
    text-decoration: none; 
    transition: background-color 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), color 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s ease; 
    cursor: pointer; pointer-events: auto; position: relative; z-index: 101; 
}
.satelliteShardLink.small { padding: 0.2rem 0.6rem; font-size: 1rem; border-width: 1px; }

/* FIX: Mobile Active State for Tags */
.satelliteShardLink:active {
    background-color: var(--accent);
    color: #000;
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
    transform: scale(0.95);
}

@media (hover: hover) { .satelliteShardLink:hover { background-color: var(--accent); color: #000; transform: scale(1.15) translateY(-3px); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent); z-index: 200; } }

/* NO GLASS HOVER FIXES */
:global(body.no-glass) .satelliteShardLink:hover {
    background-color: var(--accent) !important;
    color: #000 !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent) !important;
}
:global(body.no-glass) .satelliteShardLink:active {
    background-color: var(--accent) !important;
    color: #000 !important;
    border-color: var(--accent) !important;
}

.dateReadout { font-family: var(--font-ui); font-size: 1.1rem; color: rgba(255,255,255,0.7); font-weight: 500; white-space: nowrap; display: flex; align-items: center; gap: 0.5rem; padding-bottom: 0.5rem; pointer-events: none; }
.techDecoration { display: flex; gap: 5px; padding: 0.5rem 0; justify-content: flex-end; pointer-events: none; }
.techDot { width: 4px; height: 4px; background-color: rgba(255,255,255,0.2); border-radius: 50%; transition: background-color 0.3s ease; }
@keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 0.6; } 50% { transform: scale(1.6); opacity: 1; box-shadow: 0 0 10px var(--accent); } }

@media (max-width: 768px) {
    /* MODIFIED: Allow 3D transforms on mobile */
    .livingCardWrapper { overflow: visible !important; border-radius: 12px; background: transparent; margin-bottom: 2.5rem; }
    .monolithFrame { min-height: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.3); mask-image: none; -webkit-mask-image: none; }
    
    .cardTitle { font-size: 1.6rem; }
    
    .titleOverlay { padding: 4rem 1.5rem 5rem 1.5rem; }
    
    .hudContainer { padding: 0 1rem 1rem 1rem; z-index: 50; transform: none !important; }
    
    /* MOBILE OPTIMIZATION: Kill Blur */
    .scoreBadge { 
        width: 40px; height: 40px; font-size: 1.5rem; transform: none !important; top: 0.8rem; left: 0.8rem; 
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(20, 20, 25, 0.95); 
    }
    .holoSpotlight, .satelliteField { display: none; }
    .livingCardWrapper.activeState .satelliteField { display: block; }

    a.creditCapsule, div.creditCapsule {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(10, 11, 15, 0.95);
    }
}

/* NO GLASS HOVER FIXES */
:global(body.no-glass) .livingCardWrapper:hover .creditCapsule,
:global(body.no-glass) .livingCardWrapper.activeState .creditCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
    color: #000 !important;
    box-shadow: none !important;
}

:global(body.no-glass) .livingCardWrapper:hover .capsuleIcon,
:global(body.no-glass) .livingCardWrapper.activeState .capsuleIcon {
    background-color: #000 !important;
    color: var(--accent) !important;
}

:global(body.no-glass) .livingCardWrapper:hover .creditCapsule :global(span),
:global(body.no-glass) .livingCardWrapper.activeState .creditCapsule :global(span) {
    color: #000 !important;
}

/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .imageBadge {
  background-color: rgba(255, 255, 255, 0.85);
  border-color: rgba(0,0,0,0.05);
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  color: var(--text-primary);
}
:global([data-theme="light"] body.no-glass) .imageBadge {
  background-color: rgba(255, 255, 255, 0.95) !important;
}
:global([data-theme="light"]) a.creatorCapsule,
:global([data-theme="light"]) div.creatorCapsule {
  background: #ffffff !important; /* White Background Default */
  border-color: rgba(0,0,0,0.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .creatorCapsule :global(span) {
  color: var(--accent) !important; /* Cyan Text Default */
}
:global([data-theme="light"]) .capsuleIcon {
  color: #fff !important;
  background-color: var(--accent) !important; /* Cyan Circle Default */
}
:global([data-theme="light"]) .satelliteShardLink {
  background: #ffffff !important;
  border-color: var(--accent);
  color: var(--accent) !important; /* Cyan Text Default */
  box-shadow: 0 5px 20px rgba(0,0,0,0.1);
}
:global([data-theme="light"]) .satelliteShardLink:hover {
  background-color: var(--accent) !important;
  color: #fff !important;
}
:global([data-theme="light"] body.no-glass) .satelliteShardLink {
  background: #ffffff !important;
  color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .satelliteShardLink:hover {
  background-color: var(--accent) !important;
  color: #ffffff !important;
}
:global([data-theme="light"]) .techDot {
  background-color: rgba(0,0,0,0.2);
}

/* --- Light Mode Fixes (NO BLACK) --- */

/* 1. Card Hover/Active: Capsule turns Cyan */
:global([data-theme="light"]) .livingCardWrapper:hover a.creatorCapsule,
:global([data-theme="light"]) .livingCardWrapper.activeState a.creatorCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}

/* 2. Card Hover/Active: Name Text turns White */
:global([data-theme="light"]) .livingCardWrapper:hover .creatorCapsule :global(span),
:global([data-theme="light"]) .livingCardWrapper.activeState .creatorCapsule :global(span) {
    color: #fff !important;
}

/* 3. Card Hover/Active: Icon Circle turns White, Icon turns Cyan */
:global([data-theme="light"]) .livingCardWrapper:hover .capsuleIcon,
:global([data-theme="light"]) .livingCardWrapper.activeState .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* 4. Direct Hover on Capsule (Overrides above) */
:global([data-theme="light"]) a.creatorCapsule:hover,
:global([data-theme="light"]) div.creatorCapsule:hover {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}
:global([data-theme="light"]) a.creatorCapsule:hover :global(span),
:global([data-theme="light"]) div.creatorCapsule:hover :global(span) {
    color: #fff !important;
}
:global([data-theme="light"]) a.creatorCapsule:hover .capsuleIcon,
:global([data-theme="light"]) div.creatorCapsule:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

/* 5. Light Mode No-Glass Override (Specific Fix for the black issue) */
:global([data-theme="light"] body.no-glass) a.creatorCapsule,
:global([data-theme="light"] body.no-glass) div.creatorCapsule {
    background-color: #ffffff !important;
    border-color: rgba(0,0,0,0.1) !important;
}
:global([data-theme="light"] body.no-glass) .creatorCapsule :global(span) {
    color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .capsuleIcon {
    background-color: var(--accent) !important;
    color: #fff !important;
}

/* Ensure Hover/Active via Card triggers Cyan BG, White Text, White Icon Circle */
:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover a.creatorCapsule,
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState a.creatorCapsule,
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover,
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover {
     background-color: var(--accent) !important;
     border-color: var(--accent) !important;
}

:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover .creatorCapsule :global(span),
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState .creatorCapsule :global(span),
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover :global(span),
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover :global(span) {
     color: #ffffff !important;
}

:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState .capsuleIcon,
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover .capsuleIcon {
     background-color: #ffffff !important;
     color: var(--accent) !important;
}

/* --- LIGHT MODE + NO-GLASS SPECIAL FIXES --- */

/* 1. Gradient Overlay -> White in Light/No-Glass */
:global([data-theme="light"] body.no-glass) .titleOverlay {
    background: linear-gradient(to top, rgba(255,255,255,0.98) 30%, rgba(255,255,255,0.8) 60%, transparent 100%);
}

:global([data-theme="light"] body.no-glass) .cardTitle {
    color: #000000;
    text-shadow: none;
}

/* 2. Credits Capsule - Idle State (Light/No-Glass) */
/* "credits pill should be white and the author's name black" */
:global([data-theme="light"] body.no-glass) a.creditCapsule,
:global([data-theme="light"] body.no-glass) div.creditCapsule {
    background-color: #ffffff !important;
    border-color: rgba(0,0,0,0.1) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05) !important;
}

:global([data-theme="light"] body.no-glass) .creditCapsule :global(span) {
    color: #000000 !important;
}

:global([data-theme="light"] body.no-glass) .capsuleIcon {
    background-color: var(--accent) !important;
    color: #ffffff !important;
}

/* 3. Credits Capsule - Hover State (Light/No-Glass) */
/* "after hovering the name's font should turn white and the pill turns cyan" */
/* Triggered by Card Hover OR Direct Capsule Hover */
:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover a.creditCapsule,
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState a.creditCapsule,
:global([data-theme="light"] body.no-glass) a.creditCapsule:hover,
:global([data-theme="light"] body.no-glass) div.creditCapsule:hover {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}

:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover .creditCapsule :global(span),
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState .creditCapsule :global(span),
:global([data-theme="light"] body.no-glass) a.creditCapsule:hover :global(span),
:global([data-theme="light"] body.no-glass) div.creditCapsule:hover :global(span) {
    color: #ffffff !important;
}

:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState .capsuleIcon,
:global([data-theme="light"] body.no-glass) a.creditCapsule:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) div.creditCapsule:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

/* Also ensure title turns Cyan on card hover in light mode */
:global([data-theme="light"] body.no-glass) .livingCardWrapper:hover .cardTitle,
:global([data-theme="light"] body.no-glass) .livingCardWrapper.activeState .cardTitle {
    color: var(--accent) !important;
}

--- END OF FILE components/ArticleCard.module.css ---

================================================================================

--- START OF FILE components/ArticleCard.tsx ---

// components/ArticleCard.tsx
'use client';

import React, { memo, useState, useRef } from 'react';
import Image from 'next/image';
import { motion, useMotionValue, useSpring, AnimatePresence } from 'framer-motion';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useScrollStore } from '@/lib/scrollStore';
import { CardProps } from '@/types';
import { sanityLoader } from '@/lib/sanity.loader';
import { PenEdit02Icon, Calendar03Icon } from '@/components/icons/index';
import { useLivingCard } from '@/hooks/useLivingCard';
import { translateTag } from '@/lib/translations';
import styles from './ArticleCard.module.css';
import { useIsMobile } from '@/hooks/useIsMobile';
import { useActiveCardStore } from '@/lib/activeCardStore';
import { useClickOutside } from '@/hooks/useClickOutside';
import { usePerformanceStore } from '@/lib/performanceStore';
import KineticLink from '@/components/kinetic/KineticLink'; 
import { generateLayoutId } from '@/lib/layoutUtils'; 

const getCreatorName = (creators: any[]): string | null => {
    if (!creators || creators.length === 0) return null;
    return creators[0]?.name || null;
};

// MODIFIED: Accept creatorData prop
const CreatorCapsule = ({ authorName, authorUsername, creatorData }: { authorName: string | null, authorUsername?: string | null, creatorData?: any }) => {
    const content = (
        <>
            <div className={styles.capsuleIcon}>
                <PenEdit02Icon style={{ width: 14, height: 14 }} />
            </div>
            <span title={authorName || ''}>{authorName}</span>
        </>
    );

    if (authorUsername) {
        return (
            <KineticLink 
                href={`/creators/${authorUsername}`}
                slug={authorUsername}
                type="creators"
                className={`${styles.creditCapsule} no-underline`}
                onClick={(e) => e.stopPropagation()} 
                // PASS DATA for instant load
                preloadedData={creatorData}
            >
                {content}
            </KineticLink>
        );
    }
    return (
        <div className={styles.creditCapsule}>
            {content}
        </div>
    );
};

type ArticleCardProps = {
    article: CardProps & { width?: number; height?: number; mainImageRef?: any; };
    layoutIdPrefix: string;
    isPriority?: boolean;
    disableLivingEffect?: boolean; 
    smallTags?: boolean;
};

const ArticleCardComponent = ({ article, layoutIdPrefix, isPriority = false, disableLivingEffect = false, smallTags = false }: ArticleCardProps) => {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix); 
    const setScrollPos = useScrollStore((state) => state.setScrollPos);
    const isMobile = useIsMobile();
    
    const { isLivingCardEnabled, isFlyingTagsEnabled, isHeroTransitionEnabled, isCornerAnimationEnabled, isHoverDebounceEnabled } = usePerformanceStore();
    const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLDivElement>();
    const { activeCardId, setActiveCardId } = useActiveCardStore();

    const [isHoveredLocal, setIsHoveredLocal] = useState(false);
    const [isTextExpanded, setIsTextExpanded] = useState(false);
    
    const hoverTimeout = useRef<NodeJS.Timeout | null>(null);
    const touchTimeout = useRef<NodeJS.Timeout | null>(null);
    const touchStartPos = useRef({ x: 0, y: 0 });

    const isHovered = isMobile ? activeCardId === article.id : isHoveredLocal;

    useClickOutside(livingCardRef, () => {
        if (isMobile && activeCardId === article.id) {
            setActiveCardId(null);
            setIsTextExpanded(false);
        }
    });

    const mouseX = useMotionValue(0);
    const mouseY = useMotionValue(0);
    const smoothMouseX = useSpring(mouseX, { stiffness: 300, damping: 25 });
    const smoothMouseY = useSpring(mouseY, { stiffness: 300, damping: 25 });

    const effectivelyDisabledLiving = disableLivingEffect || !isLivingCardEnabled;

    const handlers = !isMobile ? {
        onMouseMove: (e: React.MouseEvent<HTMLDivElement>) => {
            if (!effectivelyDisabledLiving) {
                livingCardAnimation.onMouseMove(e);
                const rect = e.currentTarget.getBoundingClientRect();
                mouseX.set(e.clientX - rect.left - 75); 
                mouseY.set(e.clientY - rect.top - 75);
            }
        },
        onMouseEnter: () => {
            if (!effectivelyDisabledLiving) livingCardAnimation.onMouseEnter();
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if (!isHoverDebounceEnabled) {
                setIsHoveredLocal(true);
                setIsTextExpanded(true);
            } else {
                hoverTimeout.current = setTimeout(() => {
                    setIsHoveredLocal(true);
                    setIsTextExpanded(true);
                }, 75); 
            }
        },
        onMouseLeave: () => {
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if (!effectivelyDisabledLiving) livingCardAnimation.onMouseLeave();
            setIsHoveredLocal(false);
        }
    } : {
        onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => {
            const touch = e.touches[0];
            touchStartPos.current = { x: touch.clientX, y: touch.clientY };
            if (touchTimeout.current) clearTimeout(touchTimeout.current);
            if (!isHoverDebounceEnabled) {
                if (activeCardId !== article.id) {
                    setActiveCardId(article.id);
                    setIsTextExpanded(true);
                }
            } else {
                touchTimeout.current = setTimeout(() => {
                     if (activeCardId !== article.id) {
                         setActiveCardId(article.id);
                         setIsTextExpanded(true);
                    }
                }, 75);
            }
            if (!effectivelyDisabledLiving) livingCardAnimation.onTouchStart(e);
        },
        onTouchMove: (e: React.TouchEvent<HTMLDivElement>) => {
             const touch = e.touches[0];
             const diffX = Math.abs(touch.clientX - touchStartPos.current.x);
             const diffY = Math.abs(touch.clientY - touchStartPos.current.y);
             if (diffX > 10 || diffY > 10) {
                 if (touchTimeout.current) clearTimeout(touchTimeout.current);
             }
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchMove(e);
        },
        onTouchEnd: () => {
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchEnd();
        },
    };

    const getLinkBasePath = () => {
        switch (article.type) {
            case 'review': return '/reviews/';
            case 'article': return '/articles/';
            case 'news': return '/news/';
            default: return '/';
        }
    };
    const linkPath = `${getLinkBasePath()}${article.slug}`;
    const kineticType = article.type === 'review' ? 'reviews' : article.type === 'article' ? 'articles' : 'news';

    const hasScore = article.type === 'review' && typeof article.score === 'number';
    const author = article.authors?.[0];
    const authorName = author?.name;
    const authorUsername = author?.username;
    
    // Prepare partial data for instant load
    const creatorData = author ? { name: author.name, image: author.image } : undefined;

    const displayTags = article.tags.slice(0, 3);
    
    const satelliteConfig = [
        { hoverX: -110, hoverY: -50, rotate: -12 },
        { hoverX: 100, hoverY: -30, rotate: 12 }, 
        { hoverX: 0, hoverY: -115, rotate: 5 } 
    ];
    
    const animationStyles = !effectivelyDisabledLiving ? livingCardAnimation.style : {};

    const containerLayoutId = !isMobile && isHeroTransitionEnabled ? generateLayoutId(layoutIdPrefix, 'container', article.legacyId) : undefined;
    const imageLayoutId = !isMobile && isHeroTransitionEnabled ? generateLayoutId(layoutIdPrefix, 'image', article.legacyId) : undefined;
    const titleLayoutId = !isMobile && isHeroTransitionEnabled ? generateLayoutId(layoutIdPrefix, 'title', article.legacyId) : undefined;

    return (
        <div
            className={`${styles.livingCardWrapper} ${isHovered ? styles.activeState : ''} ${!isCornerAnimationEnabled ? 'noCornerAnimation' : ''}`}
            ref={livingCardRef}
            {...handlers}
            style={{ zIndex: isHovered ? 500 : 1 }}
        >
            <motion.div
                layoutId={containerLayoutId}
                style={{ height: '100%', position: 'relative', zIndex: 1 }}
            >
                <motion.div
                    className="tilt-container flex flex-col"
                    style={{ ...animationStyles, borderRadius: '16px', height: '100%', transformStyle: 'preserve-3d' }}
                >
                    <div className="no-underline block w-full flex flex-col" style={{ height: '100%', cursor: 'pointer', transformStyle: 'preserve-3d' }}>
                        
                        <KineticLink 
                            href={linkPath} 
                            slug={article.slug}
                            type={kineticType}
                            layoutId={layoutIdPrefix} 
                            imageSrc={article.imageUrl}
                            className={`${styles.cardOverlayLink} no-underline`}
                            onClick={() => {
                                if (!isMobile) {
                                    setScrollPos(window.scrollY);
                                }
                            }}
                        >
                            <span />
                        </KineticLink>

                        <div className={styles.monolithFrame}>
                            <div className={styles.innerClippingFrame}>
                                {!isMobile && (
                                    <motion.div 
                                        className={styles.holoSpotlight} 
                                        style={{ x: smoothMouseX, y: smoothMouseY }} 
                                    />
                                )}
                                
                                {!isMobile && <div className={styles.scanLine} />}

                                <motion.div 
                                    className={styles.imageWrapper}
                                    layoutId={imageLayoutId} 
                                >
                                    <Image 
                                        loader={sanityLoader}
                                        src={article.imageUrl}
                                        alt={article.title}
                                        fill
                                        className={styles.cardImage}
                                        sizes="(max-width: 768px) 90vw, 500px"
                                        // FIX: Conditional blur to prevent crash if data is missing
                                        placeholder={article.blurDataURL ? 'blur' : 'empty'}
                                        blurDataURL={article.blurDataURL}
                                        priority={isPriority}
                                    />
                                </motion.div>

                                {hasScore && (
                                    <motion.div 
                                        className={styles.scoreBadge}
                                        initial={{ scale: 1, rotate: 0 }}
                                        animate={{ scale: isHovered ? 1.2 : 1, rotate: isHovered ? -12 : 0, z: 50 }}
                                        transition={{ type: "spring", stiffness: 300, damping: 15 }}
                                    >
                                        {article.score!.toFixed(1)}
                                    </motion.div>
                                )}

                                <div className={styles.titleOverlay}>
                                    <motion.div 
                                        className={styles.titleMaskWrapper}
                                        initial={{ height: '2.8rem' }} 
                                        animate={{ height: isHovered ? 'auto' : '2.8rem' }}
                                        transition={{ duration: 0.3, ease: "easeOut" }}
                                        onAnimationComplete={() => {
                                            if (!isHovered) {
                                                setIsTextExpanded(false);
                                            }
                                        }}
                                    >
                                        <motion.h3 
                                            className={`${styles.cardTitle} ${isTextExpanded ? styles.expanded : ''}`}
                                            layoutId={titleLayoutId}
                                        >
                                            {article.title}
                                        </motion.h3>
                                    </motion.div>
                                </div>
                            </div> 
                            
                            <div className={styles.cyberCorner} />

                            <div className={styles.hudContainer} style={{ transform: 'translateZ(60px)' }}>
                                 {authorName ? <CreatorCapsule authorName={authorName} authorUsername={authorUsername} creatorData={creatorData} /> : <div />}

                                 <div style={{display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '0.2rem'}}>
                                    {article.date && (
                                        <div className={styles.dateReadout}>
                                            <Calendar03Icon style={{ width: '14px', height: '14px', color: 'var(--accent)' }} />
                                            {article.date.split(' - ')[0]}
                                        </div>
                                    )}
                                    <div className={styles.techDecoration}>
                                        <div className={styles.techDot} />
                                        <div className={styles.techDot} />
                                        <div className={styles.techDot} />
                                    </div>
                                 </div>
                            </div>
                        </div>

                        {isFlyingTagsEnabled && (
                            <div className={styles.satelliteField} style={{ transform: 'translateZ(60px)' }}>
                                <AnimatePresence>
                                    {isHovered && displayTags.map((tag, i) => (
                                         <motion.div
                                            key={`${article.id}-${tag.slug}`}
                                            className={styles.satelliteShard}
                                            initial={{ opacity: 0, scale: 0.4, x: 0, y: 50, z: 0 }}
                                            animate={{ opacity: 1, scale: 1.15, x: satelliteConfig[i]?.hoverX || 0, y: satelliteConfig[i]?.hoverY || 0, rotate: satelliteConfig[i]?.rotate || 0, z: -30 }}
                                            exit={{ opacity: 0, scale: 0.4, x: 0, y: 50, rotate: 0, z: 0 }}
                                            transition={{ type: "spring", stiffness: 180, damping: 20, delay: i * 0.05 }}
                                            style={{ position: 'absolute', left: '50%', top: '50%', transformStyle: 'preserve-3d' }}
                                            onClick={(e) => e.stopPropagation()}
                                         >
                                             <KineticLink 
                                                href={`/tags/${tag.slug}`} 
                                                slug={tag.slug}
                                                type="tags"
                                                onClick={(e) => e.stopPropagation()}
                                                className={`${styles.satelliteShardLink} ${smallTags ? styles.small : ''} no-underline`}
                                             >
                                                 {translateTag(tag.title)}
                                             </KineticLink>
                                         </motion.div>
                                    ))}
                                </AnimatePresence>
                            </div>
                        )}

                    </div>
                </motion.div>
            </motion.div>
        </div>
    );
};

const ArticleCard = memo(ArticleCardComponent);
export default ArticleCard;

--- END OF FILE components/ArticleCard.tsx ---

================================================================================

--- START OF FILE components/AuthOrb.module.css ---

.authOrb {
  position: relative;
  width: 80px;
  height: 80px;
  background-color: var(--bg-secondary);
  border: 2px solid var(--border-color);
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.2s ease-out;
  box-shadow: 0 10px 25px -5px color-mix(in srgb, var(--text-primary) 10%, transparent);
}
.large {
  width: 120px;
  height: 120px;
}
@media (hover: hover) {@media (hover: hover) {
  
  .authOrb:hover:not(:disabled)  {
  border-color: var(--accent);
}
}

  .authOrb:active:not(:disabled)  {
  border-color: var(--accent);
}
}
.authOrb:active:not(:disabled) {
  border-color: var(--accent);
}

.iconWrapper {
  width: 50%;
  height: 50%;
}
.large .iconWrapper {
  width: 45%;
  height: 45%;
}
.icon {
  width: 100%;
  height: 100%;
  color: var(--text-primary);
  filter: grayscale(1) opacity(0.7);
  transition: filter 0.3s ease, color 0.3s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .authOrb:hover:not(:disabled) .icon  {
  filter: grayscale(0) opacity(1);
  color: var(--accent);
}
}

  .authOrb:active:not(:disabled) .icon  {
  filter: grayscale(0) opacity(1);
  color: var(--accent);
}
}
.authOrb:active:not(:disabled) .icon {
  filter: grayscale(0) opacity(1);
  color: var(--accent);
}

.loaderExternal {
  position: absolute;
  width: 130%;
  height: 130%;
  top: 50%;
  left: 50%; /* THE DEFINITIVE FIX: Changed from 'right' to 'left' for correct centering. */
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* ADDED: Mobile responsiveness for orbs */
@media (max-width: 480px) {
  .authOrb {
    width: 64px;
    height: 64px;
  }
  .large {
    width: 96px;
    height: 96px;
  }
  .iconWrapper {
    width: 45%;
    height: 45%;
  }
  .large .iconWrapper {
    width: 40%;
    height: 40%;
  }
}




--- END OF FILE components/AuthOrb.module.css ---

================================================================================

--- START OF FILE components/AuthOrb.tsx ---

// components/AuthOrb.tsx

import { motion, AnimatePresence } from 'framer-motion';
import styles from './AuthOrb.module.css';

const OrbLoader = () => (
    <motion.svg
        className={styles.loaderExternal}
        viewBox="0 0 60 60"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.3 }}
    >
        <motion.circle
            cx="30"
            cy="30"
            r="28"
            fill="none"
            stroke="var(--accent)"
            strokeWidth="2.5"
            strokeLinecap="round"
            pathLength="1"
            strokeDasharray="1"
            strokeDashoffset="0.75"
            initial={{ rotate: -90 }}
            animate={{ rotate: 270 }}
            transition={{ duration: 1.2, repeat: Infinity, ease: "linear" }}
        />
    </motion.svg>
);

interface AuthOrbProps {
    Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
    onClick: () => void;
    ariaLabel: string;
    isLarge?: boolean;
    isLoading?: boolean;
    isDisabled?: boolean;
}

export const AuthOrb = ({ Icon, onClick, ariaLabel, isLarge = false, isLoading = false, isDisabled = false }: AuthOrbProps) => {
    return (
        <motion.button
            onClick={onClick}
            aria-label={ariaLabel}
            disabled={isDisabled}
            className={`${styles.authOrb} ${isLarge ? styles.large : ''}`}
            animate={{
                scale: isLoading ? 1.2 : (isDisabled ? 0.8 : 1),
                opacity: isLoading ? 1 : (isDisabled ? 0.4 : 1),
            }}
            whileHover={!isDisabled ? { scale: 1.1, y: -5 } : {}}
            whileTap={!isDisabled ? { scale: 0.95 } : {}}
            transition={{ type: 'spring' as const, stiffness: 500, damping: 20 }}
            style={{ cursor: isDisabled ? 'default' : 'pointer' }}
        >
            <motion.div
                className={styles.iconWrapper}
                animate={{ opacity: isLoading ? 0.5 : 1 }}
            >
                <Icon className={styles.icon} />
            </motion.div>

            <AnimatePresence>
                {isLoading && <OrbLoader key="loader" />}
            </AnimatePresence>
        </motion.button>
    );
};




--- END OF FILE components/AuthOrb.tsx ---

================================================================================

--- START OF FILE components/AvatarCropperModal.tsx ---

'use client';

import { useState, useRef } from 'react';
import ReactCrop, { type Crop, type PixelCrop } from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import Modal from './modals/Modal'; // <-- THE FIX: Import generic modal
import modalStyles from './modals/Modals.module.css'; // <-- THE FIX: Import modal styles

interface AvatarCropperModalProps {
    isOpen: boolean;
    onClose: () => void;
    imageSrc: string;
    onCropComplete: (file: File) => void;
}

function canvasToFile(canvas: HTMLCanvasElement, fileName: string): Promise<File> {
    return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
            if (!blob) {
                reject(new Error('Canvas is empty'));
                return;
            }
            resolve(new File([blob], fileName, { type: 'image/png' }));
        }, 'image/png');
    });
}

export default function AvatarCropperModal({ isOpen, onClose, imageSrc, onCropComplete }: AvatarCropperModalProps) {
    const imgRef = useRef<HTMLImageElement>(null);
    const [crop, setCrop] = useState<Crop>({ unit: '%', width: 50, height: 50, x: 25, y: 25 });
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();

    const handleCrop = async () => {
        if (!completedCrop || !imgRef.current) return;
        const image = imgRef.current;
        const canvas = document.createElement('canvas');
        const scaleX = image.naturalWidth / image.width;
        const scaleY = image.naturalHeight / image.height;
        canvas.width = completedCrop.width;
        canvas.height = completedCrop.height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.drawImage(image, completedCrop.x * scaleX, completedCrop.y * scaleY, completedCrop.width * scaleX, completedCrop.height * scaleY, 0, 0, completedCrop.width, completedCrop.height);
        try {
            const croppedFile = await canvasToFile(canvas, 'avatar.png');
            onCropComplete(croppedFile);
        } catch (error) {
            console.error("Error creating cropped file:", error);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '600px', width: '100%' }}>
            <h3 style={{ marginTop: 0, marginBottom: '2rem' }}>Crop Your Avatar</h3>
            <div style={{ display: 'flex', justifyContent: 'center', marginBottom: '2rem' }}>
                <ReactCrop crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)} aspect={1} circularCrop>
                    {/* eslint-disable-next-line @next/next/no-img-element */}
                    <img ref={imgRef} alt="Crop me" src={imageSrc} style={{ maxHeight: '70vh' }} />
                </ReactCrop>
            </div>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={handleCrop} className="primary-button">تأكيد</button>
            </div>
        </Modal>
    );
}







--- END OF FILE components/AvatarCropperModal.tsx ---

================================================================================

--- START OF FILE components/BookmarkButton.tsx ---

// components/BookmarkButton.tsx
'use client';

import React from 'react';
import { useUserStore } from '@/lib/store';
import { motion } from 'framer-motion';
import { useSession } from 'next-auth/react';
import ActionButton from './ActionButton';

const iconVariants = {
    unmarked: { scale: 1, rotate: 0 },
    marked: {
        rotate: [0, -5, 5, -2, 2, 0],
        scale: 1,
        transition: { rotate: { duration: 0.5, ease: 'easeInOut' as const } }
    },
};

const fillVariants = {
    unmarked: { opacity: 0, transition: { duration: 0.2 } },
    marked: { opacity: 1, transition: { duration: 0.3, ease: 'easeIn' as const } },
};

const BookmarkIcon = () => (
    <div style={{ position: 'relative', display: 'flex' }}>
        <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </svg>
        <motion.svg
            width="24" height="24" viewBox="0 0 24"
            fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
            style={{ position: 'absolute' }}
            variants={fillVariants}
        >
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" />
        </motion.svg>
    </div>
);

const BookmarkButton = ({ contentId, contentType }: { contentId: number; contentType: string; }) => {
    const { status } = useSession();
    const { bookmarks, toggleBookmark, setSignInModalOpen } = useUserStore();
    
    const contentKey = `${contentType}-${contentId}`;
    const isBookmarked = bookmarks.includes(contentKey);

    const handleClick = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        if (status !== 'authenticated') {
            setSignInModalOpen(true);
            return;
        }
        toggleBookmark(contentId, contentType);
    };

    return (
        <ActionButton
            onClick={handleClick}
            aria-label="إحفظ"
        >
            <motion.div
                initial={false}
                animate={isBookmarked ? "marked" : "unmarked"}
                variants={iconVariants}
            >
                <BookmarkIcon />
            </motion.div>
        </ActionButton>
    );
};

export default BookmarkButton;







--- END OF FILE components/BookmarkButton.tsx ---

================================================================================

--- START OF FILE components/BookmarksGrid.tsx ---

// components/BookmarksGrid.tsx

'use client';

import { useUserStore } from '@/lib/store';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ArticleCard from './ArticleCard';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';

export default function BookmarksGrid({ initialItems }: { initialItems: any[] }) {
    const bookmarksFromStore = useUserStore(state => state.bookmarks);
    
    // THE FIX: Wrap in arrow function and apply width optimization for grid
    const initialBookmarkedItems = initialItems
        .map(item => adaptToCardProps(item, { width: 600 }))
        .filter(Boolean) as CardProps[];
    
    const [bookmarkedItems, setBookmarkedItems] = useState<CardProps[]>(initialBookmarkedItems);

    useEffect(() => {
        // The keys being compared must use the numeric `legacyId`
        // to match the format used in the Zustand store (e.g., 'review-101').
        const currentKeysInGrid = new Set(bookmarkedItems.map(item => `${item.type}-${item.legacyId}`));
        
        if (bookmarksFromStore.length < currentKeysInGrid.size) {
            // An item was removed from the store, so remove it from the displayed grid.
            setBookmarkedItems(prev => prev.filter(item => bookmarksFromStore.includes(`${item.type}-${item.legacyId}`)));
        }
    }, [bookmarksFromStore, bookmarkedItems]);

    if (initialItems.length === 0 && bookmarkedItems.length === 0) {
        return <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>لم تحفظ شيئًا بعد.</p>;
    }

    return (
        <motion.div 
            layout 
            className="content-grid gpu-cull" // Added gpu-cull
            // Note: content-grid in globals.css already has the 3rem padding expansion.
            // Since bookmark cards don't fly out excessively, standard expansion is fine here.
        >
            <AnimatePresence>
                {bookmarkedItems.map(item => (
                    <motion.div
                        key={`bookmark-${item.id}`}
                        layout
                        initial={{ opacity: 0, scale: 0.8 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.8 }}
                        transition={{ type: 'spring' as const, stiffness: 250, damping: 25 }}
                        style={{ height: '100%' }}
                    >
                        <ArticleCard
                            article={item}
                            layoutIdPrefix="bookmark"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </motion.div>
    );
}

--- END OF FILE components/BookmarksGrid.tsx ---

================================================================================

--- START OF FILE components/ConfirmationModal.tsx ---

'use client';

import Modal from './modals/Modal';
import modalStyles from './modals/Modals.module.css';

interface ConfirmationModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => void;
    title: string;
    message: string;
}

export default function ConfirmationModal({ 
    isOpen, 
    onClose, 
    onConfirm, 
    title, 
    message 
}: ConfirmationModalProps) {
    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ padding: '2rem', maxWidth: '450px' }}>
            <h3 style={{ marginTop: 0, fontFamily: 'var(--font-main)', fontSize: '2rem' }}>{title}</h3>
            <p style={{ color: 'var(--text-secondary)', margin: '1rem 0 2rem 0' }}>{message}</p>
            <div className={modalStyles.modalActions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={onConfirm} className="primary-button delete-forever">
                    تأكيد
                </button>
            </div>
        </Modal>
    );
}




--- END OF FILE components/ConfirmationModal.tsx ---

================================================================================

--- START OF FILE components/ContentActionBar.tsx ---

// components/ContentActionBar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import BookmarkButton from './BookmarkButton';
import { motion, AnimatePresence } from 'framer-motion';
import ActionButton from './ActionButton';

const iconVariants = { unliked: { scale: 1 }, liked: { scale: [1, 1.4, 1.1], transition: { duration: 0.4, ease: "easeOut" as const } }, };
const fillVariants = { unliked: { fill: 'rgba(0,0,0,0)', transition: { duration: 0.2 } }, liked: { fill: 'currentColor', transition: { duration: 0.25, delay: 0.1 } }, };
const shockwaveVariants = { unliked: { scale: 0, opacity: 0 }, liked: { scale: 1, opacity: [1, 0], transition: { duration: 0.5, ease: "easeOut" as const } } };
const HeartIcon = ({ isLiked }: { isLiked: boolean }) => ( <motion.div initial={false} animate={isLiked ? "liked" : "unliked"} variants={iconVariants} style={{ position: 'relative', display: 'flex' }}> <motion.div variants={shockwaveVariants} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, border: '2px solid var(--accent)', borderRadius: '50%' }} /> <svg width="24" height="24" viewBox="0 0 24" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <motion.path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" variants={fillVariants} /> </svg> </motion.div> );
const ShareIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>);
const CheckIcon = () => (<svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>);

interface ContentActionBarProps { 
    contentId: number; 
    contentType: 'review' | 'article' | 'news'; 
    contentSlug: string; 
    title: string;
}

export default function ContentActionBar({ contentId, contentType, contentSlug, title }: ContentActionBarProps) {
    const { status } = useSession();
    const { setSignInModalOpen, likes, toggleLike, addShare } = useUserStore();
    const [justCopied, setJustCopied] = useState(false);
    const [hasMounted, setHasMounted] = useState(false);
    
    useEffect(() => { setHasMounted(true); }, []);

    const contentKey = `${contentType}-${contentId}`;
    const isLiked = hasMounted && likes.includes(contentKey);

    const handleLike = () => { if (status !== 'authenticated') { setSignInModalOpen(true); return; } toggleLike(contentId, contentType, contentSlug); };
    
    const handleShare = async () => { 
        const shareData = { 
            title: title, 
            text: title, 
            url: window.location.href 
        }; 
        
        if (navigator.share) { 
            try { 
                await navigator.share(shareData); 
                if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } 
            } catch (error) { 
                console.log('Web Share API canceled or failed.', error); 
            } 
        } else { 
            await navigator.clipboard.writeText(window.location.href); 
            setJustCopied(true); 
            if (status === 'authenticated') { addShare(contentId, contentType, contentSlug); } 
            setTimeout(() => setJustCopied(false), 2000); 
        } 
    };

    if (!hasMounted) { return <div style={{display: 'flex', gap: '1rem', height: '44px'}}><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div><div style={{width:'44px'}}></div></div>; }

    return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
            <ActionButton onClick={handleLike} aria-label={isLiked ? 'Unlike' : 'Like'}><HeartIcon isLiked={isLiked} /></ActionButton>
            <ActionButton onClick={handleShare} aria-label="مشاركة"><AnimatePresence mode="wait" initial={false}><motion.div key={justCopied ? 'check' : 'share'} initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: 10 }} transition={{ duration: 0.2 }}>{justCopied ? <CheckIcon /> : <ShareIcon />}</motion.div></AnimatePresence></ActionButton>
            <BookmarkButton contentId={contentId} contentType={contentType} />
        </div>
    );
}

--- END OF FILE components/ContentActionBar.tsx ---

================================================================================

--- START OF FILE components/ContentBlock.module.css ---

/* components/ContentBlock.module.css */
.contentBlock {
    margin-bottom: 6rem;
}

.contentBlockTitle {
    position: relative; 
    font-size: clamp(2.8rem, 4vw, 3.6rem);
    margin-bottom: 3rem;
    font-weight: 700;
    text-align: right;
    padding-right: 1.5rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
}

.titleIcon {
    color: var(--accent);
    width: 28px;
    height: 28px;
    flex-shrink: 0;
}

.contentBlockTitle span {
    transform: translateY(-2px); 
}

/* --- Kinetic Border and Bloom Pseudo-elements --- */
.contentBlockTitle::before,
.contentBlockTitle::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 4px;
    height: 100%;
    pointer-events: none;
}

.contentBlockTitle::before {
    background-color: var(--accent);
    transform-origin: top;
}

.contentBlockTitle::after {
    box-shadow: 0 0 12px var(--accent);
    transform-origin: top;
}


.contentBlockBody {
    /* Default body styles */
}

/* 
  MODIFIED: 'variantFullbleed' is now completely transparent.
  The container no longer forces a background color, effectively
  letting the content float on the page/space background.
*/
.variantFullbleed {
    width: 100vw;
    position: relative;
    left: 50%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    padding-top: 4rem;
    padding-bottom: 4rem;
    /* REMOVED background-color: var(--bg-secondary) */
    background-color: transparent; 
}

.variantFullbleed .contentBlockTitle {
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
    padding-right: 3.5rem;
    padding-left: 2rem;
}

.variantFullbleed .contentBlockBody {
    padding: 0;
    max-width: none;
}

@media (max-width: 480px) {
    .contentBlockTitle {
        font-size: 2.6rem;
    }
}




--- END OF FILE components/ContentBlock.module.css ---

================================================================================

--- START OF FILE components/ContentBlock.tsx ---

// components/ContentBlock.tsx
'use client';

import React, { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import styles from './ContentBlock.module.css';

type ContentBlockProps = {
    title: string;
    children?: React.ReactNode;
    variant?: 'default' | 'fullbleed';
    Icon?: React.ComponentType<{ className?: string }>;
};

const blockVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.1, // Faster stagger between title and body
        },
    },
};

const titleContainerVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.06, // Stagger between icon and words
            delayChildren: 0.3, // Wait for border to draw
        },
    },
};

const borderVariant = {
    hidden: { scaleY: 0 },
    // THE DEFINITIVE FIX: Added 'as const' to the ease array.
    visible: { scaleY: 1, transition: { duration: 0.4, ease: [0.6, 0.01, -0.05, 0.95] as const } }
};

const titleIconVariant = {
    hidden: { opacity: 0, scale: 0.5 },
    visible: { opacity: 1, scale: 1, transition: { type: 'spring' as const, stiffness: 200, damping: 20 } }
};

const titleWordVariant = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0, transition: { type: 'spring' as const, stiffness: 120, damping: 14 } }
};

const bodyVariants = {
    hidden: { opacity: 0, y: 30 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            duration: 0.7,
            ease: 'easeOut' as const,
            staggerChildren: 0.08,
        },
    },
};

export function ContentBlock({ title, children, variant = 'default', Icon }: ContentBlockProps) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0 });

    const blockClasses = `${styles.contentBlock} ${variant === 'fullbleed' ? styles.variantFullbleed : ''}`;

    return (
        <motion.section
            ref={ref}
            className={blockClasses}
            variants={blockVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            <motion.h2 className={styles.contentBlockTitle} variants={titleContainerVariants}>
                <motion.div className={styles.contentBlockTitle_before} variants={borderVariant} style={{'--pseudo-selector': '::before'} as any} />
                <motion.div className={styles.contentBlockTitle_after} variants={borderVariant} style={{'--pseudo-selector': '::after'} as any} />
                
                {Icon && (
                    <motion.div variants={titleIconVariant} style={{ display: 'flex' }}>
                        <Icon className={styles.titleIcon} />
                    </motion.div>
                )}
                <span style={{ display: 'inline-block' }}>
                    {title.split(' ').map((word, index) => (
                        <motion.span
                            key={index}
                            variants={titleWordVariant}
                            style={{ display: 'inline-block', marginRight: '0.7rem' }}
                        >
                            {word}
                        </motion.span>
                    ))}
                </span>
            </motion.h2>
            {children && (
                <motion.div className={styles.contentBlockBody} variants={bodyVariants}>
                    {children}
                </motion.div>
            )}
        </motion.section>
    );
}




--- END OF FILE components/ContentBlock.tsx ---

================================================================================

--- START OF FILE components/CookieConsent.module.css ---

/* components/CookieConsent.module.css */

.consentBanner {
    position: fixed;
    /* FIX: Changed positioning strategy for absolute center stability */
    bottom: 2rem;
    left: 0;
    right: 0;
    margin: 0 auto;
    
    width: 90%;
    max-width: 900px;
    z-index: 9999;
    
    background-color: rgba(10, 11, 15, 0.85);
    backdrop-filter: blur(16px) saturate(180%);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    padding: 1.5rem 2rem;
    
    box-shadow: 
        0 20px 50px -10px rgba(0,0,0,0.6),
        0 0 0 1px rgba(0, 255, 240, 0.1);
    
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 2rem;
    overflow: hidden;
}

/* The cyan top line */
.consentBanner::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0.6;
}

:global(body.no-glass) .consentBanner {
    backdrop-filter: none !important;
    background-color: #0A0B0F !important;
    border-color: var(--border-color);
}

.content {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    color: var(--text-primary);
    font-size: 1.4rem;
    font-weight: 500;
}

.iconContainer {
    width: 42px;
    height: 42px;
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--accent);
    flex-shrink: 0;
    border: 1px solid color-mix(in srgb, var(--accent) 20%, transparent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 15%, transparent);
}

.textContainer p {
    margin: 0;
    line-height: 1.5;
}

.actions {
    display: flex;
    gap: 1rem;
    flex-shrink: 0;
}

.acceptBtn {
    background-color: var(--accent);
    color: #050505;
    font-weight: 800;
    border: none;
    padding: 0.8rem 2.2rem;
    border-radius: 8px;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.4rem;
    transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 40%, transparent);
}

.declineBtn {
    background: rgba(255, 255, 255, 0.05);
    color: var(--text-secondary);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 0.8rem 1.5rem;
    border-radius: 8px;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.4rem;
    transition: all 0.2s ease;
    font-weight: 600;
}

.settingsBtn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    text-decoration: underline;
    text-decoration-color: color-mix(in srgb, var(--text-secondary) 30%, transparent);
    cursor: pointer;
    padding: 0.5rem;
    font-size: 1.3rem;
    transition: color 0.2s;
    margin-right: 1rem;
}

@media (hover: hover) {
    .acceptBtn:hover { 
        transform: translateY(-2px); 
        box-shadow: 0 5px 20px color-mix(in srgb, var(--accent) 60%, transparent);
    }
    .declineBtn:hover { 
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
        border-color: var(--text-primary);
    }
    .settingsBtn:hover {
        color: var(--accent);
        text-decoration-color: var(--accent);
    }
}

@media (max-width: 860px) {
    .consentBanner {
        flex-direction: column;
        align-items: flex-start;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        max-width: 100%;
        border-radius: 20px 20px 0 0;
        border-bottom: none;
        padding: 2.5rem 2rem;
        margin: 0; /* Reset margin on mobile */
    }
    
    .actions {
        width: 100%;
        margin-top: 1rem;
        justify-content: stretch;
        display: grid;
        grid-template-columns: 1fr 1fr;
    }
    
    .settingsBtn {
        grid-column: 1 / -1;
        text-align: center;
        margin: 0;
        padding: 1rem;
    }
}

--- END OF FILE components/CookieConsent.module.css ---

================================================================================

--- START OF FILE components/CookieConsent.tsx ---

// components/CookieConsent.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { setConsent } from '@/lib/gtm'; 
import styles from './CookieConsent.module.css';
import CookieSettingsModal from './CookieSettingsModal';

const CookieIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5" />
        <path d="M8.5 8.5v.01" />
        <path d="M16 15.5v.01" />
        <path d="M12 12v.01" />
        <path d="M11 17v.01" />
        <path d="M7 14v.01" />
    </svg>
);

export default function CookieConsent() {
    const [showBanner, setShowBanner] = useState(false);
    const [showSettings, setShowSettings] = useState(false);

    useEffect(() => {
        const stored = localStorage.getItem('eternal_cookie_consent');
        
        if (stored) {
            try {
                const prefs = JSON.parse(stored);
                setConsent(prefs);
            } catch (e) {
                if (stored === 'granted') setConsent({ analytics: true, marketing: true });
            }
        } else {
            const timer = setTimeout(() => setShowBanner(true), 2500); // Delayed slightly more for intro animations
            return () => clearTimeout(timer);
        }
    }, []);

    const handleAcceptAll = () => {
        const prefs = { analytics: true, marketing: true };
        localStorage.setItem('eternal_cookie_consent', JSON.stringify(prefs));
        setConsent(prefs);
        setShowBanner(false);
    };

    const handleDeclineAll = () => {
        const prefs = { analytics: false, marketing: false };
        localStorage.setItem('eternal_cookie_consent', JSON.stringify(prefs));
        setConsent(prefs);
        setShowBanner(false);
    };

    const handleSavePreferences = (prefs: { analytics: boolean; marketing: boolean }) => {
        localStorage.setItem('eternal_cookie_consent', JSON.stringify(prefs));
        setConsent(prefs);
        setShowBanner(false);
    };

    return (
        <>
            <AnimatePresence>
                {showBanner && (
                    <motion.div
                        className={styles.consentBanner}
                        initial={{ y: 100, opacity: 0, scale: 0.95 }}
                        animate={{ y: 0, opacity: 1, scale: 1 }}
                        exit={{ y: 100, opacity: 0, scale: 0.95 }}
                        transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                    >
                        <div className={styles.content}>
                            <div className={styles.iconContainer}><CookieIcon /></div>
                            <div className={styles.textContainer}>
                                <p>
                                    نستخدم ملفات تعريف الارتباط لتحسين تجربتك في EternalGames.
                                </p>
                            </div>
                        </div>
                        <div className={styles.actions}>
                            <button onClick={() => setShowSettings(true)} className={styles.settingsBtn}>تخصيص</button>
                            <button onClick={handleDeclineAll} className={styles.declineBtn}>رفض الكل</button>
                            <button onClick={handleAcceptAll} className={styles.acceptBtn}>موافق</button>
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
            
            <CookieSettingsModal 
                isOpen={showSettings} 
                onClose={() => setShowSettings(false)} 
                onSave={handleSavePreferences} 
            />
        </>
    );
}

--- END OF FILE components/CookieConsent.tsx ---

================================================================================

--- START OF FILE components/CookieSettingsModal.module.css ---

/* components/CookieSettingsModal.module.css */

.container {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
    margin: 2rem 0;
}

/* THE NEW CARD BUTTON */
.preferenceCard {
    width: 100%;
    background-color: rgba(255, 255, 255, 0.02);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1.8rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    text-align: right;
    transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    overflow: hidden;
    user-select: none;
}

/* Hover Effect */
@media (hover: hover) {
    .preferenceCard:hover {
        background-color: rgba(255, 255, 255, 0.05);
        transform: translateY(-2px);
    }
}

/* Active (Selected) State */
.preferenceCard.active {
    background-color: color-mix(in srgb, var(--accent) 8%, transparent);
    border-color: var(--accent);
    box-shadow: 0 0 20px -5px color-mix(in srgb, var(--accent) 20%, transparent);
}

/* Disabled (Required) State */
.preferenceCard.disabled {
    cursor: default;
    opacity: 0.8;
}
@media (hover: hover) {
    .preferenceCard.disabled:hover {
        transform: none;
    }
}

.labelContainer {
    flex-grow: 1;
    padding-left: 2rem;
}

.headerRow {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.5rem;
}

.title {
    font-family: var(--font-main);
    font-size: 1.7rem;
    font-weight: 700;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.2s;
}

.preferenceCard.active .title {
    color: var(--accent);
}

.badge {
    font-size: 1rem;
    padding: 0.3rem 0.8rem;
    border-radius: 4px;
    background: var(--border-color);
    color: var(--text-secondary);
    font-weight: 700;
    letter-spacing: 0.5px;
}

.preferenceCard.required .badge {
    background-color: var(--accent);
    color: #000;
    border: none;
}

.description {
    font-size: 1.3rem;
    color: var(--text-secondary);
    margin: 0;
    line-height: 1.5;
}

/* --- THE STATUS INDICATOR (Replaces the Toggle) --- */
.statusIndicator {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.6rem 1.2rem;
    border-radius: 99px;
    background-color: rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    transition: all 0.3s ease;
}

.statusDot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--text-secondary);
    transition: all 0.3s ease;
}

.statusText {
    font-family: var(--font-ui);
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-secondary);
    transition: color 0.3s ease;
}

/* Active Status Styles */
.preferenceCard.active .statusIndicator {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
}

.preferenceCard.active .statusDot {
    background-color: var(--accent);
    box-shadow: 0 0 8px var(--accent);
}

.preferenceCard.active .statusText {
    color: var(--accent);
}

/* Action Bar */
.actions {
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
    margin-top: 1rem;
}

.saveButton {
    background-color: var(--accent);
    color: #000;
    font-weight: 800;
    padding: 1rem 3rem;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.4rem;
    transition: transform 0.2s, box-shadow 0.2s;
}

.saveButton:hover {
    transform: scale(1.02);
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 40%, transparent);
}

--- END OF FILE components/CookieSettingsModal.module.css ---

================================================================================

--- START OF FILE components/CookieSettingsModal.tsx ---

// components/CookieSettingsModal.tsx
'use client';

import { useState } from 'react';
import Modal from '@/components/modals/Modal';
import { motion } from 'framer-motion';
import styles from './CookieSettingsModal.module.css';

interface CookieSettingsModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSave: (preferences: { analytics: boolean; marketing: boolean }) => void;
}

interface OptionCardProps {
    title: string;
    description: string;
    isActive: boolean;
    isRequired?: boolean;
    onClick?: () => void;
}

const LockIcon = () => (
    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
    </svg>
);

const OptionCard = ({ title, description, isActive, isRequired, onClick }: OptionCardProps) => {
    const [isShaking, setIsShaking] = useState(false);

    const handleClick = () => {
        if (isRequired) {
            // Trigger the "Deny" animation
            setIsShaking(true);
            setTimeout(() => setIsShaking(false), 500);
        } else {
            onClick?.();
        }
    };

    // Animation for "Denied/Locked" state
    const shakeVariants = {
        idle: { x: 0, borderColor: 'var(--border-color)' },
        shake: { 
            x: [0, -6, 6, -6, 6, 0], 
            borderColor: '#DC2626', // Flash Red
            transition: { duration: 0.4 } 
        }
    };

    // Standard styling logic
    const activeClass = isActive ? styles.active : '';
    const disabledClass = isRequired ? styles.disabled : '';
    const requiredClass = isRequired ? styles.required : '';
    // If it's shaking (denied), temporarily remove the 'active' blue/cyan styling to show the red flash clearly
    const appliedClasses = `${styles.preferenceCard} ${isShaking ? '' : activeClass} ${disabledClass} ${requiredClass}`;

    return (
        <motion.div 
            className={appliedClasses}
            onClick={handleClick}
            variants={shakeVariants}
            animate={isShaking ? "shake" : "idle"}
            whileTap={!isRequired ? { scale: 0.98 } : {}}
            style={{ cursor: isRequired ? 'not-allowed' : 'pointer' }}
            role="button"
            aria-pressed={isActive}
            aria-disabled={isRequired}
        >
            <div className={styles.labelContainer}>
                <div className={styles.headerRow}>
                    <h4 className={styles.title}>{title}</h4>
                    {isRequired && (
                        <span className={styles.badge} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <LockIcon /> إلزامي
                        </span>
                    )}
                </div>
                <p className={styles.description}>{description}</p>
            </div>

            <div className={styles.statusIndicator} style={isShaking ? { borderColor: '#DC2626', backgroundColor: 'rgba(220, 38, 38, 0.1)' } : {}}>
                <div 
                    className={styles.statusDot} 
                    style={isShaking ? { backgroundColor: '#DC2626', boxShadow: '0 0 10px #DC2626' } : {}} 
                />
                <span 
                    className={styles.statusText}
                    style={isShaking ? { color: '#DC2626' } : {}}
                >
                    {isShaking ? 'مقفل' : (isActive ? 'مفعل' : 'معطل')}
                </span>
            </div>
        </motion.div>
    );
};

export default function CookieSettingsModal({ isOpen, onClose, onSave }: CookieSettingsModalProps) {
    const [analytics, setAnalytics] = useState(true);
    const [marketing, setMarketing] = useState(false);

    const handleSave = () => {
        onSave({ analytics, marketing });
        onClose();
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '600px' }}>
            <div style={{ textAlign: 'center', marginBottom: '2.5rem' }}>
                <h3 style={{ marginTop: 0, marginBottom: '0.5rem', fontFamily: 'var(--font-heading)', fontSize: '2.4rem' }}>
                    مركز التحكم بالخصوصية
                </h3>
                <p style={{ color: 'var(--text-secondary)', fontSize: '1.4rem' }}>
                    بياناتك، قراراتك. اختر ما تشاركه معنا لتحسين تجربتك.
                </p>
            </div>

            <div className={styles.container}>
                <OptionCard 
                    title="ملفات ضرورية"
                    description="لازمة لعمل الموقع الأساسي (تسجيل الدخول، الأمان، وحفظ هذه التفضيلات). لا يمكن تعطيلها."
                    isActive={true}
                    isRequired={true}
                />

                <OptionCard 
                    title="التحليلات والأداء"
                    description="تساعدنا في فهم الصفحات الأكثر زيارة وإصلاح الأخطاء التقنية."
                    isActive={analytics}
                    onClick={() => setAnalytics(!analytics)}
                />

                <OptionCard 
                    title="التسويق والتخصيص"
                    description="تستخدم لتقديم محتوى أو عروض تناسب اهتماماتك."
                    isActive={marketing}
                    onClick={() => setMarketing(!marketing)}
                />
            </div>

            <div className={styles.actions}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={handleSave} className={styles.saveButton}>
                    حفظ التغييرات
                </button>
            </div>
        </Modal>
    );
}

--- END OF FILE components/CookieSettingsModal.tsx ---

================================================================================

--- START OF FILE components/CreatorCredit.module.css ---

/* components/CreatorCredit.module.css */

.creatorsWrapper {
    display: flex;
    flex-wrap: wrap;
    gap: 0.8rem;
    justify-content: flex-start; /* Align right in RTL */
    margin-bottom: 0.2rem;
}

/* --- CAPSULE STYLES (MATCHING CARDS) --- */
.creditCapsule {
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
    background: rgba(10, 11, 15, 0.8);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 0;
    border-radius: 999px;
    height: 32px;
    backdrop-filter: blur(8px);
    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    padding-left: 1.2rem;
    text-decoration: none;
    cursor: pointer;
    z-index: 10;
}

:global(body.no-glass) .creditCapsule {
    backdrop-filter: none !important;
    background-color: rgba(10, 11, 15, 0.95) !important;
}

/* Mobile Opt: Kill Blur */
@media (max-width: 768px) {
    .creditCapsule {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(10, 11, 15, 0.95);
    }
}

/* Hover Effects (Default / Dark Mode) */
@media (hover: hover) {
    .creditCapsule:hover {
        background-color: var(--accent);
        border-color: var(--accent);
        box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
        transform: translateY(-2px) scale(1.02);
        z-index: 20;
    }
    
    /* FIX: Force override for no-glass mode to ensure cyan background on hover */
    :global(body.no-glass) .creditCapsule:hover {
        background-color: var(--accent) !important;
        border-color: var(--accent) !important;
    }

    /* Invert colors on hover (Dark Mode -> Icon becomes Black) */
    .creditCapsule:hover .capsuleIcon {
        background-color: #000;
        color: var(--accent);
        box-shadow: none;
    }
    
    :global(body.no-glass) .creditCapsule:hover .capsuleIcon {
        background-color: #000 !important;
        color: var(--accent) !important;
    }

    .creditCapsule:hover .creatorName {
        color: #000;
    }
    
    :global(body.no-glass) .creditCapsule:hover .creatorName {
        color: #000 !important;
    }
}

.creditCapsule:active {
    transform: scale(0.98);
}

.capsuleIcon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: var(--accent);
    color: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: color 0.4s ease, background-color 0.4s ease, box-shadow 0.4s ease;
    margin: -1px; /* Slight offset to overlap border cleanly */
}

.capsuleIcon svg {
    width: 14px;
    height: 14px;
}

.creatorName {
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
    white-space: nowrap;
    padding-right: 0.2rem;
    transition: color 0.4s ease;
    font-family: var(--font-main);
}

/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .creditCapsule {
  background: #ffffff !important; /* Force White BG Default */
  border-color: rgba(0,0,0,0.1);
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .creditCapsule :global(span),
:global([data-theme="light"]) .creatorLink,
:global([data-theme="light"]) .creatorName,
:global([data-theme="light"]) .label,
:global([data-theme="light"]) .separator {
  color: var(--accent) !important; /* Force Cyan Text Default */
}
:global([data-theme="light"]) .capsuleIcon {
  color: #fff !important;
  background-color: var(--accent) !important; /* Cyan Circle Default */
}

/* Light Mode Hover States (THE FIX: NO BLACK) */
:global([data-theme="light"]) .creditCapsule:hover {
  background-color: var(--accent) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 5px 20px color-mix(in srgb, var(--accent) 40%, transparent);
}
:global([data-theme="light"]) .creditCapsule:hover .creatorLink,
:global([data-theme="light"]) .creditCapsule:hover :global(span),
:global([data-theme="light"]) .creditCapsule:hover .creatorName,
:global([data-theme="light"]) .creditCapsule:hover .label,
:global([data-theme="light"]) .creditCapsule:hover .separator {
  color: #fff !important; /* Force White Text */
}
:global([data-theme="light"]) .creditCapsule:hover .capsuleIcon {
  background-color: #ffffff !important; /* Force White Icon Background */
  color: var(--accent) !important; /* Cyan Icon */
}

/* No-glass overrides */
:global([data-theme="light"] body.no-glass) .creditCapsule {
  background-color: #ffffff !important;
}
:global([data-theme="light"] body.no-glass) .creditCapsule:hover {
  background-color: var(--accent) !important;
}

--- END OF FILE components/CreatorCredit.module.css ---

================================================================================

--- START OF FILE components/CreatorCredit.tsx ---

// components/CreatorCredit.tsx
'use client';

import React from 'react';
import type { SanityAuthor } from '@/types/sanity';
import { PenEdit02Icon, ColorPaletteIcon } from '@/components/icons/index';
import styles from './CreatorCredit.module.css';
import { useContentStore } from '@/lib/contentStore'; 
import KineticLink from '@/components/kinetic/KineticLink';

export default function CreatorCredit({ label, creators, disableLink = false }: { 
    label: string; 
    creators: SanityAuthor[] | null | undefined;
    small?: boolean; 
    disableLink?: boolean;
}) {
    const safeCreators = Array.isArray(creators) ? creators : [];
    const { creatorMap } = useContentStore(); 

    const enrichedCreators = safeCreators.map(creator => {
        if (creator.username) return creator;
        // Try to resolve username from store if missing in prop
        if (creator.prismaUserId) {
            for (const c of creatorMap.values()) {
                if (c.prismaUserId === creator.prismaUserId && c.username) {
                    return { ...creator, username: c.username };
                }
            }
        }
        if (creator._id) {
             for (const c of creatorMap.values()) {
                 if (c._id === creator._id && c.username) {
                     return { ...creator, username: c.username };
                 }
             }
        }
        return creator;
    });

    if (!enrichedCreators || enrichedCreators.length === 0) {
        return null;
    }

    const IconComponent = label === 'تصميم' ? ColorPaletteIcon : PenEdit02Icon;

    return (
        <div className={styles.creatorsWrapper}>
            {enrichedCreators.map((creator) => {
                const content = (
                    <>
                        <div className={styles.capsuleIcon}>
                            <IconComponent style={{ width: 14, height: 14 }} />
                        </div>
                        <span className={styles.creatorName}>{creator.name}</span>
                    </>
                );
                
                // Construct partial data to seed the store instantly
                const creatorData = { name: creator.name, image: creator.image };

                if (creator.username && !disableLink) {
                    return (
                        <KineticLink 
                            key={creator._id}
                            href={`/creators/${creator.username}`}
                            slug={creator.username}
                            type="creators"
                            className={`${styles.creditCapsule} no-underline`}
                            onClick={(e) => e.stopPropagation()} 
                            // PASS PRELOADED DATA
                            preloadedData={creatorData}
                        >
                            {content}
                        </KineticLink>
                    );
                }

                return (
                    <div key={creator._id} className={styles.creditCapsule}>
                        {content}
                    </div>
                );
            })}
        </div>
    );
}

--- END OF FILE components/CreatorCredit.tsx ---

================================================================================

--- START OF FILE components/CreatorHubClient.tsx ---

// components/CreatorHubClient.tsx
'use client';

import React, { useEffect, useLayoutEffect, RefObject } from 'react';
import HubPageClient from '@/components/HubPageClient';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import Link from 'next/link';

interface CreatorHubClientProps {
    creatorName: string;
    username: string;
    image?: string | null;
    bio?: string | null;
    items: any[];
    scrollContainerRef?: RefObject<HTMLElement | null>;
    isLoading?: boolean; // Accept isLoading here
}

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

export default function CreatorHubClient({
    creatorName,
    username,
    image,
    bio,
    items,
    scrollContainerRef,
    isLoading
}: CreatorHubClientProps) {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);

    // Reset scroll on mount
    useIsomorphicLayoutEffect(() => { 
        if (scrollContainerRef?.current) {
            scrollContainerRef.current.scrollTop = 0;
        }
    }, [scrollContainerRef]);

    useEffect(() => {
        return () => setPrefix('default');
    }, [setPrefix]);

    return (
        <HubPageClient
            initialItems={items}
            hubTitle={creatorName}
            hubType="أعمال"
            synopsis={bio}
            fallbackImage={image}
            scrollContainerRef={scrollContainerRef}
            headerAction={
                 <Link 
                    href={`/profile/${username}`} 
                    className="outline-button no-underline" 
                    style={{ backgroundColor: 'color-mix(in srgb, var(--bg-secondary) 80%, transparent)', backdropFilter: 'blur(4px)' }} 
                    prefetch={false}
                >
                    → الملف الشخصي
                </Link>
            }
            isLoading={isLoading} // Pass it down
        />
    );
}

--- END OF FILE components/CreatorHubClient.tsx ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.module.css ---

/* components/DigitalAtriumHomePage.module.css */
.atriumPageContainer {
  position: relative;
  width: 100%;
  padding-top: var(--nav-height-scrolled);
}

.vanguardFullBleedContainer {
    /* REMOVED: background-color: var(--bg-secondary); */
    background-color: transparent; /* Force transparent for floating look */
    padding-top: 4rem;
    /* FIX: Set margin-bottom to user request (8rem) */
    margin-bottom: 8rem;
    overflow-x: clip; 
}

.atriumMainContent {
  padding-bottom: 8rem;
}

.homeGrid {
  display: grid;
  grid-template-columns: 1fr 1.75fr;
  gap: 4rem;
  margin-bottom: 8rem;
}

@media (max-width: 1024px) {
  .homeGrid {
    grid-template-columns: 1fr;
    gap: 8rem;
  }
}

@media (max-width: 768px) {
    .vanguardFullBleedContainer {
        margin-bottom: 3rem;
    }
    .atriumMainContent {
        padding-bottom: 4rem;
    }
}

--- END OF FILE components/DigitalAtriumHomePage.module.css ---

================================================================================

--- START OF FILE components/DigitalAtriumHomePage.tsx ---

// components/DigitalAtriumHomePage.tsx
'use client';

import React, { Suspense, memo } from 'react';
import { ContentBlock } from './ContentBlock';
import VanguardReviews from './VanguardReviews/VanguardReviews';
import { adaptToCardProps } from '@/lib/adapters';
import { ReviewIcon, ReleaseIcon } from '@/components/icons/index';
import styles from './DigitalAtriumHomePage.module.css';
import { CardProps } from '@/types';

const DigitalAtriumHomePage = memo(function DigitalAtriumHomePage({
    reviews,
    feedsContent,
    releasesSection
}: {
    reviews: any[];
    feedsContent: React.ReactNode;
    releasesSection: React.ReactNode;
}) {
  // LIMIT: Slice to top 10 items for the Vanguard carousel
  const adaptedReviews = (reviews || [])
      .slice(0, 10)
      .map(item => adaptToCardProps(item, { width: 800 }))
      .filter(Boolean) as CardProps[];
  
  return (
    <div className={styles.atriumPageContainer}>
      <div className={styles.vanguardFullBleedContainer}>
        <div className="container">
            <ContentBlock title="أحدث المراجعات" Icon={ReviewIcon} />
        </div>
        <VanguardReviews reviews={adaptedReviews} />
      </div>
      
      <div className={styles.atriumMainContent}>
          <div className="container">
              {feedsContent}
          </div>
          
          <ContentBlock title="إصدارات هذا الشهر" Icon={ReleaseIcon} variant="fullbleed">
              <div className="container">
                  <p style={{textAlign: 'center', maxWidth: '600px', margin: '-2rem auto 4rem auto', color: 'var(--text-secondary)'}}>
                      نظرة على الألعاب التي ترى النور هذا الشهر. ما صدر منها قد وُسِمَ بعلامة.
                  </p>
                  <Suspense fallback={null}>
                      {releasesSection}
                  </Suspense>
              </div>
          </ContentBlock>
      </div>
    </div>
  );
});

export default DigitalAtriumHomePage;

--- END OF FILE components/DigitalAtriumHomePage.tsx ---

================================================================================

--- START OF FILE components/FPSAutoTuner.tsx ---

// components/FPSAutoTuner.tsx
'use client';

import { useEffect, useRef } from 'react';
import { usePerformanceStore, PerformanceTier } from '@/lib/performanceStore';
import { useIsMobile } from '@/hooks/useIsMobile';
import { useToast } from '@/lib/toastStore';

// CONFIGURATION
const CHECK_INTERVAL = 1000; // Check every second
const STABILIZATION_TIME = 5000; // Wait 5s before first check
const COOLDOWN_TIME = 10000; // Wait 10s after changing tier before checking again

// THRESHOLDS
const DESKTOP_LOW_FPS = 40; // Drop to Tier 5 (No Flying Tags)
const DESKTOP_CRITICAL_FPS = 15; // Drop to Tier 0 (All Off)

const MOBILE_LOW_FPS = 35;
const MOBILE_CRITICAL_FPS = 15;

export default function FPSAutoTuner() {
    const isMobile = useIsMobile();
    const toast = useToast();
    
    const { 
        isAutoTuningEnabled, 
        setPerformanceTier,
        isGlassmorphismEnabled,
        isFlyingTagsEnabled,
        isBackgroundVisible
    } = usePerformanceStore();

    // Determine current logical tier
    const getCurrentTier = (): PerformanceTier => {
        if (!isBackgroundVisible) return 0;
        if (!isFlyingTagsEnabled) return 5;
        if (isFlyingTagsEnabled && isGlassmorphismEnabled) return 6;
        return 6; // Default to max if ambiguous
    };

    const rafId = useRef<number>(0);
    const lastCheckTime = useRef<number>(0);
    const frameCount = useRef<number>(0);
    const startTime = useRef<number>(0);
    const lastTierChange = useRef<number>(0);
    
    // Critical failure counter
    const criticalFailures = useRef<number>(0);

    useEffect(() => {
        if (!isAutoTuningEnabled) {
            cancelAnimationFrame(rafId.current);
            return;
        }

        // Reset counters on mount/enable
        frameCount.current = 0;
        startTime.current = performance.now();
        lastCheckTime.current = performance.now();
        lastTierChange.current = performance.now();
        criticalFailures.current = 0;

        const loop = () => {
            rafId.current = requestAnimationFrame(loop);
            const now = performance.now();
            frameCount.current++;

            // Wait for initialization grace period
            if (now - startTime.current < STABILIZATION_TIME) return;

            // Wait for cooldown after a change
            if (now - lastTierChange.current < COOLDOWN_TIME) return;

            const elapsed = now - lastCheckTime.current;

            if (elapsed >= CHECK_INTERVAL) {
                const fps = Math.round((frameCount.current * 1000) / elapsed);
                const currentTier = getCurrentTier();

                const LOW_THRESHOLD = isMobile ? MOBILE_LOW_FPS : DESKTOP_LOW_FPS;
                const CRITICAL_THRESHOLD = isMobile ? MOBILE_CRITICAL_FPS : DESKTOP_CRITICAL_FPS;

                // 1. CRITICAL CHECK (Unusable Site)
                if (fps < CRITICAL_THRESHOLD) {
                    criticalFailures.current++;
                    
                    // If consistent critical failure (2 seconds in a row)
                    if (criticalFailures.current >= 2 && currentTier > 0) {
                        console.warn(`[AutoTuner] 🚨 Critical FPS (${fps}). Emergency Drop to Tier 0.`);
                        setPerformanceTier(0);
                        toast.error("تم تعطيل المؤثرات لضمان استقرار الموقع.", "left");
                        lastTierChange.current = now;
                        criticalFailures.current = 0;
                    }
                } else {
                    criticalFailures.current = 0; // Reset critical counter if we survived a second
                }

                // 2. LOW PERFORMANCE CHECK (Disable Flying Tags)
                // Only if we are at max tier (6)
                if (fps < LOW_THRESHOLD && currentTier === 6) {
                    console.warn(`[AutoTuner] 📉 Low FPS (${fps}). Disabling Flying Tags.`);
                    setPerformanceTier(5);
                    lastTierChange.current = now;
                }

                // Reset for next interval
                frameCount.current = 0;
                lastCheckTime.current = now;
            }
        };

        rafId.current = requestAnimationFrame(loop);

        return () => cancelAnimationFrame(rafId.current);
    }, [isAutoTuningEnabled, isMobile, setPerformanceTier, isGlassmorphismEnabled, isFlyingTagsEnabled, isBackgroundVisible]);

    return null;
}

--- END OF FILE components/FPSAutoTuner.tsx ---

================================================================================

--- START OF FILE components/Footer.module.css ---

/* components/Footer.module.css */

.footer {
  background-color: var(--bg-secondary);
  border-top: 1px solid var(--border-color);
  
  /* REMOVED: content-visibility: auto; - Causing scroll jump issues */
}
/* ... rest of existing CSS ... */
.newFooterLayout {
  padding: 4rem 0;
}
.footerContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2.5rem;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 2rem;
}
.footerSocialsWrapper {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
}
.footerDivider {
  width: 60px;
  height: 1px;
  background-color: var(--border-color);
  margin: 0 auto;
}
.footerInfo {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1.5rem;
  font-size: 1.4rem;
  color: var(--text-secondary);
  flex-wrap: wrap;
}
.footerCopyright, .footerInfo a {
  margin: 0;
}
.designerCredit {
  display: inline-flex;
  align-items: center;
  gap: 0.7rem;
  color: var(--text-primary);
  transition: color 0.3s ease, transform 0.3s ease;
}
@media (hover: hover) {
  
  .designerCredit:hover  {
  color: var(--accent);
  transform: translateY(-2px);
}
}
.designerCredit:active {
  color: var(--accent);
  transform: translateY(-2px);
}

.designerIcon {
  width: 14px;
  height: 14px;
}
.infoSeparator {
  font-weight: 300;
}
.footerSocialsWrapper a {
  transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1);
}
@media (hover: hover) {
  
  .footerSocialsWrapper a:hover  {
  filter: none !important;
  transform: translateY(-4px); 
}
}
.footerSocialsWrapper a:active {
  filter: none !important;
  transform: translateY(-4px); 
}

.socialLinkFrame {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  background-color: transparent;
  transition: all 0.2s ease-out;
  flex-shrink: 0;
}
@media (hover: hover) {
  
  .footerSocialsWrapper a:hover .socialLinkFrame  {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  color: var(--accent);
}
}
.footerSocialsWrapper a:active .socialLinkFrame {
  background-color: var(--bg-secondary);
  border-color: var(--accent);
  color: var(--accent);
}

.socialIconSvg {
  width: 20px;
  height: 20px;
}

@media (max-width: 768px) {
  .newFooterLayout {
    padding: 3rem 0;
  }
  .footerContainer {
    gap: 2rem;
  }
  .footerInfo {
    flex-direction: column;
    gap: 4rem;
  }
  .infoSeparator {
    display: none;
  }
  .footerSocialsWrapper {
    gap: 1rem;
  }
}

--- END OF FILE components/Footer.module.css ---

================================================================================

--- START OF FILE components/Footer.tsx ---

// components/Footer.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import styles from './Footer.module.css';

// ... (Icons remain same)
const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 1200 1227" fill="currentColor" {...props}>
<g transform="scale(0.8) translate(150, 150)">
<path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
</g>
</svg>
);
const TikTokIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="80 80 320 320" fill="currentColor" {...props}>
<path d="M207.26,200.54c3.77,0,7.48.28,11.1.81v43.65c-3.47-1.22-7.21-1.88-11.1-1.88-18.55,0-33.59,15.04-33.59,33.59s15.04,33.59,33.59,33.59,33.59-15.04,33.59-33.59V113.28h42.83c-.06,1.09-.1,2.19-.1,3.3,0,30.64,24.84,55.48,55.48,55.48v40.79c-20.73,0-39.92-6.55-55.63-17.7v81.57c0,42.07-34.11,76.17-76.17,76.17s-76.17-34.11-76.17-76.17,34.1-76.17,76.17-76.17"/>
</svg>
);
const YouTubeIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M21.58 7.19a2.5 2.5 0 0 0-1.76-1.77C18.25 5 12 5 12 5s-6.25 0-7.82.42a2.5 2.5 0 0 0-1.76 1.77A26.12 26.12 0 0 0 2 12s0 4.25.42 5.81a2.5 2.5 0 0 0 1.76 1.77C5.75 20 12 20 12 20s6.25 0 7.82-.42a2.5 2.5 0 0 0 1.76-1.77A26.12 26.12 0 0 0 22 12s0-4.25-.42-4.81zM9.75 15.5v-7l6 3.5-6 3.5z"/>
</svg>
);
const InstagramIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M7.8 2h8.4C19.4 2 22 4.6 22 7.8v8.4a5.8 5.8 0 0 1-5.8 5.8H7.8C4.6 22 2 19.4 2 16.2V7.8A5.8 5.8 0 0 1 7.8 2m-.2 2A3.6 3.6 0 0 0 4 7.6v8.8C4 18.39 5.61 20 7.6 20h8.8a3.6 3.6 0 0 0 3.6-3.6V7.6C20 5.61 18.39 4 16.4 4H7.6m9.65 1.5a1.25 1.25 0 0 1 1.25 1.25A1.25 1.25 0 0 1 17.25 8 1.25 1.25 0 0 1 16 6.75a1.25 1.25 0 0 1 1.25-1.25M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z"/>
</svg>
);
const FacebookIcon = (props: React.SVGProps<SVGSVGElement>) => (
<svg viewBox="0 0 24 24" fill="currentColor" {...props}>
<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
</svg>
);

const Footer = () => {
  const pathname = usePathname();
  const isStudioEditor = /^\/studio\/(reviews|articles|news|releases|social-templates)\/.+/.test(pathname);

  if (isStudioEditor) return null;

  return (
    <footer className={`${styles.footer} ${styles.newFooterLayout}`}>
      <div className={`container ${styles.footerContainer}`}>
        <div className={`${styles.footerSocialsWrapper}`}>
          <a href="https://x.com/1EternalGames" target="_blank" rel="noopener noreferrer" aria-label="X / Twitter" className="no-underline">
            <div className={styles.socialLinkFrame}><XIcon className={styles.socialIconSvg} /></div>
          </a>
          <a href="https://www.tiktok.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="TikTok" className="no-underline">
            <div className={styles.socialLinkFrame}><TikTokIcon className={styles.socialIconSvg} /></div>
          </a>
          <a href="https://www.youtube.com/@1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="YouTube" className="no-underline">
            <div className={styles.socialLinkFrame}><YouTubeIcon className={styles.socialIconSvg} /></div>
          </a>
          <a href="https://www.instagram.com/1eternalgames" target="_blank" rel="noopener noreferrer" aria-label="Instagram" className="no-underline">
            <div className={styles.socialLinkFrame}><InstagramIcon className={styles.socialIconSvg} /></div>
          </a>
          <a href="https://www.facebook.com/people/Eternal-Games/61574132488834/" target="_blank" rel="noopener noreferrer" aria-label="Facebook" className="no-underline">
            <div className={styles.socialLinkFrame}><FacebookIcon className={styles.socialIconSvg} /></div>
          </a>
        </div>

        <div className={styles.footerDivider}></div>
        
        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '2rem', fontSize: '1.4rem', justifyContent: 'center' }}>
            <Link href="/about" className="no-underline" prefetch={false} style={{ color: 'var(--text-secondary)', transition: 'color 0.2s' }}>من نحن</Link>
            <Link href="/sitemap-html" className="no-underline" prefetch={false} style={{ color: 'var(--text-secondary)', transition: 'color 0.2s' }}>خريطة الموقع</Link>
            {/* FIX: Disable prefetching here */}
            <Link href="/privacy-policy" className="no-underline" prefetch={false} style={{ color: 'var(--text-secondary)', transition: 'color 0.2s' }}>سياسة الخصوصية</Link>
            <Link href="/terms-of-service" className="no-underline" prefetch={false} style={{ color: 'var(--text-secondary)', transition: 'color 0.2s' }}>شروط الخدمة</Link>
        </div>

        <div className={styles.footerInfo}>
          <p className={styles.footerCopyright}>&copy; {new Date().getFullYear()} EternalGames</p>
          <span className={styles.infoSeparator}>•</span>
          <a href="https://x.com/MoVisionX" target="_blank" rel="noopener noreferrer" className={`${styles.designerCredit} no-underline`}>
            <span>تطوير محمد السعد - @MoVisionX</span>
            <XIcon className={styles.designerIcon} />
          </a>
        </div>
      </div>
    </footer>
  );
};

export default Footer;

--- END OF FILE components/Footer.tsx ---

================================================================================

--- START OF FILE components/GameHubClient.tsx ---

// components/GameHubClient.tsx
'use client';

import React, { useRef, RefObject } from 'react'; // Added RefObject
import { motion } from 'framer-motion';
import HubPageClient from '@/components/HubPageClient';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useEffect } from 'react';

interface GameHubClientProps {
    gameTitle: string;
    items: any[];
    synopsis?: string | null;
    releaseTags: any[];
    mainImage: any;
    price?: string;
    developer?: string;
    publisher?: string;
    platforms?: string[];
    onGamePass?: boolean;
    onPSPlus?: boolean;
    forcedLayoutIdPrefix?: string;
    scrollContainerRef?: RefObject<HTMLElement | null>; // Added Prop
}

export default function GameHubClient({
    gameTitle,
    items,
    synopsis,
    releaseTags,
    mainImage,
    price,
    developer,
    publisher,
    platforms,
    onGamePass,
    onPSPlus,
    forcedLayoutIdPrefix,
    scrollContainerRef // Destructure
}: GameHubClientProps) {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);

    useEffect(() => {
        if (forcedLayoutIdPrefix) {
            setPrefix(forcedLayoutIdPrefix);
        }
        return () => setPrefix('default');
    }, [forcedLayoutIdPrefix, setPrefix]);

    return (
        <HubPageClient
            initialItems={items}
            hubTitle={gameTitle}
            hubType="اللعبة"
            synopsis={synopsis}
            tags={releaseTags}
            fallbackImage={mainImage}
            price={price}
            developer={developer}
            publisher={publisher}
            platforms={platforms}
            onGamePass={onGamePass}
            onPSPlus={onPSPlus}
            scrollContainerRef={scrollContainerRef} // Pass down
        />
    );
}

--- END OF FILE components/GameHubClient.tsx ---

================================================================================

--- START OF FILE components/GameLink.module.css ---

/* components/GameLink.module.css */

.kineticGameTag {
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.6rem 1.4rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 600;
    border: 1px solid var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
    color: var(--accent);
    transition: all 0.25s ease-out;
    white-space: nowrap;
    flex-direction: row-reverse;
    /* MODIFIED: Add max-width to constrain the button on small screens */
    max-width: 100%;
}
@media (hover: hover) {@media (hover: hover) {
  
  .kineticGameTag:hover  {
    transform: translateY(-2px);
    background-color: var(--accent);
    border-color: var(--accent);
    color: #FFFFFF;
    box-shadow: 0 4px 15px color-mix(in srgb, var(--accent) 20%, transparent);
}
}

  .kineticGameTag:active  {
    transform: translateY(-2px);
    background-color: var(--accent);
    border-color: var(--accent);
    color: #FFFFFF;
    box-shadow: 0 4px 15px color-mix(in srgb, var(--accent) 20%, transparent);
}
}
.kineticGameTag:active {
    transform: translateY(-2px);
    background-color: var(--accent);
    border-color: var(--accent);
    color: #FFFFFF;
    box-shadow: 0 4px 15px color-mix(in srgb, var(--accent) 20%, transparent);
}

@media (hover: hover) {@media (hover: hover) {
  
  [data-theme="dark"] .kineticGameTag:hover  {
    color: var(--bg-primary);
}
}

  [data-theme="dark"] .kineticGameTag:active  {
    color: var(--bg-primary);
}
}
[data-theme="dark"] .kineticGameTag:active {
    color: var(--bg-primary);
}

  
.gameTagArrow {
    display: inline-block;
    opacity: 0;
    transform: translateX(8px);
    transition: opacity 0.25s ease-out, transform 0.25s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .kineticGameTag:hover .gameTagArrow  {
    opacity: 1;
    transform: translateX(-0);
}
}

  .kineticGameTag:active .gameTagArrow  {
    opacity: 1;
    transform: translateX(-0);
}
}
.kineticGameTag:active .gameTagArrow {
    opacity: 1;
    transform: translateX(-0);
}


/* MODIFIED: Add mobile-specific styles for smart text wrapping */
@media (max-width: 768px) {
    .kineticGameTag {
        /* Allow text to wrap if it exceeds the button's width */
        white-space: normal;
        /* Center content vertically when it wraps */
        justify-content: center;
        /* Ensure text alignment is centered when it wraps */
        text-align: center;
    }
}




--- END OF FILE components/GameLink.module.css ---

================================================================================

--- START OF FILE components/GameLink.tsx ---

// components/GameLink.tsx
import React from 'react';
import styles from './GameLink.module.css';
// IMPORT KineticLink
import KineticLink from '@/components/kinetic/KineticLink';

type GameLinkProps = {
    gameName?: string | null;
    gameSlug?: string | null;
    className?: string;
};

const GameLink = ({ gameName, gameSlug, className = '' }: GameLinkProps) => {
    if (!gameName || !gameSlug) {
        return null;
    }
    
    const finalClassName = `${styles.kineticGameTag} ${className} no-underline`;

    // Use KineticLink with type="games"
    return (
        <KineticLink 
            href={`/games/${gameSlug}`} 
            slug={gameSlug}
            type="games" // <--- SUPPORTED
            className={finalClassName} 
        >
            <span>{gameName}</span>
            <span className={styles.gameTagArrow}>→</span>
        </KineticLink>
    );
};

export default GameLink;

--- END OF FILE components/GameLink.tsx ---

================================================================================

--- START OF FILE components/HomepageHydrator.tsx ---

// components/HomepageHydrator.tsx
'use client';

import { useRef } from 'react';
import { useContentStore } from '@/lib/contentStore';

// This component is used ONLY on the homepage.
// It takes the Server-Side Generated data and immediately hydrates the client store.
// This ensures the homepage loads instantly without needing an API call.
export default function HomepageHydrator({ data }: { data: any }) {
    const hydrated = useRef(false);
    const { hydrateUniversal } = useContentStore();

    if (!hydrated.current) {
        hydrateUniversal(data);
        hydrated.current = true;
    }

    return null; // It renders nothing visual itself; the Layout's Loader will pick up the data.
}

--- END OF FILE components/HomepageHydrator.tsx ---

================================================================================

--- START OF FILE components/HorizontalShowcase.module.css ---

/* components/HorizontalShowcase.module.css */

/* --- Page Structure & Background --- */
.articlesPageContainer {
  position: relative;
  padding-top: var(--nav-height-scrolled);
}

.articlesPageBg {
  position: fixed;
  top: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
}
.articlesPageBgOverlay {
  position: absolute;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 80%, transparent);
  backdrop-filter: blur(16px) saturate(120%);
}

.showcaseSection {
  margin-bottom: 6rem;
}
.gridSection {
  margin-top: 0;
}

/* --- Desktop Horizontal Showcase --- */
.horizontalShowcaseWrapper {
  position: relative;
  height: 500px; /* Increased height */
  display: flex;
  align-items: center;
  overflow: visible; 
  cursor: grab;
  /* THE FIX: Add padding-top to push cards down */
  padding-top: 5rem;
}
.horizontalShowcaseWrapper:active {
  cursor: grabbing;
}

.horizontalShowcaseList {
  display: flex;
  align-items: center;
  --showcase-card-width: 40vw;
  --showcase-card-max-width: 480px; 
  --showcase-card-gap: 8rem;
}

.showcaseItemWrapper {
  flex-shrink: 0;
  width: var(--showcase-card-width);
  max-width: var(--showcase-card-max-width);
  margin-right: var(--showcase-card-gap);
  perspective: 1000px; 
  z-index: 1;
  transition: opacity 0.4s ease, filter 0.4s ease;
}
.showcaseItemWrapper:first-child {
  margin-left: var(--showcase-card-gap);
}

/* Scale Wrapper */
.showcaseCardWrapper {
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 1;
  transform-origin: center center;
}

/* Living Tilt Container */
.livingCardContainer {
    width: 100%;
    height: 100%;
    aspect-ratio: 16 / 9;
    position: relative;
    transform-style: preserve-3d;
}

/* The Link */
.showcaseCardLink {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 12px;
  background: transparent;
  border: none;
  box-shadow: none;
  transform-style: preserve-3d;
}

/* Monolith Frame Look */
.monolithFrame {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    border-radius: 12px;
    /* OPTIMIZATION: Visible for shadow expansion */
    overflow: visible; 
    transform: translateZ(0);
    pointer-events: none;
    z-index: 10;
    
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5);
    transition: border-color 0.3s ease; 
}

/* OPTIMIZATION: Shadow Layer */
.monolithFrame::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 12px;
    box-shadow: 
        0 35px 70px -15px rgba(0,0,0,0.8),
        0 0 0 1px color-mix(in srgb, var(--accent) 30%, transparent);
    opacity: 0;
    transition: opacity 0.4s ease;
    z-index: -1;
    pointer-events: none;
}

/* NEW: EXPLICIT CYBER CORNER ELEMENT */
.cyberCorner {
    position: absolute;
    /* Align perfectly with the 1px border */
    top: -1px;
    left: -1px;
    width: 40px;
    height: 40px;
    
    /* Define borders - ONLY Top and Left */
    border-top: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-left: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    
    /* Match parent radius exactly */
    border-top-left-radius: 12px;
    
    transition: all 0.3s ease;
    z-index: 20; 
    pointer-events: none;
}

.showcaseCardLink:hover .cyberCorner {
    width: calc(100% + 2px);
    height: calc(100% + 2px);
    border-radius: 12px;
    border-color: var(--accent);
    filter: drop-shadow(0 0 4px var(--accent));
    border-right: none;
    border-bottom: none;
}

:global(.noCornerAnimation) .cyberCorner {
    display: none !important;
}

/* --- HOVER EFFECTS --- */
.showcaseCardLink:hover .monolithFrame {
    border-color: var(--accent);
}
.showcaseCardLink:hover .monolithFrame::after {
    opacity: 1; /* Fade in shadow */
}

.showcaseCardLink:hover .showcaseCardImage { transform: scale(1.1); }
.showcaseCardLink:hover .holoSpotlight { opacity: 1; }
.showcaseCardLink:hover .cardTitle { color: var(--accent); text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 60%, transparent); }
.showcaseCardLink:hover .creditCapsule { border-color: var(--accent); background-color: var(--accent); }
.showcaseCardLink:hover .capsuleIcon { background-color: var(--bg-primary); color: var(--accent); }
.showcaseCardLink:hover .creditCapsule :global(span) { color: var(--bg-primary); }
.showcaseCardLink:hover .techDot { background-color: var(--accent); animation: pulse-dot 1.2s infinite ease-in-out; }
.showcaseCardLink:hover .techDot:nth-child(2) { animation-delay: 0.2s; }
.showcaseCardLink:hover .techDot:nth-child(3) { animation-delay: 0.4s; }


.showcaseCardImageWrapper {
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: 12px; 
  transform: translateZ(0);
}
.showcaseCardImage {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.8s cubic-bezier(0.19, 1, 0.22, 1);
  scale: 1.02;
}

.holoSpotlight {
    position: absolute;
    width: 200px; 
    height: 200px;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 15;
    opacity: 0;
    transition: opacity 0.2s ease;
    background: radial-gradient(circle, rgba(255,255,255,0.4) 0%, transparent 70%);
    mix-blend-mode: overlay; 
    border-radius: 50%;
}

.showcaseCardContent {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 2.5rem; 
  padding-bottom: 5rem; /* Extra space for HUD */
  color: #fff;
  background: linear-gradient(to top, rgba(0,0,0,0.95) 10%, rgba(0,0,0,0.6) 50%, transparent 100%);
  text-align: right;
  z-index: 25;
  transform: translateZ(20px);
  pointer-events: none;
  /* Ensure radius at bottom matches */
  border-bottom-left-radius: 12px;
  border-bottom-right-radius: 12px;
}

:global([data-theme="light"]) .showcaseCardContent {
    background: none !important;
}

.showcaseCardTitle {
  font-family: var(--font-main);
  font-size: 2.8rem;
  line-height: 1.2;
  font-weight: 800;
  transition: color 0.3s ease;
}
.showcaseCardGame {
  font-family: var(--font-main);
  color: var(--accent);
  font-weight: 700;
  margin-top: 0.5rem;
  font-size: 1.4rem;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  text-shadow: 0 0 10px color-mix(in srgb, var(--accent) 30%, transparent);
}

/* --- HUD & SATELLITES --- */
.hudContainer {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: auto;
    
    /* UPDATED LAYOUT: GRID FOR CENTERED DOTS */
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    gap: 1rem;
    
    padding: 0 1.5rem 1.5rem 1.5rem;
    z-index: 30; 
    pointer-events: none; 
    transform: translateZ(30px);
}
.hudContainer > * { pointer-events: auto; }

.techDecoration { 
    display: flex; 
    gap: 6px; 
    align-items: center;
    justify-content: center; /* Center in grid cell */
    pointer-events: none; 
}
.techDot { width: 5px; height: 5px; background-color: rgba(255,255,255,0.2); border-radius: 50%; transition: background-color 0.3s ease; }
@keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 0.6; } 50% { transform: scale(1.6); opacity: 1; box-shadow: 0 0 10px var(--accent); } }

.creditCapsule { display: inline-flex; align-items: center; gap: 0.8rem; background: rgba(10, 11, 15, 0.8); border: 1px solid rgba(255,255,255,0.1); padding: 0; border-radius: 999px; transition: all 0.4s ease; height: 32px; backdrop-filter: blur(8px); text-decoration: none; cursor: pointer; pointer-events: auto; }
.capsuleIcon { width: 32px; height: 32px; border-radius: 50%; background-color: var(--accent); color: #000; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: all 0.4s ease; }
.creditCapsule span { font-size: 1.2rem; font-weight: 700; color: #fff; max-width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 1.2rem; padding-right: 0.8rem; transition: color 0.4s ease; }

.dateReadout { font-family: var(--font-ui); font-size: 1.2rem; color: rgba(255,255,255,0.7); font-weight: 500; white-space: nowrap; display: flex; align-items: center; gap: 0.5rem; pointer-events: none; }

.satelliteField { position: absolute; inset: -80px; pointer-events: none; z-index: 50; overflow: visible; transform-style: preserve-3d; }
.satelliteShard { position: absolute; padding: 0; background: transparent; pointer-events: none; display: flex; align-items: center; justify-content: center; transform-style: preserve-3d; }
.satelliteShardLink { display: flex; align-items: center; justify-content: center; padding: 0.4rem 1rem; background: #000; border: 2px solid var(--accent); color: var(--accent); font-family: var(--font-ui); font-size: 1.2rem; font-weight: 800; border-radius: 6px; white-space: nowrap; box-shadow: 0 15px 40px rgba(0,0,0,0.8); filter: drop-shadow(0 0 10px rgba(0,255,240,0.3)); text-decoration: none; transition: all 0.3s ease; cursor: pointer; pointer-events: auto; }
@media (hover: hover) { .satelliteShardLink:hover { background-color: var(--accent); color: #000; transform: scale(1.15) translateY(-3px); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent); } }

/* --- Arrows --- */
.showcaseArrow {
  position: absolute;
  top: 50%;
  z-index: 100;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  backdrop-filter: blur(8px);
}
.showcaseArrow.left {
  left: 3rem;
  right: auto;
}
.showcaseArrow.right {
  right: 3rem;
  left: auto;
}

/* --- Mobile Vertical Showcase --- */
.mobileShowcaseContainer {
    position: relative;
    width: 85%; 
    max-width: 400px;
    margin: 4rem auto 2rem auto; 
    display: flex;
    align-items: center;
    justify-content: center;
    /* THE FIX: Force aspect ratio to prevent collapse and ensure space for full card */
    aspect-ratio: 16 / 10;
}

.mobileShowcaseCardWrapper {
    width: 100%;
    height: 100%;
}

/* --- MOBILE RESPONSIVENESS --- */
@media (max-width: 768px) {
  .horizontalShowcaseWrapper {
    display: none;
  }

  .articlesPageContainer .page-title {
    margin-bottom: 2rem;
  }

  .showcaseSection {
    margin-bottom: 4rem;
  }

  .showcaseArrow {
    width: 40px;
    height: 40px;
  }

  .showcaseArrow.left {
    left: -2rem; /* Move arrows closer */
  }

  .showcaseArrow.right {
    right: -2rem; /* Move arrows closer */
  }

  .showcaseCardTitle {
    font-size: 2.2rem;
  }
}

--- END OF FILE components/HorizontalShowcase.module.css ---

================================================================================

--- START OF FILE components/HorizontalShowcase.tsx ---

// components/HorizontalShowcase.tsx
'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link'; // Keep for non-kinetic fallbacks if needed
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { CardProps } from '@/types';
import styles from './HorizontalShowcase.module.css';
import { sanityLoader } from '@/lib/sanity.loader';
import { useLivingCard } from '@/hooks/useLivingCard';
import { PenEdit02Icon, Calendar03Icon } from '@/components/icons';
import { translateTag } from '@/lib/translations';
import { usePerformanceStore } from '@/lib/performanceStore';
import KineticLink from '@/components/kinetic/KineticLink';

const ArrowIcon = ({ direction = 'right' }: { direction?: 'left' | 'right' }) => (
  <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
    <polyline points={direction === 'right' ? "9 18 15 12 9 6" : "15 18 9 12 15 6"} />
  </svg>
);

const satelliteConfig = [
    { hoverX: -120, hoverY: -40, rotate: -8 },
    { hoverX: 110, hoverY: -20, rotate: 10 }, 
    { hoverX: -10, hoverY: -130, rotate: 4 } 
];

const ShowcaseCard = ({ article, isActive }: { article: CardProps, isActive: boolean }) => {
  const setPrefix = useLayoutIdStore((state) => state.setPrefix);
  const layoutIdPrefix = "articles-showcase";
  const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLDivElement>();
  const [isHovered, setIsHovered] = useState(false);
  
  const { isLivingCardEnabled, isFlyingTagsEnabled, isHeroTransitionEnabled, isCornerAnimationEnabled } = usePerformanceStore();
  const effectivelyDisabledLiving = !isLivingCardEnabled;

  const handleClick = (e: React.MouseEvent) => {
    if ((e.target as HTMLElement).closest('a[href^="/tags/"]')) return;
    if ((e.target as HTMLElement).closest('a[href^="/creators/"]')) return;
    if (isHeroTransitionEnabled) {
        setPrefix(layoutIdPrefix);
    }
  };

  const imageSource = article.imageUrl;
  if (!imageSource) return null;
  
  const displayTags = article.tags.slice(0, 3);
  const author = article.authors?.[0];
  const authorName = author?.name;
  const authorUsername = author?.username;
  
  // Prepare partial data for instant load
  const creatorData = author ? { name: author.name, image: author.image } : undefined;

  const animationStyles = !effectivelyDisabledLiving ? livingCardAnimation.style : {};
  const safeLayoutIdPrefix = isHeroTransitionEnabled ? layoutIdPrefix : undefined;
  
  const kineticType = article.type === 'review' ? 'reviews' : article.type === 'article' ? 'articles' : 'news';

  return (
    <motion.div
       className={`${styles.showcaseCardWrapper} ${!isCornerAnimationEnabled ? 'noCornerAnimation' : ''}`}
       animate={{ 
         scale: isActive ? 1 : 0.9, 
         opacity: isActive ? 1 : (isHovered ? 1 : 0.4),
         filter: isActive ? 'grayscale(0%)' : (isHovered ? 'grayscale(0%)' : 'grayscale(100%) brightness(0.6)')
       }}
       transition={{ type: 'spring', stiffness: 300, damping: 30 }}
       style={{ zIndex: isActive || isHovered ? 100 : 1 }}
    >
      <motion.div
        className={styles.livingCardContainer}
        ref={livingCardRef}
        onMouseMove={!effectivelyDisabledLiving ? livingCardAnimation.onMouseMove : undefined}
        onMouseEnter={() => { 
            if(!effectivelyDisabledLiving) livingCardAnimation.onMouseEnter(); 
            setIsHovered(true); 
        }}
        onMouseLeave={() => { 
            if(!effectivelyDisabledLiving) livingCardAnimation.onMouseLeave(); 
            setIsHovered(false); 
        }}
        onTouchStart={!effectivelyDisabledLiving ? livingCardAnimation.onTouchStart : undefined}
        onTouchEnd={!effectivelyDisabledLiving ? livingCardAnimation.onTouchEnd : undefined}
        style={{ ...animationStyles, perspective: '1000px' }}
      >
        <KineticLink 
            href={`/articles/${article.slug}`}
            slug={article.slug}
            type={kineticType}
            imageSrc={imageSource}
            layoutId={safeLayoutIdPrefix}
            onClick={handleClick}
            className={`no-underline ${styles.showcaseCardLink}`}
            draggable="false"
        >
            <div className={styles.monolithFrame}>
                <div className={styles.cyberCorner} />
                
                <motion.div 
                    className={styles.holoSpotlight} 
                    style={{ opacity: isHovered ? 1 : 0 }} 
                />
                
                <motion.div layoutId={safeLayoutIdPrefix ? `${safeLayoutIdPrefix}-card-image-${article.legacyId}` : undefined} className={styles.showcaseCardImageWrapper}>
                  <Image 
                    loader={sanityLoader} 
                    src={imageSource} alt={article.title} fill sizes="60vw"
                    style={{ objectFit: 'cover' }} className={styles.showcaseCardImage}
                    draggable="false"
                    priority={isActive}
                  />
                </motion.div>

                <div className={styles.showcaseCardContent}>
                  <motion.h3 layoutId={safeLayoutIdPrefix ? `${safeLayoutIdPrefix}-card-title-${article.legacyId}` : undefined} className={styles.showcaseCardTitle}>{article.title}</motion.h3>
                  <p className={styles.showcaseCardGame}>{article.game}</p>
                </div>
                
                <div className={styles.hudContainer} style={{ transform: 'translateZ(40px)' }}>
                    <div style={{ justifySelf: 'start' }}>
                        {article.date && (
                            <div className={styles.dateReadout}>
                                <Calendar03Icon style={{ width: '14px', height: '14px', color: 'var(--accent)' }} />
                                {article.date.split(' - ')[0]}
                            </div>
                        )}
                    </div>
                    <div className={styles.techDecoration}>
                        <div className={styles.techDot} />
                        <div className={styles.techDot} />
                        <div className={styles.techDot} />
                    </div>
                    <div style={{ justifySelf: 'end' }}>
                        {authorName ? (
                            authorUsername ? (
                                <KineticLink 
                                    href={`/creators/${authorUsername}`}
                                    slug={authorUsername}
                                    type="creators"
                                    onClick={(e) => e.stopPropagation()} 
                                    className={`${styles.creditCapsule} no-underline`}
                                    style={{ flexDirection: 'row-reverse' }} 
                                    // PASS DATA
                                    preloadedData={creatorData}
                                >
                                    <div className={styles.capsuleIcon}>
                                        <PenEdit02Icon style={{ width: 14, height: 14 }} />
                                    </div>
                                    <span title={authorName}>{authorName}</span>
                                </KineticLink>
                            ) : (
                                <div className={styles.creditCapsule} style={{ flexDirection: 'row-reverse' }}>
                                    <div className={styles.capsuleIcon}>
                                        <PenEdit02Icon style={{ width: 14, height: 14 }} />
                                    </div>
                                    <span title={authorName}>{authorName}</span>
                                </div>
                            )
                        ) : <div />}
                    </div>
                </div>
            </div>
            
            {isFlyingTagsEnabled && (
                <div className={styles.satelliteField} style={{ transform: 'translateZ(60px)' }}>
                    <AnimatePresence>
                        {isHovered && displayTags.map((tag, i) => (
                             <motion.div
                                key={`${article.id}-${tag.slug}`}
                                className={styles.satelliteShard}
                                initial={{ opacity: 0, scale: 0.4, x: 0, y: 50, z: 0 }}
                                animate={{
                                    opacity: 1,
                                    scale: 1.1,
                                    x: satelliteConfig[i]?.hoverX || 0,
                                    y: satelliteConfig[i]?.hoverY || 0,
                                    rotate: satelliteConfig[i]?.rotate || 0,
                                    z: -30 
                                }}
                                transition={{
                                    type: "spring",
                                    stiffness: 180,
                                    damping: 20,
                                    delay: i * 0.05
                                }}
                                style={{ position: 'absolute', left: '50%', top: '50%', transformStyle: 'preserve-3d' }}
                                onClick={(e) => e.stopPropagation()}
                             >
                                 <KineticLink 
                                    href={`/tags/${tag.slug}`} 
                                    slug={tag.slug}
                                    type="tags"
                                    onClick={(e) => e.stopPropagation()}
                                    className={`${styles.satelliteShardLink} no-underline`}
                                >
                                     {translateTag(tag.title)}
                                 </KineticLink>
                             </motion.div>
                        ))}
                    </AnimatePresence>
                </div>
            )}
        </KineticLink>
      </motion.div>
    </motion.div>
  );
};

export default function HorizontalShowcase({ articles, onActiveIndexChange }: { articles: CardProps[], onActiveIndexChange: (index: number) => void }) {
  const [activeIndex, setActiveIndex] = useState(0);
  const [xOffset, setXOffset] = useState(0);
  const [isCalculated, setIsCalculated] = useState(false);
  
  const wrapperRef = useRef<HTMLDivElement>(null);
  const cardRefs = useRef<(HTMLDivElement | null)[]>([]);

  const calculateAndGoToIndex = useCallback((index: number) => {
    if (!wrapperRef.current || !cardRefs.current[index]) return;
    const wrapperWidth = wrapperRef.current.offsetWidth;
    const targetCard = cardRefs.current[index]!;
    const targetOffsetLeft = targetCard.offsetLeft;
    const targetWidth = targetCard.offsetWidth;
    const newXOffset = (wrapperWidth / 2) - targetOffsetLeft - (targetWidth / 2);
    setXOffset(newXOffset);
    setActiveIndex(index);
    onActiveIndexChange(index);
    setIsCalculated(true);
  }, [onActiveIndexChange]);

  useEffect(() => {
    const handleResize = () => calculateAndGoToIndex(activeIndex);
    window.addEventListener('resize', handleResize);
    const timeoutId = setTimeout(() => handleResize(), 100); 
    return () => { window.removeEventListener('resize', handleResize); clearTimeout(timeoutId); };
  }, [activeIndex, calculateAndGoToIndex]);
  
  const handleNext = useCallback(() => { const nextIndex = Math.min(activeIndex + 1, articles.length - 1); calculateAndGoToIndex(nextIndex); }, [activeIndex, articles.length, calculateAndGoToIndex]);
  const handlePrev = useCallback(() => { const prevIndex = Math.max(activeIndex - 1, 0); calculateAndGoToIndex(prevIndex); }, [activeIndex, calculateAndGoToIndex]);
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => { if (event.key === 'ArrowRight') handleNext(); if (event.key === 'ArrowLeft') handlePrev(); };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleNext, handlePrev]);

  const onDragEnd = (event: any, { offset, velocity }: any) => {
    const swipeConfidenceThreshold = 10000;
    const swipePower = Math.abs(offset.x) * velocity.x;
    if (swipePower < -swipeConfidenceThreshold) { handleNext(); } 
    else if (swipePower > swipeConfidenceThreshold) { handlePrev(); } 
    else { calculateAndGoToIndex(activeIndex); }
  };

  return (
    <div ref={wrapperRef} className={styles.horizontalShowcaseWrapper} dir="ltr">
      <AnimatePresence>
        {isCalculated && activeIndex > 0 && (
          <motion.button 
              className={`${styles.showcaseArrow} ${styles.left}`} 
              onClick={handlePrev} 
              initial={{ opacity: 0, translateY: "-50%" }}
              animate={{ opacity: 1, translateY: "-50%" }} 
              exit={{ opacity: 0, translateY: "-50%" }} 
              whileHover={{ scale: 1.1 }} 
              whileTap={{ scale: 0.9 }}
            >
            <ArrowIcon direction="left" />
          </motion.button>
        )}
      </AnimatePresence>
      <AnimatePresence>
        {isCalculated && activeIndex < articles.length - 1 && (
          <motion.button 
              className={`${styles.showcaseArrow} ${styles.right}`} 
              onClick={handleNext} 
              initial={{ opacity: 0, translateY: "-50%" }}
              animate={{ opacity: 1, translateY: "-50%" }} 
              exit={{ opacity: 0, translateY: "-50%" }} 
              whileHover={{ scale: 1.1 }} 
              whileTap={{ scale: 0.9 }}
            >
            <ArrowIcon direction="right" />
          </motion.button>
        )}
      </AnimatePresence>

      <motion.div
        className={styles.horizontalShowcaseList}
        drag="x" dragConstraints={{ left: 0, right: 0 }} dragElastic={0.1} onDragEnd={onDragEnd}
        initial={{ opacity: 0 }}
        animate={{ x: xOffset, opacity: isCalculated ? 1 : 0 }}
        transition={{ x: { type: 'spring', stiffness: 300, damping: 50 }, opacity: { duration: 0.5 } }}
      >
        {articles.map((article, index) => (
          <div key={article.id} ref={(el) => { cardRefs.current[index] = el; }} className={styles.showcaseItemWrapper}>
            <ShowcaseCard article={article} isActive={activeIndex === index} />
          </div>
        ))}
      </motion.div>
    </div>
  );
}

--- END OF FILE components/HorizontalShowcase.tsx ---

================================================================================

--- START OF FILE components/HubFilters.tsx ---

// components/HubFilters.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './filters/Filters.module.css';

export type HubTypeFilter = 'all' | 'review' | 'article' | 'news';
export type HubSortOrder = 'latest' | 'viral';

const typeFilters: { label: string, value: HubTypeFilter }[] = [
    { label: 'الكل', value: 'all' },
    { label: 'مراجعات', value: 'review' },
    { label: 'مقالات', value: 'article' },
    { label: 'أخبار', value: 'news' },
];

const sortOrders: { label: string, value: HubSortOrder }[] = [
    { label: 'الأحدث', value: 'latest' },
    { label: 'الأكثر رواجًا', value: 'viral' },
];

interface HubFiltersProps {
    activeTypeFilter: HubTypeFilter;
    onTypeFilterChange: (filter: HubTypeFilter) => void;
    activeSort: HubSortOrder;
    onSortChange: (sort: HubSortOrder) => void;
}

export default function HubFilters({
    activeTypeFilter,
    onTypeFilterChange,
    activeSort,
    onSortChange
}: HubFiltersProps) {
    return (
        <div className={styles.filtersContainer} style={{ marginBottom: '3rem' }}>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>نوع المحتوى:</span>
                <div className={styles.filterButtonsGroup}>
                    {typeFilters.map(filter => (
                        <motion.button
                            key={filter.value}
                            onClick={() => onTypeFilterChange(filter.value)}
                            className={`${styles.filterButton} ${activeTypeFilter === filter.value ? styles.active : ''}`}
                        >
                            {filter.label}
                            {activeTypeFilter === filter.value && <motion.div layoutId="hub-type-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
            <div className={styles.filterGroup}>
                <span className={styles.filterLabel}>الفرز حسب:</span>
                <div className={styles.filterButtonsGroup}>
                    {sortOrders.map(sort => (
                        <motion.button
                            key={sort.value}
                            onClick={() => onSortChange(sort.value)}
                            className={`${styles.filterButton} ${activeSort === sort.value ? styles.active : ''}`}
                        >
                            {sort.label}
                            {activeSort === sort.value && <motion.div layoutId="hub-sort-highlight" className={styles.filterHighlight} />}
                        </motion.button>
                    ))}
                </div>
            </div>
        </div>
    );
}










--- END OF FILE components/HubFilters.tsx ---

================================================================================

--- START OF FILE components/HubPage.module.css ---

/* components/HubPage.module.css */

.hubPageContainer {
  /* No top padding here as the hero handles transparency */
}

/* --- HERO SECTION --- */
.hubHero {
  /* Increased height for comprehensive metadata display */
  height: 70vh; 
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  margin-bottom: -4rem; 
  padding-top: var(--nav-height-scrolled);
}

.heroBg {
  position: absolute;
  inset: 0;
  z-index: -2;
}

.heroOverlay {
  position: absolute;
  inset: 0;
  /* Deep gradient to make sure white metadata pops over any image */
  background: linear-gradient(to top, rgba(5,6,8,1) 5%, rgba(5,6,8,0.7) 40%, rgba(5,6,8,0.4) 100%);
  z-index: -1;
}

:global([data-theme="light"]) .heroOverlay {
    background: none !important;
}

.heroTitle {
  font-size: 6.4rem;
  text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  margin: 0;
}

.heroContentContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2.5rem;
    z-index: 5;
    /* REDUCED PADDING to lift content up */
    padding: 0 2rem 4rem 2rem; 
}

/* --- SYNOPSIS (NABDA) --- */
.synopsis {
    max-width: 800px;
    text-align: center;
    font-size: 1.8rem;
    line-height: 1.7;
    color: #E2E8F0; /* High contrast off-white */
    margin: 0 auto;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

.synopsisFirstWord {
    color: var(--accent);
    font-weight: 800;
}

/* --- METADATA ROW & PILLS --- */
.metadataRow {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 1rem;
}

/* Base Pill Style (Static by default) */
.hubPill {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    padding: 0.6rem 1.4rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 700;
    white-space: nowrap;
    cursor: default;
    background-color: rgba(10, 10, 15, 0.85);
    border: 1px solid var(--border-color);
    color: var(--text-secondary);
    backdrop-filter: blur(8px);
    text-decoration: none !important; /* Ensure no underline */
    transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative; /* For pseudo-element handling */
}

:global(body.no-glass) .hubPill {
    backdrop-filter: none !important;
    background-color: #0A0A0F !important;
}

/* Mobile Opt */
@media (max-width: 768px) {
    .hubPill {
        backdrop-filter: none !important;
        background-color: rgba(10, 10, 15, 0.95);
    }
}

/* Remove any global link pseudo-element underlines */
.hubPill::after {
    display: none !important;
    content: none !important;
}

/* Specific Metadata Colors */
.hubPill.price { 
    border-color: #FFD700; 
    color: #FFD700; 
}

.hubPill.platform { 
    border-color: #fff; 
    color: #fff; 
}

.hubPill.genre {
    border-color: var(--accent);
    color: var(--accent);
}

/* INTERACTIVE PILLS (Developer / Publisher) */
.hubPill.interactive {
    cursor: pointer;
    border-color: var(--accent);
    color: var(--accent);
}

@media (hover: hover) {
    .hubPill.interactive:hover {
        background-color: var(--accent);
        color: #000; /* Text turns black against cyan background */
        border-color: var(--accent);
        transform: translateY(-3px) scale(1.05);
        box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent);
        z-index: 10;
        text-decoration: none !important;
    }
    /* Ensure no underline on hover specifically */
    .hubPill.interactive:hover::after {
        display: none !important;
    }
}

.hubPill.interactive:active {
    transform: scale(0.95);
    background-color: var(--accent);
    color: #000;
    text-decoration: none !important;
}

/* --- RESPONSIVENESS --- */
@media (max-width: 1024px) {
    .heroTitle {
        font-size: 4.8rem;
    }
}

@media (max-width: 768px) {
  .hubHero {
    height: auto;
    min-height: 85vh;
    padding-bottom: 6rem;
  }
  
  .heroTitle {
    font-size: 3.6rem;
  }
  
  .synopsis {
      font-size: 1.5rem;
      padding: 0 1rem;
  }
  
  .metadataRow {
      gap: 0.75rem;
  }
  
  .hubPill {
      padding: 0.5rem 1.1rem;
      font-size: 1.3rem;
  }
}

--- END OF FILE components/HubPage.module.css ---

================================================================================

--- START OF FILE components/HubPageClient.tsx ---

// components/HubPageClient.tsx
'use client';

import { useState, useMemo, useRef, useEffect, useLayoutEffect, RefObject } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import HubFilters, { HubTypeFilter, HubSortOrder } from './HubFilters';
import ArticleCard from './ArticleCard';
import Image from 'next/image';
import Link from 'next/link';
import { adaptToCardProps } from '@/lib/adapters';
import { urlFor } from '@/sanity/lib/image';
import styles from './HubPage.module.css';
import { CardProps, EngagementScore } from '@/types';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { sanityLoader } from '@/lib/sanity.loader'; 
import { translateTag } from '@/lib/translations';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';
import KineticLink from '@/components/kinetic/KineticLink'; 
import ArticleCardSkeleton from '@/components/ui/ArticleCardSkeleton';

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

interface HubPageClientProps {
    initialItems: any[];
    hubTitle: string;
    hubType: 'اللعبة' | 'وسم' | 'أعمال';
    headerAction?: React.ReactNode;
    synopsis?: string | null;      
    tags?: { title: string, slug?: string }[];    
    fallbackImage?: any; 
    price?: string;
    developer?: any; // Can be string or object
    publisher?: any; // Can be string or object
    platforms?: string[];
    onGamePass?: boolean;
    onPSPlus?: boolean;
    scrollContainerRef?: RefObject<HTMLElement | null>;
    isLoading?: boolean; 
}

const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    'PC': PCIcon,
    'PlayStation': PS5Icon, 'PlayStation 5': PS5Icon,
    'Xbox': XboxIcon,
    'Switch': SwitchIcon,
};

const formatSynopsis = (text: string) => {
    const parts = text.split(/(\s+)/);
    return parts.map((part, i) => {
        if (/^[A-Za-z0-9]+$/.test(part.replace(/[^\w\s]/gi, ''))) {
            return <strong key={i} style={{fontWeight: 800}}>{part}</strong>;
        }
        return part;
    });
};

const MetadataDivider = () => (
    <div style={{ width: '1px', height: '20px', backgroundColor: 'var(--border-color)', margin: '0 0.5rem' }} />
);

export default function HubPageClient({ 
    initialItems, hubTitle, hubType, headerAction, synopsis, tags, fallbackImage,
    price, developer, publisher, platforms, onGamePass, onPSPlus,
    scrollContainerRef,
    isLoading = false 
}: HubPageClientProps) {
    const { prefix: layoutIdPrefix, setPrefix } = useLayoutIdStore();
    
    useIsomorphicLayoutEffect(() => { 
        if (scrollContainerRef?.current) {
            scrollContainerRef.current.scrollTop = 0;
        } else {
            window.scrollTo(0, 0); 
        }
    }, [scrollContainerRef]);

    useEffect(() => {
        return () => setPrefix('default');
    }, [setPrefix]);
    
    const [activeTypeFilter, setActiveTypeFilter] = useState<HubTypeFilter>('all');
    const [activeSort, setActiveSort] = useState<HubSortOrder>('latest');
    const [engagementScores, setEngagementScores] = useState<Map<number, number>>(new Map());
    const contentRef = useRef(null);
    const isInView = useInView(contentRef, { once: true, amount: 0.1 });

    useEffect(() => {
        const fetchScores = async () => {
            try {
                const res = await fetch('/api/engagement-scores');
                const data: EngagementScore[] = await res.json();
                const scoresMap = new Map(data.map(score => [score.id, score.engagementScore]));
                setEngagementScores(scoresMap);
            } catch (error) {
                console.error("Failed to fetch engagement scores for Hub Page:", error);
            }
        };
        if (activeSort === 'viral') {
            fetchScores();
        }
    }, [activeSort]);

    const adaptedInitialItems = useMemo(() => 
        (initialItems || [])
            .map(item => adaptToCardProps(item, { width: 600 }))
            .filter(Boolean) as CardProps[],
        [initialItems]
    );

    const filteredAndSortedItems = useMemo(() => {
        let items = [...adaptedInitialItems];

        if (activeTypeFilter !== 'all') {
            items = items.filter(item => item.type === activeTypeFilter);
        }

        if (activeSort === 'viral') {
            items.sort((a, b) => {
                const scoreA = engagementScores.get(a.legacyId) || 0;
                const scoreB = engagementScores.get(b.legacyId) || 0;
                return scoreB - scoreA;
            });
        }
        
        return items;
    }, [adaptedInitialItems, activeTypeFilter, activeSort, engagementScores]);

    const latestItem = (initialItems && initialItems.length > 0) ? initialItems[0] : null;
    
    let heroImageRef = latestItem?.mainImageRef || fallbackImage;
    if (hubType === 'اللعبة' && fallbackImage) {
        heroImageRef = fallbackImage;
    }

    let heroImageUrl = '/placeholder.svg';
    let heroBlurDataURL = null;
    let isExternalImage = false;

    try {
        if (typeof heroImageRef === 'string') {
            if (heroImageRef.startsWith('http') || heroImageRef.startsWith('/')) {
                heroImageUrl = heroImageRef;
                isExternalImage = true;
            }
        } else if (heroImageRef && (heroImageRef.asset || heroImageRef._ref || heroImageRef._id)) {
             heroImageUrl = urlFor(heroImageRef).width(1920).auto('format').url();
             heroBlurDataURL = urlFor(heroImageRef).width(20).blur(10).auto('format').url();
        }
    } catch (e) {
        console.warn("HubPageClient: Failed to resolve hero image", e);
        heroImageUrl = '/placeholder-game.svg';
    }
    
    const heroLayoutId = layoutIdPrefix === 'default' 
        ? `hub-hero-${hubTitle.replace(/\s+/g, '-')}` 
        : `${layoutIdPrefix}-image`;

    const synopsisContent = useMemo(() => {
        if (!synopsis) return null;
        const [firstWord, ...rest] = synopsis.split(' ');
        const restText = rest.join(' ');
        return (
            <p className={styles.synopsis}>
                <span className={styles.synopsisFirstWord}>{firstWord}</span>
                {' '}
                {formatSynopsis(restText)}
            </p>
        );
    }, [synopsis]);

    // THE FIX: Robustly get name and slug
    const getDevPubInfo = (data: any) => {
        if (!data) return null;
        if (typeof data === 'string') return { name: data, slug: data.toLowerCase().replace(/\s+/g, '-') };
        return { name: data.title, slug: data.slug };
    };

    const devInfo = getDevPubInfo(developer);
    const pubInfo = getDevPubInfo(publisher);

    const heroContent = (
        <motion.div 
            className={styles.hubHero} 
            layoutId={`${layoutIdPrefix}-container`}
        >
            <motion.div 
                className={styles.heroBg}
                layoutId={heroLayoutId}
                style={{ position: 'absolute', inset: 0, zIndex: -2, backgroundColor: 'var(--border-color)' }}
            >
                {!isLoading && (
                    <Image 
                        loader={sanityLoader} 
                        src={heroImageUrl} 
                        alt={`Background for ${hubTitle}`} 
                        fill 
                        style={{ objectFit: 'cover' }} 
                        priority 
                        placeholder={heroBlurDataURL ? 'blur' : 'empty'}
                        blurDataURL={heroBlurDataURL || ''}
                        unoptimized={isExternalImage} 
                    />
                )}
            </motion.div>
            <div className={styles.heroOverlay} />
            
            <motion.div 
                className={`container ${styles.heroContentContainer}`}
                initial={{opacity: 0, y: 20}} animate={{opacity: 1, y: 0}} transition={{duration: 0.5, delay: 0.2}}
            >
                {headerAction}
                <motion.h1 
                    className={`${styles.heroTitle} page-title`} 
                    style={{margin: 0}}
                    layoutId={`${layoutIdPrefix}-title`}
                >
                    {hubType}<span>: &quot;{hubTitle}&quot;</span>
                </motion.h1>
                
                {synopsisContent && (
                    <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ delay: 0.3 }}>
                        {synopsisContent}
                    </motion.div>
                )}
                
                <motion.div 
                    className={styles.metadataRow}
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: 0.4 }}
                >
                    {price && <div className={`${styles.hubPill} ${styles.price}`}>{price}</div>}
                    
                    {onGamePass && ( <div className={`${styles.hubPill} ${styles.platform}`} style={{ borderColor: '#10B981', color: '#10B981' }}> <XboxIcon style={{ width: 14, height: 14 }} /> <span>Game Pass</span> </div> )}
                    {onPSPlus && ( <div className={`${styles.hubPill} ${styles.platform}`} style={{ borderColor: '#3B82F6', color: '#3B82F6' }}> <PS5Icon style={{ width: 16, height: 16 }} /> <span>PS Plus</span> </div> )}
                    
                    {price && (devInfo || pubInfo) && <MetadataDivider />}

                    {devInfo && ( <Link href={`/developers/${devInfo.slug}`} className={`${styles.hubPill} ${styles.dev} ${styles.interactive}`} prefetch={false}> {devInfo.name} </Link> )}
                    {pubInfo && pubInfo.name !== devInfo?.name && ( <Link href={`/publishers/${pubInfo.slug}`} className={`${styles.hubPill} ${styles.dev} ${styles.interactive}`} prefetch={false}> {pubInfo.name} </Link> )}

                    {(devInfo || pubInfo) && platforms && platforms.length > 0 && <MetadataDivider />}

                    {platforms && platforms.map(p => {
                        const Icon = PlatformIcons[p];
                        if (!Icon) return null;
                        return ( <div key={p} className={`${styles.hubPill} ${styles.platform}`}> <Icon style={{ width: 16, height: 16 }} /> <span>{p === 'PlayStation' || p === 'PlayStation 5' ? 'PS5' : p}</span> </div> );
                    })}

                    {platforms && platforms.length > 0 && tags && tags.length > 0 && <MetadataDivider />}

                     {tags && tags.map(t => ( <KineticLink key={t.title} href={t.slug ? `/tags/${t.slug}` : '#'} slug={t.slug || ''} type="tags" className={`${styles.hubPill} ${styles.genre} ${styles.interactive}`} onClick={(e) => e.stopPropagation()}> {translateTag(t.title)} </KineticLink> ))}
                </motion.div>
            </motion.div>
        </motion.div>
    );

    const listLayoutIdPrefix = `hub-${hubType}-${hubTitle.replace(/\s+/g, '-')}`;

    return (
        <div className={styles.hubPageContainer}>
            {heroContent}
            <div ref={contentRef} className="container" style={{paddingTop: '4rem'}}>
                     {isLoading ? ( <div className="content-grid gpu-cull"> <ArticleCardSkeleton variant="default" /> <ArticleCardSkeleton variant="default" /> <ArticleCardSkeleton variant="default" /> <ArticleCardSkeleton variant="default" /> </div>
                     ) : (
                         initialItems && initialItems.length > 0 ? (
                            <>
                                <motion.div initial={{ opacity: 0, y: 50 }} animate={isInView ? { opacity: 1, y: 0 } : {}} transition={{ duration: 0.7, ease: "easeOut" as const }} >
                                    <HubFilters activeTypeFilter={activeTypeFilter} onTypeFilterChange={setActiveTypeFilter} activeSort={activeSort} onSortChange={setActiveSort} />
                                </motion.div>
                                <div className="content-grid" style={{ paddingBottom: '6rem' }}>
                                    <AnimatePresence>
                                        {filteredAndSortedItems.length > 0 ? (
                                            filteredAndSortedItems.map(item => (
                                                <motion.div key={item.id} initial={false} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }} style={{ height: '100%' }}>
                                                    <ArticleCard article={item} layoutIdPrefix={listLayoutIdPrefix} />
                                                </motion.div>
                                            ))
                                        ) : ( <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} style={{gridColumn: '1 / -1', textAlign: 'center', padding: '4rem 0', color: 'var(--text-secondary)'}} > لا يوجد محتوى يطابق بحثك. </motion.div> )}
                                    </AnimatePresence>
                                </div>
                            </>
                         ) : ( <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ delay: 0.5 }} style={{ textAlign: 'center', padding: '6rem 0', color: 'var(--text-secondary)' }} > <p style={{ fontSize: '1.8rem' }}>لم يُنشر أي محتوى (مراجعات، أخبار، مقالات) هنا بعد.</p> </motion.div> )
                     )}
            </div>
        </div>
    );
}

--- END OF FILE components/HubPageClient.tsx ---

================================================================================

--- START OF FILE components/ImageCompare.module.css ---

/* components/ImageCompare.module.css */
.compareWrapper {
  margin: 2rem 0;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid var(--border-color);
  box-shadow: 0 10px 30px -10px rgba(0,0,0,0.2);
  line-height: 0; 
}

.placeholder {
  width: 100%;
  aspect-ratio: 16/9;
  background-color: var(--bg-primary);
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  padding: 1rem;
}

.dropzone {
  aspect-ratio: 16 / 9;
  border: 2px dashed var(--border-color);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  font-family: var(--font-main);
  font-size: 1.4rem;
  transition: border-color 0.2s, background-color 0.2s;
  position: relative; /* For image positioning */
  overflow: hidden; /* To contain the image */
  cursor: pointer; /* For click-to-upload */
}

.dropzone.active {
  border-color: var(--accent);
  background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.uploadIcon {
  width: 2.4rem;
  height: 2.4rem;
  margin-bottom: 0.5rem;
  opacity: 0.6;
}

.imagePreview {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
}

.dropzoneContent {
  position: relative;
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(0,0,0,0.5);
  color: white;
  padding: 1rem;
  border-radius: 6px;
  opacity: 0;
  transition: opacity 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .dropzone:hover .dropzoneContent  {
  opacity: 1;
}
}

  .dropzone:active .dropzoneContent  {
  opacity: 1;
}
}
.dropzone:active .dropzoneContent {
  opacity: 1;
}


.imageCompareContainer {
  margin: 2rem 0;
}

.imageCompareContainer[data-size="small"] { max-width: 50%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="medium"] { max-width: 75%; margin-left: auto; margin-right: auto; }
.imageCompareContainer[data-size="large"] { max-width: 100%; }

.twoImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}

.fourImageGrid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1rem;
}







--- END OF FILE components/ImageCompare.module.css ---

================================================================================

--- START OF FILE components/ImageCompare.tsx ---

// components/ImageCompare.tsx
'use client';

import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import { urlFor } from '@/sanity/lib/image'; // Import urlFor
import styles from './ImageCompare.module.css';

export default function ImageCompare({ value }: { value: any }) {
    const { image1, image2, size } = value;

    if (!image1?.asset || !image2?.asset) {
        return <div className={styles.placeholder}>Could not load image comparison.</div>;
    }

    // --- THE DEFINITIVE FIX ---
    const imageUrl1 = urlFor(image1).auto('format').url();
    const imageUrl2 = urlFor(image2).auto('format').url();

    return (
        <div className={styles.imageCompareContainer} data-size={size || 'large'}>
            <div className={styles.compareWrapper}>
                <ReactCompareSlider
                    itemOne={<ReactCompareSliderImage src={imageUrl1} alt={image1.alt || 'Before'} />}
                    itemTwo={<ReactCompareSliderImage src={imageUrl2} alt={image2.alt || 'After'} />}
                />
            </div>
        </div>
    );
}







--- END OF FILE components/ImageCompare.tsx ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.module.css ---

/* components/KineticReleaseTimeline.module.css */
.timelineContainer {
  position: relative;
  max-width: 800px;
  margin: 0 auto;
  padding: 4rem 2rem;
  overflow: visible;
}

.timelineSpine {
  position: absolute;
  top: 0;
  right: 50%;
  transform: translateX(50%);
  width: 2px;
  height: 100%;
  z-index: 1;
}

.timelineSpineTrack {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
  border-radius: 2px;
}

.timelineSpineProgress {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  box-shadow: 0 0 10px 0 var(--accent);
  transform-origin: top;
  /* GPU FIX: Removed will-change */
}

.timelineItemsWrapper {
  display: flex;
  flex-direction: column;
  position: relative;
  z-index: 2;
  
  /* GPU CULL FIX: Expand render boundary */
  padding: 10rem;
  margin: -10rem;
  width: calc(100% + 20rem);
  
  /* FIX: Prevent padding from capturing mouse events */
  pointer-events: none;
}

/* Restore interaction */
.timelineItemsWrapper > * {
    pointer-events: auto;
}

.timelineItemWrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  position: relative;
  margin-bottom: 4rem;
  gap: 60px; 
}

.cardContainer {
    flex: 1;
    max-width: 340px;
    width: 100%;
    min-width: 0;
    z-index: 10;
}

/* REFACTORED: Floating Glass Style instead of solid block */
.synopsisContainer {
  flex: 1;
  max-width: 340px;
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  color: var(--text-primary);
  line-height: 1.7;
  pointer-events: none;
  
  /* Glassy Background */
  background-color: rgba(10, 11, 15, 0.4);
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.05);
  
  border-radius: 12px;
  padding: 2.5rem;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
  z-index: 5;
}

.timelineItemWrapper.left { flex-direction: row-reverse; }
.timelineItemWrapper.right { flex-direction: row; }
.timelineItemWrapper.left .synopsisContainer { text-align: right; }
.timelineItemWrapper.right .synopsisContainer { text-align: left; }

.synopsisFirstWord {
  font-weight: 700;
  color: var(--accent);
}

.dotsContainer {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  pointer-events: none;
}

/* OPTIMIZED DOT STYLES */
.dotWrapper {
    position: absolute;
    left: 50%;
    transform: translateX(-50%) translateY(-50%);
    width: 12px;
    height: 12px;
}

/* Static Base Dot (Always Visible, Cheap) */
.dotBase {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background-color: var(--border-color);
}

/* Animated Active Dot (Fades in, GPU Accelerated) */
.dotActive {
    position: absolute;
    inset: 0;
    border-radius: 50%;
    background-color: var(--accent);
    box-shadow: 0 0 8px 0 var(--accent);
    /* Keep will-change here as it's small and frequently updated via opacity */
    will-change: opacity;
}


.terminusContainer {
  position: relative;
  text-align: center;
  margin-top: 2rem;
  height: 60px;
  z-index: 3;
}

.timelineTerminusButton {
  display: inline-flex;
  align-items: center;
  gap: 1rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  padding: 1rem 2.5rem;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-secondary);
  transition: all 0.15s ease-out;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
}
@media (hover: hover) {
  .timelineTerminusButton:hover  {
    color: var(--accent);
    border-color: var(--accent);
    transform: translateY(-3px);
    box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent);
  }
  .timelineTerminusButton:active  {
    color: var(--accent);
    border-color: var(--accent);
    transform: translateY(-3px);
    box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent);
  }
}
.timelineTerminusButton:active {
  color: var(--accent);
  border-color: var(--accent);
  transform: translateY(-3px);
  box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent);
}

.terminusIcon {
  width: 20px;
  height: 20px;
}

@media (max-width: 768px) {
  .timelineContainer { padding: 4rem 0.5rem; }
  .timelineSpine { display: block; }
  .timelineItemWrapper { gap: 0; margin-bottom: 3rem; }
  .cardContainer { flex: 0 0 42%; max-width: none; }
  
  .synopsisContainer { 
      flex: 0 0 42%; 
      max-width: none; 
      padding: 1rem; 
      font-size: 1.1rem; 
      line-height: 1.4; 
      border-radius: 8px;
      /* Simpler on mobile for perf, but still transparent/dark */
      background-color: rgba(10, 11, 15, 0.6); 
      border-color: rgba(255,255,255,0.05);
  }
  
  .synopsisContainer p { margin: 0; display: -webkit-box; -webkit-line-clamp: 5; -webkit-box-orient: vertical; overflow: hidden; }
  
  .dotWrapper, .dotBase, .dotActive { width: 8px; height: 8px; }
  
  .timelineItemsWrapper {
  }
}
/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .synopsisContainer {
  background-color: rgba(255, 255, 255, 0.75);
  border-color: rgba(0,0,0,0.05);
  color: var(--text-primary);
  box-shadow: 0 5px 20px rgba(0,0,0,0.05);
  backdrop-filter: blur(12px);
}
:global([data-theme="light"]) .dotBase {
  background-color: rgba(0,0,0,0.1);
}
:global([data-theme="light"]) .timelineSpineTrack {
  background-color: rgba(0,0,0,0.05);
}


--- END OF FILE components/KineticReleaseTimeline.module.css ---

================================================================================

--- START OF FILE components/KineticReleaseTimeline.tsx ---

// components/KineticReleaseTimeline.tsx
'use client';

import React, { useMemo, useRef, useState, useEffect, useCallback } from 'react';
import { motion, useScroll, useInView, useTransform, MotionValue, AnimatePresence } from 'framer-motion';
// Link is replaced by button for kinetic action
import TimelineCard from './TimelineCard';
import styles from './KineticReleaseTimeline.module.css';
import ReleasesCredits from './releases/ReleasesCredits';
import { useContentStore } from '@/lib/contentStore';

const ViewAllIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" {...props}>
        <rect x="3" y="3" width="7" height="7"></rect>
        <rect x="14" y="3" width="7" height="7"></rect>
        <rect x="14" y="14" width="7" height="7"></rect>
        <rect x="3" y="14" width="7" height="7"></rect>
    </svg>
);

const SynopsisDisplay = ({ synopsis, isLeft, isInView }: { synopsis: string; isLeft: boolean; isInView: boolean; }) => {
    const [firstWord, ...rest] = synopsis.split(' ');
    const restOfText = rest.join(' ');

    return (
        <AnimatePresence>
            {isInView && (
                <motion.div
                    className={`${styles.synopsisContainer} ${isLeft ? styles.left : styles.right}`}
                    initial={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    transition={{ duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                >
                    <p>
                        <span className={styles.synopsisFirstWord}>{firstWord}</span>
                        {' '}{restOfText}
                    </p>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

const TimelineItem = ({ release, index }: { release: any, index: number }) => {
    const itemRef = useRef(null);
    const cardIsInView = useInView(itemRef, { once: true, amount: 0.4 });
    const isLeft = index % 2 === 0;
    
    const variants = {
        hidden: { opacity: 0, x: isLeft ? -30 : 30, scale: 0.95 },
        visible: { opacity: 1, x: 0, scale: 1, transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] as const } }
    };

    return (
        <div ref={itemRef} className={`${styles.timelineItemWrapper} ${isLeft ? styles.left : styles.right}`}>
            <SynopsisDisplay synopsis={release.synopsis} isLeft={isLeft} isInView={cardIsInView} />
            <motion.div 
                variants={variants} 
                initial="hidden" 
                animate={cardIsInView ? "visible" : "hidden"}
                className={styles.cardContainer}
            >
                <TimelineCard release={release} variant="homepage" />
            </motion.div>
        </div>
    );
};

const TimelineDot = ({ position, scrollYProgress }: { position: number, scrollYProgress: MotionValue<number> }) => {
    const activeOpacity = useTransform( scrollYProgress, [position - 0.001, position], [0, 1] );
    return ( 
        <div className={styles.dotWrapper} style={{ top: `${position * 100}%` }}>
            <div className={styles.dotBase} />
            <motion.div className={styles.dotActive} style={{ opacity: activeOpacity }} /> 
        </div> 
    );
};

export default function KineticReleaseTimeline({ releases: allReleases, credits }: { releases: any[], credits?: any[] }) {
    const timelineRef = useRef<HTMLDivElement>(null);
    const terminusRef = useRef(null);
    const isTerminusInView = useInView(terminusRef, { once: true, amount: 0.8 });
    const [dotPositions, setDotPositions] = useState<number[]>([]);
    
    const { scrollYProgress } = useScroll({ target: timelineRef, offset: ["start 60%", "end 50%"], });
    const scaleY = useTransform(scrollYProgress, [0, 1], [0, 1]);
    
    const { openIndexOverlay } = useContentStore();
    
    const releasesForThisMonth = useMemo(() => {
        if (!allReleases) return [];
        const now = new Date();
        const currentMonth = now.getUTCMonth();
        const currentYear = now.getUTCFullYear();
        
        return allReleases
            .filter(release => {
                if (release.isTBA || !release.releaseDate) return false;
                const releaseDate = new Date(release.releaseDate);
                return releaseDate.getUTCMonth() === currentMonth && releaseDate.getUTCFullYear() === currentYear; 
            })
            .sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    }, [allReleases]);

    // Recalculate positions based on real DOM geometry
    const calculatePositions = useCallback(() => {
        if (!timelineRef.current) return;
        const containerEl = timelineRef.current;
        
        // Get precise dimensions
        const containerRect = containerEl.getBoundingClientRect();
        const containerHeight = containerRect.height;
        
        if (containerHeight === 0) return;

        const itemElements = Array.from(containerEl.querySelectorAll(`.${styles.timelineItemWrapper}`));
        
        const positions = itemElements.map(el => { 
            const item = el as HTMLElement; 
            const itemRect = item.getBoundingClientRect();
            
            // Calculate center relative to the container's current visual position
            // boundingClientRect accounts for transforms and scrolling, ensuring accuracy
            const relativeTop = itemRect.top - containerRect.top;
            const center = relativeTop + (itemRect.height / 2);
            
            return center / containerHeight; 
        });
        
        // Avoid state update loops if values haven't changed
        setDotPositions(prev => {
            if (prev.length === positions.length && prev.every((v, i) => Math.abs(v - positions[i]) < 0.0001)) {
                return prev;
            }
            return positions;
        });
    }, []);

    // Observer setup to catch layout shifts (images loading, window resize)
    useEffect(() => {
        if (!timelineRef.current || releasesForThisMonth.length === 0) return;

        // 1. Calculate immediately
        calculatePositions();

        // 2. Observe container resize
        const observer = new ResizeObserver(() => {
            window.requestAnimationFrame(() => {
                calculatePositions();
            });
        });
        
        observer.observe(timelineRef.current);
        
        // 3. Safety fallback for late loading assets that might not trigger resize immediately
        const timeoutId = setTimeout(calculatePositions, 1000);

        return () => {
            observer.disconnect();
            clearTimeout(timeoutId);
        };
    }, [releasesForThisMonth, calculatePositions]);

    return (
        <div ref={timelineRef} className={styles.timelineContainer}>
            <ReleasesCredits initialCredits={credits || []} />

            <div className={styles.timelineContent}>
                <div className={styles.timelineSpine}>
                    <div className={styles.timelineSpineTrack} />
                    <motion.div className={styles.timelineSpineProgress} style={{ scaleY, transformOrigin: 'top' }} />
                    <div className={styles.dotsContainer}>
                        {dotPositions.map((pos, index) => ( 
                            <TimelineDot key={index} position={pos} scrollYProgress={scrollYProgress} /> 
                        ))}
                    </div>
                </div>
                <div className={`${styles.timelineItemsWrapper} gpu-cull`}>
                    {releasesForThisMonth.length > 0 ? (
                        releasesForThisMonth.map((release, index) => ( 
                            <TimelineItem key={release._id} release={release} index={index} /> 
                        ))
                    ) : (
                        <motion.div 
                            style={{ paddingTop: '5vh', textAlign: 'center', color: 'var(--text-secondary)', width: '100%' }} 
                            initial={{ opacity: 0 }} 
                            animate={{ opacity: 1 }} 
                            transition={{ duration: 0.8, delay: 0.2, ease: 'easeOut' as const }}
                        >
                            لا إصدارات مجدولة لهذا الشهر.
                        </motion.div>
                    )}
                </div>

                {releasesForThisMonth.length > 0 && (
                    <motion.div
                        ref={terminusRef}
                        className={styles.terminusContainer}
                        initial={{ opacity: 0, y: 30 }}
                        animate={isTerminusInView ? { opacity: 1, y: 0 } : {}}
                        transition={{ duration: 0.6, ease: 'easeOut', delay: 0.3 }}
                    >
                        <motion.button 
                            whileHover={{ scale: 1.05 }}
                            whileTap={{ scale: 0.95 }}
                            onClick={() => openIndexOverlay('releases')}
                            className={styles.timelineTerminusButton}
                        >
                            <ViewAllIcon className={styles.terminusIcon} />
                            <span>عرض كل الإصدارات</span>
                        </motion.button>
                    </motion.div>
                )}
            </div>
        </div>
    );
}

--- END OF FILE components/KineticReleaseTimeline.tsx ---

================================================================================

--- START OF FILE components/Lightbox.module.css ---

/* components/Lightbox.module.css */
.lightboxOverlay {
    position: fixed;
    inset: 0;
    background-color: color-mix(in srgb, var(--bg-primary) 70%, transparent);
    backdrop-filter: blur(10px) saturate(120%);
    z-index: 9998;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 15vh 20vw;
    cursor: zoom-out;
    
    /* THE DEFINITIVE FIX: CSS-based Scroll Locking */
    /* This prevents scroll events from bubbling to the parent (overlay/body) */
    overscroll-behavior: contain;
    touch-action: none;
    /* Ensure it captures all pointer events */
    pointer-events: auto;
}

:global(body.no-glass) .lightboxOverlay {
    backdrop-filter: none !important;
    background-color: rgba(0,0,0,0.95) !important;
}

@media (max-width: 1024px) {
    .lightboxOverlay {
        padding: 10vh 5vw;
        /* MOBILE OPTIMIZATION: Kill Blur */
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(5, 5, 5, 0.95);
    }
}

.imageContainer {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    box-shadow: 0 25px 50px -12px rgba(0,0,0,0.6);
    background-color: var(--border-color); /* Fallback for loading */
    
    /* Ensure clicks here don't close the overlay */
    cursor: auto;
}

.lightboxImage {
    max-width: none;
    max-height: none;
    width: 100%;
    height: 100%;
    object-fit: contain; /* THE FIX: Ensures the whole image is visible */
    cursor: grab;
    will-change: transform;
}
.lightboxImage:active {
    cursor: grabbing;
}

.controls {
    position: absolute;
    top: 2rem;
    left: 2rem; /* RTL */
    right: auto;
    z-index: 9999;
    display: flex;
    gap: 0.75rem;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    padding: 0.5rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

:global(body.no-glass) .controls {
    background-color: var(--bg-secondary) !important;
    opacity: 1 !important;
}

.controlButton {
    width: 44px;
    height: 44px;
    border-radius: 6px;
    background-color: transparent;
    border: none;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
}
@media (hover: hover) {
  .controlButton:hover  {
    background-color: var(--bg-primary);
    color: var(--accent);
}
}
.controlButton:active {
    background-color: var(--bg-primary);
    color: var(--accent);
}

.controlButton svg {
    width: 22px;
    height: 22px;
}

/* --- THE DEFINITIVE FIX: Navigation Button Styles --- */
.navButton {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(4px);
    z-index: 9999;
    transition: all 0.2s ease-out;
}

:global(body.no-glass) .navButton {
    backdrop-filter: none !important;
    background-color: var(--bg-secondary) !important;
    opacity: 1 !important;
}

@media (max-width: 768px) {
    .navButton {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(10, 11, 15, 0.95);
    }
}
@media (hover: hover) {
  .navButton:hover  {
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-50%) scale(1.1);
}
}
.navButton:active {
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-50%) scale(1.1);
}

.navButton.prev {
    left: 2rem; /* RTL */
    right: auto;
}
.navButton.next {
    right: 2rem; /* RTL */
    left: auto;
}

--- END OF FILE components/Lightbox.module.css ---

================================================================================

--- START OF FILE components/Lightbox.tsx ---

// components/Lightbox.tsx
'use client';

import { createPortal } from 'react-dom';
import { AnimatePresence, motion, useMotionValue, useSpring } from 'framer-motion';
import { useLightboxStore } from '@/lib/lightboxStore';
import { useEffect, useState, useRef, useCallback } from 'react';
import styles from './Lightbox.module.css';

const ZoomInIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ZoomOutIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>;
const ResetIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/></svg>;
const DownloadIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
const CloseIcon = () => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const ArrowIcon = ({ dir }: { dir: 'left' | 'right' }) => <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points={dir === 'left' ? "15 18 9 12 15 6" : "9 18 15 12 9 6"} /></svg>;

const clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max);
const springConfig = { type: 'spring', damping: 30, stiffness: 400 };

export default function Lightbox() {
    const { isOpen, imageUrls, currentIndex, closeLightbox, goToNext, goToPrevious } = useLightboxStore();
    const [isMounted, setIsMounted] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const imageRef = useRef<HTMLImageElement>(null);
    const imageUrl = imageUrls[currentIndex];

    // --- SCROLL FREEZE STRATEGY: EVENT INTERCEPTION ---
    // Instead of modifying body overflow (which causes layout jumps), we simply
    // swallow 'wheel' and 'touchmove' events on the document level while open.
    useEffect(() => {
        if (isOpen) {
            const preventScroll = (e: Event) => {
                // Prevent default behavior (scrolling)
                e.preventDefault();
            };

            // Option { passive: false } is required to allow calling preventDefault
            document.addEventListener('wheel', preventScroll, { passive: false });
            document.addEventListener('touchmove', preventScroll, { passive: false });

            // Also prevent spacebar/arrow scrolling
            const preventKeys = (e: KeyboardEvent) => {
                if ([' ', 'ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', 'Home', 'End'].includes(e.key)) {
                    e.preventDefault();
                }
            };
            document.addEventListener('keydown', preventKeys);

            return () => {
                document.removeEventListener('wheel', preventScroll);
                document.removeEventListener('touchmove', preventScroll);
                document.removeEventListener('keydown', preventKeys);
            };
        }
    }, [isOpen]);

    const scale = useMotionValue(1);
    const x = useMotionValue(0);
    const y = useMotionValue(0);

    const animatedScale = useSpring(scale, springConfig);
    const animatedX = useSpring(x, springConfig);
    const animatedY = useSpring(y, springConfig);
    
    const [dragConstraints, setDragConstraints] = useState({ left: 0, right: 0, top: 0, bottom: 0 });

    useEffect(() => {
        setIsMounted(true);
        const handleKeyDown = (e: KeyboardEvent) => { 
            if (e.key === 'Escape') closeLightbox();
            if (isOpen && imageUrls.length > 1) {
                if (e.key === 'ArrowRight') goToPrevious();
                if (e.key === 'ArrowLeft') goToNext();
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [closeLightbox, isOpen, imageUrls, goToNext, goToPrevious]);

    const resetTransform = useCallback(() => {
        scale.set(1);
        x.set(0);
        y.set(0);
    }, [scale, x, y]);

    useEffect(() => { if (isOpen) resetTransform(); }, [isOpen, resetTransform, currentIndex]);
    
    const updateConstraints = useCallback((currentScale: number) => {
        const currentX = x.get();
        const currentY = y.get();

        if (currentScale <= 1) {
            setDragConstraints({ left: 0, right: 0, top: 0, bottom: 0 });
            resetTransform();
            return;
        }

        if (containerRef.current && imageRef.current && imageRef.current.naturalWidth > 0) {
            const container = containerRef.current.getBoundingClientRect();
            const imageAspectRatio = imageRef.current.naturalWidth / imageRef.current.naturalHeight;
            const containerAspectRatio = container.width / container.height;
            
            let renderedWidth, renderedHeight;
            if (imageAspectRatio > containerAspectRatio) {
                renderedWidth = container.width;
                renderedHeight = container.width / imageAspectRatio;
            } else {
                renderedHeight = container.height;
                renderedWidth = container.height * imageAspectRatio;
            }

            const overhangX = Math.max(0, (renderedWidth * currentScale - container.width) / 2);
            const overhangY = Math.max(0, (renderedHeight * currentScale - container.height) / 2);

            setDragConstraints({ left: -overhangX, right: overhangX, top: -overhangY, bottom: overhangY });
            
            x.set(clamp(currentX, -overhangX, overhangX));
            y.set(clamp(currentY, -overhangY, overhangY));
        }
    }, [x, y, resetTransform, scale]);

    useEffect(() => {
        const unsubscribe = scale.onChange(updateConstraints);
        return () => unsubscribe();
    }, [scale, updateConstraints]);
    
    const handleZoom = useCallback((delta: number, clientX?: number, clientY?: number) => {
        const currentScale = scale.get();
        const newScale = clamp(currentScale + delta, 1, 8);
        const scaleRatio = newScale / currentScale;

        const currentX = x.get();
        const currentY = y.get();
        
        if (containerRef.current && clientX && clientY) {
            const rect = containerRef.current.getBoundingClientRect();
            const pointerX = clientX - rect.left - rect.width / 2;
            const pointerY = clientY - rect.top - rect.height / 2;
            
            const newX = pointerX + (currentX - pointerX) * scaleRatio;
            const newY = pointerY + (currentY - pointerY) * scaleRatio;
            
            x.set(newX);
            y.set(newY);
        }
        scale.set(newScale);
    }, [scale, x, y]);

    const handleWheel = useCallback((e: React.WheelEvent) => {
        // Prevent default zoom/scroll behavior
        e.preventDefault();
        e.stopPropagation();
        handleZoom(e.deltaY * -0.01, e.clientX, e.clientY);
    }, [handleZoom]);

    const isZoomed = scale.get() > 1.001;
    
    const downloadUrl = imageUrl ? `${imageUrl.split('?')[0]}?dl` : '';

    const lightboxContent = (
        <AnimatePresence>
            {isOpen && imageUrl && (
                <motion.div 
                    className={styles.lightboxOverlay} 
                    onWheel={handleWheel} 
                    onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        closeLightbox();
                    }}
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1 }} 
                    exit={{ opacity: 0 }}
                >
                    <motion.div ref={containerRef} className={styles.imageContainer} onClick={(e) => e.stopPropagation()} initial={{ scale: 0.9, opacity: 0 }} animate={{ scale: 1, opacity: 1 }} exit={{ scale: 0.9, opacity: 0 }} transition={{type: 'spring', damping: 25, stiffness: 250}}>
                        <AnimatePresence mode="wait">
                            <motion.img
                                key={currentIndex}
                                ref={imageRef}
                                drag={isZoomed}
                                dragConstraints={dragConstraints}
                                dragElastic={0}
                                dragMomentum={false}
                                src={imageUrl}
                                alt="Full resolution view"
                                className={styles.lightboxImage}
                                style={{ 
                                    scale: animatedScale, 
                                    x: animatedX, 
                                    y: animatedY 
                                }}
                                initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{ duration: 0.2 }}
                            />
                        </AnimatePresence>
                    </motion.div>
                    
                    <div className={styles.controls} onClick={(e) => e.stopPropagation()}>
                        <button className={styles.controlButton} onClick={() => handleZoom(0.5)} title="Zoom In"><ZoomInIcon /></button>
                        <button className={styles.controlButton} onClick={() => handleZoom(-0.5)} title="Zoom Out"><ZoomOutIcon /></button>
                        <button className={styles.controlButton} onClick={resetTransform} title="Reset Zoom"><ResetIcon /></button>
                        <a href={downloadUrl} download className={styles.controlButton} title="Download Image"><DownloadIcon /></a>
                        <button className={styles.controlButton} onClick={closeLightbox} title="Close"><CloseIcon /></button>
                    </div>

                    {imageUrls.length > 1 && (
                        <>
                            <button className={`${styles.navButton} ${styles.prev}`} onClick={(e) => { e.stopPropagation(); goToPrevious(); }}><ArrowIcon dir="left" /></button>
                            <button className={`${styles.navButton} ${styles.next}`} onClick={(e) => { e.stopPropagation(); goToNext(); }}><ArrowIcon dir="right" /></button>
                        </>
                    )}
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) return null;
    return createPortal(lightboxContent, document.body);
}

--- END OF FILE components/Lightbox.tsx ---

================================================================================

--- START OF FILE components/Navbar.module.css ---

/* components/Navbar.module.css */

.navbar {
  position: fixed;
  top: 0;
  right: 0;
  width: 100%;
  /* FIX: Z-Index 2060 to sit ABOVE Kinetic Overlay (2050) but BELOW Search (3000) */
  z-index: 2060;
  height: var(--nav-height);
  display: flex;
  align-items: center;
  
  /* OPTIMIZATION: Hint browser about expensive layout changes */
  will-change: height, background-color, backdrop-filter;
  
  /* FIX: Removed 'width' from transition to prevent layout jump on scrollbar removal */
  transition: height 0.4s cubic-bezier(0.16, 1, 0.3, 1), 
              background-color 0.4s ease, 
              backdrop-filter 0.4s ease;
  border-bottom: 1px solid transparent;
}

/* Cyber-Industrial Glass Dock (Default / Dark Mode) */
.navbar.scrolled {
  height: var(--nav-height-scrolled);
  background-color: rgba(5, 5, 5, 0.6);
  backdrop-filter: blur(20px) saturate(140%);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow: 0 10px 40px -10px rgba(0,0,0,0.9);
}

/* Light Mode Override for Scrolled State */
:global([data-theme="light"]) .navbar.scrolled {
  background-color: rgba(255, 255, 255, 0.8) !important;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05) !important;
  box-shadow: 0 10px 40px -10px rgba(0,0,0,0.05) !important;
}

:global(body.no-glass) .navbar.scrolled {
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  background-color: rgba(5, 5, 5, 0.95) !important;
}

:global([data-theme="light"] body.no-glass) .navbar.scrolled {
  background-color: rgba(255, 255, 255, 0.95) !important;
}

@media (max-width: 768px) {
  /* MOBILE OPTIMIZATION: Kill Blur */
  .navbar.scrolled {
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    background-color: rgba(5, 5, 5, 0.95) !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
  }

  :global([data-theme="light"]) .navbar.scrolled {
    background-color: rgba(255, 255, 255, 0.95) !important;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1) !important;
  }
}

.navContainer {
  width: 100%;
  height: 100%;
}

.desktopView {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  width: 100%;
  height: 100%;
}

.navLogo {
  font-family: var(--font-heading), sans-serif;
  font-size: 3rem;
  font-weight: 800;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  z-index: 10;
}

.desktopView > nav { 
    justify-self: center; 
    height: 100%;
    display: flex;
    align-items: center;
}

.navLinks {
  display: flex;
  gap: 0.5rem;
  list-style: none;
  align-items: center;
  height: 100%;
  margin: 0;
  padding: 0;
}

.navItem {
    position: relative;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    perspective: 1000px;
}

.blackHoleLink {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 2.4rem;
    height: 100%;
    text-decoration: none !important;
    cursor: pointer;
    color: var(--text-primary);
    font-family: var(--font-ui);
    font-weight: 700;
    font-size: 1.5rem;
    border-radius: 999px;
    background: transparent;
    transition: background-color 0.3s ease;
}
@media (hover: hover) {
  .blackHoleLink:hover  {
    background-color: rgba(255, 255, 255, 0.03);
  }
  :global([data-theme="light"]) .blackHoleLink:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }

  .blackHoleLink:active  {
    background-color: rgba(255, 255, 255, 0.03);
  }
  :global([data-theme="light"]) .blackHoleLink:active {
    background-color: rgba(0, 0, 0, 0.05);
  }
}
.blackHoleLink:active {
    background-color: rgba(255, 255, 255, 0.03);
}
:global([data-theme="light"]) .blackHoleLink:active {
    background-color: rgba(0, 0, 0, 0.05);
}


/* Override global underline animation */
.blackHoleLink::after {
    display: none !important;
    content: none !important;
}

.contentContainer {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Text Layer */
.textWrapper {
    position: relative;
    display: block;
    white-space: nowrap;
    z-index: 2;
    will-change: transform, opacity, filter;
    backface-visibility: hidden; 
}

/* Icon Layer */
.iconWrapper {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3;
    pointer-events: none;
    will-change: transform, opacity, filter;
}

.navIconSvg {
    width: 26px;
    height: 26px;
    filter: drop-shadow(0 0 12px var(--accent));
    color: var(--accent);
}

.navControls {
  justify-self: end;
  display: flex;
  align-items: center;
  gap: 2rem;
}

.navSearch {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  position: relative;
  width: 2.4rem;
  height: 2.4rem;
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
}

.navSearch svg {
  width: 2.2rem;
  height: 2.2rem;
  stroke: currentColor;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}
@media (hover: hover) {
  .navSearch:hover svg  {
  color: var(--accent);
  transform: scale(1.15) rotate(-15deg);
  filter: drop-shadow(0 0 8px var(--accent));
  }
  .navSearch:active svg  {
  color: var(--accent);
  transform: scale(1.15) rotate(-15deg);
  filter: drop-shadow(0 0 8px var(--accent));
  }
}
.navSearch:active svg {
  color: var(--accent);
  transform: scale(1.15) rotate(-15deg);
  filter: drop-shadow(0 0 8px var(--accent));
}


/* --- MOBILE --- */
.mobileView { display: none; }
.hamburgerButton { display: none; }
.mobileNavOverlay { display: none; }
.orbitalCenter { font-family: var(--font-heading); font-weight: 800; font-size: 8rem; color: var(--text-secondary); background-color: var(--bg-secondary); border: 1px solid var(--border-color); width: 120px; height: 120px; border-radius: 50%; display: flex; align-items: center; justify-content: center; line-height: 1; box-shadow: 0 5px 15px rgba(0,0,0,0.1); transition: all 0.2s ease-out; }
@media (hover: hover) {
  .orbitalCenter:hover  { transform: scale(1.05); border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent); }
  .orbitalCenter:active  { transform: scale(1.05); border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent); }
}
.orbitalCenter:active { transform: scale(1.05); border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent); }

.orbitalCenter.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent); }
.orbitalItemWrapper { position: absolute; display: flex; flex-direction: column; align-items: center; gap: 0.75rem; }
.orbitalOrb { width: 64px; height: 64px; border-radius: 50%; background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-secondary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease-out; box-shadow: 0 5px 15px rgba(0,0,0,0.1); font-size: 2rem; font-weight: 800; }
.orbitalOrb.active { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 50%, transparent); }
.orbitalOrb svg { width: 28px; height: 28px; }
.orbitalTitle { font-family: var(--font-main); font-size: 1.4rem; font-weight: 600; color: var(--text-primary); pointer-events: none; text-align: center; text-shadow: 0 2px 5px var(--bg-primary); }

@media (max-width: 1024px) {
  .desktopView { display: none; }
  .mobileView { display: flex; justify-content: space-between; align-items: center; width: 100%; }
  .mobileNavGroupLeft, .mobileNavGroupRight { display: flex; align-items: center; gap: 1.5rem; flex: 1; }
  .mobileNavGroupLeft { justify-content: flex-start; }
  .mobileNavGroupRight { justify-content: flex-end; }
  .hamburgerButton { display: flex; align-items: center; justify-content: center; background: none; border: none; padding: 0; cursor: pointer; z-index: 1201; color: var(--text-primary); width: 2.4rem; height: 2.4rem; }
  
  .mobileNavOverlay { 
      display: flex; align-items: center; justify-content: center; position: fixed; inset: 0; 
      background-color: color-mix(in srgb, var(--bg-primary) 85%, transparent); 
      backdrop-filter: blur(10px); 
      /* FIX: Must be higher than Overlay (2050) and Navbar (2060) to allow interaction */
      z-index: 2100; 
  }
  
  :global(body.no-glass) .mobileNavOverlay {
      backdrop-filter: none !important;
      background-color: rgba(5, 5, 5, 0.98) !important;
  }
  
  :global([data-theme="light"] body.no-glass) .mobileNavOverlay {
      background-color: rgba(255, 255, 255, 0.98) !important;
  }
  
  /* Mobile Opt for Overlay: Kill Blur */
  @media (max-width: 768px) {
      .mobileNavOverlay { 
          backdrop-filter: none !important;
          -webkit-backdrop-filter: none !important;
          background-color: rgba(5, 5, 5, 0.98); /* Higher opacity fallback */
      }
      :global([data-theme="light"]) .mobileNavOverlay {
          background-color: rgba(255, 255, 255, 0.98);
      }
  }

  .mobileNavContent { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; }
}

body.editor-active .desktopView > nav { display: none; }
body.editor-active .desktopView { grid-template-columns: auto 1fr; }
@media (max-width: 1024px) { body.editor-active .mobileView { display: none; } }

--- END OF FILE components/Navbar.module.css ---

================================================================================

--- START OF FILE components/Navbar.tsx ---

// components/Navbar.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { ThemeToggle } from './ThemeToggle';
import UserProfile from './UserProfile';
import NotificationBell from '@/components/notifications/NotificationBell';
import PerformanceSettings from '@/components/PerformanceSettings';
import { motion, AnimatePresence, Variants, Transition } from 'framer-motion';
import { useScrolled } from '@/hooks/useScrolled';
import { useBodyClass } from '@/hooks/useBodyClass';
import { useUIStore } from '@/lib/uiStore';
import { ReviewIcon, NewsIcon, ArticleIcon, ReleaseIcon, StudioIcon, PreviewIcon } from '@/components/icons/index';
import { EternalGamesIcon } from '@/components/icons/AuthIcons';
import { useEditorStore } from '@/lib/editorStore';
import { QualityToggle } from '@/app/studio/[contentType]/[id]/editor-components/QualityToggle';
import Search from './Search';
import styles from './Navbar.module.css';
import editorStyles from '@/app/studio/[contentType]/[id]/Editor.module.css';
import { useContentStore } from '@/lib/contentStore'; 
import { startNavigation } from '@/components/ui/ProgressBar'; 

const SearchIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
);

export const HamburgerIcon = ({ isOpen }: { isOpen: boolean }) => (
    <div style={{ width: '24px', height: '24px', position: 'relative' }}>
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '6px', borderRadius: '2px' }} animate={{ rotate: isOpen ? 45 : 0, y: isOpen ? 5 : 0 }} transition={{ type: 'spring', stiffness: 300, damping: 20 }} />
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '11px', borderRadius: '2px' }} animate={{ opacity: isOpen ? 0 : 1 }} transition={{ duration: 0.1 }} />
        <motion.span style={{ position: 'absolute', right: 0, height: '2.5px', width: '24px', backgroundColor: 'currentColor', top: '16px', borderRadius: '2px' }} animate={{ rotate: isOpen ? -45 : 0, y: isOpen ? -5 : 0 }} transition={{ type: 'spring', stiffness: 300, damping: 20 }} />
    </div>
);

const ConstellationIcon = (props: React.SVGProps<SVGSVGElement>) => (<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" role="img" color="currentColor" {...props} style={{ transform: 'translate(1px, 2px)' }}><path d="M12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path><path d="M20 18C21.1046 18 22 17.1046 22 16C22 14.8954 21.1046 14 20 14C18.8954 14 18 14.8954 18 16C18 17.1046 18.8954 18 20 18Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path><path d="M11 22C12.1046 22 13 21.1046 13 20C13 18.8954 12.1046 18 11 18C9.89543 18 9 18.8954 9 20C9 21.1046 9.89543 22 11 22Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path><path d="M15 6C16.1046 6 17 5.10457 17 4C17 2.89543 16.1046 2 15 2C13.8954 2 13 2.89543 13 4C13 5.10457 13.8954 6 15 6Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path><path d="M4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path><path d="M14.5 6L12.5 10M13 4.5L6 7.5M12 14L11 18M14 13L18 15M18 17L13 19.5" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path></svg>);
const CelestialAlmanacIcon = (props: React.SVGProps<SVGSVGElement>) => (<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24" fill="none" color="currentColor" {...props}><path fillRule="evenodd" clipRule="evenodd" d="M18 1.25C19.5188 1.25 20.75 2.48122 20.75 4V4.23047C20.75 5.5687 20.1855 6.84489 19.1953 7.74512L15.7441 10.8818C15.4292 11.1681 15.25 11.5744 15.25 12C15.25 12.4256 15.4292 12.8319 15.7441 13.1182L19.1953 16.2549C20.1855 17.1551 20.75 18.4313 20.75 19.7695V20C20.75 21.5188 19.5188 22.75 18 22.75H6C4.48122 22.75 3.25 21.5188 3.25 20V19.7695C3.25 18.4313 3.81451 17.1551 4.80469 16.2549L8.25586 13.1182C8.57077 12.8319 8.75 12.4256 8.75 12C8.75 11.5744 8.57077 11.1681 8.25586 10.8818L4.80469 7.74512C3.81451 6.84489 3.25 5.5687 3.25 4.23047V4C3.25 2.48122 4.48122 1.25 6 1.25H18Z" fill="currentColor"/><path d="M16.5 19.5001V17.0001H14C13.4477 17.0001 13 16.5523 13 16.0001C13 15.4478 13.4477 15.0001 14 15.0001H16.5V12.5001C16.5 11.9478 16.9477 11.5001 17.5 11.5001C18.0523 11.5001 18.5 11.9478 18.5 12.5001V15.0001H21C21.5523 15.0001 22 15.4478 22 16.0001C22 16.5523 21.5523 17.0001 21 17.0001H18.5V19.5001C18.5 20.0523 18.0523 20.5001 17.5 20.5001C16.9477 20.5001 16.5 20.0523 16.5 19.5001Z" fill="none" stroke="var(--bg-primary)" strokeWidth="2.5"/><path d="M16.5 19.5001V17.0001H14C13.4477 17.0001 13 16.5523 13 16.0001C13 15.4478 13.4477 15.0001 14 15.0001H16.5V12.5001C16.5 11.9478 16.9477 11.5001 17.5 11.5001C18.0523 11.5001 18.5 11.9478 18.5 12.5001V15.0001H21C21.5523 15.0001 22 15.4478 22 16.0001C22 16.5523 21.5523 17.0001 21 17.0001H18.5V19.5001C18.5 20.0523 18.0523 20.5001 17.5 20.5001C16.9477 20.5001 16.5 20.0523 16.5 19.5001Z" fill="currentColor"/></svg>);

const navItems = [
    { href: '/reviews', label: 'المراجعات', Icon: ReviewIcon, section: 'reviews' },
    { href: '/news', label: 'الأخبار', Icon: NewsIcon, section: 'news' },
    { href: '/articles', label: 'المقالات', Icon: ArticleIcon, section: 'articles' },
    { href: '/releases', label: 'الإصدارات', Icon: ReleaseIcon, section: 'releases' },
    { href: '/celestial-almanac', label: 'قريباً', Icon: CelestialAlmanacIcon },
    { href: '/constellation', label: 'الكوكبة', Icon: ConstellationIcon }
];

const orbitalContainerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.08, delayChildren: 0.2 } } };
const itemTransition: Transition = { type: 'spring', stiffness: 400, damping: 20 };

const OrbitalNavItem = ({ item, angle, radius, isActive, onClick }: any) => {
    const { openIndexOverlay, forceCloseOverlay } = useContentStore();
    
    const handleNavClick = (e: React.MouseEvent) => {
        if (item.section) {
            e.preventDefault();
            openIndexOverlay(item.section as any);
        } else {
            forceCloseOverlay();
            startNavigation(); // TRIGGER LOADER
        }
        onClick();
    };
    
    const cosAngle = Math.round(Math.cos(angle) * 1e10) / 1e10;
    const sinAngle = Math.round(Math.sin(angle) * 1e10) / 1e10;
    const x = `calc(${radius} * ${cosAngle})`;
    const y = `calc(${radius} * ${sinAngle})`;

    const itemVariants: Variants = { hidden: { scale: 0, x: 0, y: 0, opacity: 0 }, visible: { scale: 1, x, y, opacity: 1 }, exit: { scale: 0, x: 0, y: 0, opacity: 0, transition: { duration: 0.2, ease: 'easeIn' } }, };
    
    return (
        <motion.div variants={itemVariants} transition={itemTransition} className={styles.orbitalItemWrapper}>
            <Link href={item.href} onClick={handleNavClick} className="no-underline" prefetch={false}>
                <motion.div className={`${styles.orbitalOrb} ${isActive ? styles.active : ''}`} whileHover={{ scale: 1.15 }} whileTap={{ scale: 0.9 }}>
                    <item.Icon />
                </motion.div>
            </Link>
            <motion.div className={styles.orbitalTitle} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0, transition: { delay: 0.15, duration: 0.3 } }} exit={{ opacity: 0, y: 5, transition: { duration: 0.1 } }}>
                {item.label}
            </motion.div>
        </motion.div>
    );
};

const AnimatedPreviewIcon = () => (<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><motion.circle cx="12" cy="12" r="3" variants={{ hover: { scaleY: 0.1, transition: { duration: 0.1, ease: "easeOut" } }, rest: { scaleY: 1, transition: { duration: 0.2, delay: 0.1, ease: "easeIn" } } }} /></svg>);
const EditorPreviewButton = () => {
    const { liveUrl } = useEditorStore();
    const MotionLink = motion(Link);
    const linkVariants = { rest: { color: 'var(--text-primary)', scale: 1 }, hover: { color: 'var(--accent)', scale: 1.15 } };
    return liveUrl ? (<MotionLink href={liveUrl} target="_blank" className={`${editorStyles.iconButton} no-underline`} title="معاينة الصفحة الحية" initial="rest" whileHover="hover" whileTap="hover" animate="rest" variants={linkVariants} transition={{ type: 'spring', stiffness: 400, damping: 15 }} prefetch={false}><AnimatedPreviewIcon /></MotionLink>) : (<motion.button className={editorStyles.iconButton} disabled title="المستند غير منشور"><PreviewIcon /></motion.button>);
};

const BlackHoleNavLink = ({ item, isActive, onClick }: any) => {
    const { openIndexOverlay, forceCloseOverlay } = useContentStore();
    const [isHovered, setIsHovered] = useState(false);
    
    const handleClick = (e: React.MouseEvent) => {
        if (item.section) {
            e.preventDefault();
            openIndexOverlay(item.section as any);
        } else {
            forceCloseOverlay();
            startNavigation(); // TRIGGER LOADER
        }
        if (onClick) onClick();
    };
    
    return (
        <Link 
            href={item.href} 
            onClick={handleClick} 
            prefetch={false} 
            className={styles.blackHoleLink}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
        >
            <div className={styles.contentContainer}>
                <motion.span
                    className={styles.textWrapper}
                    animate={isHovered ? "sucked" : "rest"}
                    variants={{ rest: { y: 0, scale: 1, opacity: 1, filter: "blur(0px)", transition: { duration: 0.4, ease: "easeOut" } }, sucked: { y: -20, scale: 0.6, opacity: 0, filter: "blur(8px)", transition: { duration: 0.3, ease: "easeIn" } } }}
                    style={{ color: isActive ? "var(--accent)" : "var(--text-primary)", transformOrigin: "center bottom" }}
                >
                    {item.label}
                </motion.span>
                <motion.div
                    className={styles.iconWrapper}
                    initial={{ y: 25, scale: 0.5, rotate: -45, opacity: 0 }}
                    animate={isHovered ? "active" : "inactive"}
                    variants={{ inactive: { y: 25, scale: 0.5, rotate: -45, opacity: 0, transition: { duration: 0.3, ease: "easeOut" } }, active: { y: 0, scale: 1.1, rotate: 0, opacity: 1, transition: { type: "spring", stiffness: 400, damping: 25, mass: 1, delay: 0.05 } } }}
                >
                     <item.Icon className={styles.navIconSvg} />
                </motion.div>
            </div>
        </Link>
    );
};

const Navbar = () => {
    const scrolled = useScrolled(50);
    const [isSearchOpen, setIsSearchOpen] = useState(false);
    const { isMobileMenuOpen, toggleMobileMenu, setMobileMenuOpen } = useUIStore();
    const { isEditorActive, blockUploadQuality, setBlockUploadQuality } = useEditorStore();
    const pathname = usePathname();
    
    const indexSection = useContentStore(s => s.indexSection);
    const { isOverlayOpen, closeOverlay, forceCloseOverlay } = useContentStore();

    useBodyClass('mobile-menu-open', isMobileMenuOpen);

    const openSearch = () => { setIsSearchOpen(true); setMobileMenuOpen(false); };
    const closeAll = () => { setMobileMenuOpen(false); setIsSearchOpen(false); }
    
    const handleLogoClick = (e: React.MouseEvent) => {
        closeAll();
        forceCloseOverlay();
        startNavigation(); // TRIGGER LOADER
    };
    
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                setIsSearchOpen(prev => !prev);
            }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, []);

    const isImmersiveRoute = pathname === '/constellation' || pathname === '/celestial-almanac';
    
    return (
        <>
            <header 
                className={`${styles.navbar} ${scrolled && !isImmersiveRoute ? styles.scrolled : ''}`}
                style={{ 
                    ...(isOverlayOpen ? { width: 'calc(100% - 8px)', right: 'auto', left: 0 } : undefined),
                    ...(isImmersiveRoute ? { 
                        backgroundColor: 'transparent',
                        backdropFilter: 'none',
                        borderBottom: 'none',
                        boxShadow: 'none'
                    } : {})
                }}
            >
                <div className={`container ${styles.navContainer}`}>
                    <div className={styles.desktopView}>
                        <Link href="/" className={`${styles.navLogo} no-underline`} onClick={handleLogoClick} prefetch={false}>
                            <EternalGamesIcon style={{ width: '30px', height: '30px' }} />
                        </Link>
                        {/* Add ID here for global CSS targeting */}
                        <nav id="navbar-desktop-nav">
                            <ul className={styles.navLinks}>
                                {navItems.map(item => {
                                    const isActive = pathname.startsWith(item.href) || indexSection === item.section;
                                    return (
                                        <li key={item.href} className={styles.navItem}>
                                            <BlackHoleNavLink 
                                                item={item} 
                                                isActive={isActive} 
                                            />
                                        </li>
                                    );
                                })}
                            </ul>
                        </nav>
                        {/* Add ID here for global CSS targeting */}
                        <div id="navbar-desktop-controls" className={styles.navControls}>
                            <PerformanceSettings />
                            {isEditorActive && <EditorPreviewButton />}
                            <NotificationBell />
                            <ThemeToggle />
                            <UserProfile />
                            <button className={styles.navSearch} onClick={openSearch} aria-label="فتح البحث (Ctrl+K)">
                                <SearchIcon />
                            </button>
                        </div>
                    </div>

                    <div className={styles.mobileView}>
                        {/* Add ID here for global CSS targeting */}
                        <div id="navbar-mobile-left" className={styles.mobileNavGroupLeft}>
                            <button className={styles.hamburgerButton} onClick={toggleMobileMenu} aria-label="تبديل القائمة">
                                <HamburgerIcon isOpen={isMobileMenuOpen} />
                            </button>
                            {isEditorActive && (
                                <QualityToggle currentQuality={blockUploadQuality} onQualityChange={setBlockUploadQuality} isMobile={true} />
                            )}
                             <button className={styles.navSearch} onClick={openSearch} aria-label="فتح البحث">
                                <SearchIcon />
                            </button>
                            <PerformanceSettings isMobile={true} />
                        </div>
                        <Link href="/" className={`${styles.navLogo} no-underline`} onClick={handleLogoClick} prefetch={false}>
                            <EternalGamesIcon style={{ width: '28px', height: '28px' }} />
                        </Link>
                        {/* Add ID here for global CSS targeting */}
                        <div id="navbar-mobile-right" className={styles.mobileNavGroupRight}>
                            {isEditorActive && <EditorPreviewButton />}
                            <NotificationBell />
                            <ThemeToggle />
                            <UserProfile />
                        </div>
                    </div>
                </div>
            </header>
            
            <AnimatePresence>
                {isMobileMenuOpen && (
                    <motion.div className={styles.mobileNavOverlay} onClick={closeAll} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                        <motion.div className={styles.mobileNavContent} variants={orbitalContainerVariants} initial="hidden" animate="visible" exit="exit">
                            <Link href="/" onClick={handleLogoClick} className={`${styles.orbitalCenter} no-underline ${pathname === '/' ? styles.active : ''}`} prefetch={false}>
                                <EternalGamesIcon style={{ width: '48px', height: '48px' }} />
                            </Link>
                            {navItems.map((item, i) => {
                                const angle = -Math.PI / 2 + (i / navItems.length) * (Math.PI * 2);
                                return ( <OrbitalNavItem key={item.href} item={item} angle={angle} radius="min(38vh, 38vw)" isActive={pathname.startsWith(item.href) || indexSection === item.section} onClick={closeAll} /> );
                            })}
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
            
            <Search isOpen={isSearchOpen} onClose={() => setIsSearchOpen(false)} />
        </>
    );
};

export default Navbar;

--- END OF FILE components/Navbar.tsx ---

================================================================================

--- START OF FILE components/PageTransitionWrapper.tsx ---

// components/PageTransitionWrapper.tsx
'use client';

import React from 'react';

// MODIFIED: Removed AnimatePresence and motion.div to resolve nested animation conflict.
// This component now acts as a simple pass-through wrapper.
// The actual page transition logic is handled in app/template.tsx.
export default function PageTransitionWrapper({ children }: { children: React.ReactNode }) {
  return (
    <>
      {children}
    </>
  );
}




--- END OF FILE components/PageTransitionWrapper.tsx ---

================================================================================

--- START OF FILE components/PaginatedCarousel.module.css ---

/* components/PaginatedCarousel.module.css */

.paginatedContainer {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.paginatedContent {
    /* flex-grow: 1; <-- This property was pushing the controls to the bottom, it has been removed. */
    position: relative;
    min-height: 380px; /* Adjust based on item height to prevent layout shift */
}

.itemList {
    display: flex;
    flex-direction: column;
    
    /* GPU CULL FIX: Expand render boundary for list items */
    padding: 10rem;
    margin: -10rem;
    width: calc(100% + 20rem);
    pointer-events: none; /* Pass-through for padding */
}

.itemList > * {
    pointer-events: auto; /* Restore interaction */
}

.paginationControls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    padding-top: 1rem; /* Reduced top padding to bring controls closer to content */
    padding-bottom: 1.5rem; /* Added bottom padding for spacing from elements below */
    position: relative;
    z-index: 10;
}

.paginationDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: var(--border-color);
    border: none;
    cursor: pointer;
    padding: 0;
    transition: all 0.3s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .paginationDot:hover  {
    background-color: var(--text-secondary);
}
}

  .paginationDot:active  {
    background-color: var(--text-secondary);
}
}
.paginationDot:active {
    background-color: var(--text-secondary);
}


.paginationDot.active {
    background-color: var(--accent);
    transform: scale(1.2);
    box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 50%, transparent);
}

@media (max-width: 768px) {
    .itemList {
        /* Reset on mobile */
    }
}

--- END OF FILE components/PaginatedCarousel.module.css ---

================================================================================

--- START OF FILE components/PaginatedCarousel.tsx ---

// components/PaginatedCarousel.tsx
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import { CardProps } from '@/types';
import styles from './PaginatedCarousel.module.css';
import NewsGridCard from '@/components/news/NewsGridCard';
import { useActiveCardStore } from '@/lib/activeCardStore';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useContentStore } from '@/lib/contentStore'; 

type PaginatedCarouselProps = {
    items: CardProps[];
    itemsPerPage?: number;
    layoutIdPrefix?: string; // New Prop
};

export default function PaginatedCarousel({ items, itemsPerPage = 5, layoutIdPrefix = "paginated-carousel" }: PaginatedCarouselProps) {
    const [currentPage, setCurrentPage] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
    
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    const totalPages = Math.ceil(items.length / itemsPerPage);
    
    const { activeCardId } = useActiveCardStore();
    const { isCarouselAutoScrollEnabled } = usePerformanceStore();
    const isOverlayOpen = useContentStore((s) => s.isOverlayOpen);

    const containerRef = useRef<HTMLDivElement>(null);
    const isInView = useInView(containerRef, { amount: 0.1 });

    const resetTimeout = () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } };

    useEffect(() => {
        resetTimeout();
        if (!isHovered && isInView && totalPages > 1 && isCarouselAutoScrollEnabled && !isOverlayOpen) {
            timeoutRef.current = setTimeout(
                () => setCurrentPage((prevPage) => (prevPage + 1) % totalPages),
                3800
            );
        }
        return () => resetTimeout();
    }, [currentPage, isHovered, totalPages, isInView, isCarouselAutoScrollEnabled, isOverlayOpen]);

    const startIndex = currentPage * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = items.slice(startIndex, endIndex);
    
    const interactionHandlers = {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => {
            setIsHovered(false);
            setHoveredIndex(null); 
        },
        onTouchStart: () => setIsHovered(true),
        onTouchEnd: () => setIsHovered(false),
        onTouchCancel: () => setIsHovered(false),
    };

    return (
        <div 
            ref={containerRef}
            className={styles.paginatedContainer}
            {...interactionHandlers}
        >
            <div className={styles.paginatedContent}>
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentPage}
                        initial={{ opacity: 0, x: -50 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 50 }} 
                        transition={{ duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                        className={`${styles.itemList} gpu-cull`} 
                        style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}
                    >
                        {currentItems.map((item, index) => (
                            <motion.div
                                key={item.legacyId}
                                style={{ 
                                    height: 'auto', 
                                    position: 'relative', 
                                    zIndex: (activeCardId === item.id || hoveredIndex === index) ? 100 : 1 
                                }}
                                onMouseEnter={() => setHoveredIndex(index)}
                                onMouseLeave={() => setHoveredIndex(null)}
                            >
                                <NewsGridCard 
                                    item={item} 
                                    // Pass dynamic prefix based on item ID to ensure uniqueness for layoutID
                                    layoutIdPrefix={`${layoutIdPrefix}-${item.legacyId}`}
                                    variant="compact"
                                />
                            </motion.div>
                        ))}
                    </motion.div>
                </AnimatePresence>
            </div>
            {totalPages > 1 && (
                <div className={styles.paginationControls}>
                    {Array.from({ length: totalPages }).map((_, index) => (
                        <button
                            key={index}
                            className={`${styles.paginationDot} ${currentPage === index ? styles.active : ''}`}
                            onClick={() => setCurrentPage(index)}
                            aria-label={`Go to page ${index + 1}`}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}

--- END OF FILE components/PaginatedCarousel.tsx ---

================================================================================

--- START OF FILE components/PasswordChangeForm.tsx ---

// components/PasswordChangeForm.tsx
'use client';

import { useState, useTransition } from 'react';
import { changePasswordAction } from '@/app/actions/userActions';
import { useToast } from '@/lib/toastStore';
import ButtonLoader from './ui/ButtonLoader';
import { motion, AnimatePresence } from 'framer-motion';

export default function PasswordChangeForm({ canSkipCurrentPassword = false }: { canSkipCurrentPassword?: boolean }) {
    const [isPending, startTransition] = useTransition();
    const toast = useToast();
    
    // State to manage form fields for floating labels
    const [currentPassword, setCurrentPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');

    const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const formData = new FormData(event.currentTarget);
        const form = event.currentTarget;

        startTransition(async () => {
            const result = await changePasswordAction(formData);
            if (result.success) {
                toast.success(result.message || 'تم تغيير كلمة السر بنجاح!');
                // Clear state on success
                setCurrentPassword('');
                setNewPassword('');
                setConfirmPassword('');
                form.reset();
            } else {
                toast.error(result.message || 'Failed to change password.');
            }
        });
    };

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <form onSubmit={handleSubmit} style={{ maxWidth: '400px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
            {!canSkipCurrentPassword && (
                <div className={`profile-form-group ${hasContent(currentPassword)}`}>
                    <input 
                        id="currentPassword" 
                        name="currentPassword" 
                        type="password" 
                        required 
                        className="profile-input" 
                        value={currentPassword}
                        onChange={(e) => setCurrentPassword(e.target.value)}
                        placeholder=" "
                    />
                     <label className="profile-form-label" htmlFor="currentPassword">كلمة السر الحالية</label>
                </div>
            )}
            
            {canSkipCurrentPassword && (
                 <p style={{ fontSize: '1.4rem', color: 'var(--accent)', margin: 0 }}>
                    صلاحية المدير: لست بحاجة لإدخال كلمة السر القديمة.
                 </p>
            )}

            <div className={`profile-form-group ${hasContent(newPassword)}`}>
                <input 
                    id="newPassword" 
                    name="newPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={newPassword}
                    onChange={(e) => setNewPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="newPassword">كلمة السر الجديدة</label>
            </div>
            <div className={`profile-form-group ${hasContent(confirmPassword)}`}>
                <input 
                    id="confirmPassword" 
                    name="confirmPassword" 
                    type="password" 
                    required 
                    className="profile-input" 
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    placeholder=" "
                />
                <label className="profile-form-label" htmlFor="confirmPassword">تأكيد الجديدة</label>
            </div>
            <motion.button 
                type="submit" 
                className="primary-button" 
                disabled={isPending}
                animate={{
                    width: isPending ? '48px' : 'auto',
                    height: '48px',
                    borderRadius: isPending ? '50%' : '5px',
                }}
                transition={{ type: 'spring', stiffness: 400, damping: 25 }}
            >
                <AnimatePresence mode="wait">
                    {isPending ? (
                        <ButtonLoader key="loader" />
                    ) : (
                        <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>تحديث كلمة السر</motion.span>
                    )}
                </AnimatePresence>
            </motion.button>
        </form>
    );
}

--- END OF FILE components/PasswordChangeForm.tsx ---

================================================================================

--- START OF FILE components/PerformanceHint.module.css ---

/* components/PerformanceHint.module.css */

.hintContainer {
    position: fixed;
    bottom: 2rem;
    right: 2rem; /* MOVED TO RIGHT */
    left: auto;  /* Reset left */
    max-width: 320px;
    width: 90%;
    z-index: 9999;
    
    background-color: rgba(10, 11, 15, 0.9);
    backdrop-filter: blur(12px);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1.5rem;
    
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

:global(body.no-glass) .hintContainer {
    backdrop-filter: none !important;
    background-color: #0A0B0F !important;
}

.hintHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.hintTitle {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    font-family: var(--font-heading);
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--accent);
    margin: 0;
}

.closeButton {
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.2rem;
    transition: color 0.2s;
}

.closeButton:hover {
    color: var(--text-primary);
}

.hintText {
    font-family: var(--font-main);
    font-size: 1.3rem;
    color: var(--text-primary);
    line-height: 1.5;
    margin: 0;
}

.dismissButton {
    align-self: flex-end;
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
    border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
    padding: 0.5rem 1.2rem;
    border-radius: 6px;
    font-size: 1.2rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.dismissButton:hover {
    background-color: var(--accent);
    color: #000;
}

@media (max-width: 768px) {
    .hintContainer {
        /* Center on mobile */
        left: 0;
        right: 0;
        margin: 0 auto;
        bottom: 8rem; /* Higher to avoid floating mobile navbar buttons */
        width: 90%;
    }
}

--- END OF FILE components/PerformanceHint.module.css ---

================================================================================

--- START OF FILE components/PerformanceHint.tsx ---

// components/PerformanceHint.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './PerformanceHint.module.css';

const SettingsIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M15.5 12C15.5 13.933 13.933 15.5 12 15.5C10.067 15.5 8.5 13.933 8.5 12C8.5 10.067 10.067 8.5 12 8.5C13.933 8.5 15.5 10.067 15.5 12Z" stroke="currentColor" strokeWidth="1.5"></path>
        <path d="M9.77208 2.68377L9 5L7.44016 5.98656L4.88796 5.35506C4.46009 5.2492 4.01337 5.43595 3.78816 5.81484L2.42396 8.10993C2.17813 8.52353 2.26167 9.05356 2.62281 9.37147L4.41294 10.9474V13.0526L2.62337 14.6285C2.26231 14.9464 2.17882 15.4764 2.42463 15.8899L3.78888 18.1851C4.01409 18.564 4.46082 18.7508 4.88868 18.6449L7.44089 18.0134L8.91858 18.8421L9.62394 21.2781C9.74775 21.7057 10.1393 22 10.5845 22H13.4163C13.8614 22 14.253 21.7057 14.3768 21.2781L15.0822 18.8421L16.5591 18.0134L19.1113 18.6449C19.5392 18.7508 19.9859 18.564 20.2111 18.1851L21.6011 15.8466C21.8352 15.4528 21.7717 14.9502 21.4471 14.627L19.6409 12.8287L19.6416 11.1713L21.4478 9.37298C21.7725 9.04974 21.836 8.54721 21.6019 8.15339L20.2118 5.81484C19.9866 5.43595 19.5399 5.2492 19.112 5.35506L16.5598 5.98656L15 5L14.2279 2.68377C14.0918 2.27543 13.7097 2 13.2792 2H10.7208C10.2903 2 9.90819 2.27543 9.77208 2.68377Z" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path>
    </svg>
);

const CloseIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
);

export default function PerformanceHint() {
    const [show, setShow] = useState(false);

    useEffect(() => {
        // Check if user has already seen the hint
        const hasSeen = localStorage.getItem('eternal-perf-hint-seen');
        if (!hasSeen) {
            // Delay showing to not overwhelm on initial load
            const timer = setTimeout(() => setShow(true), 3000);
            return () => clearTimeout(timer);
        }
    }, []);

    const handleDismiss = () => {
        setShow(false);
        localStorage.setItem('eternal-perf-hint-seen', 'true');
    };

    return (
        <AnimatePresence>
            {show && (
                <motion.div
                    className={styles.hintContainer}
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 50 }}
                    transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                >
                    <div className={styles.hintHeader}>
                        <div className={styles.hintTitle}>
                            <SettingsIcon />
                            <span>تنويه الأداء</span>
                        </div>
                        <button onClick={handleDismiss} className={styles.closeButton}>
                            <CloseIcon />
                        </button>
                    </div>
                    <p className={styles.hintText}>
                        هل الموقع ثقيل على جهازك؟ اضغط على أيقونة الإعدادات في الشريط العلوي لتقليل المؤثرات البصرية.
                    </p>
                    <button onClick={handleDismiss} className={styles.dismissButton}>
                        حسنًا، فهمت
                    </button>
                </motion.div>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE components/PerformanceHint.tsx ---

================================================================================

--- START OF FILE components/PerformanceSettings.module.css ---

/* components/PerformanceSettings.module.css */
.container {
    position: relative;
    z-index: 1200;
}

/* Navbar Trigger Icon */
.triggerButton {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border-radius: 50%;
}

.triggerButton:hover {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    transform: rotate(90deg);
}

.triggerButton:active {
    transform: rotate(180deg) scale(0.9);
}

/* --- DESKTOP PANEL --- */
.panel {
    position: absolute;
    top: calc(100% + 25px);
    left: 50%;
    transform: translateX(-50%);
    /* MODIFIED: Increased width to fit 3 columns comfortably */
    width: 460px;
    background-color: rgba(10, 11, 15, 0.95);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 2rem;
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.8);
    backdrop-filter: blur(16px);
    transform-origin: top center;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

:global(body.no-glass) .panel {
    backdrop-filter: none !important;
    background-color: #0A0B0F !important;
}

/* --- MOBILE BOTTOM SHEET --- */
.mobilePanel {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    
    background-color: #0A0B0F;
    border-top: 1px solid var(--accent);
    box-shadow: 0 -10px 60px rgba(0, 229, 255, 0.15);
    border-radius: 24px 24px 0 0;
    padding: 2.5rem 2rem 4rem 2rem;
    
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    
    z-index: 10001 !important;
    pointer-events: auto;
    
    transform: none !important;
    top: auto !important;
}

.mobileOverlay {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0,0,0,0.7);
    backdrop-filter: blur(5px);
    z-index: 10000 !important;
    cursor: pointer;
}

:global(body.no-glass) .mobileOverlay {
    backdrop-filter: none !important;
    background-color: rgba(0,0,0,0.9) !important;
}

/* Header */
.header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
}

.headerLeft {
    display: flex;
    align-items: center;
    gap: 1rem;
    color: var(--accent);
}

.headerTitle {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    font-weight: 800;
    color: var(--text-primary);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.closeButton {
    background: none;
    border: none;
    padding: 0.8rem;
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s ease;
    border-radius: 50%;
    background-color: rgba(255,255,255,0.05);
}
.closeButton:active {
    background-color: rgba(255,255,255,0.1);
    color: #fff;
}

/* --- CYBER BUTTON GRID --- */
.optionsGrid {
    display: grid;
    /* MODIFIED: Changed from 2 to 3 columns per row */
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
}

.optionButton {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 0.8rem;
    
    padding: 1.2rem 0.5rem;
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    
    color: var(--text-secondary);
    font-family: var(--font-main);
    font-size: 1.2rem; /* Slightly smaller font to fit 3 cols */
    font-weight: 600;
    text-align: center;
    
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
}

@media (max-width: 768px) {
    .optionsGrid {
        /* Keep 3 columns on mobile too, but tighter gap */
        gap: 0.8rem;
    }
    .optionButton {
        padding: 1rem 0.4rem;
        font-size: 1.1rem;
    }
}

/* Hover Effect (Desktop) */
@media (hover: hover) {
    .optionButton:hover {
        border-color: var(--text-primary);
        color: var(--text-primary);
        background-color: rgba(255, 255, 255, 0.08);
        transform: translateY(-2px);
    }
}

/* Active State */
.optionButton.active {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 20%, transparent);
}

.optionButton:active {
    transform: scale(0.96);
}

.buttonIcon {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}

.optionButton.active .buttonIcon {
    transform: scale(1.1);
    filter: drop-shadow(0 0 8px var(--accent));
}

.indicator {
    width: 100%;
    height: 3px;
    background-color: var(--border-color);
    border-radius: 999px;
    margin-top: 0.5rem;
    overflow: hidden;
    position: relative;
}

.indicatorFill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 100%;
    background-color: var(--accent);
    transform: translateX(-105%); /* Hidden by default */
    transition: transform 0.3s ease;
}

.optionButton.active .indicatorFill {
    transform: translateX(0);
}

--- END OF FILE components/PerformanceSettings.module.css ---

================================================================================

--- START OF FILE components/PerformanceSettings.tsx ---

// components/PerformanceSettings.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useClickOutside } from '@/hooks/useClickOutside';
import styles from './PerformanceSettings.module.css';
import { createPortal } from 'react-dom';
import { useTheme } from 'next-themes';
import { useBodyClass } from '@/hooks/useBodyClass';

// --- Icons ---
const SettingsIcon = () => ( <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M15.5 12C15.5 13.933 13.933 15.5 12 15.5C10.067 15.5 8.5 13.933 8.5 12C8.5 10.067 10.067 8.5 12 8.5C13.933 8.5 15.5 10.067 15.5 12Z" stroke="currentColor" strokeWidth="1.5"></path> <path d="M9.77208 2.68377L9 5L7.44016 5.98656L4.88796 5.35506C4.46009 5.2492 4.01337 5.43595 3.78816 5.81484L2.42396 8.10993C2.17813 8.52353 2.26167 9.05356 2.62281 9.37147L4.41294 10.9474V13.0526L2.62337 14.6285C2.26231 14.9464 2.17882 15.4764 2.42463 15.8899L3.78888 18.1851C4.01409 18.564 4.46082 18.7508 4.88868 18.6449L7.44089 18.0134L8.91858 18.8421L9.62394 21.2781C9.74775 21.7057 10.1393 22 10.5845 22H13.4163C13.8614 22 14.253 21.7057 14.3768 21.2781L15.0822 18.8421L16.5591 18.0134L19.1113 18.6449C19.5392 18.7508 19.9859 18.564 20.2111 18.1851L21.6011 15.8466C21.8352 15.4528 21.7717 14.9502 21.4471 14.627L19.6409 12.8287L19.6416 11.1713L21.4478 9.37298C21.7725 9.04974 21.836 8.54721 21.6019 8.15339L20.2118 5.81484C19.9866 5.43595 19.5399 5.2492 19.112 5.35506L16.5598 5.98656L15 5L14.2279 2.68377C14.0918 2.27543 13.7097 2 13.2792 2H10.7208C10.2903 2 9.90819 2.27543 9.77208 2.68377Z" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"></path> </svg> );
const CloseIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const PerfIcon = () => <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2v20M2 12h20M4.93 4.93l14.14 14.14M19.07 4.93 4.93 19.07"/></svg>;
const AutoIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M12 3v18M3 12h18M18 6l-6-3-6 3M6 18l6 3 6-3"/></svg>;
const CardIcon3D = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M12 3L2 9l10 6 10-6-10-6z"/><path d="M2 14l10 6 10-6"/><path d="M2 9l10 6 10-6"/></svg>;
const TagIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"/></svg>;
const HeroIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><rect x="2" y="3" width="20" height="18" rx="2" ry="2" /><circle cx="12" cy="12" r="3" /></svg>;
const BorderIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M2 8V4a2 2 0 0 1 2-2h4" /><path d="M16 2h4a2 2 0 0 1 2 2v4" /><path d="M22 16v4a2 2 0 0 1-2 2h-4" /><path d="M8 22H4a2 2 0 0 1-2-2v-4" /></svg>;
const EyeIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>;
const PlayPauseIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
const BlurIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/><path d="M2 12s3 7 10 7 10-7 10-7 3-7 10-7 10 7 10 7Z" opacity="0.3"/></svg>;
const BoltIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>;
const TimerIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M10 2h4"/><path d="M12 14v-4"/><path d="M4 13a8 8 0 0 1 8-7 8 8 0 1 1-8 8"/></svg>;
const ScrollIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><path d="M8 9l4-4 4 4"/><path d="M16 15l-4 4-4-4"/></svg>; 

interface OptionButtonProps { label: string; isActive: boolean; onClick: () => void; Icon: React.ComponentType<any>; disabled?: boolean; isAutoControlled?: boolean; }

const OptionButton = ({ label, isActive, onClick, Icon, disabled, isAutoControlled }: OptionButtonProps) => (
    <button onClick={onClick} className={`${styles.optionButton} ${isActive ? styles.active : ''}`} aria-checked={isActive} role="switch" disabled={disabled} style={{ ...(disabled ? { opacity: 0.5, cursor: 'not-allowed' } : {}), ...(isAutoControlled ? { borderColor: 'var(--accent)', opacity: 0.9 } : {}) }}>
        <div className={styles.buttonIcon}><Icon /></div>
        <span>{label}</span>
        {isAutoControlled && <span style={{position:'absolute', top:2, right:4, fontSize:'0.7rem', color:'var(--accent)', fontWeight:800}}>تلقائي</span>}
        <div className={styles.indicator}><div className={styles.indicatorFill} /></div>
    </button>
);

export default function PerformanceSettings({ isMobile = false }: { isMobile?: boolean }) {
    const [isOpen, setIsOpen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const store = usePerformanceStore();
    const [mounted, setMounted] = useState(false);
    const { resolvedTheme } = useTheme();

    useEffect(() => {
        usePerformanceStore.persist.rehydrate();
        setMounted(true);
    }, []);

    useBodyClass('no-glass', !store.isGlassmorphismEnabled);
    useClickOutside(containerRef, () => { if (!isMobile) setIsOpen(false); });

    if (!mounted) {
        return (
            <div className={styles.container}>
                 <button className={styles.triggerButton} disabled style={{ opacity: 0.5 }}>
                    <SettingsIcon />
                 </button>
            </div>
        );
    }

    const isLightMode = resolvedTheme === 'light';
    const isAnimationDisabled = !store.isBackgroundVisible || isLightMode;
    const auto = store.isAutoTuningEnabled;

    const PanelContent = () => (
        <>
            <div className={styles.header}>
                <div className={styles.headerLeft}><PerfIcon /><h3 className={styles.headerTitle}>تحكم المؤثرات</h3></div>
                {isMobile && (<button onClick={() => setIsOpen(false)} className={styles.closeButton} onTouchEnd={() => setIsOpen(false)}><CloseIcon /></button>)}
            </div>
            
            <div className={styles.optionsGrid}>
                <OptionButton label="الضبط التلقائي" isActive={store.isAutoTuningEnabled} onClick={store.toggleAutoTuning} Icon={AutoIcon} />
                <OptionButton label="استجابة فورية" isActive={!store.isHoverDebounceEnabled} onClick={store.toggleHoverDebounce} Icon={BoltIcon} isAutoControlled={auto} />
                <OptionButton label="تقليب تلقائي" isActive={store.isCarouselAutoScrollEnabled} onClick={store.toggleCarouselAutoScroll} Icon={TimerIcon} isAutoControlled={auto} />
                
                <OptionButton label="تمرير سلس" isActive={store.isSmoothScrollingEnabled} onClick={store.toggleSmoothScrolling} Icon={ScrollIcon} isAutoControlled={false} />

                <OptionButton label="تأثير الزجاج" isActive={store.isGlassmorphismEnabled} onClick={store.toggleGlassmorphism} Icon={BlurIcon} isAutoControlled={auto} />
                <OptionButton 
                    label="إظهار الخلفية" 
                    isActive={store.isBackgroundVisible} 
                    onClick={store.toggleBackgroundVisibility} 
                    Icon={EyeIcon} 
                    disabled={isLightMode} 
                    isAutoControlled={isMobile ? false : auto} 
                />
                
                <OptionButton label="بطاقات حية" isActive={store.isLivingCardEnabled} onClick={store.toggleLivingCard} Icon={CardIcon3D} isAutoControlled={auto} />
                <OptionButton label="الوسوم الطائرة" isActive={store.isFlyingTagsEnabled} onClick={store.toggleFlyingTags} Icon={TagIcon} isAutoControlled={auto} />
                <OptionButton label="إطارات مشعة" isActive={store.isCornerAnimationEnabled} onClick={store.toggleCornerAnimation} Icon={BorderIcon} isAutoControlled={auto} />
                <OptionButton label="حركة الخلفية" isActive={store.isBackgroundAnimated} onClick={store.toggleBackgroundAnimation} Icon={PlayPauseIcon} disabled={isAnimationDisabled} />
                
                {/* UNLOCKED BUTTON */}
                <OptionButton label="انتقال سلس" isActive={store.isHeroTransitionEnabled} onClick={store.toggleHeroTransition} Icon={HeroIcon} isAutoControlled={auto} /> 
            </div>
        </>
    );

    return (
        <div className={styles.container} ref={containerRef}>
            <button className={styles.triggerButton} onClick={() => setIsOpen(!isOpen)} onTouchEnd={(e) => { if (isMobile) { e.preventDefault(); setIsOpen(!isOpen); } }} aria-label="Performance Settings" title="إعدادات الأداء" style={isOpen ? { color: 'var(--accent)', transform: 'rotate(90deg)' } : {}}>
                <SettingsIcon />
            </button>

            {!isMobile && (
                <AnimatePresence>
                    {isOpen && (
                        <motion.div className={styles.panel} initial={{ opacity: 0, y: 15, scale: 0.95 }} animate={{ opacity: 1, y: 0, scale: 1 }} exit={{ opacity: 0, y: 15, scale: 0.95 }} transition={{ type: "spring", duration: 0.3 }}>
                            <PanelContent />
                        </motion.div>
                    )}
                </AnimatePresence>
            )}

            {isMobile && mounted && isOpen && createPortal(
                <AnimatePresence mode="wait">
                     <motion.div key="backdrop" className={styles.mobileOverlay} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} onClick={() => setIsOpen(false)} />
                    <motion.div key="sheet" className={styles.mobilePanel} initial={{ y: "100%" }} animate={{ y: "0%" }} exit={{ y: "100%" }} transition={{ type: "spring", damping: 25, stiffness: 200 }} onClick={(e) => e.stopPropagation()} >
                        <PanelContent />
                    </motion.div>
                </AnimatePresence>,
                document.body
            )}
        </div>
    );
}

--- END OF FILE components/PerformanceSettings.tsx ---

================================================================================

--- START OF FILE components/PortableTextComponent.tsx ---

// components/PortableTextComponent.tsx
'use client'

import React, {useEffect, useState, useMemo} from 'react'
import {
  PortableText,
  PortableTextComponents,
  PortableTextComponentProps,
  PortableTextMarkComponentProps,
} from '@portabletext/react'
import {urlFor} from '@/sanity/lib/image'
import dynamic from 'next/dynamic'
import NextImage from 'next/image'
import {useLightboxStore} from '@/lib/lightboxStore'
import type {PortableTextBlock} from '@portabletext/types'
import {useTheme} from 'next-themes'
import {sanityLoader} from '@/lib/sanity.loader'
import { generateId } from '@/lib/text-utils'
import KineticLink from '@/components/kinetic/KineticLink'

const LoadingSpinner = () => (
  <div style={{display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '200px'}}>
    <div className="spinner" />
  </div>
)

const ImageCompare = dynamic(() => import('./ImageCompare'), {
  loading: () => <LoadingSpinner />,
  ssr: false,
})
const TwoImageGrid = dynamic(() => import('./custom/TwoImageGrid'), {
  loading: () => <LoadingSpinner />,
})
const FourImageGrid = dynamic(() => import('./custom/FourImageGrid'), {
  loading: () => <LoadingSpinner />,
})
const SanityTable = dynamic(() => import('./custom/SanityTable'), {
  loading: () => <LoadingSpinner />,
})
const GameDetails = dynamic(() => import('./content/GameDetails'), {
  loading: () => <LoadingSpinner />,
})
const YoutubeEmbed = dynamic(() => import('./content/YoutubeEmbed'), {
  loading: () => <LoadingSpinner />,
  ssr: false,
})

type ColorMapping = {
  word: string
  color: string
}

// NOTE: English Regex is now mostly handled server-side, but kept for legacy client rendering
const ENGLISH_REGEX = /(\b[a-zA-Z]+(?:['’][a-zA-Z]+)?\b)/g

const shouldIgnoreColor = (hex: string): boolean => {
  if (!hex || !hex.startsWith('#')) return true
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  if (isNaN(r) || isNaN(g) || isNaN(b)) return true
  const maxDiff = Math.max(Math.abs(r - g), Math.abs(r - b), Math.abs(g - b))
  const isGrayscale = maxDiff < 20 
  if (isGrayscale) {
    if (r < 80 || r > 180) { return true }
  }
  return false 
}

const ColorMark = ({ value, children }: PortableTextMarkComponentProps<{_type: 'color'; hex: string}>) => {
  const {resolvedTheme} = useTheme()
  const [mounted, setMounted] = useState(false)
  useEffect(() => { setMounted(true) }, [])
  const originalColor = value?.hex
  if (!mounted || !originalColor) return <span style={{color: originalColor, fontWeight: '700'}}>{children}</span>
  if (shouldIgnoreColor(originalColor)) return <span style={{fontWeight: '700'}}>{children}</span>
  let finalColor = originalColor
  const getLuminance = (hex: string): number => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    if (!result) return 0
    const r = parseInt(result[1], 16)
    const g = parseInt(result[2], 16)
    const b = parseInt(result[3], 16)
    return 0.2126 * r + 0.7152 * g + 0.0722 * b
  }
  const luminance = getLuminance(finalColor)
  if (resolvedTheme === 'dark' && luminance < 60) finalColor = `color-mix(in srgb, ${finalColor} 30%, white 70%)`
  else if (resolvedTheme === 'light' && luminance > 200) finalColor = `color-mix(in srgb, ${finalColor} 70%, black 30%)`
  return <span style={{color: finalColor, fontWeight: '700'}}>{children}</span>
}

const SanityImageComponent = ({value}: {value: any}) => {
  const {asset, alt} = value
  const openLightbox = useLightboxStore((state) => state.openLightbox)
  if (!asset?._id || !asset?.url) return null
  const {width, height} = asset.metadata?.dimensions || {width: 1920, height: 1080}
  const blurDataURL = asset.metadata?.lqip
  const optimizedSrc = urlFor(asset).width(1920).auto('format').url()
  const fullResSrc = urlFor(asset).auto('format').url()
  return (
    <figure style={{ margin: '4rem 0', display: 'block' }}>
      <div 
        onClick={(e) => {
            e.preventDefault();
            e.stopPropagation();
            openLightbox([fullResSrc], 0);
        }} 
        className="image-lightbox-trigger" 
        role="button" 
        aria-label="View full size image"
      >
        <NextImage loader={sanityLoader} src={optimizedSrc} alt={alt || 'Content Image'} width={width} height={height} sizes="(max-width: 960px) 90vw, 850px" placeholder={blurDataURL ? 'blur' : 'empty'} blurDataURL={blurDataURL} loading="lazy" draggable={false} style={{ width: '100%', height: 'auto' }} />
      </div>
      {alt && <figcaption style={{ textAlign: 'center', color: 'var(--text-secondary)', fontSize: '1.4rem', marginTop: '1rem', fontStyle: 'italic', maxWidth: '80%', marginLeft: 'auto', marginRight: 'auto' }}>{alt}</figcaption>}
    </figure>
  )
}

const HeadingComponent = ({level, children, value}: {level: number; children?: React.ReactNode; value?: PortableTextBlock}) => {
  const textContent = value?.children 
    ? value.children.map((child: any) => child.text).join('') 
    : (Array.isArray(children) ? children.join('') : (children as string) || '');
  
  const id = generateId(textContent);

  const styles: Record<number, React.CSSProperties> = {
    1: { fontSize: '3.6rem', margin: '5rem 0 2rem 0', paddingBottom: '1rem', borderBottom: '1px solid var(--border-color)' },
    2: { fontSize: '2.8rem', margin: '5rem 0 2rem 0', paddingBottom: '1rem', borderBottom: '1px solid var(--border-color)' },
    3: { fontSize: '2.2rem', margin: '4rem 0 1.5rem 0' },
  }

  return React.createElement(`h${level}`, {id, style: styles[level] || styles[2]}, children)
}

const BlockquoteComponent = (props: PortableTextComponentProps<PortableTextBlock>) => {
  return (
    <blockquote style={{ margin: '4rem 0', paddingRight: '2rem', borderRight: '4px solid var(--accent)', fontSize: '2.4rem', fontStyle: 'italic', color: 'var(--text-primary)' }}>
      {props.children}
    </blockquote>
  )
}

// MODIFIED: Accept `any[]` to handle mixed HTML strings and PortableTextBlock objects
export default function PortableTextComponent({ content, colorDictionary }: { content: any[], colorDictionary?: ColorMapping[] }) {
  if (!content) return null
  const safeColorDictionary = Array.isArray(colorDictionary) ? colorDictionary : [];

  const components: PortableTextComponents = useMemo(() => {
    const colorMap = new Map(safeColorDictionary.map((item) => [item.word.toLowerCase(), item.color]))
    const colorRegex = safeColorDictionary.length > 0 ? new RegExp(`\\b(${safeColorDictionary.map((item) => item.word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})\\b`, 'gi') : null

    const processTextForEnglish = (text: string) => {
      const parts = text.split(ENGLISH_REGEX)
      return parts.map((part, i) => {
        if (ENGLISH_REGEX.test(part)) {
          if (/[a-zA-Z]/.test(part)) {
             return <strong key={`eng-${i}`} style={{ fontWeight: '700' }}>{part}</strong>
          }
        }
        return part
      })
    }

    const NormalBlockRenderer = (props: PortableTextComponentProps<PortableTextBlock>) => {
      return (
        <p>
          {React.Children.map(props.children, (child: any) => {
            if (typeof child !== 'string') return child
            if (colorRegex) {
              const parts = child.split(colorRegex)
              return parts.map((part, i) => {
                const lowerPart = part.toLowerCase()
                if (colorMap.has(lowerPart)) {
                  return <span key={i} style={{color: colorMap.get(lowerPart), fontWeight: '700'}}>{part}</span>
                }
                return <React.Fragment key={i}>{processTextForEnglish(part)}</React.Fragment>
              })
            }
            return processTextForEnglish(child)
          })}
        </p>
      )
    }

    return {
      types: {
        image: SanityImageComponent,
        imageCompare: ({value}) => <ImageCompare value={value} />,
        twoImageGrid: ({value}) => <TwoImageGrid value={value} />,
        fourImageGrid: ({value}) => <FourImageGrid value={value} />,
        table: ({value}) => <SanityTable value={value} />,
        gameDetails: ({value}) => <GameDetails details={value.details} />,
        youtube: ({value}) => <YoutubeEmbed value={value} />,
      },
      block: {
        h1: ({children, value}) => <HeadingComponent level={1} value={value}>{children}</HeadingComponent>,
        h2: ({children, value}) => <HeadingComponent level={2} value={value}>{children}</HeadingComponent>,
        h3: ({children, value}) => <HeadingComponent level={3} value={value}>{children}</HeadingComponent>,
        blockquote: BlockquoteComponent,
        normal: NormalBlockRenderer,
      },
      marks: {
        color: ColorMark,
        link: ({value, children}) => {
          const href = value.href || '';
          
          const isCreatorLink = href.startsWith('/creators/');
          const isTagLink = href.startsWith('/tags/');
          const isGameLink = href.startsWith('/games/');
          
          if (isCreatorLink) {
              const slug = href.replace('/creators/', '');
              return (
                  <KineticLink href={href} slug={slug} type="creators" className="text-accent underline hover:text-white transition-colors" onClick={(e) => e.stopPropagation()}>
                      {children}
                  </KineticLink>
              );
          }
          
          if (isTagLink) {
               const slug = href.replace('/tags/', '');
               return (
                  <KineticLink href={href} slug={slug} type="tags" className="text-accent underline hover:text-white transition-colors" onClick={(e) => e.stopPropagation()}>
                      {children}
                  </KineticLink>
               );
          }
          
          if (isGameLink) {
              const slug = href.replace('/games/', '');
               return (
                  <KineticLink href={href} slug={slug} type="games" className="text-accent underline hover:text-white transition-colors" onClick={(e) => e.stopPropagation()}>
                      {children}
                  </KineticLink>
               );
          }

          const rel = !href.startsWith('/') ? 'noreferrer noopener' : undefined
          const isExternal = rel === 'noreferrer noopener'
          return <a href={href} rel={rel} target={isExternal ? '_blank' : '_self'}>{children}</a>
        },
      },
    }
  }, [safeColorDictionary])

  return (
    <div className="portable-text-content" style={{fontSize: '1.8rem', lineHeight: 1.8}}>
        {content.map((item, index) => {
            // Case 1: Pre-rendered HTML String (optimized block)
            if (typeof item === 'string') {
                return <div key={`html-${index}`} dangerouslySetInnerHTML={{ __html: item }} />;
            }
            
            // Case 2: Custom Block (image, youtube, etc.) or Legacy Block
            return <PortableText key={(item as any)._key || index} value={[item as any]} components={components} />;
        })}
    </div>
  )
}

--- END OF FILE components/PortableTextComponent.tsx ---

================================================================================

--- START OF FILE components/ProfileEditForm.module.css ---

/* components/ProfileEditForm.module.css */
.avatarFormGroup{margin-bottom:2rem}
.avatarInputContainer{display:flex;align-items:center;gap:1.5rem}
.avatarPreviewButton{position:relative;border-radius:50%;overflow:hidden;padding:0;border:none;background:none;cursor:pointer;width:80px;height:80px;flex-shrink:0}
.profileAvatarPreview{border-radius:50%;transition:all .3s ease-out}
.avatarUploadPrompt{position:absolute;inset:0;background-color:color-mix(in srgb,var(--bg-primary) 70%,transparent);color:var(--text-primary);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.5rem;font-size:1.2rem;font-weight:500;font-family:var(--font-ui);opacity:0;transition:opacity .3s ease-out;z-index:2}
@media (hover: hover) {@media (hover: hover) {
  
  .avatarPreviewButton:hover .avatarUploadPrompt  {opacity:1}
}

  .avatarPreviewButton:active .avatarUploadPrompt  {opacity:1}
}
.avatarPreviewButton:active .avatarUploadPrompt {opacity:1}

@media (hover: hover) {@media (hover: hover) {
  
  .avatarPreviewButton:hover .profileAvatarPreview  {transform:scale(1.1);filter:blur(2px) brightness(.8)}
}

  .avatarPreviewButton:active .profileAvatarPreview  {transform:scale(1.1);filter:blur(2px) brightness(.8)}
}
.avatarPreviewButton:active .profileAvatarPreview {transform:scale(1.1);filter:blur(2px) brightness(.8)}

.formDescription{font-size:1.4rem;color:var(--text-secondary);margin:0}













--- END OF FILE components/ProfileEditForm.module.css ---

================================================================================

--- START OF FILE components/ProfileEditForm.tsx ---

// components/ProfileEditForm.tsx
'use client';

import { updateUserAvatar, updateUserProfile, checkUsernameAvailability } from '@/app/actions/userActions';
// THE FIX: Import User but define a looser type for the prop to handle partial selects and schema mismatches
import { User } from '@/lib/generated/client';
import { useRef, useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import { useSession } from 'next-auth/react';
import AvatarCropperModal from './AvatarCropperModal';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import { useDebounce } from '@/hooks/useDebounce';
import { useToast } from '@/lib/toastStore';
import avatarStyles from './ProfileEditForm.module.css';

const UploadIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24" strokeWidth={1.5} stroke="currentColor" width="24" height="24"> <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /> </svg> );

const ToggleSwitch = ({ checked, onChange, name }: { checked: boolean, onChange: (checked: boolean) => void, name: string }) => (
    <button
        type="button"
        role="switch"
        aria-checked={checked}
        onClick={() => onChange(!checked)}
        className={`toggle ${checked ? 'active' : ''}`}
    >
        <motion.div className="toggle-handle" layout transition={{ type: 'spring', stiffness: 700, damping: 30 }} />
        <input type="checkbox" name={name} checked={checked} readOnly style={{ display: 'none' }} />
    </button>
);

// THE FIX: Define a specific type for the user prop that matches what we actually use and fetch.
// This avoids issues where the Prisma User type requires fields (like 'lastRoleChange') that we don't select.
type ProfileUser = {
    id: string;
    name?: string | null;
    username?: string | null;
    image?: string | null;
    bio?: string | null;
    twitterHandle?: string | null;
    instagramHandle?: string | null;
    age?: number | null;
    country?: string | null;
    agePublic: boolean;
    countryPublic: boolean;
}

export default function ProfileEditForm({ user }: { user: ProfileUser }) {
    const inputFileRef = useRef<HTMLInputElement>(null);
    const { update: updateSession } = useSession();
    const toast = useToast();
    const [isSaving, startSaveTransition] = useTransition();
    const [isCheckingUsername, startUsernameCheckTransition] = useTransition();
    
    const [avatarPreview, setAvatarPreview] = useState(user.image ?? '/default-avatar.svg');
    const [avatarFile, setAvatarFile] = useState<File | null>(null);
    const [name, setName] = useState(user.name ?? '');
    const [username, setUsername] = useState(user.username ?? '');
    const [bio, setBio] = useState(user.bio ?? '');
    const [twitterHandle, setTwitterHandle] = useState(user.twitterHandle ?? '');
    const [instagramHandle, setInstagramHandle] = useState(user.instagramHandle ?? '');
    const [agePublic, setAgePublic] = useState(user.agePublic);
    const [countryPublic, setCountryPublic] = useState(user.countryPublic);

    const [usernameStatus, setUsernameStatus] = useState<{ type: 'idle' | 'checking' | 'valid' | 'invalid', message: string }>({ type: 'idle', message: '' });
    const debouncedUsername = useDebounce(username, 500);
    const [isCropperOpen, setIsCropperOpen] = useState(false);
    const [cropperImageSrc, setCropperImageSrc] = useState<string | null>(null);
    
    const hasTextChanged = 
        name !== (user.name ?? '') ||
        username !== (user.username ?? '') ||
        bio !== (user.bio ?? '') ||
        twitterHandle !== (user.twitterHandle ?? '') ||
        instagramHandle !== (user.instagramHandle ?? '') ||
        agePublic !== user.agePublic ||
        countryPublic !== user.countryPublic;

    const hasChanges = !!avatarFile || hasTextChanged;
    const isSaveDisabled = isSaving || !hasChanges || usernameStatus.type === 'invalid' || usernameStatus.type === 'checking';

    useEffect(() => {
        if (debouncedUsername && debouncedUsername !== user.username) {
            setUsernameStatus({ type: 'checking', message: 'Checking...' });
            startUsernameCheckTransition(async () => {
                const result = await checkUsernameAvailability(debouncedUsername);
                setUsernameStatus({ type: result.available ? 'valid' : 'invalid', message: result.message });
            });
        } else {
            setUsernameStatus({ type: 'idle', message: '' });
        }
    }, [debouncedUsername, user.username]);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => { setCropperImageSrc(reader.result as string); setIsCropperOpen(true); };
        reader.readAsDataURL(file);
        if(inputFileRef.current) inputFileRef.current.value = "";
    };
    const handleCropComplete = (croppedFile: File) => {
        setAvatarFile(croppedFile);
        setAvatarPreview(URL.createObjectURL(croppedFile));
        setIsCropperOpen(false);
    };
    async function handleProfileSave(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault();
        if (isSaveDisabled) return;
        startSaveTransition(async () => {
            try {
                if (avatarFile) {
                    const avatarFormData = new FormData();
                    avatarFormData.append('avatar', avatarFile);
                    const avatarResult = await updateUserAvatar(avatarFormData);
                    if (!avatarResult.success) throw new Error(avatarResult.message);
                }
                if (hasTextChanged) {
                    const profileFormData = new FormData(event.currentTarget);
                    const profileResult = await updateUserProfile(profileFormData);
                    if (!profileResult.success) throw new Error(profileResult.message);
                }
                await updateSession();
                toast.success('حُدِّثَ الملف بنجاح!');
                setAvatarFile(null);
            } catch (error: any) {
                toast.error(error.message || 'أخفق تحديث الملف.');
            }
        });
    }

    const hasContent = (value: string) => value ? 'has-content' : '';

    return (
        <>
            <AvatarCropperModal isOpen={isCropperOpen} onClose={() => setIsCropperOpen(false)} imageSrc={cropperImageSrc || ''} onCropComplete={handleCropComplete} />
            <form onSubmit={handleProfileSave} style={{ maxWidth: '600px', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                <div className={avatarStyles.avatarFormGroup}>
                    <label className="profile-form-label" style={{position: 'static', transform: 'none', marginBottom: '0.5rem', fontSize: '1.4rem', color: 'var(--text-primary)', fontWeight: '600'}}>صورتك الرمزية</label>
                    <div className={avatarStyles.avatarInputContainer}>
                        <button type="button" className={avatarStyles.avatarPreviewButton} onClick={() => inputFileRef.current?.click()}>
                            <div className={avatarStyles.avatarUploadPrompt}><UploadIcon /><span>تغيير</span></div>
                            <Image src={avatarPreview} alt="Avatar preview" width={80} height={80} className={avatarStyles.profileAvatarPreview} />
                        </button>
                        <p className={avatarStyles.formDescription}>انقر لرفع صورة جديدة (أقصاه 4.5 ميجابايت).</p>
                        <input ref={inputFileRef} type="file" name="avatar_source" onChange={handleFileChange} accept="image/png, image/jpeg, image/webp" style={{ display: 'none' }} disabled={isSaving} />
                    </div>
                </div>
                <div className={`profile-form-group ${hasContent(name)}`}>
                    <input id="name" name="name" value={name} onChange={(e) => setName(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="name" className="profile-form-label">الاسم المعروض</label>
                </div>
                <div className={`profile-form-group ${hasContent(username)}`}>
                    <input id="username" name="username" value={username} onChange={(e) => setUsername(e.target.value)} className="profile-input" required placeholder=" " />
                    <label htmlFor="username" className="profile-form-label">اسم المستخدم</label>
                    <AnimatePresence>
                        {usernameStatus.message && ( <motion.p initial={{opacity: 0, height: 0}} animate={{opacity: 1, height: 'auto'}} exit={{opacity: 0, height: 0}} style={{ fontSize: '1.3rem', margin: '0.5rem 0 0 0', color: usernameStatus.type === 'invalid' ? '#DC2626' : (usernameStatus.type === 'valid' ? '#16A34A' : 'var(--text-secondary)') }}>{usernameStatus.message}</motion.p> )}
                    </AnimatePresence>
                </div>
                <div className={`profile-form-group ${hasContent(bio)}`}>
                    <textarea id="bio" name="bio" value={bio} onChange={(e) => setBio(e.target.value)} rows={4} className="profile-input" maxLength={500} placeholder=" " />
                    <label htmlFor="bio" className="profile-form-label">النبذة التعريفية</label>
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                    <div className={`profile-form-group ${hasContent(twitterHandle)}`}>
                        <input id="twitterHandle" name="twitterHandle" value={twitterHandle} onChange={(e) => setTwitterHandle(e.target.value)} className="profile-input" placeholder=" " />
                         <label htmlFor="twitterHandle" className="profile-form-label">حساب تويتر</label>
                    </div>
                    <div className={`profile-form-group ${hasContent(instagramHandle)}`}>
                        <input id="instagramHandle" name="instagramHandle" value={instagramHandle} onChange={(e) => setInstagramHandle(e.target.value)} className="profile-input" placeholder=" "/>
                        <label htmlFor="instagramHandle" className="profile-form-label">حساب إنستغرام</label>
                    </div>
                </div>

                <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem', background: 'var(--bg-primary)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border-color)'}}>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="agePublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار العمر علنًا</label>
                        <ToggleSwitch name="agePublic" checked={agePublic} onChange={setAgePublic} />
                    </div>
                    <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                        <label htmlFor="countryPublic" style={{fontFamily: 'var(--font-ui)', fontWeight: 500}}>إظهار البلد علنًا</label>
                        <ToggleSwitch name="countryPublic" checked={countryPublic} onChange={setCountryPublic} />
                    </div>
                </div>

                <motion.button
                    type="submit"
                    className="primary-button"
                    disabled={isSaveDisabled}
                    style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        overflow: 'hidden'
                    }}
                    animate={{
                        width: isSaving ? '48px' : '100%',
                        height: '48px',
                        borderRadius: isSaving ? '50%' : '5px',
                        paddingLeft: isSaving ? '0rem' : '2.4rem',
                        paddingRight: isSaving ? '0rem' : '2.4rem',
                    }}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                >
                    <AnimatePresence mode="wait">
                        {isSaving ? (
                            <ButtonLoader key="loader" />
                        ) : (
                            <motion.span
                                key="text"
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                style={{ whiteSpace: 'nowrap' }}
                            >
                                حفظ التغييرات
                            </motion.span>
                        )}
                    </AnimatePresence>
                </motion.button>
            </form>
        </>
    );
}




--- END OF FILE components/ProfileEditForm.tsx ---

================================================================================

--- START OF FILE components/ReadingHud.module.css ---

/* components/ReadingHud.module.css */

.readingHud {
  position: fixed;
  bottom: 15vh; /* THE FIX: Anchor to the bottom */
  top: auto; /* THE FIX: Unset top anchor */
  left: 2rem;
  transform: none; /* THE FIX: Remove vertical centering transform */
  display: flex;
  align-items: center;
  height: 70vh; /* THE FIX: Set height relative to viewport height */
  max-height: 700px; /* THE FIX: Add a max-height */
  z-index: 100;
}

@media (max-width: 1024px) {
  .readingHud {
    display: none;
  }
}

.track {
  width: 2px;
  height: 100%;
  background-color: var(--border-color);
  position: relative;
  border-radius: 2px;
  overflow: hidden; /* THE FIX: This container now acts as a mask */
}

.progress {
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  box-shadow: 0 0 8px 0 color-mix(in srgb, var(--accent) 70%, transparent);
  /* THE FIX: We now animate translateY instead of scaleY */
  transform-origin: top; 
  will-change: transform;
}

.markers {
  position: absolute;
  top: 0;
  right: 50%;
  width: 1px;
  height: 100%;
  margin-right: -5px; 
}

.marker {
  position: absolute;
  right: 50%;
  width: 10px; 
  height: 10px; 
  border: 2px solid var(--bg-primary);
  border-radius: 50%;
  cursor: pointer;
  padding: 0;
}

.markerDot {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: var(--border-color);
    transition: transform 0.15s ease-out, background-color 0.15s ease-out, box-shadow 0.15s ease-out;
    will-change: transform, background-color, box-shadow;
    transform: scale(1);
}

.marker.active .markerDot {
    background-color: var(--accent);
    box-shadow: 0 0 12px 2px color-mix(in srgb, var(--accent) 70%, transparent);
    transform: scale(1.8);
}
@media (hover: hover) {@media (hover: hover) {
  
  .marker:hover .markerDot  {
    background-color: var(--accent);
    transform: scale(2.2);
    z-index: 2; 
}
}

  .marker:active .markerDot  {
    background-color: var(--accent);
    transform: scale(2.2);
    z-index: 2; 
}
}
.marker:active .markerDot {
    background-color: var(--accent);
    transform: scale(2.2);
    z-index: 2; 
}


.marker::after {
  content: attr(data-title);
  position: absolute;
  top: 50%;
  left: 18px;
  transform: translateY(-50%) scale(0.9);
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  padding: 0.5rem 1.2rem;
  border-radius: 6px;
  font-family: var(--font-ui);
  font-size: 1.4rem;
  font-weight: 500;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s ease-out, transform 0.15s ease-out, left 0.15s ease-out;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  border: 1px solid var(--border-color);
}
@media (hover: hover) {@media (hover: hover) {
  
  .marker:hover::after  {
  opacity: 1;
  transform: translateY(-50%) scale(1);
  left: 25px;
}
}

  .marker:active::after  {
  opacity: 1;
  transform: translateY(-50%) scale(1);
  left: 25px;
}
}
.marker:active::after {
  opacity: 1;
  transform: translateY(-50%) scale(1);
  left: 25px;
}


.readingHudMobile {
  position: fixed;
  top: var(--nav-height-scrolled);
  left: 0;
  right: 0;
  height: 3px;
  z-index: 100;
  pointer-events: none;
}

.mobileTrack {
  width: 100%;
  height: 100%;
  background-color: color-mix(in srgb, var(--border-color) 50%, transparent);
  position: relative;
}

.mobileProgress {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0; 
  width: 100%;
  background-color: var(--accent);
  transform-origin: right; 
  box-shadow: 0 0 10px 0 var(--accent);
}

@media (min-width: 1025px) {
  .readingHudMobile {
    display: none;
  }
}




--- END OF FILE components/ReadingHud.module.css ---

================================================================================

--- START OF FILE components/ReadingHud.tsx ---

// components/ReadingHud.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, useScroll, useSpring, AnimatePresence, useTransform } from 'framer-motion';
import styles from './ReadingHud.module.css';

type Heading = {
    id: string;
    title: string;
    top: number;
    level: number;
};

export default function ReadingHud({ 
    headings,
    isMobile,
    scrollContainerRef 
}: { 
    contentContainerRef?: React.RefObject<HTMLDivElement | null>, 
    headings: Heading[],
    isMobile: boolean,
    scrollContainerRef?: React.RefObject<HTMLElement | null>
}) {
    const [activeHeadings, setActiveHeadings] = useState<Set<string>>(new Set());
    const [showHud, setShowHud] = useState(false);
    
    // Target specific scroll container if provided (for Overlay), otherwise default (Window)
    const { scrollYProgress } = useScroll({ 
        container: scrollContainerRef,
        offset: ['start start', 'end end'] 
    });
    
    const springyProgress = useSpring(scrollYProgress, { stiffness: 200, damping: 40, restDelta: 0.001 });
    const progressValue = useTransform(scrollYProgress, (p) => p);
    const translateY = useTransform(springyProgress, [0, 1], ['-100%', '0%']);

    useEffect(() => {
        const unsubscribe = progressValue.on('change', (latestProgress) => {
            
            let scrollTop = 0;
            let scrollHeight = 0;
            let clientHeight = 0;

            if (scrollContainerRef?.current) {
                const el = scrollContainerRef.current;
                scrollTop = el.scrollTop;
                scrollHeight = el.scrollHeight;
                clientHeight = el.clientHeight;
            } else {
                scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                scrollHeight = document.documentElement.scrollHeight;
                clientHeight = document.documentElement.clientHeight;
            }
            
            const documentScrollHeight = scrollHeight - clientHeight;
            
            setShowHud(scrollTop > 100 && latestProgress < 0.99);

            if (headings.length === 0 || documentScrollHeight <= 0) return;
            
            const currentlyActive = new Set<string>();

            for (let i = 0; i < headings.length; i++) {
                const heading = headings[i];
                const headingProgressPosition = heading.top / documentScrollHeight;
                if (latestProgress >= headingProgressPosition) {
                    currentlyActive.add(heading.id);
                }
            }
            
            setActiveHeadings(currentlyActive);
        });

        return () => unsubscribe();
    }, [headings, progressValue, scrollContainerRef]); 

    const handleMarkerClick = (headingId: string) => {
        const targetScrollPosition = headings.find(h => h.id === headingId)?.top;

        if (targetScrollPosition !== undefined) {
             if (scrollContainerRef?.current) {
                 scrollContainerRef.current.scrollTo({ top: targetScrollPosition, behavior: 'smooth' });
             } else {
                 window.scrollTo({ top: targetScrollPosition, behavior: 'smooth' });
             }
        }
    };

    if (isMobile) {
        return (
            <AnimatePresence>
                {showHud && (
                    <motion.aside
                        className={styles.readingHudMobile}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <div className={styles.mobileTrack}>
                            <motion.div className={styles.mobileProgress} style={{ scaleX: springyProgress }} /> 
                        </div>
                    </motion.aside>
                )}
            </AnimatePresence>
        );
    }

    return (
        <AnimatePresence>
            {showHud && headings.length > 0 && (
                <motion.aside
                    className={styles.readingHud}
                    initial={{ opacity: 0, x: 20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: 20 }}
                    transition={{ duration: 0.5, ease: 'easeOut' }}
                >
                    <div className={styles.track}>
                        <motion.div className={styles.progress} style={{ translateY }} />
                    </div>
                    <div className={styles.markers}>
                        {headings.map((h) => {
                            const isActive = activeHeadings.has(h.id);
                            
                            let scrollHeight = 0;
                            let clientHeight = 0;
                            if (scrollContainerRef?.current) {
                                scrollHeight = scrollContainerRef.current.scrollHeight;
                                clientHeight = scrollContainerRef.current.clientHeight;
                            } else {
                                scrollHeight = document.documentElement.scrollHeight;
                                clientHeight = document.documentElement.clientHeight;
                            }
                            
                            const documentScrollHeight = scrollHeight - clientHeight;
                            if (documentScrollHeight <= 0) return null;
                            
                            const topPercentage = (h.top / documentScrollHeight) * 100;
                            const markerClass = h.level === 2 ? styles.markerH2 : '';

                            return (
                                <button
                                    key={h.id}
                                    className={`${styles.marker} ${markerClass} ${isActive ? styles.active : ''}`}
                                    style={{ 
                                        top: `${topPercentage}%`,
                                    }}
                                    onClick={() => handleMarkerClick(h.id)}
                                    data-title={h.title}
                                    aria-label={`Scroll to ${h.title}`}
                                >
                                    <div className={styles.markerDot} />
                                </button>
                            )
                        })}
                    </div>
                </motion.aside>
            )}
        </AnimatePresence>
    );
};

--- END OF FILE components/ReadingHud.tsx ---

================================================================================

--- START OF FILE components/ScoreBox.module.css ---

/* components/ScoreBox.module.css */

.scoreBox {
  background-color: transparent;
  border: 1px solid var(--border-color);
  box-shadow: 0 8px 30px rgba(0,0,0,0.08);
  border-radius: 12px;
  padding: 4rem;
  margin-top: 5rem;
  text-align: center;
  position: relative;
  overflow: hidden;
  transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}
[data-theme="dark"] .scoreBox {
  border: 1px solid var(--border-color);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 15%, transparent);
}

.scoreBoxBorder {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
}
[data-theme="dark"] .scoreBoxBorder {
  filter: drop-shadow(0 0 10px color-mix(in srgb, var(--accent) 70%, transparent));
}

.scoreBoxScore {
  font-family: var(--font-main), sans-serif;
  font-size: 9rem;
  font-weight: 800;
  color: var(--accent);
  line-height: 1;
  text-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.scoreBoxVerdictLabel {
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1.5px;
  margin-top: 0.5rem;
}

.scoreBoxVerdictText {
  font-size: 1.8rem;
  font-style: italic;
  max-width: 600px;
  margin: 1.5rem auto 3rem auto;
  color: var(--text-primary);
}

.scoreBoxDivider {
  width: 100%;
  height: 1px;
  background-color: var(--border-color);
  margin-bottom: 3rem;
}

.scoreBoxProsCons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3rem;
  text-align: right;
}

.scoreBoxProsCons h4 {
  font-family: var(--font-main), sans-serif;
  font-weight: 700;
  font-size: 1.8rem;
  margin-bottom: 1rem;
}

.scoreBoxProsCons ul {
  list-style: none;
  padding-right: 0;
}

.scoreBoxProsCons li {
  display: flex;
  flex-direction: row-reverse;
  justify-content: flex-end;
  align-items: flex-start;
  margin-bottom: 1rem;
  font-family: var(--font-main), sans-serif;
  font-size: 1.6rem;
  gap: 1rem;
}

/* --- THE DEFINITIVE FIX FOR MOBILE --- */
@media (max-width: 640px) {
  .scoreBox {
    padding: 2rem;
  }
  .scoreBoxProsCons {
    grid-template-columns: 1fr; /* Stack to a single column */
    gap: 4rem; /* Increase gap between pros and cons sections */
  }
}




--- END OF FILE components/ScoreBox.module.css ---

================================================================================

--- START OF FILE components/ScoreBox.tsx ---

// components/ScoreBox.tsx
'use client';

import React, { useRef, memo } from 'react';
import { motion, useInView } from 'framer-motion';
import { AnimatedNumber } from './AnimatedNumber';
import { CheckIcon, CancelIcon } from '@/components/icons/index';
import styles from './ScoreBox.module.css';

const containerVariants = { hidden: { opacity: 0 }, visible: { opacity: 1, transition: { staggerChildren: 0.25, delayChildren: 0.2 }, }, };
const itemVariants = { hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0, transition: { duration: 0.5, ease: 'easeOut' as const } }, };

const ScoreBoxComponent = ({ review, className }: { review: any, className?: string }) => {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 'some' });
    
    // SAFEGUARD: Ensure arrays exist
    const pros = Array.isArray(review.pros) ? review.pros : [];
    const cons = Array.isArray(review.cons) ? review.cons : [];

    return (
        <motion.div ref={ref} className={`${styles.scoreBox} ${className || ''}`} initial="hidden" animate={isInView ? "visible" : "hidden"} variants={containerVariants}>
            <svg className={styles.scoreBoxBorder} width="100%" height="100%">
                <motion.rect x="1" y="1" width="calc(100% - 2px)" height="calc(100% - 2px)" rx="12" stroke="var(--accent)" strokeWidth="2" fill="transparent" initial={{ pathLength: 0 }} animate={{ pathLength: isInView ? 1 : 0 }} transition={{ duration: 1, ease: 'easeInOut' }} />
            </svg>
            <AnimatedNumber value={review.score || 0} isInView={isInView} className={styles.scoreBoxScore} />
            <motion.div variants={itemVariants} className={styles.scoreBoxVerdictLabel}>الخلاصة</motion.div>
            <motion.p variants={itemVariants} className={styles.scoreBoxVerdictText}>{review.verdict}</motion.p>
            <motion.div variants={itemVariants} className={styles.scoreBoxDivider} />
            <div className={styles.scoreBoxProsCons}>
                <motion.div variants={itemVariants}>
                    <h4>المحاسن</h4>
                    <ul>{pros.map((pro: string, index: number) => (<li key={`pro-${index}`}>{pro} <CheckIcon style={{flexShrink:0,width:'3.5rem',height:'3.5rem',marginTop:'-0.3rem',color:'#16A34A'}} /></li>))}</ul>
                </motion.div>
                <motion.div variants={itemVariants}>
                    <h4>المساوئ</h4>
                    <ul>{cons.map((con: string, index: number) => (<li key={`con-${index}`}>{con} <CancelIcon style={{flexShrink:0,width:'1.8rem',height:'1.8rem',marginTop:'0.6rem',color:'#DC2626'}} /></li>))}</ul>
                </motion.div>
            </div>
        </motion.div>
    );
};

export default memo(ScoreBoxComponent);

--- END OF FILE components/ScoreBox.tsx ---

================================================================================

--- START OF FILE components/Search.module.css ---

/* components/Search.module.css */

.searchOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: color-mix(in srgb, var(--bg-primary) 85%, transparent);
  backdrop-filter: blur(10px);
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding-top: 15vh;
  z-index: 3000;
}

:global(body.no-glass) .searchOverlay {
    backdrop-filter: none !important;
    background-color: rgba(5, 5, 5, 0.95) !important;
}

.searchContainer {
  position: relative;
  width: 100%;
  max-width: 1200px;
  padding: 0 2rem;
}

.searchCloseButton {
  position: absolute;
  top: -60px;
  right: 2rem; 
  left: auto;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  padding: 1rem;
  width: 40px;
  height: 40px;
  transition: color 0.3s ease, transform 0.3s ease;
}
@media (hover: hover) {
  .searchCloseButton:hover  {
    transform: scale(1.1) rotate(90deg);
    color: var(--accent);
    filter: drop-shadow(0 0 8px var(--accent));
  }
}
.searchCloseButton:active {
  transform: scale(1.1) rotate(90deg);
  color: var(--accent);
}

/* --- UPGRADED SEARCH INPUT --- */
.searchInput {
  width: 100%;
  
  /* Glassy Background */
  background: rgba(10, 11, 15, 0.6);
  backdrop-filter: blur(12px);
  
  /* Cyan Border (Default) */
  border: 1px solid color-mix(in srgb, var(--accent) 50%, transparent);
  border-radius: 12px; /* Slightly rounder */
  
  color: var(--text-primary);
  font-family: var(--font-main), sans-serif;
  font-size: 2.4rem; /* Larger Text */
  font-weight: 700;
  padding: 1.8rem 2.5rem;
  outline: none;
  text-align: right;
  
  /* Smooth Physics Transition */
  transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  
  /* Initial Subtle Glow */
  box-shadow: 
    0 10px 30px -10px rgba(0,0,0,0.5),
    0 0 10px -2px color-mix(in srgb, var(--accent) 15%, transparent);
  
  position: relative;
  z-index: 20; 
}

/* Hover Effect */
.searchInput:hover {
    border-color: color-mix(in srgb, var(--accent) 80%, transparent);
    background: rgba(10, 11, 15, 0.8);
    box-shadow: 
        0 10px 40px -10px rgba(0,0,0,0.6),
        0 0 20px -5px color-mix(in srgb, var(--accent) 30%, transparent);
}

/* Focus/Active Effect (High Energy) */
.searchInput:focus {
  border-color: var(--accent);
  background: rgba(5, 5, 5, 0.95);
  
  /* Power-up Glow + Double Border */
  box-shadow: 
    0 0 0 2px color-mix(in srgb, var(--accent) 20%, transparent), /* Outer Ring */
    0 0 50px color-mix(in srgb, var(--accent) 40%, transparent), /* Large Glow */
    inset 0 0 30px color-mix(in srgb, var(--accent) 10%, transparent); /* Inner Depth */
    
  transform: scale(1.01) translateY(-2px);
}

.searchInput::placeholder {
    color: var(--text-secondary);
    font-weight: 500;
    opacity: 0.7;
    transition: opacity 0.2s ease;
}

.searchInput:focus::placeholder {
    opacity: 0.4;
}

.searchResultsList {
  margin-top: 2rem;
  max-height: 65vh;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 6rem 2rem 2rem 2rem;
  mask-image: linear-gradient(to bottom, black 95%, transparent);
  -webkit-mask-image: linear-gradient(to bottom, black 95%, transparent);
}

.resultsGrid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 3rem;
    padding: 6rem;
    margin: -6rem;
    width: calc(100% + 12rem);
    align-items: stretch;
    pointer-events: none;
}

@media (min-width: 1024px) {
    .resultsGrid {
        grid-template-columns: repeat(2, 1fr);
    }
}

.resultsGrid > * {
    pointer-events: auto;
}

.searchInitialPrompt {
  font-family: var(--font-main), sans-serif;
  font-size: 2.8rem;
  text-align: center;
  color: var(--text-secondary);
  margin-top: 5rem;
  text-shadow: 0 2px 10px rgba(0,0,0,0.5); /* Added shadow to prompt */
  opacity: 0.8;
}

@media (max-width: 768px) {
    .searchOverlay {
        padding-top: 10vh;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(5, 5, 5, 0.98);
    }
    .searchContainer {
        padding: 0 1rem;
    }
    .searchInput {
        font-size: 1.8rem;
        padding: 1.5rem;
    }
    .resultsGrid {
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 4rem;
        margin: -4rem;
        width: calc(100% + 8rem);
    }
    .searchResultsList {
        padding: 4rem 1rem 1rem 1rem;
    }
}

--- END OF FILE components/Search.module.css ---

================================================================================

--- START OF FILE components/Search.tsx ---

// components/Search.tsx

'use client';

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import type { SanitySearchResult } from '@/types/sanity';
import { useDebounce } from '@/hooks/useDebounce';
import styles from './Search.module.css';
import NewsGridCard from '@/components/news/NewsGridCard';
import { CardProps } from '@/types';

const CrossIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

const overlayVariants = { hidden: { opacity: 0, backdropFilter: 'blur(0px)' }, visible: { opacity: 1, backdropFilter: 'blur(12px)' } };
const containerVariants = { hidden: { y: '-10vh', opacity: 0, scale: 0.98, transition: { type: 'spring' as const, stiffness: 200, damping: 25 } }, visible: { y: 0, opacity: 1, scale: 1, transition: { type: 'spring' as const, stiffness: 200, damping: 25 } } };
const listVariants = { visible: { transition: { staggerChildren: 0.05 } } };

// FIX: Added 'as const' to the transition type to satisfy TypeScript
const resultItemVariants = { 
    hidden: { opacity: 0, y: 30 }, 
    visible: { 
        opacity: 1, 
        y: 0, 
        transition: { type: 'spring' as const, stiffness: 300, damping: 25 } 
    } 
};

// Mapping function to convert Search Result to CardProps
const adaptSearchResultToCard = (result: SanitySearchResult): CardProps => {
    // Format date
    const date = result.publishedAt ? new Date(result.publishedAt).toLocaleDateString('ar-EG', { year: 'numeric', month: 'short', day: 'numeric' }) : '';

    return {
        id: result._id,
        legacyId: result.legacyId || 0,
        type: result._type,
        title: result.title,
        slug: result.slug,
        imageUrl: result.imageUrl || '/placeholder-game.jpg',
        blurDataURL: result.blurDataURL || '',
        date: date,
        // Adapt authors/reporters
        authors: (result.authors || result.reporters || []).map(a => ({
            _id: 'search-author', // minimal dummy for display
            name: a.name,
            image: a.image, // Assuming query returns image object or url
            slug: '',
            prismaUserId: ''
        })),
        tags: (result.tags || []).map(t => ({ title: t.title, slug: t.slug })),
        game: result.game,
        category: result.category,
        newsType: result.newsType,
        score: result.score,
        // Defaults
        isPinned: false,
        onGamePass: false,
        onPSPlus: false,
    };
};

export default function Search({ isOpen, onClose }: { isOpen: boolean, onClose: () => void }) {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState<SanitySearchResult[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    // NEW: State to track if an item was just clicked to force unmount
    const [isItemSelected, setIsItemSelected] = useState(false);
    
    const debouncedQuery = useDebounce(query, 600);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (isOpen) {
            inputRef.current?.focus();
            setIsItemSelected(false); // Reset on open
            const handleKeyDown = (event: KeyboardEvent) => { if (event.key === 'Escape') onClose(); };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
        } else {
            setQuery('');
            setResults([]);
        }
    }, [isOpen, onClose]);

    const performSearch = useCallback(async (searchQuery: string) => {
        if (searchQuery.length < 3) { setResults([]); return; }
        setIsSearching(true);
        try {
            const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) throw new Error('Search failed');
            const data: SanitySearchResult[] = await response.json();
            setResults(data);
        } catch (error) {
            console.error('Search error:', error);
            setResults([]);
        } finally {
            setIsSearching(false);
        }
    }, []);

    useEffect(() => { performSearch(debouncedQuery); }, [debouncedQuery, performSearch]);

    // Handle instant close on selection
    const handleResultClick = (e: React.MouseEvent) => {
        setIsItemSelected(true);
        onClose();
    };

    const hasContent = useMemo(() => query.length >= 3 && results.length > 0, [query, results]);
    const isInitialPrompt = query.length < 3;
    
    // Logic: if item selected, force null (instant unmount) to skip exit animation
    if (isItemSelected) return null;

    return (
        <AnimatePresence>
            {isOpen && (
                // FIX: Ensure higher z-index than Navbar (3000)
                <motion.div className={styles.searchOverlay} onClick={onClose} variants={overlayVariants} initial="hidden" animate="visible" exit="hidden" style={{ zIndex: 3000 }} >
                    <motion.div className={styles.searchContainer} onClick={(e) => e.stopPropagation()} variants={containerVariants} initial="hidden" animate="visible" exit="hidden" >
                        <button className={styles.searchCloseButton} onClick={onClose} aria-label="إغلاق البحث"><CrossIcon /></button>
                        <input ref={inputRef} type="search" className={styles.searchInput} placeholder="استنطاق الأرشيف" value={query} onChange={(e) => setQuery(e.target.value)} />
                        
                        <div className={styles.searchResultsList}>
                            <AnimatePresence mode="wait">
                                {isInitialPrompt && (<motion.p key="prompt" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} className={styles.searchInitialPrompt}>خُطَّ ما في نفسِكَ تُجِبْكَ السجلات.</motion.p> )}
                                {isSearching && (<motion.div key="loading" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ display: 'flex', justifyContent: 'center', padding: '4rem' }}><div className="spinner" style={{ width: '50px', height: '50px', borderTopColor: 'var(--accent)' }} /></motion.div> )}
                                
                                {hasContent && (
                                    <motion.div 
                                        key="results" 
                                        variants={listVariants} 
                                        initial="hidden" 
                                        animate="visible" 
                                        exit="hidden"
                                        className={styles.resultsGrid}
                                    >
                                        {results.map(result => {
                                            const cardProps = adaptSearchResultToCard(result);
                                            return (
                                                <motion.div key={result._id} variants={resultItemVariants} style={{ height: 'auto' }}>
                                                    <NewsGridCard 
                                                        item={cardProps} 
                                                        layoutIdPrefix="search-results"
                                                        variant="compact"
                                                        onClick={handleResultClick}
                                                    />
                                                </motion.div>
                                            );
                                        })}
                                    </motion.div>
                                )}

                                {!isSearching && query.length >= 3 && results.length === 0 && (<motion.div key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{ color: 'var(--text-secondary)', marginTop: '3rem', textAlign: 'center', fontSize: '2.4rem' }}><p>لا أثرَ في السجلاتِ لـ &quot;{query}&quot;.</p></motion.div>)}
                            </AnimatePresence>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE components/Search.tsx ---

================================================================================

--- START OF FILE components/SessionProvider.tsx ---

// components/SessionProvider.tsx
'use client';
import { SessionProvider } from 'next-auth/react';
import type { Session } from 'next-auth';
import React from 'react';

type Props = {
  children: React.ReactNode;
  session?: Session | null;
};

export default function NextAuthProvider({ children, session }: Props) {
  // THE FIX: Disable automatic refetching on window focus to reduce API calls.
  return (
    <SessionProvider 
      session={session as any} 
      refetchOnWindowFocus={false}
    >
      {children}
    </SessionProvider>
  );
}




--- END OF FILE components/SessionProvider.tsx ---

================================================================================

--- START OF FILE components/SignInModal.module.css ---

.authModalPanelContainer {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  max-width: 420px;
  min-height: 450px;
}
.authSatelliteContainer {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 0;
}
.authOrbRowTop {
  display: flex;
  justify-content: center;
  gap: 3rem;
  width: 100%;
}
.authFooterText {
  font-family: var(--font-ui);
  font-size: 1.6rem;
  color: var(--text-secondary);
  text-align: center;
}
.authMorphWrapper {
  position: relative;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}
.authCredentialsPanel {
  width: 420px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 16px;
  box-shadow: 0 25px 50px -12px rgba(0,0,0,0.35);
  padding: 3rem;
  overflow: hidden;
}
.authCredentialsContent {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.authBackButton {
  position: absolute;
  top: 1.5rem;
  right: 1.5rem;
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 0.5rem;
  width: 24px;
  height: 24px;
  z-index: 20;
  transition: color 0.2s ease-out, transform 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .authBackButton:hover  {
  color: var(--text-primary);
  transform: translateX(2px);
}
}

  .authBackButton:active  {
  color: var(--text-primary);
  transform: translateX(2px);
}
}
.authBackButton:active {
  color: var(--text-primary);
  transform: translateX(2px);
}

.formHeader {
  text-align: center;
  margin-bottom: 2rem;
}
.formTitle {
  font-size: 2.4rem;
  margin: 0;
  font-family: var(--font-heading);
}
.credentialsForm {
  display: flex;
  flex-direction: column;
  gap: 2.5rem; /* Increased gap to accommodate labels */
  width: 100%;
}

/* --- THE DEFINITIVE FIX: FLOATING LABEL STYLES --- */
.authFormGroup {
  position: relative;
}
.authFormLabel {
  position: absolute;
  right: 1.5rem;
  left: auto;
  top: 1.2rem;
  font-family: var(--font-main);
  font-size: 1.4rem;
  color: var(--text-secondary);
  pointer-events: none;
  transition: all 0.2s ease-out;
}
.authInput:focus ~ .authFormLabel,
.authInput:not(:placeholder-shown) ~ .authFormLabel {
  top: -2.4rem; /* Move label up */
  right: 0;
  font-size: 1.4rem;
  font-weight: 600;
  color: var(--accent);
}
.authInput {
  width: 100%;
  height: 4.8rem;
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
  text-align: right;
}
.authInput:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 20%, transparent);
}
/* --- END FLOATING LABEL STYLES --- */

.authSubmitButton {
  background-color: var(--accent);
  color: #fff;
  border: none;
  padding: 1.2rem 2.4rem;
  border-radius: 8px;
  font-weight: 700;
  font-size: 1.6rem;
  cursor: pointer;
  margin-top: 1rem;
  box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
  transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .authSubmitButton:hover:not(:disabled)  {
  transform: scale(1.05);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 50%, transparent);
}
}

  .authSubmitButton:active:not(:disabled)  {
  transform: scale(1.05);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 50%, transparent);
}
}
.authSubmitButton:active:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 50%, transparent);
}

[data-theme="dark"] .authSubmitButton {
  color: var(--bg-primary);
}
.authViewSwitcher {
  margin-top: 2rem;
  text-align: center;
  font-size: 1.4rem;
  color: var(--text-secondary);
}
.linkButton {
  position: relative;
  background: none;
  border: none;
  padding: 0;
  margin: 0 0.5rem;
  font: inherit;
  color: var(--accent);
  font-weight: 600;
  cursor: pointer;
  text-decoration: none;
}

.linkButton::after {
  content: '';
  position: absolute;
  width: 100%;
  transform: scaleX(0);
  height: 2px;
  bottom: -2px;
  right: 0;
  background-color: var(--accent);
  transform-origin: bottom right;
  transition: transform 0.3s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .linkButton:hover::after  {
  transform: scaleX(1);
}
}

  .linkButton:active::after  {
  transform: scaleX(1);
}
}
.linkButton:active::after {
  transform: scaleX(1);
}


.authMessage {
  margin-top: 1rem;
  font-size: 1.4rem;
  text-align: center;
}
.authMessage.error {
  color: #DC2626;
}
.authMessage.success {
  color: #16A34A;
}

/* ADDED: Mobile responsiveness */
@media (max-width: 480px) {
  .authModalPanelContainer {
    max-width: 90vw;
    min-height: 400px;
  }
  .authCredentialsPanel {
    width: 75vw;
    padding: 2rem;
  }
  .formTitle {
    font-size: 2rem;
  }
  .authInput {
    height: 4.4rem;
    font-size: 1.5rem;
  }
  .authFormLabel {
    top: 1rem;
  }
  .authSubmitButton {
    font-size: 1.5rem;
  }
  .authOrbRowTop {
    gap: 1.5rem;
  }
}




--- END OF FILE components/SignInModal.module.css ---

================================================================================

--- START OF FILE components/SignInModal.tsx ---

// components/SignInModal.tsx
'use client';

import React, { useState, useEffect, useTransition } from 'react';
import { createPortal } from 'react-dom';
import { signIn } from 'next-auth/react';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { useRouter, usePathname } from 'next/navigation';
import { AuthOrb } from './AuthOrb';
import { requestPasswordReset } from '@/app/actions/authActions';
import ButtonLoader from './ui/ButtonLoader';
// MODIFIED: Replaced dynamic imports with a single static import
import { GitHubIcon, GoogleIcon, XIcon, EternalGamesIcon } from '@/components/icons/AuthIcons';
import styles from './SignInModal.module.css';
import modalStyles from './modals/Modals.module.css';

const formContentVariants = {
    hidden: { opacity: 0, transition: { duration: 0.15, ease: 'easeOut' as const } },
    visible: { opacity: 1, transition: { delay: 0.25, duration: 0.3, ease: 'easeIn' as const } },
    exit: { opacity: 0, transition: { duration: 0.15, ease: 'easeOut' as const } }
};

const satelliteVariants = {
    hidden: (direction: number) => ({
        y: 80, x: direction * 20, scale: 0, opacity: 0, rotate: 360,
        transition: { duration: 0.4, ease: 'easeIn' as const }
    }),
    visible: {
        y: 0, x: 0, scale: 1, opacity: 1, rotate: 0,
        // MODIFIED: Slightly adjusted spring for a snappier feel
        transition: { type: 'spring' as const, stiffness: 350, damping: 25, delay: 0.1 }
    }
};

// --- START: Refactored Form Components (No changes within these) ---

const SignInForm = ({ onSwitchToSignUp, onForgotPassword, onAuthSuccess, onBack, callbackUrl }: { onSwitchToSignUp: () => void, onForgotPassword: () => void, onAuthSuccess: () => void, onBack: () => void, callbackUrl: string }) => {
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);
    const router = useRouter();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSignIn = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        const formData = new FormData(event.currentTarget);
        
        startTransition(async () => {
            const result = await signIn('credentials', { redirect: false, ...Object.fromEntries(formData) });
            if (result?.error) setMessage({ type: 'error', text: result.error });
            else if (result?.url) { router.push(result.url); onAuthSuccess(); } 
            else setMessage({ type: 'error', text: 'طرأ خطبٌ ما.' });
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>الدخول بالبريد الإلكتروني</h2></div>
            <form onSubmit={handleSignIn} className={styles.credentialsForm}>
                <input type="hidden" name="returnTo" value={callbackUrl} />
                <div className={styles.authFormGroup}>
                    <input id="signin-email" type="email" name="email" required className={styles.authInput} value={email} onChange={e => setEmail(e.target.value)} placeholder=" " />
                    <label htmlFor="signin-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <div className={styles.authFormGroup}>
                    <input id="signin-password" type="password" name="password" required className={styles.authInput} value={password} onChange={e => setPassword(e.target.value)} placeholder=" " />
                    <label htmlFor="signin-password" className={styles.authFormLabel}>كلمة السر</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>تسجيل الدخول</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${styles.error}`}>{message.text}</p>}
            <p className={styles.authViewSwitcher}>جديدٌ في رحابنا؟ <button type="button" onClick={() => {onSwitchToSignUp(); setMessage(null);}} className={styles.linkButton}>أنشئ حسابًا</button></p>
            <button type="button" onClick={onForgotPassword} className={styles.linkButton} style={{textAlign: 'center', fontSize: '1.4rem', color: 'var(--text-secondary)', display: 'block', margin: '1rem auto 0'}}>أنسيت كلمة السر؟</button>
        </motion.div>
    );
};

const SignUpForm = ({ onSwitchToSignIn, onAuthSuccess, onBack, callbackUrl }: { onSwitchToSignIn: () => void, onAuthSuccess: () => void, onBack: () => void, callbackUrl: string }) => {
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);
    const router = useRouter();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSignUp = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setMessage(null);
        const formData = new FormData(event.currentTarget);
        startTransition(async () => {
            const result = await signIn('signup', { redirect: false, ...Object.fromEntries(formData) });
            if (result?.error) setMessage({ type: 'error', text: result.error });
            else if (result?.url) { router.push(result.url); onAuthSuccess(); } 
            else setMessage({ type: 'error', text: 'طرأ خطبٌ ما.' });
        });
    };
    
    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>إنشاء حساب</h2></div>
             <form onSubmit={handleSignUp} className={styles.credentialsForm}>
                <input type="hidden" name="returnTo" value={callbackUrl} />
                <div className={styles.authFormGroup}>
                    <input id="signup-email" type="email" name="email" required value={email} onChange={e => setEmail(e.target.value)} className={styles.authInput} placeholder=" " />
                    <label htmlFor="signup-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <div className={styles.authFormGroup}>
                    <input id="signup-password" type="password" name="password" required value={password} onChange={e => setPassword(e.target.value)} className={styles.authInput} placeholder=" " />
                    <label htmlFor="signup-password" className={styles.authFormLabel}>كلمة السر (8 حروف على الأقل)</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>أنشئ حسابًا</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${styles.error}`}>{message.text}</p>}
            <p className={styles.authViewSwitcher}>لديك حساب؟ <button type="button" onClick={() => {onSwitchToSignIn(); setMessage(null);}} className={styles.linkButton}>تسجيل الدخول</button></p>
        </motion.div>
    );
};

const ForgotPasswordForm = ({ onBack }: { onBack: () => void }) => {
    const [email, setEmail] = useState('');
    const [isPending, startTransition] = useTransition();
    const [message, setMessage] = useState<{ type: 'error' | 'success'; text: string } | null>(null);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        setMessage(null);
        startTransition(async () => {
            const result = await requestPasswordReset(email);
            setMessage({type: result.success ? 'success' : 'error', text: result.message});
        });
    };

    return (
        <motion.div className={styles.authCredentialsContent} variants={formContentVariants} initial="hidden" animate="visible" exit="hidden">
            <button onClick={onBack} className={styles.authBackButton}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" style={{transform: 'scaleX(-1)'}}><path fillRule="evenodd" d="M12.79 5.23a.75.75 0 01-.02 1.06L8.832 10l3.938 3.71a.75.75 0 11-1.04 1.08l-4.5-4.25a.75.75 0 010-1.08l4.5-4.25a.75.75 0 011.06.02z" clipRule="evenodd" /></svg></button>
            <div className={styles.formHeader}><h2 className={styles.formTitle}>إعادة تعيين كلمة السر</h2><p style={{color: 'var(--text-secondary)', fontSize: '1.5rem'}}>أدخل بريدك ليصلك رابط التعيين.</p></div>
            <form onSubmit={handleSubmit} className={styles.credentialsForm}>
                <div className={styles.authFormGroup}>
                    <input id="reset-email" type="email" name="email" required className={styles.authInput} value={email} onChange={(e) => setEmail(e.target.value)} placeholder=" " />
                    <label htmlFor="reset-email" className={styles.authFormLabel}>البريد</label>
                </div>
                <motion.button type="submit" className={styles.authSubmitButton} disabled={isPending} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', overflow: 'hidden' }} animate={{ width: isPending ? '48px' : '100%', height: '48px', borderRadius: isPending ? '50%' : '8px' }} transition={{ type: 'spring', stiffness: 400, damping: 25 }}>
                    <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{opacity:0}} animate={{opacity:1}} exit={{opacity:0}}>إرسال الرابط</motion.span>}</AnimatePresence>
                </motion.button>
            </form>
            {message && <p className={`${styles.authMessage} ${message.type === 'error' ? styles.error : styles.success}`}>{message.text}</p>}
        </motion.div>
    );
};

// --- END: Refactored Form Components ---

const authProviders = [
    { id: 'github', Icon: GitHubIcon, label: 'GitHub' },
    { id: 'google', Icon: GoogleIcon, label: 'Google' },
    { id: 'twitter', Icon: XIcon, label: 'X/Twitter' },
];

export default function SignInModal() {
    const { isSignInModalOpen, setSignInModalOpen } = useUserStore();
    const [view, setView] = useState<'orbs' | 'signin' | 'signup' | 'forgotPassword'>('orbs');
    const [isMounted, setIsMounted] = useState(false);
    const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
    const pathname = usePathname();

    useEffect(() => { setIsMounted(true); }, []);

    const handleClose = () => {
        if (loadingProvider) return;
        setSignInModalOpen(false);
        setTimeout(() => { setView('orbs'); setLoadingProvider(null); }, 350);
    };

    const handleProviderSignIn = (provider: string) => {
        setLoadingProvider(provider);
        signIn(provider, { callbackUrl: pathname });
    };

    const modalContent = (
        <AnimatePresence>
            {isSignInModalOpen && (
                <motion.div className={modalStyles.modalOverlay} onClick={handleClose} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                    <motion.div className={styles.authModalPanelContainer} onClick={(e) => e.stopPropagation()} initial="hidden" animate="visible" >
                        <div className={styles.authSatelliteContainer}>
                            <div className={styles.authOrbRowTop}>
                                <AnimatePresence>
                                    {view === 'orbs' && authProviders.map((provider, i) => {
                                        const direction = i - 1;
                                        return (
                                            <motion.div key={provider.id} custom={direction} variants={satelliteVariants} initial="hidden" animate="visible" exit="hidden">
                                                <AuthOrb Icon={provider.Icon} onClick={() => handleProviderSignIn(provider.id)} ariaLabel={`الدخول عبر ${provider.label}`} isLoading={loadingProvider === provider.id} isDisabled={!!loadingProvider} />
                                            </motion.div>
                                        );
                                    })}
                                </AnimatePresence>
                            </div>
                            <AnimatePresence>
                                {view === 'orbs' && (
                                    <motion.p className={styles.authFooterText} initial={{ opacity: 0 }} animate={{ opacity: 1, transition: { delay: 0.2 } }} exit={{ opacity: 0, transition: { duration: 0.2 } }}>
                                        انضم إلى EternalGames عبر مزود خدمة أو تابع بالبريد.
                                    </motion.p>
                                )}
                            </AnimatePresence>
                        </div>
                        
                        <div className={styles.authMorphWrapper} style={{ zIndex: 10 }}>
                            <AnimatePresence mode="popLayout" initial={false}>
                                {view === 'orbs' && (
                                    <motion.div key="orbs" layoutId="auth-panel" style={{ zIndex: loadingProvider ? 0 : 'auto' }}>
                                        <AuthOrb Icon={EternalGamesIcon} onClick={() => setView('signin')} ariaLabel="الدخول بالبريد" isLarge isDisabled={!!loadingProvider} />
                                    </motion.div>
                                )}
                                {view === 'signin' && (
                                    <motion.div key="signin" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <SignInForm onSwitchToSignUp={() => setView('signup')} onForgotPassword={() => setView('forgotPassword')} onAuthSuccess={handleClose} onBack={() => setView('orbs')} callbackUrl={pathname} />
                                    </motion.div>
                                )}
                                {view === 'signup' && (
                                    <motion.div key="signup" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <SignUpForm onSwitchToSignIn={() => setView('signin')} onAuthSuccess={handleClose} onBack={() => setView('orbs')} callbackUrl={pathname} />
                                    </motion.div>
                                )}
                                {view === 'forgotPassword' && (
                                    <motion.div key="forgot-password" layoutId="auth-panel" className={styles.authCredentialsPanel}>
                                        <ForgotPasswordForm onBack={() => setView('signin')} />
                                    </motion.div>
                                )}
                            </AnimatePresence>
                        </div>
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) return null;
    return createPortal(modalContent, document.body);
}




--- END OF FILE components/SignInModal.tsx ---

================================================================================

--- START OF FILE components/StudioBar.module.css ---

/* components/StudioBar.module.css */

.studioBar {
  position: fixed;
  bottom: 2rem;
  right: 0;
  left: 0;
  width: max-content;
  margin-right: auto;
  margin-left: auto;
  /* FIX: Increased z-index to 2055 to sit above Kinetic Overlay (2050) but below Navbar (2060) */
  z-index: 2055;
  background-color: color-mix(in srgb, var(--bg-secondary) 85%, transparent);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 20%, transparent);
  backdrop-filter: blur(10px);
  padding: 0.5rem;
}

:global(body.no-glass) .studioBar {
  backdrop-filter: none !important;
  background-color: var(--bg-secondary) !important;
}

/* Mobile Opt: Kill Blur */
@media (max-width: 768px) {
    .studioBar {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(10, 11, 15, 0.95);
    }
}

.studioBarContent {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.studioBarButton {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1.25rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.5rem;
  color: var(--text-primary);
  background-color: transparent;
  border: none;
  cursor: pointer;
  transition: background-color 0.2s ease-out, color 0.2s ease-out;
}
@media (hover: hover) {
  .studioBarButton:hover  {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
  }
  .studioBarButton:active  {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
  }
}
.studioBarButton:active {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}


.brand {
  color: var(--accent);
}
@media (hover: hover) {
  .brand:hover  {
    color: var(--accent); 
  }
  .brand:active  {
    color: var(--accent); 
  }
}
.brand:active {
  color: var(--accent); 
}

/* NEW: Divider & Close Button */
.divider {
  width: 1px;
  height: 20px;
  background-color: var(--border-color);
  margin: 0 0.2rem;
  opacity: 0.6;
}

.closeButton {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: none;
  background-color: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.2s ease;
}

@media (hover: hover) {
  .closeButton:hover {
      background-color: rgba(220, 38, 38, 0.15);
      color: #DC2626;
  }
}

.closeButton:active {
  background-color: rgba(220, 38, 38, 0.15);
  color: #DC2626;
  transform: scale(0.9);
}

--- END OF FILE components/StudioBar.module.css ---

================================================================================

--- START OF FILE components/StudioBar.tsx ---

// components/StudioBar.tsx
'use client';

import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { StudioIcon } from '@/components/icons/index';
import { useState } from 'react';
import styles from './StudioBar.module.css';
import { useContentStore } from '@/lib/contentStore'; // IMPORTED

const EditIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /> <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /> </svg> );
const CloseIcon = () => ( <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"> <line x1="18" y1="6" x2="6" y2="18"></line> <line x1="6" y1="6" x2="18" y2="18"></line> </svg> );

export default function StudioBar() {
    const { data: session } = useSession();
    const pathname = usePathname();
    const [isVisible, setIsVisible] = useState(true);
    
    // IMPORTED: Force close overlay on click
    const { forceCloseOverlay } = useContentStore();

    const userRoles = (session?.user as any)?.roles || [];
    const isCreatorOrAdmin = userRoles.some((role: string) => ['DIRECTOR', 'ADMIN', 'REVIEWER', 'AUTHOR', 'REPORTER', 'DESIGNER'].includes(role));
    
    // Check if on studio page
    const isStudioPage = pathname.startsWith('/studio');
    
    // Determine if we should render anything
    const shouldRender = isCreatorOrAdmin && !isStudioPage && isVisible;

    let editPath = null;
    // (Logic for determining edit path could be added here if needed, currently unused in provided code)

    return (
        <AnimatePresence>
            {shouldRender && (
                <motion.div
                    className={styles.studioBar}
                    initial={{ y: '100%', opacity: 0 }}
                    animate={{ y: '0%', opacity: 1 }}
                    exit={{ y: '100%', opacity: 0 }}
                    transition={{ type: 'spring' as const, stiffness: 300, damping: 30 }}
                >
                    <div className={styles.studioBarContent}>
                        <Link 
                            href="/studio" 
                            className={`${styles.studioBarButton} ${styles.brand}`} 
                            prefetch={false}
                            onClick={() => forceCloseOverlay()} // ADDED: Close overlay on click
                        >
                            <StudioIcon height={20} width={20} />
                            <span>الديوان</span>
                        </Link>

                        {editPath && (
                            <Link href={editPath} className={styles.studioBarButton} prefetch={false}>
                                <EditIcon />
                                <span>تعديل الصفحة</span>
                            </Link>
                        )}
                        
                        <div className={styles.divider} />
                        
                        <button 
                            onClick={() => setIsVisible(false)} 
                            className={styles.closeButton} 
                            aria-label="Close Studio Bar"
                            title="إخفاء حتى التحديث"
                        >
                            <CloseIcon />
                        </button>
                    </div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE components/StudioBar.tsx ---

================================================================================

--- START OF FILE components/TagLinks.module.css ---

/* components/TagLinks.module.css */

.tagLinksContainer {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

.tagLinksContainer.small {
    margin-top: auto;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}
  
.tagLink {
    display: inline-block; /* motion.div wrapper handles block display */
    background-color: color-mix(in srgb,var(--accent) 15%,transparent);
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    font-family: var(--font-ui), sans-serif;
    font-size: 1.4rem;
    font-weight: 500;
    transition: background-color 0.2s ease, color 0.2s ease, transform 0.2s ease-out, box-shadow 0.2s ease-out;
    cursor: pointer;
}
@media (hover: hover) {@media (hover: hover) {
  
  .tagLink:hover  {
    background-color: var(--accent);
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px -3px color-mix(in srgb, var(--accent) 40%, transparent), 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}
}

  .tagLink:active  {
    background-color: var(--accent);
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px -3px color-mix(in srgb, var(--accent) 40%, transparent), 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}
}
.tagLink:active {
    background-color: var(--accent);
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px -3px color-mix(in srgb, var(--accent) 40%, transparent), 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}

@media (hover: hover) {@media (hover: hover) {
  
  [data-theme="dark"] .tagLink:hover  {
    color: var(--bg-primary);
}
}

  [data-theme="dark"] .tagLink:active  {
    color: var(--bg-primary);
}
}
[data-theme="dark"] .tagLink:active {
    color: var(--bg-primary);
}













/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .tagLink {
  background-color: rgba(0, 255, 240, 0.1);
  color: #008F86; /* Darker Cyan for better contrast on white */
  border: 1px solid rgba(0, 255, 240, 0.3);
  box-shadow: none;
}
:global([data-theme="light"]) .tagLink:hover {
  background-color: var(--accent);
  color: #fff;
  box-shadow: 0 4px 12px rgba(0, 255, 240, 0.3);
}


--- END OF FILE components/TagLinks.module.css ---

================================================================================

--- START OF FILE components/TagLinks.tsx ---

// components/TagLinks.tsx
'use client';

import { translateTag } from '@/lib/translations';
import styles from './TagLinks.module.css';
import KineticLink from '@/components/kinetic/KineticLink';

export default function TagLinks({ tags, small = false }: { tags: string[], small?: boolean }) {

  if (!tags || tags.length === 0) return null;

  return (
    <div className={`${styles.tagLinksContainer} ${small ? styles.small : ''}`}>
      {tags.map((tag) => {
        const slug = tag.toLowerCase().replace(/ /g, '-');
        return (
            <KineticLink 
                key={tag} 
                href={`/tags/${slug}`}
                slug={slug}
                type="tags" // ENABLED
                className={`${styles.tagLink} no-underline`}
                onClick={(e) => e.stopPropagation()} 
            >
                {translateTag(tag)}
            </KineticLink>
        );
      })}
    </div>
  );
}

--- END OF FILE components/TagLinks.tsx ---

================================================================================

--- START OF FILE components/TerminalTicker.tsx ---

// components/TerminalTicker.tsx
'use client';

import { useState, useEffect } from 'react';
import type { SanityNews } from '@/types/sanity';
import Link from 'next/link';
import { motion, AnimatePresence } from 'framer-motion';
import styles from '../app/news/NewsPage.module.css';
import { useContentStore } from '@/lib/contentStore'; // IMPORTED

const ScrambledText = ({ text }: { text: string }) => {
  const [displayText, setDisplayText] = useState('');
  const chars = '!<>-_\\/[]{}—=+*^?#________';

  useEffect(() => {
    let frame = 0;
    const frameRate = 2;
    const scrambleDuration = 30;

    const intervalId = setInterval(() => {
      let newText = '';
      let isComplete = true;

      for (let i = 0; i < text.length; i++) {
        const progress = (frame - i * frameRate) / scrambleDuration;
        if (progress < 1 && progress > 0) {
          const randomChar = chars[Math.floor(Math.random() * chars.length)];
          newText += randomChar;
          isComplete = false;
        } else {
          newText += text[i];
        }
      }

      setDisplayText(newText);
      frame++;

      if (isComplete) {
        clearInterval(intervalId);
      }
    }, 40);

    return () => clearInterval(intervalId);
  }, [text]);

  return <>{displayText}</>;
};

export default function TerminalTicker({ headlines }: { headlines: SanityNews[] }) {
  const [index, setIndex] = useState(0);
  const isOverlayOpen = useContentStore((s) => s.isOverlayOpen); // MODIFIED

  useEffect(() => {
    if (isOverlayOpen) return; // MODIFIED: Stop ticker if overlay is open
    const timer = setInterval(() => {
      setIndex((prevIndex) => (prevIndex + 1) % headlines.length);
    }, 6000);
    return () => clearInterval(timer);
  }, [headlines.length, isOverlayOpen]);

  return (
    <div className={styles.terminalTickerContainer}>
      <h3 className={styles.terminalTickerTitle}>
        <motion.span
          animate={{ opacity: [0.5, 1, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity }}
          style={{ display: 'inline-block', width: '8px', height: '8px', borderRadius: '50%', backgroundColor: '#ff4d4d', marginRight: '1rem' }}
        />
        LIVE FEED
      </h3>
      <div className={styles.terminalTickerContent}>
        <AnimatePresence mode="wait">
          <motion.div
            key={index}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Link 
                href={`/news/${headlines[index].slug}`} 
                className="no-underline"
                prefetch={false}
            >
              <p className={styles.terminalTickerCategory}>{headlines[index].category}</p>
              <h4 className={styles.terminalTickerHeadline}>
                <ScrambledText text={headlines[index].title} />
              </h4>
            </Link>
          </motion.div>
        </AnimatePresence>
      </div>
    </div>
  );
}

--- END OF FILE components/TerminalTicker.tsx ---

================================================================================

--- START OF FILE components/ThemeProvider.tsx ---

'use client';

import * as React from 'react';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
// CORRECTED: The 'ThemeProviderProps' type is now imported directly from the main package.
// The old '/dist/types' path no longer exists in the newer version of the library.
import { type ThemeProviderProps } from 'next-themes';

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



































--- END OF FILE components/ThemeProvider.tsx ---

================================================================================

--- START OF FILE components/ThemeToggle.module.css ---

/* components/ThemeToggle.module.css */

.themeToggleButton {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    transition: color 0.3s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .themeToggleButton:hover  {
    color: var(--accent);
}
}

  .themeToggleButton:active  {
    color: var(--accent);
}
}
.themeToggleButton:active {
    color: var(--accent);
}














--- END OF FILE components/ThemeToggle.module.css ---

================================================================================

--- START OF FILE components/ThemeToggle.tsx ---

// components/ThemeToggle.tsx
'use client';

import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './ThemeToggle.module.css'; // <-- IMPORTED MODULE

const SunIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
const MoonIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>;

export const ThemeToggle = () => {
    const [mounted, setMounted] = useState(false);
    const { theme, setTheme } = useTheme();
    useEffect(() => { setMounted(true); }, []);

    if (!mounted) { return <div style={{ width: '24px', height: '24px' }} />; }

    const isDark = theme === 'dark';

    return (
        <motion.button
            className={styles.themeToggleButton} // <-- UPDATED CLASS
            onClick={() => setTheme(isDark ? 'light' : 'dark')}
            aria-label={isDark ? 'تفعيل الوضع النهاري' : 'تفعيل الوضع الليلي'}
            title={isDark ? 'تفعيل الوضع النهاري' : 'تفعيل الوضع الليلي'}
            whileHover={{ scale: 1.2, rotate: 90 }}
            whileTap={{ scale: 0.9, rotate: -90 }}
            transition={{ type: "spring", stiffness: 400, damping: 15 }}
        >
            <AnimatePresence mode="wait" initial={false}>
                <motion.div
                    key={isDark ? "moon" : "sun"}
                    initial={{ y: -20, opacity: 0, rotate: -90 }}
                    animate={{ y: 0, opacity: 1, rotate: 0 }}
                    exit={{ y: 20, opacity: 0, rotate: 90 }}
                    transition={{ duration: 0.3, ease: 'easeInOut' }}
                >
                    {isDark ? <SunIcon /> : <MoonIcon />}
                </motion.div>
            </AnimatePresence>
        </motion.button>
    );
};













--- END OF FILE components/ThemeToggle.tsx ---

================================================================================

--- START OF FILE components/TimelineCard.module.css ---

/* components/TimelineCard.module.css */

.livingCardWrapper {
    transform-style: preserve-3d;
    height: 100%;
    position: relative;
    z-index: 1;
    perspective: 1000px;
    -webkit-tap-highlight-color: transparent;

    /* OPTIMIZATION: Isolate layout calculations */
    contain: layout style;
}

.livingCardWrapper.activeState {
    z-index: 100;
}

@media (hover: hover) {
    .livingCardWrapper:hover {
        z-index: 100;
    }
}

.timelineCard {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    background-color: var(--bg-secondary);
    border-radius: 16px;
    overflow: visible; 
    border: 1px solid var(--border-color);
    
    /* OPTIMIZATION: Removed box-shadow transition */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
                border-color 0.4s ease;
                
    /* GPU FIX: Removed persistent will-change: transform */
    transform-style: preserve-3d;
    position: relative;
    
    /* Base Shadow (Static) */
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5);

    /* Config vars */
    --tl-card-padding: 1.5rem;
    --tl-title-size: 2rem;
    --tl-date-size: 1.4rem;
    --tl-icon-size: 18px;
    --tl-cal-icon-size: 14px;
    --tl-badge-font: 1.2rem;
    --tl-badge-pad: 0;
    --tl-badge-height: 32px;
    --tl-badge-width: 32px;
    --tl-btn-size: 32px;
    --tl-btn-icon-size: 16px;
    --tl-play-btn-font: 1.3rem;
    --tl-play-btn-pad: 0.6rem 1.4rem;
    --tl-pill-font: 1.2rem;
    --tl-pill-pad: 0.5rem 1.2rem;
    --tl-meta-gap: 1rem;
    --tl-meta-direction: row;
    --tl-meta-align: center;
}

/* GPU FIX: Apply will-change only on interaction */
.livingCardWrapper:hover .timelineCard,
.livingCardWrapper.activeState .timelineCard {
    will-change: transform;
}

.timelineCard.autoHeight {
    height: auto;
}

/* OPTIMIZATION: Active Shadow on Pseudo-element */
.timelineCard::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 16px;
    /* The Heavy Active Shadow */
    box-shadow: 
        0 25px 60px -12px rgba(0,0,0,0.7),
        0 0 0 1px color-mix(in srgb, var(--accent) 40%, transparent);
    opacity: 0;
    transition: opacity 0.4s ease; /* GPU Only */
    z-index: -1;
    pointer-events: none;
}

.timelineCard::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    width: 40px;
    height: 40px;
    border-top: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-left: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-radius: 16px 0 0 0;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    z-index: 20;
    pointer-events: none;
}

/* PERFORMANCE OVERRIDE: Disable Corner Animation */
:global(.noCornerAnimation) .timelineCard::before {
    content: none !important;
    display: none !important;
    border: none !important;
    opacity: 0 !important;
    width: 0 !important;
    height: 0 !important;
}

/* Active State */
.livingCardWrapper.activeState .timelineCard {
    transform: translateZ(20px) translateY(-5px);
    border-color: var(--accent);
}
.livingCardWrapper.activeState .timelineCard::after {
    opacity: 1; /* Fade in shadow */
}

.livingCardWrapper.activeState .timelineCard::before {
    width: 100%;
    height: 100%;
    border-radius: 16px;
    border-color: var(--accent);
    box-shadow: inset 0 0 20px color-mix(in srgb, var(--accent) 10%, transparent);
}
.livingCardWrapper.activeState .cardImage {
    transform: scale(1.08);
}
.livingCardWrapper.activeState .glare {
    opacity: 1;
}

@media (hover: hover) {
    .livingCardWrapper:hover .timelineCard {
        transform: translateZ(20px) translateY(-5px);
        border-color: var(--accent);
    }
    .livingCardWrapper:hover .timelineCard::after {
        opacity: 1;
    }

    .livingCardWrapper:hover .timelineCard::before {
        width: 100%;
        height: 100%;
        border-radius: 16px;
        border-color: var(--accent);
        box-shadow: inset 0 0 20px color-mix(in srgb, var(--accent) 10%, transparent);
    }
    .livingCardWrapper:hover .cardImage {
        transform: scale(1.08);
    }
    .livingCardWrapper:hover .glare {
        opacity: 1;
    }
}

/* --- CONTROLS --- */
.controlBtn {
    width: var(--tl-btn-size);
    height: var(--tl-btn-size);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}
.controlBtn svg {
    width: var(--tl-btn-icon-size);
    height: var(--tl-btn-icon-size);
}

.wishlistButton {
    composes: controlBtn;
}

.videoCloseButton {
    composes: controlBtn;
    position: absolute;
    top: 1rem;
    right: 1rem;
    background-color: rgba(0,0,0,0.6);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.3);
    z-index: 60;
    pointer-events: auto;
}
.videoCloseButton:hover {
    background-color: var(--accent);
    color: #000;
    border-color: var(--accent);
}

.playButtonContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.8rem;
    
    padding: var(--tl-play-btn-pad);
    font-size: var(--tl-play-btn-font);
    font-family: var(--font-ui);
    font-weight: 700;
    border-radius: 999px;
    
    background: rgba(10, 10, 15, 0.95);
    backdrop-filter: blur(4px);
    border: 1.5px solid var(--accent);
    color: var(--accent);
    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
    
    cursor: pointer;
    z-index: 200;
    pointer-events: auto; 
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}
@media (hover: hover) {
    .playButtonContainer:hover {
        background-color: var(--accent);
        color: #000000;
        box-shadow: 
            0 0 20px color-mix(in srgb, var(--accent) 60%, transparent),
            0 0 40px color-mix(in srgb, var(--accent) 30%, transparent);
    }
}
.playButtonContainer:active {
    box-shadow: 0 0 10px color-mix(in srgb, var(--accent) 40%, transparent);
}

/* --- IMAGE AREA --- */
.imageFrame {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9;
    overflow: hidden;
    border-top-left-radius: 15px;
    border-top-right-radius: 15px;
    border-bottom: 1px solid var(--border-color);
    transform: translateZ(0);
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1);
}

.glare {
    position: absolute;
    inset: 0;
    background: radial-gradient(
        circle at var(--mouse-x) var(--mouse-y),
        rgba(255, 255, 255, 0.15),
        transparent 40%
    );
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
    z-index: 10;
    mix-blend-mode: overlay;
}

/* --- STATUS BADGE (ICON ONLY) --- */
.statusBadge {
    position: absolute;
    top: 1rem;
    right: 1rem;
    left: auto; 
    display: flex;
    align-items: center;
    justify-content: center;
    
    width: var(--tl-badge-width);
    height: var(--tl-badge-height);
    padding: 0; /* Icon only */
    
    border-radius: 50%;
    font-family: var(--font-ui);
    font-weight: 700;
    backdrop-filter: blur(8px);
    z-index: 20;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    transform: translateZ(20px);
}

.statusBadge.released {
    background-color: var(--accent);
    color: #000;
    border: 1px solid var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}

.statusBadge.upcoming {
    background-color: rgba(0, 0, 0, 0.6);
    color: var(--accent);
    border: 1px solid var(--accent);
}

.statusBadge svg {
    width: 16px;
    height: 16px;
}

.iconSvg {
    width: var(--tl-cal-icon-size);
    height: var(--tl-cal-icon-size);
}

.cardBody {
    padding: var(--tl-card-padding);
    background: linear-gradient(180deg, var(--bg-secondary) 0%, color-mix(in srgb, var(--bg-secondary) 95%, black) 100%);
    border-bottom-left-radius: 16px;
    border-bottom-right-radius: 16px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    transform: translateZ(10px);
    flex-grow: 1; 
}

.titleRow {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
}

.cardTitle {
    font-family: var(--font-heading);
    font-size: var(--tl-title-size);
    font-weight: 800;
    line-height: 1.2;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.3s ease;
}

.livingCardWrapper.activeState .cardTitle { color: var(--accent); }
@media (hover: hover) { .livingCardWrapper:hover .cardTitle { color: var(--accent); } }

.metaGrid {
    display: flex;
    justify-content: space-between;
    flex-direction: var(--tl-meta-direction);
    align-items: var(--tl-meta-align);
    gap: var(--tl-meta-gap);
    
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.dateBlock {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    color: var(--text-secondary);
    font-family: var(--font-ui);
    font-weight: 600;
    font-size: var(--tl-date-size);
}
.dateIconWrapper {
    width: var(--tl-cal-icon-size);
    height: var(--tl-cal-icon-size);
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
}

.platformRow {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    min-height: 24px; 
}

.platformTagBase {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    border-radius: 999px;
    font-family: var(--font-ui);
    font-weight: 700;
    white-space: nowrap;
    padding: 0;
    background-color: transparent;
    border: 1px solid transparent;
    color: var(--text-secondary);
    pointer-events: none; 
    
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    transform: translateZ(0); 
    backface-visibility: hidden;
}

.platformTagBase.flying {
    pointer-events: auto;
    cursor: default;
}

.platformIcon {
    width: var(--tl-icon-size);
    height: var(--tl-icon-size);
}

.satelliteField { position: absolute; inset: -50px; pointer-events: none; z-index: 50; overflow: visible; transform-style: preserve-3d; }
.satelliteShard { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) translateZ(0px); pointer-events: auto; z-index: 100; }
.flyingTagsContainer { position: absolute; inset: -100px; pointer-events: none; z-index: 100; transform-style: preserve-3d; overflow: visible; }

.shardPill {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: var(--tl-pill-pad);
    font-size: var(--tl-pill-font);
    font-family: var(--font-ui);
    font-weight: 700;
    background-color: rgba(10, 10, 15, 0.9);
    border: 1px solid var(--accent);
    border-radius: 999px;
    color: var(--accent);
    white-space: nowrap;
    width: max-content;
    max-width: 240px; 
    text-overflow: ellipsis;
    overflow: hidden;
    text-decoration: none;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    cursor: pointer;
    pointer-events: auto; 
    transform: translateZ(0);
    backface-visibility: hidden;
}

.shardPill.static { cursor: default; }

.statusPill.golden { border-color: #FFD700; color: #FFD700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
.statusPill.red { border-color: #DC2626; color: #DC2626; box-shadow: 0 0 15px rgba(220, 38, 38, 0.2); }
.statusPill.orange { border-color: #F97316; color: #F97316; box-shadow: 0 0 15px rgba(249, 115, 22, 0.2); }
.statusPill.cyan { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent); }
.pricePill { border-color: #FFD700; color: #FFD700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.2); }
.devPill { border-color: var(--accent); color: var(--accent); background-color: rgba(0, 0, 0, 0.85); }

.genrePill {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    border-radius: 999px;
    font-family: var(--font-ui);
    font-weight: 700;
    padding: var(--tl-pill-pad);
    font-size: var(--tl-pill-font);
    background-color: rgba(0, 0, 0, 0.85);
    border: 1px solid var(--accent);
    color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
    white-space: nowrap;
    width: max-content;
    max-width: 200px;
    text-overflow: ellipsis;
    overflow: hidden;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    pointer-events: auto; 
    transform: translateZ(0);
    backface-visibility: hidden;
}

/* FIX: Mobile Active States */
.genrePill:active, .shardPill.interactive:active {
    transform: scale(0.95);
    background-color: var(--accent);
    color: #000;
    box-shadow: 0 0 10px color-mix(in srgb, var(--accent) 40%, transparent);
}

@media (hover: hover) {
    .genrePill:hover, .shardPill.interactive:hover {
        background-color: var(--accent);
        color: #000;
        border-color: var(--accent);
        transform: scale(1.15) translateY(-4px);
        box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent), 0 0 40px color-mix(in srgb, var(--accent) 30%, transparent);
        z-index: 200;
    }
}


/* --- VIDEO OVERLAY (HOMEPAGE) --- */
.videoOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(10px);
    z-index: 10000;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 2rem;
}

.videoModal {
    position: relative;
    width: 100%;
    max-width: 1100px;
    aspect-ratio: 16 / 9;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 0 50px rgba(0, 229, 255, 0.2);
    border: 1px solid var(--border-color);
}

.modalCloseButton {
    position: absolute;
    top: -50px;
    right: 0;
    background: none;
    border: none;
    color: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1.4rem;
}
.modalCloseButton svg {
    width: 32px;
    height: 32px;
}

/* --- MOBILE --- */
@media (max-width: 768px) {
    .timelineCard {
        --tl-card-padding: 1.5rem;
        --tl-title-size: 1.8rem;
        --tl-date-size: 1.3rem;
        --tl-icon-size: 16px;
        --tl-cal-icon-size: 13px;
        --tl-badge-height: 36px;
        --tl-badge-width: 36px;
        --tl-pill-font: 1.2rem;
        --tl-pill-pad: 0.4rem 1rem;
        --tl-btn-size: 36px;
        --tl-btn-icon-size: 18px;
        --tl-play-btn-font: 1.2rem;
        --tl-play-btn-pad: 0.5rem 1.2rem;
        --tl-meta-direction: row;
        --tl-meta-align: center;
        --tl-meta-gap: 1rem;
    }
    
    /* HOMEPAGE VARIANT - MOBILE ONLY */
    .timelineCard.homepage {
        --tl-card-padding: 1rem;
        --tl-title-size: 1.4rem;
        --tl-date-size: 1.1rem;
        --tl-icon-size: 14px;
        --tl-cal-icon-size: 11px;
        --tl-badge-height: 28px;
        --tl-badge-width: 28px;
        --tl-pill-font: 1rem;
        --tl-pill-pad: 0.3rem 0.7rem;
        --tl-btn-size: 28px;
        --tl-btn-icon-size: 14px;
        --tl-play-btn-font: 1rem;
        --tl-play-btn-pad: 0.3rem 0.8rem;
        --tl-meta-direction: column;
        --tl-meta-align: flex-start;
        --tl-meta-gap: 0.3rem;
    }
    
    /* MOBILE OPTIMIZATION: Kill Blur */
    .statusBadge { 
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(20, 20, 25, 0.95); 
    }
    .shardPill, .genrePill, .playButtonContainer { 
        backdrop-filter: none !important; 
        -webkit-backdrop-filter: none !important;
        background: #000; 
    }
}
/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .cardBody {
  background: linear-gradient(180deg, var(--bg-secondary) 0%, #f3f4f6 100%);
}
:global([data-theme="light"]) .statusBadge.upcoming {
  background-color: rgba(255, 255, 255, 0.85);
  border-color: rgba(0,0,0,0.1);
}
:global([data-theme="light"]) .creditCapsule {
  background: rgba(255, 255, 255, 0.85);
  border-color: rgba(0,0,0,0.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .creditCapsule :global(span) {
  color: var(--text-primary);
}
:global([data-theme="light"]) .capsuleIcon {
  color: #fff;
}
:global([data-theme="light"]) .shardPill,
:global([data-theme="light"]) .genrePill,
:global([data-theme="light"]) .playButtonContainer {
  background-color: rgba(255, 255, 255, 0.95);
  color: var(--text-primary);
  border-color: var(--accent);
  box-shadow: 0 5px 15px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .shardPill {
  color: var(--accent);
}
:global([data-theme="light"]) .genrePill {
  color: var(--accent);
}
/* Ensure dark text on golden status pills for readability */
:global([data-theme="light"]) .statusPill.golden { color: #854D0E; border-color: #EAB308; }
:global([data-theme="light"]) .devPill {
  background-color: rgba(255, 255, 255, 0.95);
  color: var(--accent);
}
:global([data-theme="light"]) .techDot {
  background-color: rgba(0,0,0,0.2);
}

/* --- Light Mode Fixes (No Black) --- */
/* Credits in Timeline */
:global([data-theme="light"]) .creditCapsule {
    background-color: rgba(255, 255, 255, 0.9) !important;
    border-color: rgba(0, 0, 0, 0.1);
}
:global([data-theme="light"]) .creditCapsule :global(span) {
    color: var(--text-primary);
}
:global([data-theme="light"]) .capsuleIcon {
    background-color: var(--accent);
    color: #fff;
}
/* Hover Logic for Timeline Credits */
:global([data-theme="light"]) .capsuleWrapper:hover .creditCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}
:global([data-theme="light"]) .capsuleWrapper:hover .creditCapsule :global(span) {
    color: #fff !important;
}
:global([data-theme="light"]) .capsuleWrapper:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

/* Flying Tags (Platforms, Genres, Status) */
:global([data-theme="light"]) .platformTagBase.flying,
:global([data-theme="light"]) .genrePill,
:global([data-theme="light"]) .shardPill,
:global([data-theme="light"]) .devPill {
    background-color: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid var(--accent);
    color: var(--text-primary) !important;
    box-shadow: 0 5px 20px rgba(0,0,0,0.05);
}

/* Hover States for Flying Tags */
:global([data-theme="light"]) .genrePill:hover,
:global([data-theme="light"]) .shardPill.interactive:hover {
    background-color: var(--accent) !important;
    color: #fff !important;
    border-color: var(--accent) !important;
}

/* Ensure Price Pill text is visible */
:global([data-theme="light"]) .pricePill {
    color: #F59E0B !important; /* Gold text */
    border-color: #F59E0B !important;
    background-color: rgba(255,255,255,0.95) !important;
}

/* --- Light Mode Overrides (No Black) --- */

/* Status Badge (Released/Upcoming Circle) */
:global([data-theme="light"]) .statusBadge {
    background-color: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
:global([data-theme="light"]) .statusBadge.released {
    color: var(--accent);
    border-color: var(--accent);
}
:global([data-theme="light"]) .statusBadge.upcoming {
    color: var(--text-secondary);
}

/* Wishlist Button */
:global([data-theme="light"]) .wishlistButton {
    background-color: rgba(255, 255, 255, 0.9) !important;
    border-color: var(--accent);
    color: var(--accent) !important;
    box-shadow: 0 4px 12px rgba(0,0,0,0.05) !important;
}
:global([data-theme="light"]) .wishlistButton:hover {
    background-color: var(--accent) !important;
    color: #fff !important;
    transform: scale(1.1);
}

/* Play Button (Video Overlay Trigger) */
:global([data-theme="light"]) .playButtonContainer {
    background-color: rgba(255, 255, 255, 0.95) !important;
    border-color: var(--accent);
    color: var(--text-primary);
}
:global([data-theme="light"]) .playButtonContainer:hover {
    background-color: var(--accent) !important;
    color: #fff !important;
}

/* --- SPECIAL FIX: Light Mode + No-Glass for Flying Tags --- */
:global([data-theme="light"] body.no-glass) .satelliteShardLink:hover,
:global([data-theme="light"] body.no-glass) .genrePill:hover,
:global([data-theme="light"] body.no-glass) .shardPill.interactive:hover {
    background-color: #ffffff !important; /* Keep White BG */
    color: var(--accent) !important;      /* Turn Text Cyan */
    border-color: var(--accent) !important;
}

--- END OF FILE components/TimelineCard.module.css ---

================================================================================

--- START OF FILE components/TimelineCard.tsx ---

// components/TimelineCard.tsx
'use client';

import React, { memo, useState, useMemo, useRef, useEffect } from 'react';
import Image from 'next/image';
import { createPortal } from 'react-dom';
import type { SanityGameRelease } from '@/types/sanity';
import { motion, AnimatePresence, useMotionValue, useTransform, useSpring, Transition } from 'framer-motion';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { sanityLoader } from '@/lib/sanity.loader';
import { urlFor } from '@/sanity/lib/image';
import { useUserStore } from '@/lib/store';
import { useSession } from 'next-auth/react';
import { useClickOutside } from '@/hooks/useClickOutside'; 
import AdminPinButton from '@/components/releases/AdminPinButton';
import { useIsMobile } from '@/hooks/useIsMobile';
import { useActiveCardStore } from '@/lib/activeCardStore';
import { usePerformanceStore } from '@/lib/performanceStore';
import KineticLink from '@/components/kinetic/KineticLink'; 
import { generateLayoutId } from '@/lib/layoutUtils'; 

import { Calendar03Icon } from '@/components/icons';
import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

import styles from './TimelineCard.module.css';

const DESKTOP_TAG_SCALE = 0.8; 
const MOBILE_TAG_SCALE = 0.8; 
const YoutubeIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/></svg>;
const CloseIcon = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const AddToListStrokeIcon = () => (<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"><path d="M3.5 9V20C3.5 21.1046 4.39543 22 5.5 22H18.5C19.6046 22 20.5 21.1046 20.5 20V4C20.5 2.89543 19.6046 2 18.5 2H12"></path><path d="M13.5 17H17.5"></path><path d="M13.5 7H17.5"></path><path d="M13.5 12H17.5"></path><path d="M6.5 16.5L8 18L11 14"></path><path d="M10 5H3.5M10 5L7.08333 2M10 5L7.08333 8"></path></svg>);
const AddToListSolidIcon = () => (<svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path fillRule="evenodd" clipRule="evenodd" d="M8.05033 1.55292C7.66534 1.15694 7.03224 1.14802 6.63626 1.53301C6.24027 1.91799 6.23135 2.55109 6.61634 2.94708L7.88307 4.25H3.75C3.19772 4.25 2.75 4.69772 2.75 5.25C2.75 5.80229 3.19772 6.25 3.75 6.25H7.88307L6.61634 7.55292C6.23135 7.94891 6.24027 8.58201 6.63625 8.967C7.03224 9.35198 7.66534 9.34306 8.05033 8.94708L10.967 5.94708C11.3443 5.55896 11.3443 4.94104 10.967 4.55292L8.05033 1.55292ZM2.75 20V7.5H5.21144C4.92844 8.30226 5.11492 9.23131 5.76491 9.86324C6.65587 10.7295 8.08035 10.7094 8.94657 9.81843L11.8632 6.81843C12.7123 5.94516 12.7123 4.55485 11.8632 3.68158L9.49921 1.25H18.5C20.0188 1.25 21.25 2.48122 21.25 4V20C21.25 21.5188 20.0188 22.75 18.5 22.75H5.5C3.98122 22.75 2.75 21.5188 2.75 20ZM13.5 16.25C13.0858 16.25 12.75 16.5858 12.75 17C12.75 17.4142 13.0858 17.75 13.5 17.75H17.5C17.9142 17.75 18.25 17.4142 18.25 17C18.25 16.5858 17.9142 16.25 17.5 16.25H13.5ZM12.75 7C12.75 6.58579 13.0858 6.25 13.5 6.25H17.5C17.9142 6.25 18.25 6.58579 18.25 7C18.25 7.41421 17.9142 7.75 17.5 7.75H13.5C13.0858 7.75 12.75 7.41421 12.75 7ZM13.5 11.25C13.0858 11.25 12.75 11.5858 12.75 12C12.75 12.4142 13.0858 12.75 13.5 12.75H17.5C17.9142 12.75 18.25 12.4142 18.25 12C18.25 11.5858 17.9142 11.25 17.5 11.25H13.5ZM11.45 13.4C11.7814 13.6486 11.8485 14.1187 11.6 14.45L8.6 18.45C8.46955 18.624 8.27004 18.7327 8.05317 18.7482C7.8363 18.7636 7.62341 18.6841 7.46967 18.5304L5.96967 17.0304C5.67678 16.7375 5.67678 16.2626 5.96967 15.9697C6.26256 15.6768 6.73744 15.6768 7.03033 15.9697L7.91885 16.8582L10.4 13.55C10.6485 13.2187 11.1186 13.1515 11.45 13.4Z" fill="currentColor"></path></svg>);
const ArrowDownIcon = () => (<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>);
const WatchIcon = () => (<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>);
const CheckmarkCircleIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path fillRule="evenodd" clipRule="evenodd" d="M11.75 22.5C5.81294 22.5 1 17.6871 1 11.75C1 5.81294 5.81294 1 11.75 1C17.6871 1 22.5 5.81294 22.5 11.75C22.5 17.6871 17.6871 22.5 11.75 22.5ZM16.1901 9.64829C16.6861 9.40536 16.8912 8.80634 16.6483 8.31036C16.4053 7.81437 15.8063 7.60923 15.3103 7.85216C13.3545 8.81011 11.8402 10.4539 10.8372 11.7938C10.4896 12.2581 10.1962 12.6957 9.96026 13.071C9.68112 12.8292 9.40583 12.6289 9.16316 12.4689C8.88562 12.2859 8.63935 12.1481 8.45963 12.0548C8.36951 12.008 8.29538 11.9719 8.24153 11.9466C8.21458 11.934 8.19265 11.924 8.17625 11.9166L8.15586 11.9076L8.14888 11.9046L8.14622 11.9034L8.14412 11.9025C8.14388 11.9024 8.14412 11.9025 7.7502 12.8217L8.14412 11.9025C7.63649 11.685 7.04861 11.9201 6.83106 12.4277C6.61392 12.9344 6.84809 13.5211 7.3537 13.7397L7.35473 13.7401L7.35829 13.7417C7.3643 13.7444 7.37547 13.7495 7.3913 13.7569C7.423 13.7718 7.47309 13.7961 7.53765 13.8296C7.66731 13.897 7.85228 14.0002 8.06224 14.1387C8.49104 14.4214 8.97956 14.8217 9.33097 15.3237C9.53389 15.6136 9.8749 15.7746 10.2277 15.7472C10.5803 15.7198 10.8924 15.5078 11.0482 15.1902L11.0508 15.1851L11.0653 15.1563C11.079 15.1295 11.1005 15.0879 11.1297 15.0332C11.1882 14.9235 11.2772 14.7614 11.3954 14.56C11.6323 14.1564 11.9838 13.5994 12.4382 12.9924C13.3602 11.7609 14.6459 10.4046 16.1901 9.64829Z" fill="currentColor"></path>
    </svg>
);

const PLATFORM_FLY_CONFIG = { LEFT_ANCHOR: '80%', TARGET_TOP: 170, TOP_STEP: 33, BASE_ROT: -5, ROT_STEP: 0, SCALE: 0.75 };
const PRICE_FLY_CONFIG = { X: 40, Y: -60, ROT: 5, SCALE: 0.75 }; 
const VIDEO_PRICE_FLY_CONFIG = { X: 40, Y: -115, ROT: 5, SCALE: 0.75 };
const STATUS_FLY_CONFIG = { X: 0, Y: 140, ROT: -3, SCALE: 0.75 };
const PLAY_BUTTON_CONFIG = { OFFSET_X: 0, OFFSET_Y: 70, ROTATE: 0, INITIAL_SCALE: 1 };
const CLICK_MORE_CONFIG = { X: -65, Y: -170, ROT: 0, SCALE: 0.7 };
const DEV_FLY_CONFIG = { X: -90, Y: -155, ROT: 0, SCALE: 0.65 };
const PUB_FLY_CONFIG = { X: 100, Y: -155, ROT: 0, SCALE: 0.65 };
const DESKTOP_GP_CONFIG = { LEFT: '-8%', TOP: 257, ROT: 5, SCALE: 0.7 };
const VIDEO_DESKTOP_GP_CONFIG = { LEFT: '-8%', TOP: 210, ROT: 5, SCALE: 0.7 };
const DESKTOP_PS_CONFIG = { LEFT: '-8%', TOP: 225, ROT: 5, SCALE: 0.7 };
const VIDEO_DESKTOP_PS_CONFIG = { LEFT: '-8%', TOP: 175, ROT: 5, SCALE: 0.7 };

const MOBILE_STANDARD_PLATFORM_FLY_CONFIG = { LEFT_ANCHOR: '75%', TARGET_TOP: 220, TOP_STEP: 35, BASE_ROT: 0, ROT_STEP: 0, SCALE: 0.8 };
const MOBILE_STANDARD_PRICE_FLY_CONFIG = { X: 55, Y: -45, ROT: -2, SCALE: 0.8 };
const MOBILE_STANDARD_STATUS_FLY_CONFIG = { X: 0, Y: 100, ROT: 0, SCALE: 0.8 };
const MOBILE_STANDARD_CLICK_MORE_CONFIG = { X: -50, Y: -160, ROT: 0, SCALE: 0.8 };
const MOBILE_STANDARD_GP_CONFIG = { LEFT: 15, TOP: 230, ROT: -2, SCALE: 0.8 }; 
const MOBILE_STANDARD_PS_CONFIG = { RIGHT: 15, TOP: 230, ROT: 2, SCALE: 0.8 }; 
const MOBILE_STANDARD_PLAY_BUTTON_CONFIG = { OFFSET_X: 0, OFFSET_Y: 75, ROTATE: 0, INITIAL_SCALE: 1 };

const MOBILE_HOMEPAGE_PLATFORM_FLY_CONFIG = { LEFT_ANCHOR: '75%', TARGET_TOP: 180, TOP_STEP: 30, BASE_ROT: 0, ROT_STEP: 0, SCALE: 0.7 };
const MOBILE_HOMEPAGE_PRICE_FLY_CONFIG = { X: 50, Y: -45, ROT: -2, SCALE: 0.6 };
const MOBILE_HOMEPAGE_STATUS_FLY_CONFIG = { X: 0, Y: 80, ROT: 0, SCALE: 0.7 };
const MOBILE_HOMEPAGE_CLICK_MORE_CONFIG = { X: -40, Y: -110, ROT: 0, SCALE: 0.6 };
const MOBILE_HOMEPAGE_GP_CONFIG = { LEFT: 0, TOP: 165, ROT: -2, SCALE: 0.5 };
const MOBILE_HOMEPAGE_PS_CONFIG = { RIGHT: 0, TOP: 165, ROT: 2, SCALE: 0.5 };
const MOBILE_HOMEPAGE_PLAY_BUTTON_CONFIG = { OFFSET_X: 0, OFFSET_Y: 25, ROTATE: 0, INITIAL_SCALE: 0.8 };

export const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = { 'PC': PCIcon, 'PlayStation': PS5Icon, 'Xbox': XboxIcon, 'Switch': SwitchIcon };
export const PlatformNames: Record<string, string> = { 'PC': 'PC', 'PlayStation': 'PS5', 'Xbox': 'Xbox', 'Switch': 'Switch' };
const PLATFORM_SORT_WEIGHTS: Record<string, number> = { 'Switch': 4, 'Xbox': 3, 'PlayStation': 2, 'PC': 1 };

const morphTransition: Transition = { type: "spring", stiffness: 220, damping: 25, mass: 1.0 };

interface SatelliteItem {
    type: string;
    label: string;
    icon?: React.ReactNode;
    colorClass?: string;
    x: number;
    y: number;
    rotate: number;
    scale: number;
    anchor: 'center' | 'left' | 'right';
    link?: string | null;
    isKinetic?: boolean;
}

type ExtendedRelease = SanityGameRelease & { 
    game?: { slug?: string, title?: string }, 
    tags?: any[], 
    onGamePass?: boolean, 
    onPSPlus?: boolean,
    developer?: { title: string, slug?: string },
    publisher?: { title: string, slug?: string },
    datePrecision?: 'day' | 'month' | 'year',
};

const TimelineCardComponent = ({ 
    release, 
    autoHeight = false,
    showAdminControls = false,
    variant = 'default'
}: { 
    release: ExtendedRelease,
    autoHeight?: boolean,
    showAdminControls?: boolean,
    variant?: 'default' | 'homepage'
}) => {
    const isMobile = useIsMobile();
    const { isLivingCardEnabled, isFlyingTagsEnabled, isHeroTransitionEnabled, isCornerAnimationEnabled, isHoverDebounceEnabled } = usePerformanceStore();

    const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLDivElement>();
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const { data: session } = useSession();
    const { toggleBookmark, bookmarks, setSignInModalOpen } = useUserStore();
    const { activeCardId, setActiveCardId } = useActiveCardStore();
    
    const [isHoveredLocal, setIsHoveredLocal] = useState(false);
    const [isVideoActive, setIsVideoActive] = useState(false);
    const [showVideoModal, setShowVideoModal] = useState(false);
    const [mounted, setMounted] = useState(false);

    useEffect(() => { setMounted(true); }, []);
    
    const hoverTimeout = useRef<NodeJS.Timeout | null>(null);
    const touchTimeout = useRef<NodeJS.Timeout | null>(null);
    const lastTouchPos = useRef({ x: 0, y: 0 });

    const videoRef = useRef<HTMLIFrameElement>(null);
    const isHovered = isMobile ? activeCardId === release._id : isHoveredLocal;

    const mobileConfig = useMemo(() => {
        if (variant === 'homepage') {
            return {
                platform: MOBILE_HOMEPAGE_PLATFORM_FLY_CONFIG,
                price: MOBILE_HOMEPAGE_PRICE_FLY_CONFIG,
                status: MOBILE_HOMEPAGE_STATUS_FLY_CONFIG,
                clickMore: MOBILE_HOMEPAGE_CLICK_MORE_CONFIG,
                gp: MOBILE_HOMEPAGE_GP_CONFIG,
                ps: MOBILE_HOMEPAGE_PS_CONFIG,
                play: MOBILE_HOMEPAGE_PLAY_BUTTON_CONFIG 
            };
        }
        return {
            platform: MOBILE_STANDARD_PLATFORM_FLY_CONFIG,
            price: MOBILE_STANDARD_PRICE_FLY_CONFIG,
            status: MOBILE_STANDARD_STATUS_FLY_CONFIG,
            clickMore: MOBILE_STANDARD_CLICK_MORE_CONFIG,
            gp: MOBILE_STANDARD_GP_CONFIG,
            ps: MOBILE_STANDARD_PS_CONFIG,
            play: MOBILE_STANDARD_PLAY_BUTTON_CONFIG 
        };
    }, [variant]);
    
    const playConfig = isMobile ? mobileConfig.play : PLAY_BUTTON_CONFIG;

    useClickOutside(livingCardRef, () => {
        if (isMobile && activeCardId === release._id) {
            setActiveCardId(null);
        }
    });

    const activeTagScale = isMobile ? MOBILE_TAG_SCALE : DESKTOP_TAG_SCALE;
    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);
    const smoothMouseX = useSpring(mouseX, { damping: 20, stiffness: 150 });
    const smoothMouseY = useSpring(mouseY, { damping: 20, stiffness: 150 });
    const glareX = useTransform(smoothMouseX, [0, 1], ['0%', '100%']);
    const glareY = useTransform(smoothMouseY, [0, 1], ['0%', '100%']);

    const effectivelyDisabledLiving = !isLivingCardEnabled;

    const handlers = !isMobile ? {
        onMouseMove: (e: React.MouseEvent<HTMLDivElement>) => {
            if (!effectivelyDisabledLiving) {
                livingCardAnimation.onMouseMove(e);
                if (livingCardRef.current) {
                    const { left, top, width, height } = livingCardRef.current.getBoundingClientRect();
                    mouseX.set((e.clientX - left) / width);
                    mouseY.set((e.clientY - top) / height);
                }
            }
        },
        onMouseEnter: () => { 
            if (!effectivelyDisabledLiving) livingCardAnimation.onMouseEnter(); 
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if (!isHoverDebounceEnabled) {
                 setIsHoveredLocal(true);
            } else {
                 hoverTimeout.current = setTimeout(() => setIsHoveredLocal(true), 75);
            }
        },
        onMouseLeave: () => { 
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if(!effectivelyDisabledLiving) livingCardAnimation.onMouseLeave(); 
            setIsHoveredLocal(false); 
            mouseX.set(0.5); mouseY.set(0.5);
        },
    } : {
        onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => {
            const touch = e.touches[0];
            lastTouchPos.current = { x: touch.clientX, y: touch.clientY };

            if (touchTimeout.current) clearTimeout(touchTimeout.current);
            
            if (!isHoverDebounceEnabled) {
                const targetElement = document.elementFromPoint(lastTouchPos.current.x, lastTouchPos.current.y);
                const isOverCard = livingCardRef.current && targetElement && livingCardRef.current.contains(targetElement);
                if (isOverCard && activeCardId !== release._id) {
                    setActiveCardId(release._id);
                }
            } else {
                touchTimeout.current = setTimeout(() => {
                    const targetElement = document.elementFromPoint(lastTouchPos.current.x, lastTouchPos.current.y);
                    const isOverCard = livingCardRef.current && targetElement && livingCardRef.current.contains(targetElement);
                    if (isOverCard && activeCardId !== release._id) {
                        setActiveCardId(release._id);
                    }
                }, 75);
            }

            if (!effectivelyDisabledLiving) livingCardAnimation.onTouchStart(e);
        },
        onTouchMove: (e: React.TouchEvent<HTMLDivElement>) => {
             const touch = e.touches[0];
             lastTouchPos.current = { x: touch.clientX, y: touch.clientY };
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchMove(e);
        },
        onTouchEnd: () => {
             if (touchTimeout.current) clearTimeout(touchTimeout.current);
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchEnd();
        },
        onTouchCancel: () => {
             if (touchTimeout.current) clearTimeout(touchTimeout.current);
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchCancel();
        }
    };

    const toggleWishlist = (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault(); e.stopPropagation();
        if (!session) { setSignInModalOpen(true); return; }
        toggleBookmark(release.legacyId, 'release'); 
    };

    const isBookmarked = bookmarks.includes(`release-${release.legacyId}`);
    const trailerId = useMemo(() => {
        if (!release.trailer) return null;
        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = release.trailer.match(regExp);
        return (match && match[2].length === 11) ? match[2] : null;
    }, [release.trailer]);

    const handleWatchClick = (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault(); e.stopPropagation();
        if (isMobile && variant === 'homepage') {
            setShowVideoModal(true);
        } else {
            setIsVideoActive(true);
        }
    };

    const handleCloseVideo = (e: React.MouseEvent | React.TouchEvent) => {
        e.preventDefault(); e.stopPropagation();
        setIsVideoActive(false);
        setShowVideoModal(false); 
    };

    const releaseDate = new Date(release.releaseDate);
    const isReleased = releaseDate < new Date();
    const isTBA = release.isTBA;
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    
    let formattedDate = '';
    if (isTBA) {
        formattedDate = "غير معلن";
    } else {
        const d = releaseDate.getDate();
        const m = arabicMonths[releaseDate.getMonth()];
        const y = releaseDate.getFullYear();
        
        if (release.datePrecision === 'year') {
            formattedDate = `${y}`;
        } else if (release.datePrecision === 'month') {
            formattedDate = `${m} ${y}`;
        } else {
            formattedDate = `${d} ${m} ${y}`;
        }
    }

    // FIX 1: DETERMINE EFFECTIVE SLUG AND TYPE FOR KINETIC LINK
    // We want to open the Game Hub if available, otherwise fallback to release slug (though unlikely)
    const gameSlug = release.game?.slug;
    const effectiveSlug = gameSlug || release.slug || '';
    const kineticLinkType = gameSlug ? 'games' : 'releases';
    
    // Construct the URL. This must match the slug we are passing to KineticLink
    const targetUrl = gameSlug ? `/games/${gameSlug}` : `/releases/${release.slug}`;
    
    const layoutIdPrefix = `timeline-${release._id}`;
    
    const platforms = useMemo(() => {
        const raw = release.platforms || [];
        const normalizedSet = new Set<string>();
        raw.forEach(p => { if (p === 'PlayStation 5') normalizedSet.add('PlayStation'); else normalizedSet.add(p); });
        return Array.from(normalizedSet);
    }, [release.platforms]);

    const safeLayoutIdPrefix = isHeroTransitionEnabled ? layoutIdPrefix : undefined;

    const handleClick = (e: React.MouseEvent) => {
        if (isMobile && activeCardId !== release._id) {
            e.preventDefault();
            return;
        }
        if (isVideoActive) return; 
        if (!isMobile && isHeroTransitionEnabled) {
             setPrefix(layoutIdPrefix);
        }
    };

    const imageUrl = release.mainImage 
        ? urlFor(release.mainImage).width(800).height(450).fit('crop').auto('format').url()
        : '/placeholder-game.jpg';
    
    const blurDataURL = release.mainImage?.blurDataURL;

    const flyingItems = useMemo(() => {
        const satellites: SatelliteItem[] = [];
        const STATUS_CFG = isMobile ? mobileConfig.status : STATUS_FLY_CONFIG;
        const CLICK_CFG = isMobile ? mobileConfig.clickMore : CLICK_MORE_CONFIG;

        let PRICE_CFG = isMobile ? mobileConfig.price : PRICE_FLY_CONFIG;
        if (!isMobile && isVideoActive) {
            PRICE_CFG = VIDEO_PRICE_FLY_CONFIG;
        }

        satellites.push({ 
            type: 'clickHint', 
            label: 'اضغط للمزيد', 
            icon: <ArrowDownIcon />,
            colorClass: 'cyan',
            x: CLICK_CFG.X, y: CLICK_CFG.Y, rotate: CLICK_CFG.SCALE, 
            scale: CLICK_CFG.SCALE, 
            anchor: 'center', link: targetUrl // Use unified URL
        });

        if (!isReleased && !isTBA) {
             const msPerDay = 1000 * 60 * 60 * 24;
             const daysLeft = Math.ceil((releaseDate.getTime() - new Date().getTime()) / msPerDay);
             let label = `باقي ${daysLeft} يوم`;
             let colorClass = "cyan";
             if (daysLeft <= 3) colorClass = "golden";
             else if (daysLeft <= 10) colorClass = "red";
             else if (daysLeft <= 20) colorClass = "orange";
             satellites.push({ type: 'status', label: label, colorClass: colorClass, x: STATUS_CFG.X, y: STATUS_CFG.Y, rotate: STATUS_CFG.ROT, scale: STATUS_CFG.SCALE, anchor: 'center', link: null });
        }

        if (release.price) {
            satellites.push({ type: 'price', label: release.price, x: PRICE_CFG.X, y: PRICE_CFG.Y, rotate: PRICE_CFG.ROT, scale: PRICE_CFG.SCALE, anchor: 'left', link: null, colorClass: 'pricePill' });
        }
        
        if (!isMobile) {
            if (release.publisher?.title) {
                const pubSlug = release.publisher.slug;
                const pubLink = pubSlug ? `/publishers/${pubSlug}` : null;
                satellites.push({ type: 'publisher', label: release.publisher.title, x: PUB_FLY_CONFIG.X, y: PUB_FLY_CONFIG.Y, rotate: PUB_FLY_CONFIG.ROT, scale: PUB_FLY_CONFIG.SCALE, anchor: 'left', link: pubLink, colorClass: 'devPill', isKinetic: false });
            }
            if (release.developer?.title && release.developer.title !== release.publisher?.title) {
                const devSlug = release.developer.slug;
                const devLink = devSlug ? `/developers/${devSlug}` : null;
                satellites.push({ type: 'developer', label: release.developer.title, x: DEV_FLY_CONFIG.X, y: DEV_FLY_CONFIG.Y, rotate: DEV_FLY_CONFIG.ROT, scale: DEV_FLY_CONFIG.SCALE, anchor: 'right', link: devLink, colorClass: 'devPill', isKinetic: false });
            }
        }
        
        return satellites;
    }, [isReleased, isTBA, releaseDate, release.price, isMobile, mobileConfig, release.publisher, release.developer, targetUrl, isVideoActive]);

    const platformConfig = useMemo(() => {
        const validPlatforms = platforms.filter(p => PlatformIcons[p]);
        validPlatforms.sort((a, b) => (PLATFORM_SORT_WEIGHTS[b] || 0) - (PLATFORM_SORT_WEIGHTS[a] || 0));
        const CFG = isMobile ? mobileConfig.platform : PLATFORM_FLY_CONFIG;
        return validPlatforms.map((p, i) => {
            const Icon = PlatformIcons[p];
            const top = CFG.TARGET_TOP + (i * CFG.TOP_STEP); 
            return { key: p, name: PlatformNames[p] || p, Icon: Icon, left: CFG.LEFT_ANCHOR, top, rotate: CFG.BASE_ROT, scale: CFG.SCALE };
        });
    }, [platforms, isMobile, mobileConfig]);

    const subConfig = useMemo(() => {
        const items = [];
        if (release.onPSPlus) {
            let left, top, rotate, scale;
            if (isMobile) { 
                left = 'auto'; 
                const cfg = mobileConfig.ps;
                left = 'auto'; top = cfg.TOP; rotate = cfg.ROT; scale = cfg.SCALE;
            } else {
                const cfg = isVideoActive ? VIDEO_DESKTOP_PS_CONFIG : DESKTOP_PS_CONFIG;
                left = cfg.LEFT; top = cfg.TOP; rotate = cfg.ROT; scale = cfg.SCALE;
            }
            items.push({ key: 'ps', name: 'PS Plus', Icon: PS5Icon, left: isMobile ? 'auto' : left, right: isMobile ? mobileConfig.ps.RIGHT : 'auto', top, rotate, scale });
        }

        if (release.onGamePass) {
            let left, top, rotate, scale;
            if (isMobile) { 
                left = mobileConfig.gp.LEFT; top = mobileConfig.gp.TOP; rotate = mobileConfig.gp.ROT; scale = mobileConfig.gp.SCALE;
            } else {
                 const cfg = isVideoActive ? VIDEO_DESKTOP_GP_CONFIG : DESKTOP_GP_CONFIG;
                 left = cfg.LEFT; top = cfg.TOP; rotate = cfg.ROT; scale = cfg.SCALE;
            }
            items.push({ key: 'gp', name: 'Game Pass', Icon: XboxIcon, left, right: 'auto', top, rotate, scale });
        }

        return items;
    }, [release.onGamePass, release.onPSPlus, isMobile, mobileConfig, isVideoActive]);

    const renderHoverBridge = () => {
        if (!isHovered || isMobile) return null; 
        return (
            <div 
                style={{
                    position: 'absolute',
                    bottom: '95%',
                    left: '10%', 
                    width: '80%', 
                    height: '80px',
                    backgroundColor: 'transparent',
                    pointerEvents: 'auto',
                    zIndex: 90
                }}
                onMouseEnter={() => {
                    if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
                    setIsHoveredLocal(true);
                }}
            />
        );
    };
    
    const animationStyles = !effectivelyDisabledLiving ? livingCardAnimation.style : {};

    return (
        <>
            {mounted && createPortal(
                <AnimatePresence>
                    {showVideoModal && trailerId && (
                        <motion.div 
                            className={styles.videoOverlay}
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            onClick={handleCloseVideo}
                        >
                             <motion.div 
                                className={styles.videoModal}
                                initial={{ scale: 0.8, opacity: 0 }}
                                animate={{ scale: 1, opacity: 1 }}
                                exit={{ scale: 0.8, opacity: 0 }}
                                onClick={(e) => e.stopPropagation()}
                            >
                                <button className={styles.modalCloseButton} onClick={handleCloseVideo}>
                                    <span>إغلاق</span>
                                    <CloseIcon />
                                </button>
                                <iframe 
                                    src={`https://www.youtube.com/embed/${trailerId}?autoplay=1&controls=1&modestbranding=1&rel=0`} 
                                    title="Trailer Modal" 
                                    style={{ width: '100%', height: '100%', border: 'none' }} 
                                    allow="autoplay; encrypted-media; fullscreen" 
                                    allowFullScreen 
                                />
                            </motion.div>
                        </motion.div>
                    )}
                </AnimatePresence>,
                document.body
            )}

            <motion.div
                ref={livingCardRef}
                className={`${styles.livingCardWrapper} ${isHovered ? styles.activeState : ''} ${!isCornerAnimationEnabled ? 'noCornerAnimation' : ''}`}
                {...handlers}
                style={animationStyles}
            >
                <div className={`${styles.timelineCard} ${autoHeight ? styles.autoHeight : ''} ${variant === 'homepage' ? styles.homepage : ''}`} style={{ position: 'relative' }}>
                    
                    <div style={{ position: 'absolute', inset: 0, zIndex: 100, pointerEvents: 'none' }}>
                         {isVideoActive && trailerId && (
                            <div style={{ position: 'relative', width: '100%', aspectRatio: '16/9', zIndex: 110, pointerEvents: 'auto' }}>
                                <iframe ref={videoRef} src={`https://www.youtube.com/embed/${trailerId}?autoplay=1&controls=1&modestbranding=1&rel=0`} title="Trailer" style={{ width: '100%', height: '100%', border: 'none', objectFit: 'cover', borderTopLeftRadius: '15px', borderTopRightRadius: '15px' }} allow="autoplay; encrypted-media; fullscreen" allowFullScreen />
                                <button onClick={handleCloseVideo} onTouchStart={(e) => e.stopPropagation()} className={styles.videoCloseButton}> <CloseIcon /> </button>
                            </div>
                        )}
                        
                        <div style={{ position: 'absolute', top: '1rem', left: '1rem', zIndex: 30, display: 'flex', gap: '0.8rem', pointerEvents: 'auto' }}>
                            <motion.button className={styles.wishlistButton} onClick={toggleWishlist} onTouchStart={(e) => e.stopPropagation()} initial={{ scale: 0.9 }} animate={{ scale: 1 }} whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} style={{ border: '1px solid var(--accent)', backgroundColor: isBookmarked ? 'var(--accent)' : 'rgba(0, 0, 0, 0.6)', color: isBookmarked ? '#000000' : 'var(--accent)', backdropFilter: 'blur(4px)', boxShadow: isBookmarked ? '0 0 10px var(--accent)' : 'none', transition: 'all 0.2s ease' }} title={isBookmarked ? "إزالة من المحفوظات" : "حفظ"}> {isBookmarked ? <AddToListSolidIcon /> : <AddToListStrokeIcon />} </motion.button>
                            {showAdminControls && ( <div onTouchStart={(e) => e.stopPropagation()}> <AdminPinButton releaseId={release._id} isPinned={release.isPinned || false} /> </div> )}
                        </div>

                        {!isVideoActive && trailerId && (
                            <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', aspectRatio: '16/9', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 90, pointerEvents: 'none' }}>
                                <AnimatePresence>
                                    {isHovered && (
                                        <motion.button 
                                            key="play-button" 
                                            initial={{ opacity: 0, scale: playConfig.INITIAL_SCALE, x: playConfig.OFFSET_X, y: playConfig.OFFSET_Y + 20 }} 
                                            animate={{ opacity: 1, scale: activeTagScale, x: playConfig.OFFSET_X, y: playConfig.OFFSET_Y, rotate: playConfig.ROTATE }} 
                                            exit={{ opacity: 0, scale: playConfig.INITIAL_SCALE, x: playConfig.OFFSET_X, y: playConfig.OFFSET_Y + 20 }} 
                                            transition={morphTransition} 
                                            className={styles.playButtonContainer} 
                                            whileTap={{ scale: 0.95 }} 
                                            onClick={handleWatchClick} 
                                            onTouchStart={(e) => e.stopPropagation()}
                                        > 
                                            <span style={{ marginLeft: '0.4rem' }}>الإعلان</span> 
                                            <YoutubeIcon /> 
                                        </motion.button>
                                    )}
                                </AnimatePresence>
                            </div>
                        )}
                    </div>

                    {/* FIX 1: Use KineticLink with Game Slug and Type */}
                    <KineticLink 
                        href={targetUrl}
                        slug={effectiveSlug}
                        type={kineticLinkType} // Pass correct type ('games' or 'releases')
                        layoutId={safeLayoutIdPrefix}
                        imageSrc={imageUrl}
                        className="no-underline block h-full"
                        onClick={handleClick} 
                        style={{ position: 'relative', zIndex: 1 }}
                    >
                        <motion.div className={styles.glare} style={{ '--mouse-x': glareX, '--mouse-y': glareY } as any} />
                        
                        <div className={styles.monolithFrame}>
                             <div className={styles.cyberCorner} />

                            <div className={styles.imageFrame}>
                                {isReleased ? ( <div className={`${styles.statusBadge} ${styles.released}`} title="صدرت"> <CheckmarkCircleIcon /> </div> ) : ( <div className={`${styles.statusBadge} ${styles.upcoming}`} title="قادمة"> <WatchIcon /> </div> )}

                                <motion.div layoutId={!isMobile && safeLayoutIdPrefix ? generateLayoutId(safeLayoutIdPrefix, 'image', release.legacyId) : undefined} className="relative w-full h-full">
                                    <Image loader={sanityLoader} src={imageUrl} alt={release.title} fill sizes="(max-width: 768px) 100vw, 400px" className={styles.cardImage} placeholder={blurDataURL ? 'blur' : 'empty'} blurDataURL={blurDataURL} style={{ opacity: isVideoActive ? 0 : 1 }} />
                                </motion.div>
                            </div>
                        </div>

                        <div className={styles.cardBody}>
                            <div className={styles.titleRow}>
                                <motion.h3 layoutId={!isMobile && safeLayoutIdPrefix ? generateLayoutId(safeLayoutIdPrefix, 'title', release.legacyId) : undefined} className={styles.cardTitle} style={{ direction: 'ltr', textAlign: 'left', width: '100%' }}> {release.title} </motion.h3>
                            </div>
                            <div className={styles.metaGrid}>
                                <div className={styles.dateBlock}> 
                                    {!isTBA && (
                                        <div className={styles.dateIconWrapper}><Calendar03Icon width="100%" height="100%" /></div> 
                                    )}
                                    <span>{formattedDate}</span> 
                                </div>
                                <div className={styles.platformRow}>
                                    {platformConfig.map(p => {
                                        if (!p || (isHovered && isFlyingTagsEnabled && !isMobile)) return null; 
                                        const lid = `plat-${release._id}-${p.key}`;
                                        return ( 
                                            <div key={p.key} style={{ width: 18, height: 18, display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}> 
                                                <motion.div 
                                                    layoutId={!isMobile && safeLayoutIdPrefix ? lid : undefined} 
                                                    className={styles.platformTagBase} 
                                                    style={{ padding: 0 }}
                                                > 
                                                    <p.Icon className={styles.platformIcon} /> 
                                                </motion.div> 
                                            </div> 
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    </KineticLink>

                    {renderHoverBridge()}

                    {/* --- FLYING ITEMS --- */}
                    {isFlyingTagsEnabled && !isMobile && (
                         <div className={styles.flyingTagsContainer} style={{ right: 'auto', left: 0, width: '100%' }}>
                            <AnimatePresence>
                                {isHovered && platformConfig.map(p => {
                                    const lid = `plat-${release._id}-${p.key}`;
                                    return ( 
                                        <motion.div 
                                            key={p.key} 
                                            layoutId={!isMobile && safeLayoutIdPrefix ? lid : undefined} 
                                            className={`${styles.platformTagBase} ${styles.flying}`} 
                                            transition={morphTransition} 
                                            initial={false} 
                                            animate={{ rotate: p.rotate, scale: 1.2 * p.scale, backgroundColor: "rgba(0, 0, 0, 0.85)", borderColor: "var(--accent)", color: "var(--accent)", x: 15, z: 60 }} 
                                            exit={{ opacity: 0, scale: 0, transition: { duration: 0.2 } }} 
                                            whileHover={{ zIndex: 500, scale: 1.3 * p.scale }} 
                                            style={{ position: 'absolute', left: p.left, top: p.top, padding: "0.4rem 1rem", zIndex: 100, boxShadow: "0 0 15px color-mix(in srgb, var(--accent) 30%, transparent)", transformOrigin: 'center', flexDirection: 'row-reverse', overflow: 'hidden' }} 
                                            onClick={(e) => e.stopPropagation()}
                                        > 
                                            <p.Icon className={styles.platformIcon} style={{ width: '16px', height: '16px' }} /> 
                                            <span style={{ overflow: 'hidden', fontSize: '1.1rem' }}>{p.name}</span> 
                                        </motion.div> 
                                    );
                                })}
                            </AnimatePresence>
                        </div>
                    )}
                    
                    {/* Subscriptions */}
                    {isFlyingTagsEnabled && (
                        <div className={styles.flyingTagsContainer} style={{ left: 0, right: 0, width: '100%' }}>
                            <AnimatePresence>
                                {isHovered && subConfig.map((sub, i) => {
                                     return ( 
                                        <motion.div 
                                            key={sub.key} 
                                            initial={{ opacity: 0, left: '50%', top: '50%', x: '-50%', y: '-50%', scale: 0, z: 0 }} 
                                            animate={{ opacity: 1, left: sub.left, top: sub.top, rotate: sub.rotate, scale: 1.2 * sub.scale, x: !isMobile ? 15 : (sub.key === 'gp' ? -15 : 15), y: 0, z: 60 }} 
                                            whileHover={{ zIndex: 500, scale: 1.3 * sub.scale }} 
                                            exit={{ opacity: 0, scale: 0, transition: { duration: 0.2 } }} 
                                            transition={{ ...morphTransition, delay: i * 0.03 }} 
                                            style={{ position: 'absolute', right: sub.right, transformOrigin: 'center', cursor: 'default' }}
                                        > 
                                            <div className={`${styles.genrePill} no-underline`} style={{ flexDirection: 'row' }}> 
                                                <sub.Icon style={{ width: '16px', height: '16px' }} /> 
                                                <span style={{ fontSize: '1.1rem' }}>{sub.name}</span> 
                                            </div> 
                                        </motion.div> 
                                    );
                                })}
                            </AnimatePresence>
                        </div>
                    )}

                    {/* Satellites */}
                    {isFlyingTagsEnabled && (
                        <div className={styles.satelliteField}>
                            <AnimatePresence>
                                {isHovered && flyingItems.map((item, i) => {
                                    if (!item) return null;
                                    const pillStyleClass = item.colorClass ? `${styles.shardPill} ${styles.statusPill} ${styles[item.colorClass]}` : styles.shardPill;
                                    const config = { hoverX: item.x, hoverY: item.y, rotate: item.rotate }; 
                                    let positionStyle = { left: '50%', right: 'auto', top: '50%', transformOrigin: 'center' };
                                    if (item.anchor === 'left') { positionStyle = { right: 'auto', left: '0%', top: '50%', transformOrigin: 'center left' }; } else if (item.anchor === 'right') { positionStyle = { right: '0%', left: 'auto', top: '50%', transformOrigin: 'center right' }; }

                                    let initialX = 0;
                                    if (item.anchor === 'left') initialX = 160;
                                    if (item.anchor === 'right') initialX = -160;

                                    return ( 
                                        <motion.div 
                                            key={`shard-${i}`} 
                                            className={styles.satelliteShard} 
                                            initial={{ opacity: 0, scale: 0.4, x: initialX, y: 0, z: 0 }} 
                                            animate={{ opacity: 1, scale: 1.1 * item.scale, x: config.hoverX, y: config.hoverY, rotate: config.rotate, z: 60 }} 
                                            whileHover={{ zIndex: 500, scale: 1.2 * item.scale }} 
                                            exit={{ opacity: 0, scale: 0.4, x: initialX, y: 0 }} 
                                            transition={{ ...morphTransition, delay: i * 0.05 }} 
                                            style={{ position: 'absolute', ...positionStyle, transformStyle: 'preserve-3d' }}
                                            onClick={(e) => e.stopPropagation()}
                                        > 
                                            {item.link ? (
                                                item.isKinetic === false ? (
                                                    <a 
                                                        href={item.link}
                                                        onClick={(e) => { e.stopPropagation(); }}
                                                        className={`${pillStyleClass} no-underline`}
                                                        style={{ gap: '0.4rem', cursor: 'pointer' }}
                                                    >
                                                        {item.type === 'clickHint' ? (
                                                            <>
                                                                {item.icon && <span style={{display: 'flex'}}>{item.icon}</span>}
                                                                {item.label}
                                                            </>
                                                        ) : (
                                                            <>
                                                                {item.icon && <span style={{display: 'flex'}}>{item.icon}</span>}
                                                                {item.label}
                                                            </>
                                                        )}
                                                    </a>
                                                ) : (
                                                    <KineticLink 
                                                        href={item.link} 
                                                        // FIX 2: Pass correct slug and type
                                                        slug={effectiveSlug} 
                                                        type={kineticLinkType}
                                                        overrideUrl={targetUrl}
                                                        onClick={(e) => e.stopPropagation()}
                                                        className={`${pillStyleClass} no-underline`}
                                                        style={{ gap: '0.4rem', cursor: 'pointer' }}
                                                    >
                                                        {item.type === 'clickHint' ? (
                                                            <>
                                                                {item.icon && <span style={{display: 'flex'}}>{item.icon}</span>}
                                                                {item.label}
                                                            </>
                                                        ) : (
                                                            <>
                                                                {item.icon && <span style={{display: 'flex'}}>{item.icon}</span>}
                                                                {item.label}
                                                            </>
                                                        )}
                                                    </KineticLink>
                                                )
                                            ) : (
                                                <div className={pillStyleClass} style={{ gap: '0.4rem' }}>
                                                    {item.icon && <span style={{display: 'flex'}}>{item.icon}</span>}
                                                    {item.label}
                                                </div> 
                                            )}
                                        </motion.div> 
                                    );
                                })}
                            </AnimatePresence>
                        </div>
                    )}

                </div>
            </motion.div>
        </>
    );
};

const TimelineCard = memo(TimelineCardComponent);
export default TimelineCard;

--- END OF FILE components/TimelineCard.tsx ---

================================================================================

--- START OF FILE components/ToastProvider.tsx ---

// components/ToastProvider.tsx

'use client';

import { useState, useEffect, useMemo } from 'react';
import { AnimatePresence } from 'framer-motion';
import { createPortal } from 'react-dom';
import useToastStore from '@/lib/toastStore';
import { Toast } from './ui/Toast';

const ToastContainer = ({ toasts, dismissToast, position }: { toasts: any[], dismissToast: (id: string) => void, position: 'left' | 'right' }) => (
<div
className="toast-container-global"
style={{
position: 'fixed',
bottom: '2rem',
[position]: '2rem',
zIndex: 9999,
display: 'flex',
flexDirection: 'column',
gap: '1rem',
[position === 'right' ? 'left' : 'right']: 'auto',
}}
>
<AnimatePresence>
{toasts.map((toast) => (
<Toast
key={toast.id}
id={toast.id}
message={toast.message}
type={toast.type}
onDismiss={dismissToast}
/>
))}
</AnimatePresence>
</div>
);

export default function ToastProvider() {
const { toasts, dismissToast } = useToastStore();
const [isMounted, setIsMounted] = useState(false); // Must be top-level hook

//  DEFINITIVE FIX FOR HOOKS ORDER
// Hooks must be executed unconditionally at the top level.
const { leftToasts, rightToasts } = useMemo(() => {
return {
leftToasts: toasts.filter(t => t.position === 'left'),
rightToasts: toasts.filter(t => t.position === 'right'),
};
}, [toasts]); // Unconditional hook execution

// Effect to set mount status runs only on client
useEffect(() => {
setIsMounted(true);
}, []);

//  Conditionally return null only if mounting fails or on server
if (!isMounted) {
// We return null here. The internal useToastStore hooks (and useMemo above)
// are still executed, preserving the hooks order between renders.
return null;
}

// After mounting, create the portal into document.body.
return createPortal(
<>
<ToastContainer toasts={rightToasts} dismissToast={dismissToast} position="right" />
<ToastContainer toasts={leftToasts} dismissToast={dismissToast} position="left" />
</>,
document.body
);
}



































--- END OF FILE components/ToastProvider.tsx ---

================================================================================

--- START OF FILE components/UniversalBase.tsx ---

// components/UniversalBase.tsx
'use client';

import React, { useMemo, memo } from 'react';
import DigitalAtriumHomePage from '@/components/DigitalAtriumHomePage';
import AnimatedReleases from '@/components/AnimatedReleases';
import HomepageFeeds from '@/components/homepage/HomepageFeeds';
import { adaptToCardProps } from '@/lib/adapters';
import { CardProps } from '@/types';
import { useContentStore } from '@/lib/contentStore';
import { usePathname } from 'next/navigation';

interface UniversalBaseProps {
    data: {
        reviews: any[];
        articles: any[];
        news: any[];
        releases: any[];
        credits: any[];
        metadata: any;
    };
}

// Optimization: Memoize the heavy internal structure.
const HeavyHomeContent = memo(function HeavyHomeContent({ data }: UniversalBaseProps) {
    const { reviews, articles, news, releases, credits } = data;

    const feedsContent = useMemo(() => {
        const topArticles = articles.slice(0, 2).map(i => adaptToCardProps(i, { width: 800 })).filter(Boolean) as CardProps[];
        const latestArticles = articles.slice(2, 12).map(i => adaptToCardProps(i, { width: 400 })).filter(Boolean) as CardProps[];
        
        const pinnedNews = news.slice(0, 3).map(i => adaptToCardProps(i, { width: 600 })).filter(Boolean) as CardProps[];
        const newsList = news.slice(3, 18).map(i => adaptToCardProps(i, { width: 300 })).filter(Boolean) as CardProps[];
        
        return (
            <HomepageFeeds 
                topArticles={topArticles} 
                latestArticles={latestArticles} 
                pinnedNews={pinnedNews} 
                newsList={newsList} 
            />
        );
    }, [articles, news]);

    const releasesSection = useMemo(() => {
        const sanitizedReleases = (releases || []).filter((item: any) => 
            item?.mainImage?.url && item.releaseDate && item.title && item.slug
        );
        return <AnimatedReleases releases={sanitizedReleases} credits={credits} />;
    }, [releases, credits]);

    return (
        <DigitalAtriumHomePage 
            reviews={reviews}
            feedsContent={feedsContent}
            releasesSection={releasesSection}
        />
    );
});

export default function UniversalBase({ data }: UniversalBaseProps) {
    const pathname = usePathname();
    const isOverlayOpen = useContentStore(s => s.isOverlayOpen);
    
    // Logic: 
    // 1. If we are on the homepage, we MUST render the base (it's the main content).
    // 2. If we are on any other page, we ONLY render if the overlay is open (to show background).
    // 3. This CSS-based toggle is much cheaper than unmounting/remounting the heavy 3D scene.
    
    const shouldDisplay = pathname === '/' || isOverlayOpen;
    
    return (
        <div 
            id="universal-base-layer"
            style={{ 
                // Hide purely with CSS to keep WebGL context alive but invisible
                display: shouldDisplay ? 'block' : 'none',
                // Ensure it sits below everything on the Z-index stack if it's the background
                position: 'relative',
                zIndex: 0
            }}
        >
            <HeavyHomeContent data={data} />
        </div>
    );
}

--- END OF FILE components/UniversalBase.tsx ---

================================================================================

--- START OF FILE components/UniversalBaseLoader.tsx ---

// components/UniversalBaseLoader.tsx
'use client';

import React, { useEffect, useState } from 'react';
import { useContentStore } from '@/lib/contentStore';
import { usePathname } from 'next/navigation';
import dynamic from 'next/dynamic';
import { motion, AnimatePresence } from 'framer-motion';

// OPTIMIZATION: Dynamically import UniversalBase.
const UniversalBase = dynamic(() => import('@/components/UniversalBase'), {
    ssr: false, 
    loading: () => null
});

// Inline Splash Screen Component
const SplashScreen = () => {
    return (
        <motion.div 
            initial={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.5, ease: 'easeOut' }}
            style={{
                position: 'fixed',
                inset: 0,
                zIndex: 9999,
                backgroundColor: '#050505',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
            }}
        >
            <motion.div
                initial={{ scale: 0.9, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                transition={{ duration: 0.5 }}
                style={{ width: '80px', height: '80px', marginBottom: '20px' }}
            >
               <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 892 1617" width="100%" height="100%" style={{ filter: 'drop-shadow(0 0 10px #0dffff)' }}>
                    <path fill="#0dffff" d="M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z" />
                </svg>
            </motion.div>
            
            <motion.div 
                style={{ width: '150px', height: '2px', backgroundColor: '#1A1A1A', borderRadius: '2px', overflow: 'hidden' }}
            >
                <motion.div 
                    style={{ width: '100%', height: '100%', backgroundColor: '#0dffff', transformOrigin: 'left' }}
                    initial={{ scaleX: 0 }}
                    animate={{ scaleX: 1 }}
                    transition={{ duration: 1.5, repeat: Infinity, ease: 'easeInOut' }}
                />
            </motion.div>
        </motion.div>
    );
};

export default function UniversalBaseLoader() {
    const { universalData, hydrateUniversal } = useContentStore();
    const pathname = usePathname();
    const isHomepage = pathname === '/';
    const [shouldRender, setShouldRender] = useState(false);

    useEffect(() => {
        if (!universalData && !isHomepage) {
            const fetchBackgroundData = async () => {
                try {
                    // FIX: Removed 'next: { revalidate: 3600 }'
                    // Rely purely on 'force-cache' which respects the API route's infinite cache
                    const res = await fetch('/api/universal', { 
                        cache: 'force-cache'
                    });
                    if (res.ok) {
                        const data = await res.json();
                        hydrateUniversal(data);
                    }
                } catch (error) {
                    console.error("Background fetch failed:", error);
                }
            };
            
            if ('requestIdleCallback' in window) {
                // @ts-ignore
                window.requestIdleCallback(fetchBackgroundData);
            } else {
                setTimeout(fetchBackgroundData, 2000);
            }
        }
    }, [isHomepage, universalData, hydrateUniversal]);

    useEffect(() => {
        if (universalData) {
            setShouldRender(true);
        }
    }, [universalData]);

    return (
        <>
            <AnimatePresence mode="wait">
                {isHomepage && !shouldRender && (
                    <SplashScreen key="splash" />
                )}
            </AnimatePresence>
            
            {shouldRender && universalData && (
                <UniversalBase data={universalData} />
            )}
        </>
    );
}

--- END OF FILE components/UniversalBaseLoader.tsx ---

================================================================================

--- START OF FILE components/UserProfile.module.css ---

/* components/UserProfile.module.css */

.userProfileContainer {
  position: relative;
}

.userAvatarButton {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  border-radius: 50%;
}

.userAvatar {
  border-radius: 50%;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}
@media (hover: hover) {
  .userAvatarButton:hover .userAvatar  {
    border-color: var(--accent);
  }
  .userAvatarButton:active .userAvatar  {
    border-color: var(--accent);
  }
}
.userAvatarButton:active .userAvatar {
  border-color: var(--accent);
}

.userAvatarFallback {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background-color: var(--border-color);
  color: var(--text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: var(--font-main);
  font-weight: 700;
  font-size: 1.6rem;
  border: 2px solid transparent;
  transition: border-color 0.3s ease;
}
@media (hover: hover) {
  .userAvatarButton:hover .userAvatarFallback  {
    border-color: var(--accent);
  }
  .userAvatarButton:active .userAvatarFallback  {
    border-color: var(--accent);
  }
}
.userAvatarButton:active .userAvatarFallback {
  border-color: var(--accent);
}

.userAvatarSkeleton {
  width: 99px; /* Matches Sign In button width approx */
  height: 39px; 
  background-color: var(--border-color);
  border-radius: 5px;
  animation: pulse 1.5s infinite ease-in-out;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Dropdown Menu */
.userDropdown {
  position: absolute;
  top: calc(100% + 15px);
  left: 0; /* RTL alignment */
  right: auto;
  width: 240px;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  box-shadow: 0 10px 30px -5px color-mix(in srgb, var(--text-primary) 15%, transparent);
  z-index: 1100;
  overflow: hidden;
  padding: 0.5rem 0;
  transform-origin: top left; 
}

.dropdownUserInfo {
  padding: 0.75rem 1.25rem;
  text-align: right; 
}

.dropdownUserName {
  font-family: var(--font-main);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dropdownUserEmail {
  font-family: var(--font-main);
  font-size: 1.4rem;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.userDropdownDivider {
  height: 1px;
  background-color: var(--border-color);
  margin: 0.5rem 0;
}

.userDropdownItem {
  display: flex;
  align-items: center;
  gap: 1rem;
  width: 100%;
  text-align: right; 
  padding: 0.75rem 1.25rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  transition: background-color 0.2s ease, color 0.2s ease;
  background: none;
  border: none;
  cursor: pointer;
}

.dropdownItemIcon {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
    transition: color 0.2s ease;
}

@media (hover: hover) {
  .userDropdownItem:hover  {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
  }
  .userDropdownItem:active  {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
  }
  .userDropdownItem:hover .dropdownItemIcon  {
    color: var(--accent);
  }
  .userDropdownItem:active .dropdownItemIcon  {
    color: var(--accent);
  }
}
.userDropdownItem:active {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
}
.userDropdownItem:active .dropdownItemIcon {
    color: var(--accent);
}

/* Sign Out Item Specifics */
.userDropdownItem.signout {
  color: #DC2626;
}
@media (hover: hover) {
  .userDropdownItem.signout:hover  {
    background-color: color-mix(in srgb, #DC2626 15%, transparent);
    color: #DC2626;
  }
  .userDropdownItem.signout:active  {
    background-color: color-mix(in srgb, #DC2626 15%, transparent);
    color: #DC2626;
  }
  .userDropdownItem.signout:hover .dropdownItemIcon  {
    color: #DC2626;
  }
  .userDropdownItem.signout:active .dropdownItemIcon  {
    color: #DC2626;
  }
}
.userDropdownItem.signout:active {
  background-color: color-mix(in srgb, #DC2626 15%, transparent);
  color: #DC2626;
}
.userDropdownItem.signout:active .dropdownItemIcon {
    color: #DC2626;
}

/* Sign In Button Animation */
@keyframes buttonPulse {
    0% { box-shadow: 0 0 0 0 rgba(0, 255, 240, 0.4); }
    70% { box-shadow: 0 0 0 10px rgba(0, 255, 240, 0); }
    100% { box-shadow: 0 0 0 0 rgba(0, 255, 240, 0); }
}

.signInButton {
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 0.8rem 1.8rem;
  font-size: 1.2rem;
  border-radius: 5px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s ease, transform 0.2s ease-out;
  
  /* Periodic Pulse Animation */
  animation: buttonPulse 3s infinite;
}

[data-theme="dark"] .signInButton {
  color: var(--bg-primary);
}

@media (hover: hover) {
  .signInButton:hover  {
    opacity: 0.85;
    transform: scale(1.05);
    /* Pause animation on hover to avoid jitter */
    animation: none;
  }
  .signInButton:active  {
    opacity: 0.85;
    transform: scale(1.05);
  }
}
.signInButton:active {
  opacity: 0.85;
  transform: scale(1.05);
}

@media (max-width: 768px) {
  .signInButton {
    padding: 0.6rem 0.9rem;
    font-size: 1.3rem;
  }
}

--- END OF FILE components/UserProfile.module.css ---

================================================================================

--- START OF FILE components/UserProfile.tsx ---

// components/UserProfile.tsx
'use client';

import { useSession, signOut } from 'next-auth/react';
import Image from 'next/image';
import Link from 'next/link';
import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { UserCircleIcon, UserSettings01Icon, AllBookmarkIcon, Logout03Icon } from '@/components/icons/index';
import SignInModal from './SignInModal';
import styles from './UserProfile.module.css';

const UserProfile = () => {
    const { data: session, status } = useSession();
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const dropdownRef = useRef<HTMLDivElement>(null);
    const { setSignInModalOpen } = useUserStore();

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
                setIsDropdownOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    if (status === 'loading') {
        return <div className={styles.userAvatarSkeleton} />;
    }

    const avatarSrc = session?.user?.image || '/default-avatar.svg';

    if (session && session.user) {
        const userInitial = session.user.name ? session.user.name.charAt(0).toUpperCase() : '?';

        return (
            <div className={styles.userProfileContainer} ref={dropdownRef}>
                <motion.button
                    className={styles.userAvatarButton}
                    onClick={() => setIsDropdownOpen(!isDropdownOpen)}
                    aria-label="فتح قائمة المستخدم"
                    animate={{ scale: isDropdownOpen ? 1.1 : 1, rotate: isDropdownOpen ? -15 : 0 }}
                    transition={{ type: 'spring', stiffness: 400, damping: 15 }}
                >
                    {avatarSrc ? (
                        <Image
                            src={avatarSrc}
                            alt={session.user.name || 'User Avatar'}
                            width={36}
                            height={36}
                            className={styles.userAvatar}
                            // FIX: Disable Vercel Image Optimization for external auth provider avatars
                            // to save on "Fast Origin Transfer" and Image Optimization limits.
                            unoptimized
                        />
                    ) : (
                        <div className={styles.userAvatarFallback}><span>{userInitial}</span></div>
                    )}
                </motion.button>

                <AnimatePresence>
                    {isDropdownOpen && (
                        <motion.div
                            className={styles.userDropdown}
                            initial={{ opacity: 0, scale: 0.95, y: -10 }}
                            animate={{ opacity: 1, scale: 1, y: 0 }}
                            exit={{ opacity: 0, scale: 0.95, y: -10 }}
                            transition={{ duration: 0.2, ease: 'easeOut' }}
                        >
                            <div className={styles.dropdownUserInfo}>
                                <p className={styles.dropdownUserName}>{session.user.name}</p>
                                <p className={styles.dropdownUserEmail}>{session.user.email}</p>
                            </div>
                            <div className={styles.userDropdownDivider} />
                            
                            {(session.user as any).username && (
                                <Link href={`/profile/${(session.user as any).username}`} className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)} prefetch={false}>
                                    <UserCircleIcon className={styles.dropdownItemIcon} />
                                    <span>ملفك الشخصي</span>
                                </Link>
                            )}

                            <Link href="/profile" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)} prefetch={false}>
                                <UserSettings01Icon className={styles.dropdownItemIcon} />
                                <span>الإعدادات</span>
                            </Link>
                            <Link href="/profile/bookmarks" className={`${styles.userDropdownItem} no-underline`} onClick={() => setIsDropdownOpen(false)} prefetch={false}>
                                <AllBookmarkIcon className={styles.dropdownItemIcon} />
                                <span>المحفوظات</span>
                            </Link>
                            
                            <div className={styles.userDropdownDivider} />
                            <button onClick={() => signOut()} className={`${styles.userDropdownItem} ${styles.signout}`}>
                                <Logout03Icon className={styles.dropdownItemIcon} />
                                <span>تسجيل الخروج</span>
                            </button>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        );
    }

    return (
        <>
            <button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton}
            >
                تسجيل الدخول
            </button>
            <SignInModal />
        </>
    );
};

export default UserProfile;

--- END OF FILE components/UserProfile.tsx ---

================================================================================

--- START OF FILE components/UserStoreHydration.tsx ---

// components/UserStoreHydration.tsx
'use client';

import { useEffect, useRef } from 'react';
import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import { useNotificationStore } from '@/lib/notificationStore';
import { useContentStore } from '@/lib/contentStore'; 
import { useRouter, usePathname } from 'next/navigation';

export default function UserStoreHydration({ 
    universalData,
}: { 
    universalData?: any,
}) {
    const { data: session, status } = useSession();
    const router = useRouter();
    const pathname = usePathname();
    
    const { syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb } = useUserStore();
    const { setNotifications, setUnreadCount } = useNotificationStore();
    const { hydrateUniversal } = useContentStore();
    
    const lastSyncedUserId = useRef<string | null>(null);
    const hasHandledOnboarding = useRef(false);
    const hasHydratedStatic = useRef(false);

    // UNIVERSAL HYDRATION (SYNCHRONOUS EXECUTION)
    // Only if explicitly passed (which is now mostly handled by HomepageHydrator or the Loader)
    if (!hasHydratedStatic.current && universalData) {
        hasHydratedStatic.current = true;
        hydrateUniversal(universalData);
    }

    const currentUserId = (session?.user as any)?.id;

    useEffect(() => {
        // Handle Onboarding
        if (status === 'authenticated' && (session as any)?.needsOnboarding && !hasHandledOnboarding.current) {
            if (pathname !== '/welcome') {
                hasHandledOnboarding.current = true;
                const callbackUrl = pathname !== '/' ? `?callbackUrl=${encodeURIComponent(pathname)}` : '';
                router.push(`/welcome${callbackUrl}`);
            }
            return; 
        }

        if (status === 'loading') return;

        // Handle User Data Hydration (Notifications, Likes, etc.)
        if (status === 'authenticated') {
            const needsSync = !isSyncedWithDb || (currentUserId && lastSyncedUserId.current !== currentUserId);

            if (needsSync && currentUserId) {
                fetch('/api/user/init')
                    .then(res => res.json())
                    .then(result => {
                        if (result.success) {
                            if (result.userState) {
                                syncWithDb(result.userState);
                                setIsSyncedWithDb(true);
                            }
                            
                            if (result.notifications) {
                                setNotifications(result.notifications.items || []);
                                setUnreadCount(result.notifications.unreadCount || 0);
                            }

                            lastSyncedUserId.current = currentUserId;
                        }
                    })
                    .catch(err => console.error("Failed to hydrate user data:", err));
            }
        } 
        else if (status === 'unauthenticated') {
            if (_hasHydrated && lastSyncedUserId.current !== null) {
                reset();
                setNotifications([]);
                setUnreadCount(0);
                lastSyncedUserId.current = null;
                setIsSyncedWithDb(false); 
            }
        }
    }, [status, session, currentUserId, router, syncWithDb, reset, _hasHydrated, isSyncedWithDb, setIsSyncedWithDb, setNotifications, setUnreadCount, pathname]);

    return null;
}

--- END OF FILE components/UserStoreHydration.tsx ---

================================================================================

--- START OF FILE components/about/EditTeamModal.tsx ---

// components/about/EditTeamModal.tsx
'use client';

import React, { useState, useEffect, useTransition, useMemo, useRef } from 'react';
import { getAllStaffAction } from '@/app/actions/homepageActions';
import { updateAboutPageAction } from '@/app/actions/aboutActions';
import { useToast } from '@/lib/toastStore';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { sanityLoader } from '@/lib/sanity.loader';

type Creator = { _id: string; name: string; username?: string; image?: any };

// Reusable creator selector popover
const CreatorSelector = ({ label, allStaff, selected, onSelect }: { label: string, allStaff: Creator[], selected: Creator | null, onSelect: (c: Creator | null) => void }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [search, setSearch] = useState('');
    const ref = useRef<HTMLDivElement>(null);

    const filtered = useMemo(() => 
        allStaff.filter(s => s.name.toLowerCase().includes(search.toLowerCase())), 
    [allStaff, search]);

    return (
        <div ref={ref} style={{ position: 'relative' }}>
            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 600 }}>{label}</label>
            <div className="profile-input" onClick={() => setIsOpen(true)} style={{ cursor: 'pointer', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <span>{selected?.name || 'اختر عضوًا...'}</span>
                {selected && <button onClick={(e) => { e.stopPropagation(); onSelect(null); }} style={{background:'none', border:'none', color:'#DC2626', cursor:'pointer'}}>x</button>}
            </div>
            {isOpen && (
                <div style={{ position: 'absolute', top: '100%', left: 0, right: 0, background: 'var(--bg-secondary)', border: '1px solid var(--border-color)', zIndex: 10, borderRadius: '8px', marginTop: '0.5rem', padding: '0.5rem' }}>
                    <input type="search" value={search} onChange={e => setSearch(e.target.value)} placeholder="بحث..." className="profile-input" style={{ marginBottom: '0.5rem' }} autoFocus />
                    <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
                        {filtered.map(staff => <button key={staff._id} onClick={() => { onSelect(staff); setIsOpen(false); }} className="country-picker-button">{staff.name}</button>)}
                    </div>
                </div>
            )}
        </div>
    );
};

const TeamSelector = ({ label, allStaff, selected, onUpdate }: { label: string, allStaff: Creator[], selected: Creator[], onUpdate: (team: Creator[]) => void }) => {
    const add = (c: Creator) => { if (!selected.find(s => s._id === c._id)) onUpdate([...selected, c]); };
    const remove = (id: string) => onUpdate(selected.filter(s => s._id !== id));

    return (
        <div style={{ borderTop: '1px solid var(--border-color)', paddingTop: '1.5rem', marginTop: '1.5rem' }}>
            <label style={{ fontWeight: 600, fontSize: '1.6rem' }}>{label}</label>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem', margin: '1rem 0', padding: '0.5rem', background:'var(--bg-primary)', borderRadius:'8px' }}>
                {selected.map(c => <div key={c._id} style={{ display:'flex', alignItems:'center', gap:'0.5rem', background:'var(--bg-secondary)', padding:'0.2rem 0.8rem', borderRadius:'99px' }}>{c.name} <button onClick={() => remove(c._id)} style={{background:'none',border:'none',color:'#DC2626',cursor:'pointer'}}>x</button></div>)}
            </div>
            <CreatorSelector label={`إضافة إلى ${label}`} allStaff={allStaff.filter(s => !selected.some(c => c._id === s._id))} selected={null} onSelect={(c) => c && add(c)} />
        </div>
    );
};

export default function EditTeamModal({ currentTeam, onClose, onSave }: { currentTeam: any, onClose: () => void, onSave: (data: any) => void }) {
    const [allStaff, setAllStaff] = useState<Creator[]>([]);
    const [ceo, setCeo] = useState<Creator | null>(currentTeam?.ceo || null);
    const [headOfComm, setHeadOfComm] = useState<Creator | null>(currentTeam?.headOfCommunication || null);
    const [headOfReviews, setHeadOfReviews] = useState<Creator | null>(currentTeam?.headOfReviews || null);
    const [editorInChief, setEditorInChief] = useState<Creator | null>(currentTeam?.editorInChief || null);
    const [headOfVisuals, setHeadOfVisuals] = useState<Creator | null>(currentTeam?.headOfVisuals || null);
    const [reporters, setReporters] = useState<Creator[]>(currentTeam?.reportersSection || []);
    const [authors, setAuthors] = useState<Creator[]>(currentTeam?.authorsSection || []);
    const [designers, setDesigners] = useState<Creator[]>(currentTeam?.designersSection || []);
    const [isFetching, startFetch] = useTransition();
    const [isSaving, startSave] = useTransition();
    const toast = useToast();

    useEffect(() => {
        startFetch(async () => {
            const staff = await getAllStaffAction();
            setAllStaff(staff);
        });
    }, []);

    const handleSave = () => {
        startSave(async () => {
            const dataToSave = {
                ceo: ceo?._id || null,
                headOfCommunication: headOfComm?._id || null,
                headOfReviews: headOfReviews?._id || null,
                editorInChief: editorInChief?._id || null,
                headOfVisuals: headOfVisuals?._id || null,
                reportersSection: reporters.map(c => c._id),
                authorsSection: authors.map(c => c._id),
                designersSection: designers.map(c => c._id),
            };
            const result = await updateAboutPageAction(dataToSave);
            if (result.success) {
                // To reflect changes without a full reload, we need to pass back the full objects
                const updatedData = { ceo, headOfCommunication: headOfComm, headOfReviews, editorInChief, headOfVisuals, reportersSection: reporters, authorsSection: authors, designersSection: designers };
                onSave(updatedData);
                toast.success(result.message);
                onClose();
            } else {
                toast.error(result.message);
            }
        });
    };

    return (
        <Modal isOpen={true} onClose={onClose} style={{ maxWidth: '600px', height: '80vh', display: 'flex', flexDirection: 'column' }}>
            <h3 style={{ marginTop: 0 }}>تعديل هيكل الفريق</h3>
            <div style={{ flexGrow: 1, overflowY: 'auto', padding: '1rem', margin: '-1rem' }}>
                {isFetching ? <div className="spinner" /> : (
                    <>
                        <CreatorSelector label="المؤسس (CEO)" allStaff={allStaff} selected={ceo} onSelect={setCeo} />
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginTop: '2rem' }}>
                            <CreatorSelector label="رئيس التحرير" allStaff={allStaff} selected={editorInChief} onSelect={setEditorInChief} />
                            <CreatorSelector label="رئيس المراجعات" allStaff={allStaff} selected={headOfReviews} onSelect={setHeadOfReviews} />
                            <CreatorSelector label="رئيس التواصل" allStaff={allStaff} selected={headOfComm} onSelect={setHeadOfComm} />
                            <CreatorSelector label="رئيس المرئيات" allStaff={allStaff} selected={headOfVisuals} onSelect={setHeadOfVisuals} />
                        </div>
                        <TeamSelector label="فريق الأخبار" allStaff={allStaff} selected={reporters} onUpdate={setReporters} />
                        <TeamSelector label="فريق التحرير" allStaff={allStaff} selected={authors} onUpdate={setAuthors} />
                        <TeamSelector label="فريق التصميم" allStaff={allStaff} selected={designers} onUpdate={setDesigners} />
                    </>
                )}
            </div>
            <div className={modalStyles.modalActions} style={{ marginTop: 'auto', paddingTop: '2rem' }}>
                <button onClick={onClose} className="outline-button">إلغاء</button>
                <button onClick={handleSave} className="primary-button" disabled={isSaving}>
                    {isSaving ? 'جارٍ الحفظ...' : 'حفظ'}
                </button>
            </div>
        </Modal>
    );
}

--- END OF FILE components/about/EditTeamModal.tsx ---

================================================================================

--- START OF FILE components/about/StaffCard.tsx ---

// components/about/StaffCard.tsx
'use client';

import React from 'react';
import Image from 'next/image';
import Link from 'next/link';
import { sanityLoader } from '@/lib/sanity.loader';

interface StaffCardProps {
    name: string;
    username: string | null;
    imageUrl: string;
}

export default function StaffCard({ name, username, imageUrl }: StaffCardProps) {
    const profileLink = username ? `/creators/${username}` : null;

    const Content = (
        <div style={{ 
            backgroundColor: 'var(--bg-secondary)', 
            border: '1px solid var(--border-color)', 
            borderRadius: '12px', 
            padding: '2rem',
            textAlign: 'center',
            height: '100%',
            transition: 'transform 0.2s ease, border-color 0.2s ease',
            cursor: profileLink ? 'pointer' : 'default'
        }}
        className="staff-card-inner"
        >
            <div style={{ 
                width: '100px', 
                height: '100px', 
                borderRadius: '50%', 
                overflow: 'hidden', 
                margin: '0 auto 1.5rem auto',
                border: '2px solid var(--border-color)',
                position: 'relative'
            }}>
                <Image 
                    loader={sanityLoader}
                    src={imageUrl} 
                    alt={name} 
                    fill 
                    style={{ objectFit: 'cover' }} 
                />
            </div>
            <h3 style={{ fontSize: '1.8rem', margin: '0 0 0.5rem 0', color: 'var(--text-primary)' }}>
                {name}
            </h3>
            {username && (
                <p style={{ fontSize: '1.4rem', color: 'var(--accent)', margin: 0, direction: 'ltr' }}>
                    @{username}
                </p>
            )}
            
            <style jsx>{`
                .staff-card-inner:hover {
                    transform: translateY(-5px);
                    border-color: var(--accent) !important;
                }
            `}</style>
        </div>
    );

    if (profileLink) {
        return (
            <Link href={profileLink} className="no-underline" style={{ display: 'block', height: '100%' }}>
                {Content}
            </Link>
        );
    }

    return (
        <div style={{ display: 'block', height: '100%' }}>
            {Content}
        </div>
    );
}

--- END OF FILE components/about/StaffCard.tsx ---

================================================================================

--- START OF FILE components/comments/CommentForm.tsx ---

// components/comments/CommentForm.tsx
'use client';
import { useState, useTransition, FormEvent } from 'react';
import { Session } from 'next-auth';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import ButtonLoader from '@/components/ui/ButtonLoader';
import styles from './Comments.module.css';
import { useToast } from '@/lib/toastStore'; // FIX: Import Toast

export default function CommentForm({
    slug,
    session,
    parentId,
    onPostComment,
    onReplySuccess,
}: {
    slug: string;
    session: Session | null;
    parentId?: string;
    // Update type to reflect it returns a result object now
    onPostComment: (content: string, parentId?: string) => Promise<any>; 
    onReplySuccess?: () => void;
}) {
    const [commentText, setCommentText] = useState('');
    const [isPending, startTransition] = useTransition();
    const isButtonDisabled = isPending || commentText.trim().length === 0;
    const { error: toastError } = useToast(); // FIX: Use Toast Hook

    const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        const content = commentText;
        if (content.trim().length === 0) return;

        startTransition(async () => {
            const result = await onPostComment(content, parentId);
            
            // FIX: Check result success
            if (result && !result.success) {
                // Show error toast if rate limited or validaton failed
                toastError(result.error || "حدث خطأ أثناء نشر التعليق.");
                // Do NOT clear text so user doesn't lose their comment
            } else {
                // Only clear on success
                setCommentText('');
                if (parentId && onReplySuccess) {
                    onReplySuccess();
                }
            }
        });
    };

    return (
        <div className={styles.commentFormWrapper}>
            <div className={styles.commentFormAvatar}>
                <Image src={session!.user.image || '/default-avatar.svg'} alt={session!.user.name || 'User Avatar'} width={40} height={40} className="user-avatar" />
            </div>
            <div className={styles.commentFormMain}>
                <form onSubmit={handleSubmit}>
                    <textarea
                        name="comment"
                        placeholder="أدلِ برأيك..."
                        required
                        className="profile-input" 
                        disabled={isPending}
                        value={commentText}
                        onChange={(e) => setCommentText(e.target.value)}
                    />
                    <div className={styles.commentEditActions}>
                        <motion.button type="submit" className={`${isButtonDisabled ? 'outline-button' : 'primary-button'}`} disabled={isButtonDisabled} animate={{ width: isPending ? '44px' : 'auto', height: '44px', borderRadius: isPending ? '50%' : '5px' }}>
                            <AnimatePresence mode="wait">{isPending ? <ButtonLoader key="loader" /> : <motion.span key="text" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{parentId ? 'أضف ردًا' : 'انشر التعليق'}</motion.span>}</AnimatePresence>
                        </motion.button>
                        {parentId && (<button type="button" onClick={onReplySuccess} className="outline-button">إلغاء</button>)}
                    </div>
                </form>
            </div>
        </div>
    );
}

--- END OF FILE components/comments/CommentForm.tsx ---

================================================================================

--- START OF FILE components/comments/CommentItem.tsx ---

// components/comments/CommentItem.tsx
'use client';
import { motion, AnimatePresence } from 'framer-motion';
import { Session } from 'next-auth';
import { useState, useTransition } from 'react';
import { deleteComment, updateComment, getReplies } from '@/app/actions/commentActions';
import ConfirmationModal from '../ConfirmationModal';
import CommentVoteButtons from './CommentVoteButtons';
import CommentForm from './CommentForm';
import Link from 'next/link';
import Image from 'next/image';
import TimeStamp from './TimeStamp';
import ActionButton from '../ActionButton';
import styles from './Comments.module.css';

const ReplyIcon = () => ( <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"> <polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path> </svg> );
const EditIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>;
const DeleteIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>;
const animationVariants = { initial: { opacity: 0, y: -10 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 10 } };

export default function CommentItem({ comment, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comment: any;
    session: Session | null;
    slug: string;
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
    // FIX: Updated return type from Promise<void> to Promise<any>
    onPostReply: (content: string, parentId?: string) => Promise<any>;
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    const [isPending, startTransition] = useTransition();
    const [isEditing, setIsEditing] = useState(false);
    const [editText, setEditText] = useState(comment.content);
    const [showDeleteModal, setShowDeleteModal] = useState(false);
    const [isReplying, setIsReplying] = useState(false);
    const [replies, setReplies] = useState<any[]>(comment.replies || []);
    const [areRepliesVisible, setAreRepliesVisible] = useState(true);
    const [isLoadingReplies, setIsLoadingReplies] = useState(false);
    const replyCount = comment._count?.replies || 0;
    
    const userRoles = (session?.user as any)?.roles || [];
    const isAuthor = session?.user?.id === comment.author.id;
    const isModerator = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    const canDelete = isAuthor || isModerator;

    const handleToggleReplies = async () => { if (areRepliesVisible) { setAreRepliesVisible(false); return; } setIsLoadingReplies(true); setAreRepliesVisible(true); if (replies.length < replyCount) { const result = await getReplies(comment.id); if (result.success) { setReplies(result.replies as any[]); } } setIsLoadingReplies(false); };
    
    const handleDeleteConfirm = () => {
        startTransition(async () => {
            const result = await deleteComment(comment.id);
            if (result.success) {
                onDeleteSuccess(result.deletedId || comment.id, result.wasDeleted ?? false, result.updatedComment);
            }
            setShowDeleteModal(false);
        });
    };

    const handleUpdate = () => {
        startTransition(async () => {
            const result = await updateComment(comment.id, editText);
            if(result.success && result.updatedComment) {
                onUpdateSuccess(result.updatedComment);
            }
            setIsEditing(false);
        });
    };
    
    const DeletedState = () => ( <div className={`${styles.commentItem} ${styles.deleted}`}> <div className={styles.commentAuthorInfo}> <div className={styles.deletedAvatar} /> <div> <p className={`${styles.commentAuthorLink} ${styles.deleted}`}>طُمِسَ التعليق</p> <TimeStamp date={comment.createdAt} /> </div> </div> </div> );

    if (comment.isDeleted) { return ( <> <DeletedState /> {replyCount > 0 && ( <div className={styles.commentRepliesList}> {(replies || []).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </> ); }

    return ( <> <motion.div className={styles.commentItem} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }}> <div className={styles.commentHeader}> <div className={styles.commentAuthorInfo}>
        <Link href={`/profile/${comment.author.username}`} prefetch={false}><Image src={comment.author.image || '/default-avatar.svg'} alt={comment.author.name || 'User Avatar'} width={40} height={40} className="user-avatar" /></Link>
        <div className={styles.authorAndTimestamp}>
            <Link 
                href={`/profile/${comment.author.username}`} 
                prefetch={false}
                className={`${styles.commentAuthorLink} no-underline ${comment.isOptimistic ? styles.pulsingText : ''}`}
            >
                {comment.author.name}
            </Link>
            {!comment.isOptimistic && <TimeStamp date={comment.createdAt} />}
        </div>
    </div> 
    {session?.user && !comment.isOptimistic && ( <ActionButton onClick={() => setIsReplying(!isReplying)} aria-label="Reply" disabled={isPending}> <ReplyIcon /> </ActionButton> )} 
    </div> <AnimatePresence mode="wait"> {!isEditing ? ( <motion.div key="display" variants={animationVariants} initial="initial" animate="animate" exit="exit"> 
    <div className={styles.commentBody}>
        <p className={comment.isOptimistic ? styles.pulsingText : ''}>{comment.content}</p>
    </div> 
    <div className={styles.commentFooter}> 
    {!comment.isOptimistic && (
        <>
            <CommentVoteButtons commentId={comment.id} initialVotes={comment.votes} onVoteUpdate={onVoteUpdate} /> 
            {replyCount > 0 && (<button onClick={handleToggleReplies} className={`outline-button ${styles.viewRepliesButton}`} disabled={isLoadingReplies}>{isLoadingReplies ? 'جارٍ التحميل...' : areRepliesVisible ? 'إخفاء الردود' : `عرض ${replyCount} ${replyCount > 1 ? 'ردود' : 'رد'}`}</button>)} 
            {(isAuthor || canDelete) && ( <div className={styles.commentAuthorActions}>
                {isAuthor && <ActionButton onClick={() => setIsEditing(true)} aria-label="Edit" disabled={isPending}><EditIcon /></ActionButton>}
                {canDelete && <ActionButton onClick={() => setShowDeleteModal(true)} aria-label="Delete" disabled={isPending}><DeleteIcon /></ActionButton>}
            </div> )}
        </>
    )}
    </div> </motion.div> ) : ( <motion.div key="edit" variants={animationVariants} initial="initial" animate="animate" exit="exit" className={styles.commentEditForm}> <textarea defaultValue={comment.content} onChange={(e) => setEditText(e.target.value)} className="profile-input" disabled={isPending} autoFocus /> <div className={styles.commentEditActions}> <button onClick={handleUpdate} className="primary-button" disabled={isPending || editText.trim() === ''}>حفظ</button> <button onClick={() => setIsEditing(false)} className="outline-button" disabled={isPending}>إلغاء</button> </div> </motion.div> )} </AnimatePresence> <AnimatePresence> {isReplying && ( <motion.div className={styles.commentReplyFormContainer} variants={animationVariants} initial="initial" animate="animate" exit="exit"> <CommentForm slug={slug} session={session} parentId={comment.id} onPostComment={onPostReply} onReplySuccess={() => setIsReplying(false)} /> </motion.div> )} </AnimatePresence> {areRepliesVisible && ( <div className={styles.commentRepliesList}> {isLoadingReplies && <div className="spinner" />} {!isLoadingReplies && (replies).map((reply: any) => ( <CommentItem key={reply.id} comment={reply} session={session} slug={slug} onVoteUpdate={onVoteUpdate} onPostReply={onPostReply} onDeleteSuccess={onDeleteSuccess} onUpdateSuccess={onUpdateSuccess} /> ))} </div> )} </motion.div> <ConfirmationModal isOpen={showDeleteModal} onClose={() => setShowDeleteModal(false)} onConfirm={handleDeleteConfirm} title="حذف التعليق" message="أمتأكدٌ من الحذف؟" /> </> );
}

--- END OF FILE components/comments/CommentItem.tsx ---

================================================================================

--- START OF FILE components/comments/CommentList.tsx ---

// components/comments/CommentList.tsx
'use client';
import CommentItem from './CommentItem';
import type { Session } from 'next-auth';
import styles from './Comments.module.css';

export default function CommentList({ comments, session, slug, onVoteUpdate, onPostReply, onDeleteSuccess, onUpdateSuccess }: {
    comments: any[],
    session: Session | null,
    slug: string,
    onVoteUpdate: (commentId: string, newVotes: any[]) => void,
    // FIX: Updated return type from Promise<void> to Promise<any>
    onPostReply: (content: string, parentId?: string) => Promise<any>,
    onDeleteSuccess: (deletedId: string, wasDeleted: boolean, updatedComment?: any) => void,
    onUpdateSuccess: (updatedComment: any) => void,
}) {
    if (comments.length === 0) {
        return <p style={{ textAlign: 'center', color: 'var(--text-secondary)', marginTop: '4rem' }}>كن أول من يخط حرفًا هنا.</p>
    }
    return (
        <div className={`${styles.commentList} gpu-cull`}>
            {comments.map(comment => (
                <CommentItem
                    key={comment.id}
                    comment={comment}
                    session={session}
                    slug={slug}
                    onVoteUpdate={onVoteUpdate}
                    onPostReply={onPostReply}
                    onDeleteSuccess={onDeleteSuccess}
                    onUpdateSuccess={onUpdateSuccess}
                />
            ))}
        </div>
    )
}

--- END OF FILE components/comments/CommentList.tsx ---

================================================================================

--- START OF FILE components/comments/CommentSection.tsx ---

// components/comments/CommentSection.tsx
'use client';

import { useState, useOptimistic, useEffect, useRef } from 'react';
import { useSession } from 'next-auth/react';
import type { Session } from 'next-auth';
import { postReplyOrComment } from '@/app/actions/commentActions';
import CommentForm from './CommentForm';
import SignInPrompt from './SignInPrompt';
import CommentList from './CommentList';
import styles from './Comments.module.css';
import { useInView } from 'framer-motion';

const addReplyToState = (comments: any[], parentId: string, reply: any): any[] => {
    return comments.map(comment => {
        if (comment.id === parentId) {
            const updatedReplies = comment.replies ? [...comment.replies, reply] : [reply];
            return { ...comment, replies: updatedReplies, _count: { replies: (comment._count?.replies || 0) + 1 } };
        }
        if (comment.replies && comment.replies.length > 0) {
            return { ...comment, replies: addReplyToState(comment.replies, parentId, reply) };
        }
        return comment;
    });
};

export default function CommentSection({ 
    slug, 
    contentType, 
    initialComments 
}: { 
    slug: string; 
    contentType: string; 
    initialComments?: any[]; 
}) {
    const { data: session } = useSession();
    const typedSession = session as unknown as Session | null;

    const containerRef = useRef(null);
    const isInView = useInView(containerRef, { once: true, amount: 0.1 });

    const shouldFetch = !initialComments;
    const [comments, setComments] = useState<any[]>(initialComments || []);
    const [loading, setLoading] = useState(shouldFetch);
    const currentPath = `/${contentType}/${slug}`;

    useEffect(() => {
        if (!shouldFetch || !isInView) return;

        const fetchComments = async () => {
            try {
                const res = await fetch(`/api/comments/${slug}`);
                if (res.ok) {
                    const data = await res.json();
                    setComments(data);
                }
            } catch (error) {
                console.error("Failed to load comments", error);
            } finally {
                setLoading(false);
            }
        };

        fetchComments();
    }, [slug, shouldFetch, isInView]);

    const [optimisticComments, addOptimisticComment] = useOptimistic(
        comments,
        (state, { newComment, parentId }) => {
            if (parentId) {
                return addReplyToState(state, parentId, newComment);
            }
            return [newComment, ...state];
        }
    );

    // FIX: Changed return type to Promise<any> to pass result back to form
    const handlePostComment = async (content: string, parentId?: string) => {
        if (!typedSession?.user?.id) return { success: false, error: "Not authenticated" };

        const optimisticComment = {
            id: crypto.randomUUID(),
            content,
            parentId,
            createdAt: new Date().toISOString(),
            author: typedSession.user,
            authorId: typedSession.user.id,
            votes: [],
            replies: [],
            _count: { replies: 0 },
            isOptimistic: true,
        };

        addOptimisticComment({ newComment: optimisticComment, parentId });

        const result = await postReplyOrComment(slug, content, currentPath, parentId);

        if (result.success && result.comment) {
            setComments(currentComments => {
                if (parentId) {
                     return addReplyToState(currentComments, parentId, result.comment)
                        .filter(c => c.id !== optimisticComment.id);
                }
                return [result.comment, ...currentComments.filter(c => c.id !== optimisticComment.id)];
            });
        }
        
        // Return result so CommentForm knows if it failed (e.g. Rate Limit)
        return result;
    };
    
    const handleVoteUpdate = (commentId: string, newVotes: any[]) => {
        const updateVotesRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(comment => {
                if (comment.id === commentId) return { ...comment, votes: newVotes };
                if (comment.replies) return { ...comment, replies: updateVotesRecursive(comment.replies) };
                return comment;
            });
        };
        setComments(prevComments => updateVotesRecursive(prevComments));
    };

    const handleDeleteSuccess = (deletedId: string, wasDeleted: boolean, updatedComment?: any) => {
        const removeOrUpdateRecursive = (commentsList: any[]): any[] => {
            if (wasDeleted) {
                return commentsList.filter(c => {
                    if (c.replies) c.replies = removeOrUpdateRecursive(c.replies);
                    return c.id !== deletedId;
                });
            } else {
                return commentsList.map(c => {
                    if (c.id === deletedId) return updatedComment;
                    if (c.replies) return { ...c, replies: removeOrUpdateRecursive(c.replies) };
                    return c;
                });
            }
        };
        setComments(prevComments => removeOrUpdateRecursive(prevComments));
    };

    const handleUpdateSuccess = (updatedComment: any) => {
        const updateRecursive = (commentsList: any[]): any[] => {
            return commentsList.map(c => {
                if (c.id === updatedComment.id) return updatedComment;
                if (c.replies) return { ...c, replies: updateRecursive(c.replies) };
                return c;
            });
        };
        setComments(prevComments => updateRecursive(prevComments));
    };

    return (
        <div ref={containerRef} className={styles.commentsSection}>
            {typedSession?.user ? (
                <CommentForm slug={slug} session={typedSession} onPostComment={handlePostComment} />
            ) : (
                <SignInPrompt />
            )}
            
            <div style={{ minHeight: '200px' }}>
                {loading ? (
                    <div className="spinner" style={{ margin: '4rem auto' }} />
                ) : (
                    <CommentList
                        comments={optimisticComments}
                        session={typedSession}
                        slug={slug}
                        onVoteUpdate={handleVoteUpdate}
                        onPostReply={handlePostComment}
                        onDeleteSuccess={handleDeleteSuccess}
                        onUpdateSuccess={handleUpdateSuccess}
                    />
                )}
            </div>
        </div>
    );
}

--- END OF FILE components/comments/CommentSection.tsx ---

================================================================================

--- START OF FILE components/comments/CommentVoteButtons.tsx ---

// components/comments/CommentVoteButtons.tsx
'use client';
import { useTransition, useOptimistic, useRef } from 'react';
import { voteOnComment } from '@/app/actions/commentActions';
import { VoteType } from '@/lib/generated/client';
import { useUserStore } from '@/lib/store';
import { useSession } from 'next-auth/react';
import { motion, useAnimationControls } from 'framer-motion';
import styles from './Comments.module.css';

const ThumbsUpIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" as const }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
const ThumbsDownIcon = ({ isActive }: { isActive: boolean }) => ( <motion.svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style={{ transform: 'scaleY(-1)' }}> <motion.path d="M3,21a1,1,0,0,1-1-1V12a1,1,0,0,1,1-1H6V21ZM19.949,10H14.178V5c0-2-3.076-2-3.076-2s0,4-1.026,5C9.52,8.543,8.669,10.348,8,11V21H18.644a2.036,2.036,0,0,0,2.017-1.642l1.3-7A2.015,2.015,0,0,0,19.949,10Z" initial={false} animate={{ fill: isActive ? "currentColor" : "rgba(0,0,0,0)" }} transition={{ duration: 0.2, ease: "easeOut" as const }} stroke="currentColor" strokeWidth="1" /> </motion.svg> );
type Vote = { userId: string; type: VoteType; };
const buttonVariants = { inactive: { scale: 1 }, active: { scale: [1, 1.3, 1.1], transition: { duration: 0.4, ease: "easeOut" as const } } }
const countVariants = { initial: { y: 10, opacity: 0 }, animate: { y: 0, opacity: 1 }, exit: { y: -10, opacity: 0 }, transition: { type: 'spring' as const, stiffness: 400, damping: 20 } };


export default function CommentVoteButtons({ commentId, initialVotes, onVoteUpdate }: { 
    commentId: string; 
    initialVotes: Vote[];
    onVoteUpdate: (commentId: string, newVotes: any[]) => void;
}) {
    const { data: session } = useSession();
    const setSignInModalOpen = useUserStore((s) => s.setSignInModalOpen);
    const [_, startTransition] = useTransition(); 
    const latestRequestRef = useRef(0);
    const likeControls = useAnimationControls();
    const dislikeControls = useAnimationControls();

    const [optimisticVotes, setOptimisticVotes] = useOptimistic(initialVotes, (state, newVote: { voteType: VoteType; userId: string }) => {
        const existingVoteIndex = state.findIndex(v => v.userId === newVote.userId);
        if (existingVoteIndex > -1) {
            const existingVote = state[existingVoteIndex];
            if (existingVote.type === newVote.voteType) { return state.filter(v => v.userId !== newVote.userId); } 
            else { return state.map(v => v.userId === newVote.userId ? { ...v, type: newVote.voteType } : v); }
        } else { return [...state, { userId: newVote.userId, type: newVote.voteType }]; }
    });

    const likes = optimisticVotes.filter(v => v.type === 'LIKE').length;
    const dislikes = optimisticVotes.filter(v => v.type === 'DISLIKE').length;
    const currentUserVote = optimisticVotes.find(v => v.userId === (session?.user as any)?.id)?.type;

    const handleVote = (voteType: VoteType) => {
        const userId = (session?.user as any)?.id;
        if (!userId) { setSignInModalOpen(true); return; }

        const requestId = ++latestRequestRef.current;
        
        if (voteType === 'LIKE') {
            likeControls.start("active");
        } else {
            dislikeControls.start("active");
        }
        
        startTransition(() => {
            setOptimisticVotes({ voteType, userId });
        });

        voteOnComment(commentId, voteType).then(result => {
            if (requestId === latestRequestRef.current && result.success && result.updatedVotes) {
                onVoteUpdate(commentId, result.updatedVotes);
            }
        });
    };

    return (
        <div className={styles.commentVoteActions}>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'LIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.LIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants} 
                initial={currentUserVote === 'LIKE' ? 'active' : 'inactive'}
                animate={likeControls}
            >
                <ThumbsUpIcon isActive={currentUserVote === 'LIKE'} />
                <motion.span key={likes} variants={countVariants} initial="initial" animate="animate" exit="exit">{likes}</motion.span>
            </motion.button>
            <motion.button 
                className={`${styles.voteButton} ${currentUserVote === 'DISLIKE' ? styles.active : ''}`} 
                onClick={() => handleVote(VoteType.DISLIKE)} 
                whileTap={{ scale: 0.9 }} 
                variants={buttonVariants}
                initial={currentUserVote === 'DISLIKE' ? 'active' : 'inactive'}
                animate={dislikeControls}
            >
                <ThumbsDownIcon isActive={currentUserVote === 'DISLIKE'} />
                <motion.span key={dislikes} variants={countVariants} initial="initial" animate="animate" exit="exit">{dislikes}</motion.span>
            </motion.button>
        </div>
    );
}







--- END OF FILE components/comments/CommentVoteButtons.tsx ---

================================================================================

--- START OF FILE components/comments/Comments.module.css ---

/* components/comments/Comments.module.css */
@keyframes pulse-text {
    0%, 100% {
        color: var(--text-primary);
    }
    50% {
        color: var(--text-secondary);
    }
}

.pulsingText {
    animation: pulse-text 2s ease-in-out infinite;
}

.commentsSection { margin-top: 8rem; padding-top: 4rem; border-top: 1px solid var(--border-color); }
.commentsBlock .commentsSection { margin-top: 0; padding-top: 0; border-top: none; }

/* OPTIMIZATION: Heavy interaction section below fold */
.commentsBlock { 
    margin-top: 8rem; 
    background-color: var(--bg-secondary); 
    border: 1px solid var(--border-color); 
    border-radius: 12px; 
    padding: 3rem; 
    
    content-visibility: auto;
    contain-intrinsic-size: 500px;
}

.commentSigninPrompt { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 4rem; text-align: center; margin-top: 2rem; }
.commentFormWrapper { display: flex; align-items: flex-start; gap: 1.5rem; margin-bottom: 5rem; max-width: 700px; }
.commentFormAvatar { flex-shrink: 0; margin-top: 0.5rem; }
.commentFormMain { flex-grow: 1; }
.commentFormMain .profileInput { min-height: 120px; margin-bottom: 1rem; }

/* GPU CULL FIX: Expanded render boundary for long comment threads */
.commentList { 
    position: relative; 
    max-width: 700px; 
    display: flex; 
    flex-direction: column; 
    gap: 4rem; 
    border-right: 2px solid var(--border-color); 
    padding-right: 3rem; 
    border-left: none; 
    padding-left: 0;
    
    padding-top: 10rem;
    padding-bottom: 10rem;
    margin-top: -10rem;
    margin-bottom: -10rem;
}

.commentItem { position: relative; }
.commentItem::before { content: ''; position: absolute; right: -3.9rem; left: auto; top: 10px; width: 14px; height: 14px; border-radius: 50%; background-color: var(--bg-secondary); border: 3px solid var(--accent); }
.commentHeader { display: flex; align-items: flex-start; justify-content: space-between; gap: 1.2rem; margin-bottom: 1rem; }
.commentAuthorInfo { display: flex; align-items: center; gap: 1.2rem; flex-grow: 1; }
.commentAuthorLink { font-family: var(--font-main), sans-serif; font-weight: 700; font-size: 1.8rem; color: var(--text-primary); transition: color 0.2s ease; }
@media (hover: hover) {@media (hover: hover) {
  
  .commentAuthorLink:hover  { color: var(--accent); }
}

  .commentAuthorLink:active  { color: var(--accent); }
}
.commentAuthorLink:active { color: var(--accent); }


.authorAndTimestamp {
    display: flex;
    align-items: baseline; 
    gap: 0.8rem;
    flex-wrap: wrap;
}
.commentTimestamp {
    font-size: 1.3rem;
    color: var(--text-secondary);
    font-family: var(--font-main), sans-serif;
    margin: 0;
}

.commentBody { padding-right: 52px; padding-left: 0; }
.commentFooter { display: flex; justify-content: space-between; align-items: center; margin-top: 1.5rem; padding-right: 52px; padding-left: 0; flex-wrap: wrap; gap: 1rem; }
.commentVoteActions { display: flex; align-items: center; gap: 1.5rem; }
.commentAuthorActions { display: flex; align-items: center; gap: 0.5rem; }

.viewRepliesButton { margin-left: auto; margin-right: 1.5rem; padding: 0.6rem 1.2rem !important; font-size: 1.3rem !important; }

.voteButton { display: flex; align-items: center; gap: 0.6rem; background: none; border: none; cursor: pointer; color: var(--text-secondary); padding: 0.4rem 0.8rem; margin: 0 -0.8rem; border-radius: 999px; transition: color 0.2s ease, background-color 0.2s ease; }
@media (hover: hover) {@media (hover: hover) {
  
  .voteButton:hover:not(:disabled)  { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }
}

  .voteButton:active:not(:disabled)  { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }
}
.voteButton:active:not(:disabled) { color: var(--accent); background-color: color-mix(in srgb, var(--accent) 15%, transparent); }

.voteButton.active { color: var(--accent); font-weight: 700; }
.commentEditForm { margin-top: 1rem; padding-right: 52px; padding-left: 0; }
.commentEditActions { display: flex; gap: 1rem; }
.commentReplyFormContainer { padding-right: 52px; padding-left: 0; margin-top: 1.5rem; }
.commentReplyFormContainer .commentFormWrapper { margin: 0; padding: 0; }
.commentRepliesList { position: relative; display: flex; flex-direction: column; gap: 3rem; margin-top: 3rem; padding-right: 52px; padding-left: 0; }
.commentRepliesList::before { content: ''; position: absolute; top: 0; right: 20px; left: auto; bottom: 0; width: 2px; background-color: var(--border-color); }
.commentRepliesList .commentItem { padding-right: 0; border-right: none; }
.commentRepliesList .commentItem::before { display: none; }
.commentItem.deleted .commentAuthorInfo { opacity: 0.7; }
.deletedAvatar { width: 40px; height: 40px; border-radius: 50%; background-color: var(--border-color); }
.commentAuthorLink.deleted { color: var(--text-secondary); font-style: italic; }

@media (max-width: 768px) {
    .commentsBlock {
        padding: 1.5rem;
    }
    .commentList {
        padding-right: 1.5rem;
        border-right-width: 1px;
        /* Reset margins on mobile */
        padding-top: 0;
        padding-bottom: 0;
        margin-top: 0;
        margin-bottom: 0;
    }
    .commentItem::before {
        right: -2.3rem;
    }
    .commentBody, .commentFooter, .commentEditForm, .commentReplyFormContainer, .commentRepliesList {
        padding-right: 0;
    }
    .commentRepliesList {
        padding-right: 2rem;
    }
    .commentRepliesList::before {
        right: 0;
    }
    .commentHeader {
        gap: 0.5rem;
    }
    .authorAndTimestamp {
        align-items: flex-start;
        flex-direction: column;
        gap: 0.2rem;
    }
}

--- END OF FILE components/comments/Comments.module.css ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.module.css ---

/* components/comments/SignInPrompt.module.css */

.signInPrompt {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 4rem;
    text-align: center;
    margin-top: 2rem;
}

.signInButton {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 1rem 2.4rem;
    border-radius: 5px;
    font-family: var(--font-ui), sans-serif;
    font-weight: 500;
    cursor: pointer;
    transition: opacity 0.2s ease, transform 0.2s ease;
}

[data-theme="dark"] .signInButton {
    color: var(--bg-primary);
}
@media (hover: hover) {@media (hover: hover) {
  
  .signInButton:hover  {
    opacity: 0.85;
}
}

  .signInButton:active  {
    opacity: 0.85;
}
}
.signInButton:active {
    opacity: 0.85;
}














--- END OF FILE components/comments/SignInPrompt.module.css ---

================================================================================

--- START OF FILE components/comments/SignInPrompt.tsx ---

// components/comments/SignInPrompt.tsx
'use client';

import { useUserStore } from "@/lib/store";
import { motion } from "framer-motion";
import styles from './SignInPrompt.module.css'; // <-- IMPORTED MODULE

export default function SignInPrompt() {
    const { setSignInModalOpen } = useUserStore();

    return (
        <div className={styles.signInPrompt}>
            <h3>شارك في النقاش</h3>
            <p>لتترك تعليقًا، سجِّل دخولك.</p>
            <motion.button
                onClick={() => setSignInModalOpen(true)}
                className={styles.signInButton} // <-- UPDATED CLASS
                whileHover={{ scale: 1.05 }}
                transition={{ type: "spring", stiffness: 400, damping: 15 }}
            >تسجيل الدخول</motion.button>
        </div>
    );
}













--- END OF FILE components/comments/SignInPrompt.tsx ---

================================================================================

--- START OF FILE components/comments/TimeStamp.tsx ---

'use client';
import { useState, useEffect } from 'react';
export default function TimeStamp({ date }: { date: Date }) {
const [displayTime, setDisplayTime] = useState('');
useEffect(() => {
const updateDisplayTime = () => {
const seconds = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
if (seconds < 5) { setDisplayTime("للتو"); return; }
if (seconds < 60) { setDisplayTime(`منذ ${Math.floor(seconds)} ثوانٍ`); return; }
const minutes = seconds / 60;
if (minutes < 60) { setDisplayTime(`منذ ${Math.floor(minutes)} دقائق`); return; }
const hours = minutes / 60;
if (hours < 24) { setDisplayTime(`منذ ${Math.floor(hours)} ساعات`); return; }
setDisplayTime(new Date(date).toLocaleDateString(undefined, { month: 'short', day: 'numeric' }));
};
updateDisplayTime();
const interval = setInterval(updateDisplayTime, 30000); // update every 30 seconds
return () => clearInterval(interval);
}, [date]);
return <p className="comment-timestamp">{displayTime}</p>;
}







--- END OF FILE components/comments/TimeStamp.tsx ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.module.css ---

/* components/constellation/ConstellationControlPanel.module.css */

.container {
    position: absolute;
    bottom: 2rem;
    right: 2rem;
    left: auto;
    z-index: 2001;
}

/* Trigger Button (Matches PerformanceSettings) */
.triggerButton {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-primary);
    padding: 0;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border-radius: 50%;
    background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
    border: 1px solid var(--border-color);
    backdrop-filter: blur(4px);
}

.triggerButton:hover {
    color: var(--accent);
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    transform: rotate(90deg);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 50%, transparent);
}

.triggerButton:active {
    transform: rotate(180deg) scale(0.9);
}

/* Panel Container */
.panel {
    position: absolute;
    bottom: calc(100% + 15px);
    right: 0;
    width: 380px;
    background-color: rgba(10, 11, 15, 0.95);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 2rem;
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.8);
    backdrop-filter: blur(16px);
    transform-origin: bottom right;
    display: flex;
    flex-direction: column;
    gap: 2rem;
    overflow: hidden;
}

:global(body.no-glass) .panel {
    backdrop-filter: none !important;
    background-color: #0A0B0F !important;
}

/* Header */
.header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
}

.headerLeft {
    display: flex;
    align-items: center;
    gap: 1rem;
    color: var(--accent);
}

.headerTitle {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    font-weight: 800;
    color: var(--text-primary);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.closeButton {
    background: none;
    border: none;
    padding: 0.5rem;
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s ease;
    border-radius: 50%;
}
.closeButton:hover { color: var(--text-primary); }

/* --- Options Grid --- */
.optionsGrid {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

/* Section Label */
.sectionLabel {
    font-size: 1.2rem;
    color: var(--text-secondary);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 1rem;
    display: block;
}

/* Preset Buttons Row */
.presetGrid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 1rem;
}

.presetButton {
    padding: 0.8rem;
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-secondary);
    font-family: var(--font-main);
    font-size: 1.3rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
}

.presetButton:hover {
    border-color: var(--text-primary);
    color: var(--text-primary);
    background-color: rgba(255, 255, 255, 0.08);
}

.presetButton.active {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 20%, transparent);
}

/* Sliders */
.sliderGroup {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.sliderHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.sliderLabel {
    font-size: 1.3rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.8rem;
}
.sliderIcon { color: var(--text-secondary); width: 16px; height: 16px; }

.sliderValue {
    font-family: monospace;
    font-size: 1.2rem;
    color: var(--accent);
}

.rangeInput {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    background: var(--border-color);
    border-radius: 3px;
    outline: none;
    transition: background 0.2s;
}
.rangeInput::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    border: 2px solid var(--bg-secondary);
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}
.rangeInput:hover::-webkit-slider-thumb {
    background: var(--accent);
    transform: scale(1.1);
}
.rangeInput:disabled { opacity: 0.5; cursor: not-allowed; }

/* Toggles Row */
.togglesRow {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

/* Reusing the OptionButton style from PerformanceSettings context */
.optionButton {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 0.8rem;
    padding: 1.2rem 0.5rem;
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    color: var(--text-secondary);
    font-family: var(--font-main);
    font-size: 1.3rem;
    font-weight: 600;
    text-align: center;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
}

.optionButton:hover {
    border-color: var(--text-primary);
    color: var(--text-primary);
    background-color: rgba(255, 255, 255, 0.08);
    transform: translateY(-2px);
}

.optionButton.active {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 20%, transparent);
}

.buttonIcon {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}

.optionButton.active .buttonIcon {
    transform: scale(1.1);
    filter: drop-shadow(0 0 8px var(--accent));
}

.indicator {
    width: 40px;
    height: 3px;
    background-color: var(--border-color);
    border-radius: 999px;
    margin-top: 0.5rem;
    overflow: hidden;
    position: relative;
}

.indicatorFill {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 100%;
    background-color: var(--accent);
    transform: translateX(-105%);
    transition: transform 0.3s ease;
}

.optionButton.active .indicatorFill {
    transform: translateX(0);
}

/* --- MOBILE --- */
.mobilePanel {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    background-color: #0A0B0F;
    border-top: 1px solid var(--accent);
    box-shadow: 0 -10px 60px rgba(0, 229, 255, 0.15);
    border-radius: 24px 24px 0 0;
    padding: 2.5rem 2rem 4rem 2rem;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    z-index: 10001 !important;
    pointer-events: auto;
    transform: none !important;
    top: auto !important;
}

.mobileOverlay {
    position: fixed;
    inset: 0;
    background-color: rgba(0,0,0,0.7);
    backdrop-filter: blur(5px);
    z-index: 10000 !important;
    cursor: pointer;
}

@media (max-width: 768px) {
    .container {
        /* On mobile, standard positioning (likely handled by layout, but explicit here) */
        bottom: 8rem; 
        right: 2rem;
    }
}

--- END OF FILE components/constellation/ConstellationControlPanel.module.css ---

================================================================================

--- START OF FILE components/constellation/ConstellationControlPanel.tsx ---

// components/constellation/ConstellationControlPanel.tsx
'use client';

// Added AnimatePresence to imports
import { motion, AnimatePresence } from 'framer-motion';
import { useTheme } from 'next-themes';
import { createPortal } from 'react-dom';
import { useClickOutside } from '@/hooks/useClickOutside';
import styles from './ConstellationControlPanel.module.css';
import React, { useState, useRef, useEffect } from 'react';

// --- ICONS (Updated to accept props) ---
const GearIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>;
const CloseIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;
const StarIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>;
const EyeIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>;
const MaximizeIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>;
const MinimizeIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>;
const BloomIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>;
const LineIcon = (props: React.SVGProps<SVGSVGElement>) => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" {...props}><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>;

export type Preset = 'أداء' | 'مُتَّزِن' | 'فائق';
export type ConstellationSettings = {
    activePreset: Preset | 'custom';
    starCountMultiplier: number;
    bloomIntensity: number;
    alwaysShowOrbits: boolean;
    flawlessPathThickness: number;
};

interface ControlPanelProps {
    settings: ConstellationSettings;
    setSettings: (settings: ConstellationSettings) => void;
    onPresetChange: (preset: Preset) => void;
    isFullscreen: boolean;
    onToggleFullscreen: () => void;
    onClose: () => void; 
}

const OptionButton = ({ label, isActive, onClick, Icon }: { label: string, isActive: boolean, onClick: () => void, Icon: any }) => (
    <button onClick={onClick} className={`${styles.optionButton} ${isActive ? styles.active : ''}`}>
        <div className={styles.buttonIcon}><Icon /></div>
        <span>{label}</span>
        <div className={styles.indicator}><div className={styles.indicatorFill} /></div>
    </button>
);

export default function ConstellationControlPanel({ settings, setSettings, onPresetChange, isFullscreen, onToggleFullscreen, onClose }: ControlPanelProps) {
    const [isOpen, setIsOpen] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const { resolvedTheme } = useTheme();
    const isLightMode = resolvedTheme === 'light';
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const check = () => setIsMobile(window.innerWidth <= 768);
        check();
        window.addEventListener('resize', check);
        return () => window.removeEventListener('resize', check);
    }, []);

    useClickOutside(containerRef, () => { if (!isMobile) setIsOpen(false); });

    const handleValueChange = (key: keyof ConstellationSettings, value: number | boolean) => {
        setSettings({ ...settings, activePreset: 'custom', [key]: value });
    };

    const PanelContent = () => (
        <>
            <div className={styles.header}>
                <div className={styles.headerLeft}><GearIcon /><h3 className={styles.headerTitle}>تحكم الكوكبة</h3></div>
                {/* Use the passed onClose or local setIsOpen for mobile sheet close */}
                {isMobile && (<button onClick={() => { setIsOpen(false); onClose(); }} className={styles.closeButton}><CloseIcon /></button>)}
            </div>

            <div className={styles.optionsGrid}>
                {/* Presets */}
                <div>
                    <span className={styles.sectionLabel}>إعدادات سريعة</span>
                    <div className={styles.presetGrid}>
                        {(['أداء', 'مُتَّزِن', 'فائق'] as Preset[]).map(p => (
                            <button key={p} className={`${styles.presetButton} ${settings.activePreset === p ? styles.active : ''}`} onClick={() => onPresetChange(p)}>
                                {p}
                            </button>
                        ))}
                    </div>
                </div>

                {/* Sliders */}
                <div className={styles.sliderGroup}>
                    <div className={styles.sliderHeader}>
                        <span className={styles.sliderLabel}><StarIcon className={styles.sliderIcon} /> كثافة النجوم</span>
                        <span className={styles.sliderValue}>{settings.starCountMultiplier.toFixed(1)}x</span>
                    </div>
                    <input type="range" min="0.1" max="1.5" step="0.1" value={settings.starCountMultiplier} onChange={(e) => handleValueChange('starCountMultiplier', parseFloat(e.target.value))} className={styles.rangeInput} />
                </div>

                <div className={styles.sliderGroup} style={{ opacity: isLightMode ? 0.5 : 1 }}>
                    <div className={styles.sliderHeader}>
                        <span className={styles.sliderLabel}><BloomIcon className={styles.sliderIcon} /> التوهج</span>
                        <span className={styles.sliderValue}>{isLightMode ? 'OFF' : settings.bloomIntensity.toFixed(1)}</span>
                    </div>
                    <input type="range" min="0" max="2.5" step="0.1" value={settings.bloomIntensity} onChange={(e) => handleValueChange('bloomIntensity', parseFloat(e.target.value))} disabled={isLightMode} className={styles.rangeInput} />
                </div>

                <div className={styles.sliderGroup}>
                    <div className={styles.sliderHeader}>
                        <span className={styles.sliderLabel}><LineIcon className={styles.sliderIcon} /> المسار</span>
                        <span className={styles.sliderValue}>{settings.flawlessPathThickness.toFixed(1)}px</span>
                    </div>
                    <input type="range" min="1" max="5" step="0.5" value={settings.flawlessPathThickness} onChange={(e) => handleValueChange('flawlessPathThickness', parseFloat(e.target.value))} className={styles.rangeInput} />
                </div>

                {/* Toggles */}
                <div className={styles.togglesRow}>
                    <OptionButton label="إظهار المدارات" isActive={settings.alwaysShowOrbits} onClick={() => handleValueChange('alwaysShowOrbits', !settings.alwaysShowOrbits)} Icon={EyeIcon} />
                    <OptionButton label={isFullscreen ? 'تصغير' : 'ملء الشاشة'} isActive={isFullscreen} onClick={onToggleFullscreen} Icon={isFullscreen ? MinimizeIcon : MaximizeIcon} />
                </div>
            </div>
        </>
    );

    return (
        <div className={styles.container} ref={containerRef}>
            <button 
                className={styles.triggerButton} 
                onClick={() => setIsOpen(!isOpen)} 
                title="إعدادات الكوكبة"
                style={isOpen ? { color: 'var(--accent)', transform: 'rotate(90deg)' } : {}}
            >
                <GearIcon />
            </button>

            {!isMobile && (
                <AnimatePresence>
                    {isOpen && (
                        <motion.div 
                            className={styles.panel}
                            initial={{ opacity: 0, y: 15, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: 15, scale: 0.95 }}
                            transition={{ type: "spring", duration: 0.3 }}
                        >
                            <PanelContent />
                        </motion.div>
                    )}
                </AnimatePresence>
            )}

            {isMobile && isOpen && createPortal(
                <AnimatePresence mode="wait">
                    <motion.div key="backdrop" className={styles.mobileOverlay} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} onClick={() => setIsOpen(false)} />
                    <motion.div key="sheet" className={styles.mobilePanel} initial={{ y: "100%" }} animate={{ y: "0%" }} exit={{ y: "100%" }} transition={{ type: "spring", damping: 25, stiffness: 200 }} onClick={(e) => e.stopPropagation()}>
                        <PanelContent />
                    </motion.div>
                </AnimatePresence>,
                document.body
            )}
        </div>
    );
}

--- END OF FILE components/constellation/ConstellationControlPanel.tsx ---

================================================================================

--- START OF FILE components/constellation/Scene.tsx ---

// components/constellation/Scene.tsx
import React, { useRef, useMemo, Suspense, useCallback, useState, useEffect } from 'react';
import { useFrame, useThree, ThreeEvent } from '@react-three/fiber';
import { Points, PointMaterial, OrbitControls, Tube, Line, Html } from '@react-three/drei';
import { EffectComposer, Bloom, Selection, Select } from '@react-three/postprocessing';
import * as THREE from 'three';
import { THEME_CONFIG, SIZES, StarData, ScreenPosition, Placement, getStarSize, StarActionType } from './config';
import { ConstellationSettings } from './ConstellationControlPanel';
import { motion, AnimatePresence } from 'framer-motion';

const StarLayer = ({ count, radius, size, opacity, color }: { count: number, radius: number, size: number, opacity: number, color: string }) => {
    const positions = useMemo(() => {
        const pos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
            let r = radius + Math.random() * 2; let theta = Math.random() * 2 * Math.PI; let phi = Math.acos(2 * Math.random() - 1);
            pos.set([r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)], i * 3);
        }
        return pos;
    }, [count, radius]);
    return <Points positions={positions}><PointMaterial transparent color={color} size={size} sizeAttenuation depthWrite={false} opacity={opacity} /></Points>;
};

const InteractiveStar = ({ star, color, isHovered, onHover, onClick }: {
    star: StarData, color: string, isHovered: boolean,
    onHover: (star: StarData | null) => void,
    onClick: (star: StarData) => void
}) => {
    const ref = useRef<THREE.Mesh>(null!);
    const size = useMemo(() => getStarSize(star), [star]);
    useFrame(() => { ref.current.scale.lerp(new THREE.Vector3().setScalar(isHovered ? 1.5 : 1), 0.2); });
    const handlePointerOver = (e: ThreeEvent<PointerEvent>) => { e.stopPropagation(); document.body.style.cursor = 'pointer'; onHover(star); };
    const handlePointerOut = () => { onHover(null); document.body.style.cursor = 'auto'; };
    return (
        <mesh ref={ref} onClick={(e) => { e.stopPropagation(); onClick(star); }} onPointerOver={handlePointerOver} onPointerOut={handlePointerOut}>
            <sphereGeometry args={[size, 16, 16]} />
            <meshBasicMaterial color={color} toneMapped={false} />
        </mesh>
    );
};

const BackgroundStarfield = ({ themeColors, countMultiplier }: { themeColors: typeof THEME_CONFIG.dark, countMultiplier: number }) => {
    const ref = useRef<THREE.Group>(null!);
    useFrame((state, delta) => { if (ref.current) ref.current.rotation.y -= delta / 45; });
    return (
        <group ref={ref}>
            <StarLayer count={Math.floor(1500 * countMultiplier)} radius={4} size={0.015} opacity={0.7} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(1000 * countMultiplier)} radius={6} size={0.01} opacity={0.5} color={themeColors.bgStarColor} />
            <StarLayer count={Math.floor(500 * countMultiplier)} radius={8} size={0.008} opacity={0.3} color={themeColors.bgStarColor} />
        </group>
    );
};

const createUIShareIconGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const createCenteredShapeFromPoints = (points: {x: number, y: number}[]) => {
        const shape = new THREE.Shape();
        const vecs = points.map(p => new THREE.Vector2(p.x, p.y).sub(center).multiplyScalar(scale));
        shape.moveTo(vecs[0].x, -vecs[0].y);
        for (let i = 1; i < vecs.length; i++) shape.lineTo(vecs[i].x, -vecs[i].y);
        shape.closePath();
        return shape;
    };
    const createCircleShape = ({x, y, r}: {x: number, y: number, r: number}) => {
        const shape = new THREE.Shape();
        const centerVec = new THREE.Vector2(x, y).sub(center).multiplyScalar(scale);
        shape.absarc(centerVec.x, -centerVec.y, r * scale, 0, Math.PI * 2, false);
        return shape;
    };
    const circle1Shape = createCircleShape({ x: 18, y: 5, r: 3 });
    const circle2Shape = createCircleShape({ x: 6, y: 12, r: 3 });
    const circle3Shape = createCircleShape({ x: 18, y: 19, r: 3 });
    const line1Points = [{ x: 8.59, y: 13.51 }, { x: 15.42, y: 17.44 }, { x: 14.42, y: 19.18 }, { x: 7.59, y: 15.25 }];
    const line2Points = [{ x: 8.59, y: 10.49 }, { x: 9.59, y: 12.23 }, { x: 16.42, y: 8.30 }, { x: 15.42, y: 6.56 }];
    const line1Shape = createCenteredShapeFromPoints(line1Points);
    const line2Shape = createCenteredShapeFromPoints(line2Points);
    return new THREE.ShapeGeometry([circle1Shape, circle2Shape, circle3Shape, line1Shape, line2Shape]);
};

const createUIHeartGeometry = () => {
    const shape = new THREE.Shape();
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const transform = (x: number, y: number) => {
        const v = new THREE.Vector2(x, y).sub(center);
        return { x: v.x * scale, y: -v.y * scale };
    };
    let p0 = transform(12, 21); shape.moveTo(p0.x, p0.y);
    let p1 = transform(12, 21), p2 = transform(5.8, 16.4), p3 = transform(2.8, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(0.9, 9.7); p2 = transform(2.5, 5); p3 = transform(6.7, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(8.6, 4.3); p2 = transform(10.5, 5.2); p3 = transform(12, 6.7); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(13.5, 5.2); p2 = transform(15.4, 4.3); p3 = transform(17.3, 4.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(21.5, 5); p2 = transform(23.1, 9.7); p3 = transform(21.2, 12.5); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    p1 = transform(18.2, 16.4); p2 = transform(12, 21); p3 = transform(12, 21); shape.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    return new THREE.ShapeGeometry(shape);
};

const createUIBookmarkGeometry = () => {
    const scale = 0.05;
    const center = new THREE.Vector2(12, 12);
    const points = [
        new THREE.Vector2(6, 2), new THREE.Vector2(4, 4), new THREE.Vector2(4, 22),
        new THREE.Vector2(12, 17), new THREE.Vector2(20, 22), new THREE.Vector2(20, 4),
        new THREE.Vector2(18, 2),
    ];
    const transformedPoints = points.map(p => {
        const v = p.clone().sub(center);
        return new THREE.Vector2(v.x * scale, -v.y * scale);
    });
    return new THREE.ShapeGeometry(new THREE.Shape().setFromPoints(transformedPoints));
};

const ICON_GEOMETRIES = {
    heart: createUIHeartGeometry(),
    bookmark: createUIBookmarkGeometry(),
    share: createUIShareIconGeometry(),
    comment: new THREE.ShapeGeometry(new THREE.Shape().setFromPoints([
        new THREE.Vector2(-0.6, 0.4), new THREE.Vector2(0.6, 0.4), new THREE.Vector2(0.6, -0.2),
        new THREE.Vector2(0.1, -0.2), new THREE.Vector2(0, -0.4), new THREE.Vector2(-0.1, -0.2),
        new THREE.Vector2(-0.6, -0.2),
    ]))
};

const ActionOrbit3D = ({ actions }: { actions: StarActionType[] }) => {
    const { camera } = useThree();
    const groupRef = useRef<THREE.Group>(null!);
    useFrame(() => { if (groupRef.current) groupRef.current.quaternion.copy(camera.quaternion); });
    const radius = 0.3;
    const iconScale = 0.085;

    return (
        <group ref={groupRef}>
            {actions.map((action, index) => {
                const angle = (index / actions.length) * Math.PI * 2;
                const iconPosition = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                const geometryKey = action === 'like' ? 'heart' : action;
                const geometry = ICON_GEOMETRIES[geometryKey];
                return (
                    <group key={action}>
                        <Tube renderOrder={0} args={[new THREE.LineCurve3(new THREE.Vector3(0,0,0), iconPosition), 16, 0.002, 8, false]}>
                            <meshBasicMaterial color="white" toneMapped={false} />
                        </Tube>
                        <mesh renderOrder={1} position={iconPosition} geometry={geometry} scale={iconScale}>
                            <meshBasicMaterial color={THEME_CONFIG.dark.reviewColor} toneMapped={false} />
                        </mesh>
                    </group>
                );
            })}
        </group>
    );
};

const UserStarPoints = ({ stars, themeColors, hoveredStar, setHoveredStar, setActiveStar, alwaysShowOrbits }: {
    stars: StarData[], themeColors: typeof THEME_CONFIG.dark, hoveredStar: StarData | null,
    setHoveredStar: (star: StarData | null) => void,
    setActiveStar: (star: StarData, position: ScreenPosition) => void,
    alwaysShowOrbits: boolean
}) => {
    const { camera, gl } = useThree();
    const handleStarClick = useCallback((star: StarData) => {
        const canvasRect = gl.domElement.getBoundingClientRect();
        const vec = new THREE.Vector3().copy(star.position);
        vec.project(camera);
        const x = (vec.x * 0.5 + 0.5) * canvasRect.width + canvasRect.left;
        const y = (vec.y * -0.5 + 0.5) * canvasRect.height + canvasRect.top;
        const placement: Placement = y > window.innerHeight / 2 ? 'above' : 'below';
        let finalX = x;
        const cardWidth = 300;
        const padding = 20;
        if (finalX < cardWidth / 2 + padding) finalX = cardWidth / 2 + padding;
        if (finalX > window.innerWidth - cardWidth / 2 - padding) finalX = window.innerWidth - cardWidth / 2 - padding;
        setActiveStar(star, { top: y, left: finalX, placement });
    }, [camera, gl.domElement, setActiveStar]);
    return (
        <group>
            {stars.map(star => {
                const colorKey = `${star.content._type}Color` as keyof typeof themeColors;
                const isHovered = hoveredStar?.id === star.id;
                return (
                    <group key={star.id || star.content._id} position={star.position}>
                        <InteractiveStar star={star} color={themeColors[colorKey]} isHovered={isHovered} onHover={setHoveredStar} onClick={handleStarClick} />
                        {(alwaysShowOrbits || isHovered) && star.actions.length > 0 && (
                            <ActionOrbit3D actions={star.actions} />
                        )}
                    </group>
                );
            })}
        </group>
    );
};

const ConstellationPath = ({ pathPoints, color, thickness }: { pathPoints: THREE.Vector3[], color: string, thickness: number }) => {
    return (
        <Line 
            points={pathPoints} 
            color={color} 
            lineWidth={thickness} 
            transparent 
            depthWrite={false} 
            renderOrder={1} 
        />
    );
};

const HoverContext = ({ hoveredStar, alwaysShowOrbits }: { hoveredStar: StarData, alwaysShowOrbits: boolean }) => {
    return (
        <Html position={hoveredStar.position}>
            <div style={{ position: 'relative', pointerEvents: 'none', transform: 'translate(-50%, -50%)' }}>
                {!alwaysShowOrbits && (
                    <motion.div
                        initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }}
                        transition={{ duration: 0.2, ease: 'easeOut' as const }}
                        style={{
                            position: 'absolute', bottom: '80px', left: '50%', transform: 'translateX(-50%)',
                            background: 'var(--bg-secondary)', color: 'var(--text-primary)', padding: '0.5rem 1rem',
                            borderRadius: '6px', border: '1px solid var(--border-color)', fontSize: '1.4rem',
                            fontFamily: 'var(--font-ui)', whiteSpace: 'nowrap', zIndex: 10000,
                            boxShadow: '0 4px 15px rgba(0,0,0,0.2)'
                        }}
                    >
                        <p style={{ margin: 0, fontWeight: 600 }}>{hoveredStar.content.title}</p>
                        <p style={{ margin: 0, textTransform: 'capitalize', color: 'var(--text-secondary)' }}>{hoveredStar.content._type}</p>
                    </motion.div>
                )}
            </div>
        </Html>
    );
};

function InteractiveLayer({ chronologicalStars, themeColors, setActiveStar, settings, isMobile, isPaused }: any) {
    const [hoveredStar, setHoveredStar] = useState<StarData | null>(null);
    const { bloomIntensity, alwaysShowOrbits, flawlessPathThickness } = settings;
    const isBloomEnabled = bloomIntensity > 0;
    const { camera } = useThree();

    const controlsRef = useRef<any>(null);
    
    useFrame(() => {
        if (controlsRef.current) {
            // STOP rotation if card is open (isPaused) OR if hovering a star
            controlsRef.current.autoRotate = !hoveredStar && !isPaused;
            controlsRef.current.update();
        }
    });

    useEffect(() => {
        if (!chronologicalStars.length || !controlsRef.current) return;
        let maxR = 0;
        for (const s of chronologicalStars) {
            const len = s.position.length();
            if (len > maxR) maxR = len;
        }
        const fov = (camera as THREE.PerspectiveCamera).fov || 60;
        const padding = 1.3; 
        const targetDist = (maxR * padding) / Math.tan(THREE.MathUtils.degToRad(fov / 2));
        const minStartDist = isMobile ? 10 : 7;
        const finalZ = Math.max(minStartDist, targetDist);
        const startPos = camera.position.clone();
        const endPos = new THREE.Vector3(0, 0, finalZ);
        let t = 0;
        const animateCamera = () => {
            t += 0.02; 
            if (t > 1) t = 1;
            camera.position.lerpVectors(startPos, endPos, t);
            if (controlsRef.current) {
                controlsRef.current.update();
            }
            if (t < 1) requestAnimationFrame(animateCamera);
        };
        requestAnimationFrame(animateCamera);
    }, [chronologicalStars, isMobile, camera]);

    return (
        <>
            <AnimatePresence>{hoveredStar && <HoverContext hoveredStar={hoveredStar} alwaysShowOrbits={alwaysShowOrbits} />}</AnimatePresence>
            {isBloomEnabled ? (
                <Selection>
                    <EffectComposer autoClear={false} frameBufferType={THREE.HalfFloatType} multisampling={4}>
                        <Bloom intensity={bloomIntensity} luminanceThreshold={0.1} mipmapBlur luminanceSmoothing={0.2} radius={0.7} />
                    </EffectComposer>
                    {chronologicalStars.length > 0 && (
                        <Select enabled>
                            <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                            <ConstellationPath pathPoints={chronologicalStars.map((s: StarData) => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                        </Select>
                    )}
                </Selection>
            ) : (
                chronologicalStars.length > 0 && (
                    <>
                        <UserStarPoints stars={chronologicalStars} themeColors={themeColors} hoveredStar={hoveredStar} setHoveredStar={setHoveredStar} setActiveStar={setActiveStar} alwaysShowOrbits={alwaysShowOrbits} />
                        <ConstellationPath pathPoints={chronologicalStars.map((s: StarData) => s.position)} color={themeColors.pathColor} thickness={flawlessPathThickness} />
                    </>
                )
            )}
            <OrbitControls
                ref={controlsRef}
                enableZoom
                autoRotate={true}
                autoRotateSpeed={0.15}
                minDistance={2.5}
                maxDistance={isMobile ? 80 : 60}
                zoomSpeed={0.5}
            />
        </>
    );
}

interface SceneProps {
    chronologicalStars: StarData[];
    themeColors: typeof THEME_CONFIG.dark;
    setActiveStar: (star: StarData, position: ScreenPosition) => void;
    settings: ConstellationSettings;
    isMobile: boolean;
    isPaused: boolean; // Added Prop
}

export const Scene = ({ chronologicalStars, themeColors, setActiveStar, settings, isMobile, isPaused }: SceneProps) => {
    return (
        <Suspense fallback={null}>
            <color attach="background" args={[themeColors.bgColor]} />
            <ambientLight intensity={0.5} />
            <BackgroundStarfield themeColors={themeColors} countMultiplier={settings.starCountMultiplier} />
            <InteractiveLayer
                chronologicalStars={chronologicalStars}
                themeColors={themeColors}
                setActiveStar={setActiveStar}
                settings={settings}
                isMobile={isMobile}
                isPaused={isPaused} // Passed Down
            />
        </Suspense>
    );
};

--- END OF FILE components/constellation/Scene.tsx ---

================================================================================

--- START OF FILE components/constellation/StarPreviewCard.tsx ---

// components/constellation/StarPreviewCard.tsx

import React, { useState, useEffect, useRef, useLayoutEffect } from 'react';
import { motion } from 'framer-motion';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { urlFor } from '@/sanity/lib/image';
import { StarData, ScreenPosition, Placement } from './config';
import { sanityLoader } from '@/lib/sanity.loader';
import { useContentStore } from '@/lib/contentStore'; 
import ArticleCard from '@/components/ArticleCard'; 
import { adaptToCardProps } from '@/lib/adapters'; 
import { CardProps } from '@/types';

interface StarPreviewCardProps {
    starData: StarData;
    position: ScreenPosition;
    onClose: () => void;
}

const typeMap: Record<'review' | 'article' | 'news', string> = {
    review: 'مراجعة',
    article: 'مقالة',
    news: 'خبر'
}

const mapContentTypeToRouteType = (type: string): 'reviews' | 'articles' | 'news' => {
    switch (type) {
        case 'review': return 'reviews';
        case 'article': return 'articles';
        case 'news': return 'news';
        default: return 'news';
    }
};

export const StarPreviewCard = ({ starData, position, onClose }: StarPreviewCardProps) => {
    const [isMobile, setIsMobile] = useState(false);
    const { hydrateContent, openOverlay } = useContentStore();
    
    const cardRef = useRef<HTMLDivElement>(null);
    
    const initialYAlign = position.placement === 'above' ? 'bottom' : 'top';
    
    const [layoutState, setLayoutState] = useState<{
        xAlign: 'left' | 'right'; 
        yAlign: 'top' | 'bottom'; 
        isVisible: boolean;
    }>({
        xAlign: 'left',
        yAlign: initialYAlign, 
        isVisible: false 
    });

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    useLayoutEffect(() => {
        if (!cardRef.current) return;
        
        const updatePosition = () => {
             if (!cardRef.current) return;
             
             const width = cardRef.current.offsetWidth || (isMobile ? 260 : 300);
             const height = cardRef.current.offsetHeight || 350; 
             
             const gap = 20; 
             const VIEWPORT_MARGIN = 20;
    
             const { innerWidth: vw, innerHeight: vh } = window;
             const { top, left } = position;
    
             let xAlign: 'left' | 'right' = 'left';
             
             const rightEdge = left + width + gap + VIEWPORT_MARGIN;
             
             if (rightEdge > vw) {
                 const leftEdgeIfFlipped = left - width - gap - VIEWPORT_MARGIN;
                 if (leftEdgeIfFlipped > 0) {
                     xAlign = 'right';
                 } else {
                     const spaceRight = vw - left;
                     const spaceLeft = left;
                     xAlign = spaceRight > spaceLeft ? 'left' : 'right';
                 }
             }
    
             let yAlign: 'top' | 'bottom' = initialYAlign;
    
             const bottomEdgeIfTopAligned = top + height + gap + VIEWPORT_MARGIN;
             const topEdgeIfBottomAligned = top - height - gap - VIEWPORT_MARGIN;
    
             if (yAlign === 'top') {
                 if (bottomEdgeIfTopAligned > vh) {
                     if (topEdgeIfBottomAligned > 0) {
                         yAlign = 'bottom';
                     }
                 }
             } else {
                 if (topEdgeIfBottomAligned < 0) {
                     if (bottomEdgeIfTopAligned < vh) {
                         yAlign = 'top';
                     }
                 }
             }
    
             setLayoutState({
                 xAlign,
                 yAlign,
                 isVisible: true
             });
        };

        updatePosition();
        
        const observer = new ResizeObserver(updatePosition);
        observer.observe(cardRef.current);

        return () => observer.disconnect();
    }, [position, isMobile, initialYAlign]);

    // ADAPT CONTENT
    const cardProps: CardProps | null = adaptToCardProps(starData.content, { width: 600 });
    
    if (!cardProps) return null;

    const GAP_PX = 20;
    const tx = layoutState.xAlign === 'left' ? `${GAP_PX}px` : `calc(-100% - ${GAP_PX}px)`;
    const ty = layoutState.yAlign === 'top' ? `${GAP_PX}px` : `calc(-100% - ${GAP_PX}px)`;
    const transformStyle = `translate(${tx}, ${ty})`;
    const originY = layoutState.yAlign === 'top' ? 'top' : 'bottom';
    const originX = layoutState.xAlign === 'left' ? 'left' : 'right';
    const originStyle = `${originY} ${originX}`;

    return (
        <motion.div
            ref={cardRef}
            // FIX: Removed conflicting layoutId on wrapper
            
            initial={{ opacity: 0, scale: 0.8 }} 
            animate={{ 
                opacity: layoutState.isVisible ? 1 : 0, 
                scale: layoutState.isVisible ? 1 : 0.8 
            }} 
            exit={{ opacity: 0, scale: 0.8 }}
            
            transition={{ type: 'spring', damping: 25, stiffness: 350 }}
            
            style={{
                position: 'fixed', 
                top: position.top, 
                left: position.left,
                width: isMobile ? '260px' : '300px',
                // FIX: Lower Z-Index to stay under Overlay (2050)
                zIndex: 2041, 
                transform: transformStyle,
                transformOrigin: originStyle,
                cursor: 'default',
                visibility: layoutState.isVisible ? 'visible' : 'hidden' 
            }}
        >
            <div style={{ position: 'relative' }}>
                <motion.button
                    onClick={(e) => { e.stopPropagation(); onClose(); }} 
                    whileHover={{ scale: 1.2, rotate: 90 }} whileTap={{ scale: 0.9 }}
                    style={{
                        position: 'absolute', top: '10px', right: '10px', zIndex: 100, width: '32px', height: '32px',
                        borderRadius: '50%', border: 'none', background: 'rgba(0,0,0,0.6)', color: 'white',
                        display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer', backdropFilter: 'blur(4px)'
                    }} aria-label="إغلاق"
                >
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </motion.button>

                <ArticleCard 
                    article={cardProps}
                    // FIX: Unique prefix to prevent conflict
                    layoutIdPrefix={`constellation-popup-${cardProps.legacyId}`}
                    isPriority={true}
                    disableLivingEffect={false} 
                    smallTags={true} 
                />
            </div>
        </motion.div>
    );
};

--- END OF FILE components/constellation/StarPreviewCard.tsx ---

================================================================================

--- START OF FILE components/constellation/config.ts ---

import * as THREE from 'three';
// Import the new Sanity types instead of the old mock data types
import type { SanityReview, SanityArticle, SanityNews } from '@/types/sanity';

//  Type Definitions
// Create a new union type for any content object from Sanity
export type SanityContentObject = SanityReview | SanityArticle | SanityNews;

export type StarActionType = 'bookmark' | 'like' | 'comment' | 'share';
export type StarType = 'history' | 'like' | 'comment' | 'share';

export type StarData = {
    id: number;
    position: THREE.Vector3;
    content: SanityContentObject;
    // This determines the star's base size based on the most significant action
    type: StarType;
    // This contains ALL actions taken on the content, used to draw the orbit
    actions: StarActionType[];
};

export type Placement = 'above' | 'below';
export type ScreenPosition = {
    top: number;
    left: number;
    placement: Placement;
};

//  Theme-aware Color & Size Mapping
export const THEME_CONFIG = {
    dark: {
        // Updated to match site accent (#00FFF0)
        reviewColor: '#00FFF0', 
        articleColor: '#E1E1E6', 
        newsColor: '#7D808C',
        pathColor: '#FFFFFF', 
        bgStarColor: '#FFFFFF', 
        bgColor: '#0A0B0F',
    },
    light: {
        // Updated to match light mode accent (#00d1c6)
        reviewColor: '#00d1c6', 
        articleColor: '#1F2937', 
        newsColor: '#6B7280',
        pathColor: '#1F2937', 
        bgStarColor: '#1F2937', 
        bgColor: '#F0F2F5',
    },
};

const BASE_SIZE = 0.035;
const BOOKMARK_MULTIPLIER = 1.6;

export const SIZES: Record<StarType, number> = {
    history: BASE_SIZE,
    like: BASE_SIZE * 1.3,
    comment: BASE_SIZE * 1.6,
    share: BASE_SIZE * 2.0,
};

// A bookmarked star is ALWAYS the largest version of its type
export const getStarSize = (star: StarData) => {
    // legacyId is the correct property for the numeric ID
    return star.actions.includes('bookmark') ? SIZES['share'] * BOOKMARK_MULTIPLIER : SIZES[star.type];
};

--- END OF FILE components/constellation/config.ts ---

================================================================================

--- START OF FILE components/constellation/index.tsx ---

// components/constellation/index.tsx
'use client';

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { Canvas } from '@react-three/fiber';
import { useTheme } from 'next-themes';
import { motion, AnimatePresence } from 'framer-motion';
import { useUserStore } from '@/lib/store';
import { useBodyClass } from '@/hooks/useBodyClass';
import * as THREE from 'three';
import { THEME_CONFIG, StarData, SanityContentObject, ScreenPosition } from './config';
import { StarPreviewCard } from './StarPreviewCard';
import { Scene } from './Scene';
import ConstellationControlPanel, { ConstellationSettings, Preset } from './ConstellationControlPanel';
import { getCommentedContentIds } from '@/app/actions/userActions';
import styles from './ConstellationControlPanel.module.css';
import { PerformanceMonitor } from '@react-three/drei'; 

const CelestialGearIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="8"></circle>
        <path d="M12 2v2m0 16v2m8.5-10h-2m-13 0h-2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
    </svg>
);

type InitialData = {
    userContent: SanityContentObject[];
    commentedSlugs: string[];
    isGuest: boolean;
} | null;

export default function Constellation({ initialData }: { initialData?: InitialData }) {
    const [isHydrated, setIsHydrated] = useState(false);
    const [isMobile, setIsMobile] = useState(false);
    const [dpr, setDpr] = useState(1.5);

    useEffect(() => { setIsHydrated(true); }, []);

    const [isFullscreen, setIsFullscreen] = useState(false);

    useBodyClass('constellation-active'); 
    useBodyClass('fullscreen-active', isFullscreen); 
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);
    
    const { resolvedTheme } = useTheme();
    const { bookmarks, likes, shares } = useUserStore();
    
    const [userContent, setUserContent] = useState<SanityContentObject[]>(initialData?.userContent || []);
    const [activeStar, setActiveStar] = useState<StarData | null>(null);
    const [activeStarPosition, setActiveStarPosition] = useState<ScreenPosition | null>(null);
    const [isPanelOpen, setIsPanelOpen] = useState(false);
    const [commentedContentSlugs, setCommentedContentSlugs] = useState<string[]>(initialData?.commentedSlugs || []);

    useEffect(() => {
        if (!isHydrated) return;
        
        if (initialData && !initialData.isGuest) {
            return;
        }

        getCommentedContentIds().then(slugs => { setCommentedContentSlugs(slugs); });

        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));
        
        const allIds = [...new Set([...safeBookmarks, ...safeLikes, ...safeShares])];
        
        if (allIds.length === 0) { 
            setUserContent([]); 
            return; 
        }

        const fetchContent = async () => {
            const response = await fetch('/api/content-by-ids', { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ ids: allIds }), 
            });
            if (response.ok) { 
                const data = await response.json(); 
                setUserContent(data); 
            } else {
                console.error("Failed to fetch content for Constellation:", response.statusText);
            }
        };
        fetchContent();
    }, [isHydrated, bookmarks, likes, shares, initialData]);

    const PRESETS: Record<Preset, ConstellationSettings> = useMemo(() => ({
        'أداء': { activePreset: 'أداء', starCountMultiplier: 0.2, bloomIntensity: 0, alwaysShowOrbits: false, flawlessPathThickness: 1.5 },
        'مُتَّزِن': { activePreset: 'مُتَّزِن', starCountMultiplier: 1.0, bloomIntensity: 0.9, alwaysShowOrbits: false, flawlessPathThickness: 2 },
        'فائق': { activePreset: 'فائق', starCountMultiplier: 1.5, bloomIntensity: 1.5, alwaysShowOrbits: false, flawlessPathThickness: 2.5 },
    }), []);

    const [settings, setSettings] = useState<ConstellationSettings>(PRESETS['مُتَّزِن']);
    const userIntentBloom = useRef(PRESETS['مُتَّزِن'].bloomIntensity);

    useEffect(() => {
        if (resolvedTheme === 'light') {
            if (settings.bloomIntensity > 0) {
                setSettings(s => ({ ...s, bloomIntensity: 0 }));
            }
        } else {
            if (settings.bloomIntensity !== userIntentBloom.current) {
                setSettings(s => ({ ...s, bloomIntensity: userIntentBloom.current }));
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [resolvedTheme]);

    useEffect(() => {
        if (resolvedTheme === 'dark' && settings.activePreset === 'custom') {
            userIntentBloom.current = settings.bloomIntensity;
        }
    }, [settings.bloomIntensity, settings.activePreset, resolvedTheme]);

    const handlePresetChange = (preset: Preset) => {
        let newSettings = { ...PRESETS[preset] };
        userIntentBloom.current = newSettings.bloomIntensity;
        if (resolvedTheme === 'light') {
            newSettings.bloomIntensity = 0;
        }
        setSettings(newSettings);
    };

    const isDark = resolvedTheme === 'dark';
    const themeColors = isDark ? THEME_CONFIG.dark : THEME_CONFIG.light;

    const chronologicalStars = useMemo(() => {
        if (!isHydrated || userContent.length === 0) return [];
        
        const safeBookmarks = (bookmarks || []).map(k => Number(k.split('-')[1]));
        const safeLikes = (likes || []).map(k => Number(k.split('-')[1]));
        const safeShares = (shares || []).map(k => Number(k.split('-')[1]));

        const starMap = new Map<number, { type: "history" | "like" | "comment" | "share", actions: ("bookmark" | "like" | "comment" | "share")[], content: SanityContentObject }>();
        
        userContent.filter(content => content.legacyId != null).forEach(content => {
            const id = content.legacyId; 
            let type: "history" | "like" | "comment" | "share" = 'history'; 
            const actions: ("bookmark" | "like" | "comment" | "share")[] = [];

            if (safeLikes.includes(id)) { actions.push('like'); }
            if (safeShares.includes(id)) { actions.push('share'); }
            if (commentedContentSlugs.includes(content.slug)) { actions.push('comment'); }
            if (safeBookmarks.includes(id)) { actions.push('bookmark'); }

            if (initialData && !initialData.isGuest && actions.length === 0) {
                actions.push('like');
            }

            if (actions.includes('like')) type = 'like';
            if (actions.includes('comment')) type = 'comment'; 
            if (actions.includes('share')) type = 'share';
            
            starMap.set(id, { type, actions: actions.sort(), content });
        });
        
        const allUserStars: StarData[] = [];
        
        const starCount = starMap.size;
        const scaleFactor = Math.max(1, Math.sqrt(starCount) * 0.25);

        starMap.forEach((data, id) => {
            const u=Math.random(), v=Math.random(), theta=2*Math.PI*u, phi=Math.acos(2*v-1);
            const r = (1.8 + Math.random() * 0.6) * scaleFactor;
            const position = new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            allUserStars.push({ id, position, content: data.content, type: data.type, actions: data.actions });
        });
        
        const sortedStars = allUserStars.sort((a, b) => 
            new Date(a.content.publishedAt).getTime() - new Date(b.content.publishedAt).getTime()
        );

        if (sortedStars.length > 1) {
            const curve = new THREE.CatmullRomCurve3( sortedStars.map(s => s.position) );
            const points = curve.getPoints(sortedStars.length - 1);
            return sortedStars.map((star, i) => ({ ...star, position: points[i] }));
        }
        return sortedStars;
    }, [isHydrated, userContent, bookmarks, likes, shares, commentedContentSlugs, initialData]);

    const handleSetActiveStar = useCallback((star: StarData, position: ScreenPosition) => {
        if (isMobile) {
            setActiveStar(star);
            setActiveStarPosition({ top: 110, left: window.innerWidth / 2, placement: 'below' });
        } else {
            setActiveStar(star);
            setActiveStarPosition(position);
        }
    }, [isMobile]);
    const handleClosePreview = useCallback(() => { setActiveStar(null); setActiveStarPosition(null); }, []);

    if (!isHydrated) { return <div style={{ height: 'calc(100vh - var(--nav-height-scrolled))', width: '100%' }} />; }

    return (
        <>
            <AnimatePresence>
                {/* FIX: Lower zIndex to 2040 to stay under Overlay (2050) */}
                {activeStar && activeStarPosition && ( <motion.div style={{ position: 'fixed', inset: 0, zIndex: 2040 }} onClick={handleClosePreview} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}> <StarPreviewCard starData={activeStar} position={activeStarPosition} onClose={handleClosePreview} /> </motion.div> )}
            </AnimatePresence>
            
            <div style={{ position: 'relative', width: '100%', height: '100vh' }}>
                <ConstellationControlPanel 
                    settings={settings} 
                    setSettings={setSettings} 
                    onPresetChange={handlePresetChange} 
                    isFullscreen={isFullscreen} 
                    onToggleFullscreen={() => setIsFullscreen(!isFullscreen)}
                    onClose={() => setIsPanelOpen(false)}
                />
                
                <Canvas 
                    camera={{ position: [0, 0, isMobile ? 10 : 7], fov: 60 }}
                    dpr={dpr}
                >
                    <PerformanceMonitor onDecline={() => setDpr(1)} onIncline={() => setDpr(2)} />
                    <Scene 
                        settings={settings} 
                        chronologicalStars={chronologicalStars} 
                        themeColors={themeColors} 
                        setActiveStar={handleSetActiveStar} 
                        isMobile={isMobile}
                        isPaused={!!activeStar}
                    />
                </Canvas>
                
                {chronologicalStars.length === 0 && ( <div style={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', textAlign: 'center', pointerEvents: 'none', padding: '2rem' }}> <motion.h1 className="page-title" style={{ fontSize: '6rem' }} initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.2, ease: 'easeOut' }}> كوكبتك في انتظارك </motion.h1> <motion.p style={{ maxWidth: '600px', fontSize: '2rem', color: 'var(--text-secondary)' }} initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.8, delay: 0.4, ease: 'easeOut' }}> بينما تستكشف وتعجب وتشارك، ستبدأ خريطتك النجمية الشخصية في التكون هنا. </motion.p> </div> )}
            </div>
        </>
    );
}

--- END OF FILE components/constellation/index.tsx ---

================================================================================

--- START OF FILE components/content/ContentPage.module.css ---

/* components/content/ContentPage.module.css */

.contentLayout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 5rem;
}
@media (min-width: 1024px) {
  .contentLayout {
    grid-template-columns: 1fr 320px;
    gap: 4rem;
    align-items: start;
  }
}

.heroImage {
    position: relative;
    width: 100%;
    aspect-ratio: 5 / 1;
    height: auto;
    margin-bottom: 3rem;
    border-radius: 12px;
    overflow: hidden;
}

/* MODIFIED: Removed sticky positioning to let sidebar stay at the top */
.sidebar {
    margin-top: 0;
    /* position: sticky;  <-- REMOVED */
    /* top: calc(var(--nav-height-scrolled) + 2rem); <-- REMOVED */
}

.relatedGrid {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.titleWrapper {
    margin-bottom: 1.5rem;
    min-width: 0;
}

.headerBadges {
    display: flex;
    gap: 1rem;
    align-items: center;
    justify-content: flex-start;
    margin-bottom: 1.5rem;
}

.pageClassificationBadge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-family: var(--font-main);
    font-size: 1.4rem;
    font-weight: 700;
    padding: 0.4rem 1.2rem;
    border-radius: 999px;
    color: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}
.pageClassificationBadge.official { background-color: var(--accent); box-shadow: 0 2px 10px color-mix(in srgb, var(--accent) 40%, transparent); }
.pageClassificationBadge.rumor { background-color: #F59E0B; box-shadow: 0 2px 10px rgba(245, 158, 11, 0.3); }
.pageClassificationBadge.leak { background-color: #DC2626; box-shadow: 0 2px 10px rgba(220, 38, 38, 0.3); }

.metaContainer {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; 
    margin-bottom: 3rem;
    gap: 1.5rem;
    flex-direction: row-reverse;
}

.metaBlockLeft {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.metaBlockRight {
    display: flex;
    flex-direction: column;
    align-items: flex-start; 
    gap: 1rem;
    font-size: 1.5rem;
    text-align: right;
    padding-top: 0.4rem;
}

.creditsRow {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
    justify-content: flex-start; 
}

.dateContainer {
    display: flex;
    flex-direction: column; 
    align-items: flex-start; 
    gap: 0.5rem; 
    justify-content: center;
}

.metaRowItem {
    display: flex;
    align-items: center;
    gap: 0.6rem;
}

.readTimeMinimal {
    display: inline-flex;
    align-items: center;
    gap: 0.6rem;
    font-size: 1.3rem;
    color: var(--text-secondary);
    font-weight: 500;
}

.timeIcon {
    width: 16px;
    height: 16px;
    color: var(--accent); 
    flex-shrink: 0;
}

.metadataIcon {
    width: 16px;
    height: 16px;
    color: var(--accent);
    flex-shrink: 0;
}

.dateText {
    font-size: 1.4rem;
    color: var(--text-secondary);
    margin: 0;
}

.article-body {
    max-width: 100%;
}

@media (max-width: 1024px) {
    .contentLayout {
        grid-template-columns: 1fr; 
    }
    .sidebar {
        position: static;
        margin-top: 4rem;
    }
}

@media (max-width: 768px) {
    .heroImage { aspect-ratio: 3 / 1; margin-bottom: 2rem; }
    .titleWrapper { margin-bottom: 2rem; }
    .metaContainer { flex-direction: row-reverse; align-items: flex-start; gap: 1rem; }
    .metaBlockLeft { align-items: center; }
    .metaBlockRight { align-items: flex-start; padding-top: 0; }
    .dateContainer { align-items: flex-start; }
}

--- END OF FILE components/content/ContentPage.module.css ---

================================================================================

--- START OF FILE components/content/ContentPageClient.tsx ---

// components/content/ContentPageClient.tsx
'use client';

import { useEffect, useState, useRef, useCallback, useLayoutEffect, RefObject, useMemo } from 'react';
import Image from 'next/image';
import { motion } from 'framer-motion';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { adaptToCardProps } from '@/lib/adapters';
import { sanityLoader } from '@/lib/sanity.loader';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import { usePerformanceStore } from '@/lib/performanceStore'; 
import { useContentStore } from '@/lib/contentStore'; 

import type { SanityReview, SanityArticle, SanityNews } from '@/types/sanity';
import PortableTextComponent from '@/components/PortableTextComponent';
import ScoreBox from '@/components/ScoreBox';
import ArticleCard from '@/components/ArticleCard';
import GameLink from '@/components/GameLink';
import ContentActionBar from '@/components/ContentActionBar';
import TagLinks from '@/components/TagLinks';
import ReadingHud from '@/components/ReadingHud';
import { ContentBlock } from '@/components/ContentBlock';
import { SparklesIcon, Calendar03Icon } from '@/components/icons/index'; 
import CreatorCredit from '@/components/CreatorCredit';
import styles from './ContentPage.module.css';
import { CardProps } from '@/types';
import { translateTag } from '@/lib/translations';
import TableOfContents, { TocItem } from '@/components/content/TableOfContents';
import JoinVanguardCard from '@/components/ui/JoinVanguardCard';
import { formatArabicDuration, generateId, extractHeadingsFromContent } from '@/lib/text-utils';
import { calculateReadingTime, toPlainText } from '@/lib/readingTime';
import { generateLayoutId } from '@/lib/layoutUtils'; 

const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;
type Slug = { current: string } | string;

type ContentItem = Omit<SanityReview | SanityArticle | SanityNews, 'slug'> & { 
    slug: Slug; 
    relatedContent?: any[]; 
    readingTime?: number; 
    toc?: { id: string; text: string; level: number }[]; 
    contentLoaded?: boolean;
};

type ContentType = 'reviews' | 'articles' | 'news';
export type Heading = { id: string; title: string; top: number; level: number }; 
type ColorMapping = { word: string; color: string; }

const adaptReviewForScoreBox = (review: any) => ({ score: review.score, verdict: review.verdict, pros: review.pros, cons: review.cons });
const typeLabelMap: Record<string, string> = { 'official': 'رسمي', 'rumor': 'إشاعة', 'leak': 'تسريب' };
const TimeIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>;

export default function ContentPageClient({ 
    item, 
    type, 
    children, 
    colorDictionary, 
    forcedLayoutIdPrefix,
    initialImageSrc,
    scrollContainerRef
}: { 
    item: ContentItem; 
    type: ContentType; 
    children: React.ReactNode; 
    colorDictionary: ColorMapping[]; 
    forcedLayoutIdPrefix?: string;
    initialImageSrc?: string;
    scrollContainerRef?: RefObject<HTMLElement | null>;
}) {
    const { prefix: storePrefix, setPrefix } = useLayoutIdStore();
    const openLightbox = useLightboxStore((state) => state.openLightbox);
    const { isHeroTransitionEnabled } = usePerformanceStore();
    
    const isReview = type === 'reviews';
    const isNews = type === 'news';

    // --- COMPUTED DATA (Client-Side Fallback) ---
    // If TOC/ReadingTime are missing (e.g. inside Overlay), calculate them from content.
    const tocItems = useMemo(() => {
        if (item.toc && item.toc.length > 0) return item.toc;
        
        // Fallback: Generate TOC from content
        const generated = extractHeadingsFromContent(item.content || []);
        if (isReview && (item as any).verdict) {
             generated.push({ id: 'verdict-summary', text: 'الخلاصة', level: 2 });
        }
        return generated;
    }, [item.toc, item.content, isReview, (item as any).verdict]);

    const readingTime = useMemo(() => {
        if (item.readingTime) return item.readingTime;
        
        // Fallback: Calculate reading time
        if (item.content) {
            const text = toPlainText(item.content);
            return calculateReadingTime(text);
        }
        return 0;
    }, [item.readingTime, item.content]);

    // ------------------------------------------

    const [headings, setHeadings] = useState<Heading[]>([]);
    const [isMobile, setIsMobile] = useState(false);
    
    const [isBodyReady, setIsBodyReady] = useState(false);
    const [isTransitionComplete, setIsTransitionComplete] = useState(false);

    const articleBodyRef = useRef<HTMLDivElement>(null); 
    const [isLayoutStable, setIsLayoutStable] = useState(false); 
    
    const slugString = item?.slug ? (typeof item.slug === 'string' ? item.slug : item.slug.current) : '';
    const isLoaded = (item as any).contentLoaded === true || (item.content && Array.isArray(item.content) && item.content.length > 0);

    // FIXED: Removed isHeroVisible dependency. The ID now remains constant.
    const layoutIdPrefix = (forcedLayoutIdPrefix || storePrefix);
    const isSharedTransitionActive = isHeroTransitionEnabled && layoutIdPrefix && layoutIdPrefix !== 'default';

    const springTransition = { 
        type: 'spring' as const, 
        stiffness: 150, 
        damping: 22, 
        mass: 0.5,
        opacity: { duration: 0 } 
    };
    
    const bodyFadeVariants = { 
        hidden: { opacity: 0, y: 20 }, 
        visible: { 
            opacity: 1, 
            y: 0, 
            transition: { 
                duration: 0.4, 
                ease: "easeOut" as const,
                delay: isSharedTransitionActive ? 0.25 : 0 
            } 
        },
        exit: { opacity: 0, transition: { duration: 0.1 } } 
    };

    useEffect(() => {
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                setIsBodyReady(true);
            });
        });
        
        if (!isSharedTransitionActive) {
            setIsTransitionComplete(true);
        }
    }, [isSharedTransitionActive]);

    const measureHeadings = useCallback(() => {
        const contentElement = articleBodyRef.current;
        if (!contentElement) return;

        const navbarOffset = 90;
        const currentScrollTop = scrollContainerRef?.current 
            ? scrollContainerRef.current.scrollTop 
            : (document.documentElement.scrollTop || document.body.scrollTop);

        const seenIds = new Set<string>();
        let newHeadings: Heading[] = [];
        const headingElements = Array.from(contentElement.querySelectorAll('h1, h2, h3'));
        
        headingElements.forEach((h, index) => {
            let id = h.id;
            if (!id || seenIds.has(id)) { 
                const textContent = h.textContent || '';
                id = generateId(textContent) || `heading-${index}`;
            }
            seenIds.add(id);
            h.id = id;
            
            const rect = h.getBoundingClientRect();
            const topPosition = rect.top + currentScrollTop;
            const scrollToPosition = topPosition - navbarOffset;
            const level = parseInt(h.tagName.substring(1));
            const title = h.textContent || '';
            newHeadings.push({ id, title, top: Math.max(0, scrollToPosition), level });
        });

        if (isReview) {
             const scoreBoxElement = contentElement.querySelector('.score-box-container');
             if (scoreBoxElement) {
                 const rect = scoreBoxElement.getBoundingClientRect();
                 const topPosition = rect.top + currentScrollTop;
                 const scoreBoxScrollPosition = topPosition - navbarOffset;
                 const verdictHeading = { id: 'verdict-summary', title: 'الخلاصة', top: Math.max(0, scoreBoxScrollPosition), level: 2 };
                 newHeadings.push(verdictHeading);
             }
        }
        if (newHeadings.length > 0) setHeadings(newHeadings);
    }, [isReview, scrollContainerRef]);

    useEffect(() => { return () => { setPrefix('default'); }; }, [setPrefix]);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 1024);
        checkMobile();
        const handleResize = () => { checkMobile(); if (isLayoutStable) measureHeadings(); }
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, [isLayoutStable, measureHeadings]); 

    useIsomorphicLayoutEffect(() => { 
        if (scrollContainerRef?.current) {
            scrollContainerRef.current.scrollTop = 0;
        } else {
            window.scrollTo(0, 0); 
        }
    }, [scrollContainerRef]);

    useEffect(() => { 
        if (!isLoaded || !isBodyReady) return; 
        const timeout = setTimeout(() => {
             setIsLayoutStable(true);
             measureHeadings();
        }, 500); 
        return () => clearTimeout(timeout); 
    }, [item, isLoaded, isBodyReady, measureHeadings]);

    if (!item) return null;

    const relatedReviews = Array.isArray((item as any).relatedReviews) ? (item as any).relatedReviews : [];
    const relatedArticles = Array.isArray((item as any).relatedArticles) ? (item as any).relatedArticles : [];
    const relatedNews = Array.isArray((item as any).relatedNews) ? (item as any).relatedNews : [];
    
    const relatedContent = [...relatedReviews, ...relatedArticles, ...relatedNews];
    const uniqueRelatedContent = relatedContent.length > 0 ? Array.from(new Map(relatedContent.map((related: any) => [related._id, related])).values()) : [];
    
    const adaptedRelatedContent = uniqueRelatedContent.map((related: any) => adaptToCardProps(related, { width: 600 })).filter(Boolean) as CardProps[];
    
    const safeTags = Array.isArray(item.tags) ? item.tags : [];
    const safeAuthors = Array.isArray((item as any).authors) ? (item as any).authors : [];
    const safeReporters = Array.isArray((item as any).reporters) ? (item as any).reporters : [];
    const primaryCreators = [...safeAuthors, ...safeReporters];
    
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    
    let formattedDate = '';
    if (item.publishedAt) {
        const publishedDate = new Date(item.publishedAt as string);
        const day = publishedDate.getDate();
        const year = publishedDate.getFullYear();
        const monthIndex = publishedDate.getMonth();
        formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}, ${year}`;
    }

    const contentTypeForActionBar = type.slice(0, -1) as 'review' | 'article' | 'news';
    
    const highResUrl = item.mainImage ? urlFor(item.mainImage).width(2000).height(1125).fit('crop').auto('format').url() : '/placeholder.jpg';
    const displayImageUrl = initialImageSrc || highResUrl;
    const fullResImageUrl = item.mainImage ? urlFor(item.mainImage).auto('format').url() : displayImageUrl;
    const blurDataURL = (item.mainImage as any)?.blurDataURL;
    
    const newsType = (item as any).newsType || 'official';

    const imageLayoutId = isSharedTransitionActive ? generateLayoutId(layoutIdPrefix, 'image', item.legacyId) : undefined;
    const titleLayoutId = isSharedTransitionActive ? generateLayoutId(layoutIdPrefix, 'title', item.legacyId) : undefined;

    const gameObj = (item as any).game;
    const gameSlug = gameObj ? (typeof gameObj.slug === 'string' ? gameObj.slug : gameObj.slug?.current) : null;

    return (
        <>
            <ReadingHud 
                headings={headings} 
                isMobile={isMobile} 
                scrollContainerRef={scrollContainerRef} 
            />

            <motion.div 
                initial={{ opacity: 1 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0, transition: { duration: 0 } }}
                style={{ backgroundColor: 'transparent', zIndex: 50, position: 'relative' }}
            >
                <motion.div 
                    layoutId={imageLayoutId} 
                    className={`${styles.heroImage} image-lightbox-trigger`} 
                    transition={springTransition} 
                    onClick={(e) => {
                        if (!isTransitionComplete && isSharedTransitionActive) return;
                        e.stopPropagation(); 
                        openLightbox([fullResImageUrl], 0);
                    }}
                    onLayoutAnimationComplete={() => {
                        setIsTransitionComplete(true);
                    }}
                    initial={{ opacity: 1 }}
                    animate={{ opacity: 1 }}
                    style={{ 
                        pointerEvents: (isSharedTransitionActive && !isTransitionComplete) ? 'none' : 'auto' 
                    }}
                >
                    <Image 
                        loader={sanityLoader} 
                        src={displayImageUrl} 
                        alt={item.title || 'Hero Image'} 
                        fill 
                        sizes="100vw" 
                        style={{ objectFit: 'cover' }} 
                        priority 
                        placeholder={isSharedTransitionActive ? 'empty' : (blurDataURL ? 'blur' : 'empty')} 
                        blurDataURL={blurDataURL} 
                        unoptimized={!!initialImageSrc}
                    />
                </motion.div>

                <div className="container page-container" style={{ paddingTop: '0' }}>
                    <div className={styles.contentLayout}>
                        <main>
                            <div className={styles.titleWrapper}>
                                {isNews && ( 
                                    <motion.div 
                                        className={styles.headerBadges}
                                        initial={{ opacity: 1 }} 
                                        animate={{ opacity: 1 }}
                                        exit={{ opacity: 0, transition: { duration: 0 } }}
                                    > 
                                        <span className="news-card-category" style={{ margin: 0 }}>{translateTag((item as any).category?.title)}</span> 
                                        <span className={`${styles.pageClassificationBadge} ${styles[newsType]}`}> {typeLabelMap[newsType]} </span> 
                                    </motion.div> 
                                )}
                                
                                <motion.h1 
                                    layoutId={titleLayoutId}
                                    className="page-title" 
                                    style={{ textAlign: 'right', margin: 0 }} 
                                    transition={springTransition}
                                    initial={{ opacity: 1, y: isSharedTransitionActive ? 0 : 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                > 
                                    {item.title} 
                                </motion.h1>
                            </div>
                            
                            {isLoaded && isBodyReady ? (
                                <motion.div
                                    variants={bodyFadeVariants}
                                    initial="hidden"
                                    animate="visible"
                                    exit="exit"
                                >
                                    <div className={styles.metaContainer}>
                                        <div className={styles.metaBlockLeft}>
                                            {gameObj?.title && <GameLink gameName={gameObj.title} gameSlug={gameSlug} />}
                                            <ContentActionBar 
                                                contentId={item.legacyId} 
                                                contentType={contentTypeForActionBar} 
                                                contentSlug={slugString} 
                                                title={item.title}
                                            />
                                        </div>
                                        <div className={styles.metaBlockRight}>
                                            <div className={styles.creditsRow}>
                                                <CreatorCredit label="بقلم" creators={primaryCreators} />
                                                {item.designers && <CreatorCredit label="تصميم" creators={Array.isArray(item.designers) ? item.designers : []} />}
                                            </div>
                                            
                                            <div className={styles.dateContainer}>
                                                {readingTime > 0 && ( 
                                                    <span className={styles.readTimeMinimal} title="وقت القراءة المقدر">
                                                        <span className={styles.timeIcon}><TimeIcon /></span>
                                                        وقت القراءة: {formatArabicDuration(readingTime)}
                                                    </span>
                                                )}

                                                <div className={styles.metaRowItem}>
                                                    <Calendar03Icon className={styles.metadataIcon} />
                                                    <p className={styles.dateText}>{formattedDate}</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <TableOfContents 
                                        headings={tocItems} 
                                        scrollContainerRef={scrollContainerRef} 
                                    />

                                    <div ref={articleBodyRef} className="article-body">
                                        <PortableTextComponent content={item.content || []} colorDictionary={colorDictionary} />
                                        {isReview && <ScoreBox review={adaptReviewForScoreBox(item)} className="score-box-container" />}
                                    </div>
                                    <div style={{ marginTop: '4rem', paddingTop: '2rem', borderTop: '1px solid var(--border-color)' }}>
                                        <TagLinks tags={safeTags.map((t: any) => t.title)} />
                                    </div>
                                </motion.div>
                            ) : (
                                <div style={{ height: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                    <div className="spinner" />
                                </div>
                            )}
                        </main>

                        <aside className={styles.sidebar}>
                            {isLoaded && isBodyReady && (
                                <motion.div
                                    variants={bodyFadeVariants}
                                    initial="hidden"
                                    animate="visible"
                                    exit="exit"
                                >
                                    <JoinVanguardCard /> 
                                    <ContentBlock title="قد يروق لك" Icon={SparklesIcon}>
                                        <motion.div className={styles.relatedGrid} variants={{ visible: { transition: { staggerChildren: 0.1 } } }} initial="hidden" animate="visible" exit="hidden">
                                            {adaptedRelatedContent.map(related => (
                                                <motion.div key={related.id} variants={{ hidden: { opacity: 0, y: 20 }, visible: { opacity: 1, y: 0 } }}>
                                                    <ArticleCard article={related} layoutIdPrefix={`related-${type}`} />
                                                </motion.div>
                                            ))}
                                        </motion.div>
                                    </ContentBlock>
                                </motion.div>
                            )}
                        </aside>
                    </div>
                </div>
            </motion.div>
            
            {isLoaded && isBodyReady && (
                <motion.div initial="hidden" animate="visible" exit="exit" variants={bodyFadeVariants} className="container" style={{ paddingBottom: '6rem' }}>
                    <ContentBlock title="حديث المجتمع">{children}</ContentBlock>
                </motion.div>
            )}
        </>
    );
}

--- END OF FILE components/content/ContentPageClient.tsx ---

================================================================================

--- START OF FILE components/content/GameDetails.module.css ---

/* components/content/GameDetails.module.css */
.detailsContainer {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
  margin: 4rem 0;
}

[data-theme='dark'] .detailsContainer {
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 10%, transparent);
}

.detailRow {
  display: grid;
  grid-template-columns: 2fr 1fr;
  align-items: center;
  position: relative;
}

/* THE DEFINITIVE FIX: Central Divider Line */
.detailRow::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  /* Position the line at the end of the first grid column (2fr / 3fr total = 66.66%) */
  right: calc(100% / 3);
  left: auto;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

.detailRow:not(:last-child) {
  border-bottom: 1px solid var(--border-color);
}

.detailLabel {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-weight: 700;
  font-size: 1.6rem;
  color: var(--accent);
  text-align: right;
  position: relative;
}

/* This is the new rule for the TableComponent header cell's divider */
.detailLabel_before_override::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  left: 0;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

.detailValue {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  text-align: right; /* Default to RTL alignment */
}

/* Enforce LTR text alignment when dir="ltr" is set */
.detailValue[dir='ltr'] {
  text-align: left;
}

@media (max-width: 768px) {
  .detailRow {
    grid-template-columns: 1.5fr 1fr;
  }
  /* THE DEFINITIVE FIX: Adjust divider for mobile grid */
  .detailRow::before {
    right: calc(100% / 2.5); /* 1fr / 2.5fr total */
  }
  .detailLabel,
  .detailValue {
    padding: 1.2rem 1.5rem;
    font-size: 1.5rem;
  }
}




--- END OF FILE components/content/GameDetails.module.css ---

================================================================================

--- START OF FILE components/content/GameDetails.tsx ---

// components/content/GameDetails.tsx
'use client';

import React, { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import styles from './GameDetails.module.css';

type Detail = {
  label: string;
  value: string;
};

interface GameDetailsProps {
  details: Detail[];
}

const isRTL = (s: string) => {
  const rtlChars = /[\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/;
  return rtlChars.test(s);
};

// Animation Variants for Game Details
const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.12, // Stagger each row
            delayChildren: 0.2,
        },
    },
};

const rowVariants = {
    hidden: { opacity: 0, x: -30 }, // Slide in from the left
    visible: {
        opacity: 1,
        x: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX: Explicitly cast the type
            stiffness: 200,
            damping: 25,
        },
    },
};

export default function GameDetails({ details }: GameDetailsProps) {
    const containerRef = useRef(null);
    const isInView = useInView(containerRef, { once: true, amount: 0.4 });

    if (!details || details.length === 0) {
        return null;
    }

    return (
        <motion.div
            ref={containerRef}
            className={styles.detailsContainer}
            variants={containerVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            {details.map((detail, index) => (
                <motion.div key={index} className={styles.detailRow} variants={rowVariants}>
                    <span className={styles.detailLabel}>{detail.label}</span>
                    <span
                        className={styles.detailValue}
                        dir={isRTL(detail.value) ? 'rtl' : 'ltr'}
                    >
                        {detail.value}
                    </span>
                </motion.div>
            ))}
        </motion.div>
    );
}




--- END OF FILE components/content/GameDetails.tsx ---

================================================================================

--- START OF FILE components/content/TableOfContents.module.css ---

/* components/content/TableOfContents.module.css */

.tocContainer {
    position: relative;
    background-color: #080a0f;
    border-radius: 12px;
    padding: 2.5rem 1.5rem 2.5rem 2.5rem; 
    margin-bottom: 4rem;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    overflow: hidden;
}

.tocContainer:hover {
    border-color: var(--accent);
    box-shadow: 0 4px 30px color-mix(in srgb, var(--accent) 10%, transparent);
}

.tocHeader {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    font-weight: 800;
    margin-bottom: 2rem;
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: flex-start; 
    gap: 1rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-left: 1rem;
}

.tocIcon {
    width: 24px;
    height: 24px;
    color: var(--accent);
    opacity: 0.8;
}

.listWrapper {
    max-height: 350px; 
    overflow-y: auto;  
    overflow-x: hidden;
    overscroll-behavior: contain;
    
    /* Visual Fade Mask (Shadow) */
    mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
    
    /* Smooth transition for mask removal (supported in some browsers) */
    transition: -webkit-mask-image 0.3s ease, mask-image 0.3s ease;
    
    padding-bottom: 2rem; 
    padding-left: 1rem;   
    
    /* INTERACTION: Enable Grabbing */
    cursor: grab;
    /* Prevent text selection while dragging */
    user-select: none; 
    -webkit-user-select: none;
}

/* Remove shadow when at bottom */
.listWrapper.atBottom {
    mask-image: none;
    -webkit-mask-image: none;
}

.listWrapper:active {
    cursor: grabbing;
}

.listWrapper::-webkit-scrollbar { width: 4px; }
.listWrapper::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.02); border-radius: 4px; }
.listWrapper::-webkit-scrollbar-thumb { background-color: color-mix(in srgb, var(--accent) 40%, transparent); border-radius: 4px; transition: background-color 0.3s; }
.listWrapper:hover::-webkit-scrollbar-thumb { background-color: var(--accent); }
.listWrapper { scrollbar-width: thin; scrollbar-color: var(--accent) rgba(255, 255, 255, 0.02); }

.tocList {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
    position: relative;
    padding-right: 0.5rem;
}

.tocItem {
    font-family: var(--font-main);
    position: relative;
    padding-right: 3rem; 
    transition: transform 0.2s ease, opacity 0.2s ease;
    opacity: 0.9;
}

.tocItem:hover {
    transform: translateX(-5px);
    opacity: 1;
}

/* --- HIERARCHY STYLES --- */

/* Main Items (Level 1 & 2) */
.tocItem.level-1, .tocItem.level-2 {
    font-size: 1.7rem;
    font-weight: 700;
    color: var(--text-primary);
    margin-top: 0.5rem;
}

/* Main Bullet: Bigger Square */
.tocItem.level-1::before, .tocItem.level-2::before {
    content: '';
    position: absolute;
    right: 0;
    top: 10px;
    width: 8px; /* Bigger */
    height: 8px;
    background-color: var(--text-secondary);
    border-radius: 2px; /* Square */
    transition: background-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
}

.tocItem.level-1:hover::before, .tocItem.level-2:hover::before {
    background-color: var(--accent);
    transform: scale(1.4) rotate(45deg);
    box-shadow: 0 0 10px var(--accent);
}

/* Sub Items (Level 3) */
.tocItem.level-3 {
    font-size: 1.4rem;
    font-weight: 400;
    color: var(--text-secondary);
    padding-right: 5rem; /* Deep Indent */
    margin-top: -0.2rem; /* Closer grouping */
}

/* Sub Bullet: Small Circle */
.tocItem.level-3::before {
    content: '';
    position: absolute;
    right: 2.8rem; /* Indented bullet */
    top: 10px;
    width: 5px;
    height: 5px;
    background-color: var(--border-color);
    border-radius: 50%; /* Round */
    transition: background-color 0.3s ease, transform 0.3s ease;
}

.tocItem.level-3:hover {
    color: var(--text-primary);
}

.tocItem.level-3:hover::before {
    background-color: var(--accent);
    transform: scale(1.5);
}


.tocLink {
    display: block;
    color: inherit;
    text-decoration: none;
    transition: color 0.2s ease;
    line-height: 1.4;
    /* Important for drag scrolling: prevent link dragging ghost */
    -webkit-user-drag: none; 
}

.tocLink:hover {
    color: var(--accent);
}
/* --- Light Mode Overrides --- */
:global([data-theme="light"]) .tocContainer {
  background-color: #ffffff;
  border-color: var(--border-color);
  box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .listWrapper::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
}


--- END OF FILE components/content/TableOfContents.module.css ---

================================================================================

--- START OF FILE components/content/TableOfContents.tsx ---

// components/content/TableOfContents.tsx
'use client';

import React, { useRef, useState, useEffect } from 'react';
import styles from './TableOfContents.module.css';

export type TocItem = {
    id: string;
    text: string;
    level: number;
};

const ListIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="8" y1="6" x2="21" y2="6"></line>
        <line x1="8" y1="12" x2="21" y2="12"></line>
        <line x1="8" y1="18" x2="21" y2="18"></line>
        <line x1="3" y1="6" x2="3.01" y2="6"></line>
        <line x1="3" y1="12" x2="3.01" y2="12"></line>
        <line x1="3" y1="18" x2="3.01" y2="18"></line>
    </svg>
);

export default function TableOfContents({ headings, scrollContainerRef }: { headings: TocItem[], scrollContainerRef?: React.RefObject<HTMLElement | null> }) {
    const scrollRef = useRef<HTMLDivElement>(null);
    const [isAtBottom, setIsAtBottom] = useState(false);
    const isDragging = useRef(false);
    const startY = useRef(0);
    const scrollTop = useRef(0);

    const handleScroll = () => {
        if (scrollRef.current) {
            const { scrollTop: sTop, scrollHeight, clientHeight } = scrollRef.current;
            setIsAtBottom(sTop + clientHeight >= scrollHeight - 2);
        }
    };

    useEffect(() => { handleScroll(); }, [headings]);

    const handleMouseDown = (e: React.MouseEvent) => {
        if (!scrollRef.current) return;
        isDragging.current = true;
        startY.current = e.pageY - scrollRef.current.offsetTop;
        scrollTop.current = scrollRef.current.scrollTop;
        scrollRef.current.style.cursor = 'grabbing';
    };

    const handleMouseLeave = () => {
        isDragging.current = false;
        if (scrollRef.current) scrollRef.current.style.cursor = 'grab';
    };

    const handleMouseUp = () => {
        isDragging.current = false;
        if (scrollRef.current) scrollRef.current.style.cursor = 'grab';
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging.current || !scrollRef.current) return;
        e.preventDefault();
        const y = e.pageY - scrollRef.current.offsetTop;
        const walk = (y - startY.current) * 1.5; 
        scrollRef.current.scrollTop = scrollTop.current - walk;
    };

    if (!headings || headings.length < 2) return null;

    const handleLinkClick = (e: React.MouseEvent<HTMLAnchorElement>, id: string) => {
        e.preventDefault();
        if (Math.abs(e.movementY) > 2) return; 

        const element = document.getElementById(id);
        if (element) {
            // Need to account for relative position if inside overlay
            // Or use scrollIntoView which usually works generally, but smooth options might fight with container
            
            if (scrollContainerRef?.current) {
                // Calculate offset relative to the scroll container
                // This assumes the element is inside the container
                // element.offsetTop is relative to offsetParent. 
                // A reliable way for nested content is using bounding rects.
                
                const containerRect = scrollContainerRef.current.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                const offset = 100;
                
                // Current scroll + distance from container top - offset
                const targetScroll = scrollContainerRef.current.scrollTop + (elementRect.top - containerRect.top) - offset;
                
                scrollContainerRef.current.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });
            } else {
                const offset = 100;
                const elementPosition = element.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - offset;
                
                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
            }
        }
    };

    return (
        <nav className={styles.tocContainer} aria-label="Table of Contents">
            <div className={styles.tocHeader}>
                <ListIcon />
                <span>محتويات المقال</span>
            </div>
            <div 
                className={`${styles.listWrapper} ${isAtBottom ? styles.atBottom : ''}`}
                ref={scrollRef}
                onMouseDown={handleMouseDown}
                onMouseLeave={handleMouseLeave}
                onMouseUp={handleMouseUp}
                onMouseMove={handleMouseMove}
                onScroll={handleScroll}
                data-lenis-prevent
            >
                <ul className={styles.tocList}>
                    {headings.map((heading, index) => (
                        <li key={`${heading.id}-${index}`} className={`${styles.tocItem} ${styles[`level-${Math.min(heading.level, 3)}`]}`}>
                            <a 
                                href={`#${heading.id}`} 
                                onClick={(e) => handleLinkClick(e, heading.id)}
                                className={styles.tocLink}
                            >
                                {heading.text}
                            </a>
                        </li>
                    ))}
                </ul>
            </div>
        </nav>
    );
}

--- END OF FILE components/content/TableOfContents.tsx ---

================================================================================

--- START OF FILE components/content/YoutubeEmbed.tsx ---

// components/content/YoutubeEmbed.tsx
'use client'

import React, { useState } from 'react'
import Image from 'next/image'

const getYouTubeId = (url: string): string | null => {
  const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/
  const match = url.match(regExp)
  return match && match[2].length === 11 ? match[2] : null
}

export default function YoutubeEmbed({value}: {value: {url: string}}) {
  const [isLoaded, setIsLoaded] = useState(false) // <--- State to track interaction
  const {url} = value
  
  if (!url) return null
  const id = getYouTubeId(url)

  if (!id) return null

  // 1. If user clicked, load the heavy iframe (and base.js)
  if (isLoaded) {
      return (
        <div style={{ position: 'relative', paddingBottom: '56.25%', height: 0, overflow: 'hidden', borderRadius: '12px', margin: '4rem 0' }}>
          <iframe
            src={`https://www.youtube.com/embed/${id}?autoplay=1`} // Auto-play since user already clicked
            title="YouTube video player"
            frameBorder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}
          />
        </div>
      )
  }

  // 2. Otherwise, show a lightweight image placeholder
  const thumbnailUrl = `https://img.youtube.com/vi/${id}/maxresdefault.jpg`

  return (
    <div 
      onClick={() => setIsLoaded(true)}
      style={{
        position: 'relative',
        paddingBottom: '56.25%', 
        height: 0,
        overflow: 'hidden',
        maxWidth: '100%',
        background: '#000',
        margin: '4rem 0',
        borderRadius: '12px',
        border: '1px solid var(--border-color)',
        cursor: 'pointer'
      }}
    >
        <Image 
            src={thumbnailUrl} 
            alt="Video Thumbnail" 
            fill 
            style={{ objectFit: 'cover' }}
        />
        {/* Play Button Overlay */}
        <div style={{
            position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
            width: '60px', height: '40px', background: '#FF0000', borderRadius: '10px',
            display: 'flex', alignItems: 'center', justifyContent: 'center', boxShadow: '0 4px 10px rgba(0,0,0,0.5)'
        }}>
            <div style={{ width: 0, height: 0, borderTop: '8px solid transparent', borderBottom: '8px solid transparent', borderLeft: '14px solid white' }} />
        </div>
    </div>
  )
}

--- END OF FILE components/content/YoutubeEmbed.tsx ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.module.css ---

/* components/custom/FourImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}







--- END OF FILE components/custom/FourImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/FourImageGrid.tsx ---

// components/custom/FourImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import { sanityLoader } from '@/lib/sanity.loader';
import styles from './FourImageGrid.module.css';

export default function FourImageGrid({ value }: { value: any }) {
    const { image1, image2, image3, image4 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2, image3, image4].filter(img => img?.asset);
    if (images.length === 0) return null;
    
    const imageUrls = images.map(img => urlFor(img.asset).auto('format').url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={(e) => {
                        e.stopPropagation(); // Stop bubbling
                        openLightbox(imageUrls, index);
                    }}
                >
                    <Image
                        loader={sanityLoader}
                        src={urlFor(image.asset).width(800).auto('format').url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}

--- END OF FILE components/custom/FourImageGrid.tsx ---

================================================================================

--- START OF FILE components/custom/SanityTable.module.css ---

/* components/custom/SanityTable.module.css */

.tableContainer {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
  margin: 4rem 0;
}

[data-theme='dark'] .tableContainer {
  box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 10%, transparent);
}

.table {
  width: 100%;
  border-collapse: collapse;
}

.table th,
.table td {
  padding: 1.5rem 2rem;
  font-family: var(--font-main);
  font-size: 1.6rem;
  color: var(--text-primary);
  text-align: right;
  vertical-align: middle;
  position: relative;
}

.table th {
  font-weight: 700;
  color: var(--accent);
}

.table thead { 
  position: relative;
}

.table thead tr {
  border-bottom: 1px solid var(--border-color);
}

/* THE DEFINITIVE FIX: Full-width horizontal separator */
.table thead::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0; /* Changed from 5% */
  right: 0; /* Changed from 5% */
  height: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
  opacity: 0.8;
}


.table tbody tr:not(:last-child) {
  border-bottom: 1px solid var(--border-color);
}

/* Glowing dividers ONLY for header cells */
.table th:not(:first-child)::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  right: -1px;
  left: auto;
  width: 2px;
  background-color: var(--accent);
  box-shadow: 0 0 8px 0 var(--accent);
}

/* Non-glowing dividers for body cells */
.table td:not(:first-child)::before {
  content: '';
  position: absolute;
  top: 25%;
  bottom: 25%;
  right: -1px;
  left: auto;
  width: 1px; /* Thinner line */
  background-color: var(--border-color); /* Standard border color */
  box-shadow: none; /* No glow */
}

@media (max-width: 768px) {
    .tableContainer {
        overflow-x: auto;
    }
    .table {
        min-width: 600px;
    }
    .table th,
    .table td {
        padding: 1.2rem 1.5rem;
        font-size: 1.5rem;
    }
}




--- END OF FILE components/custom/SanityTable.module.css ---

================================================================================

--- START OF FILE components/custom/SanityTable.tsx ---

// components/custom/SanityTable.tsx
'use client';

import { PortableText } from '@portabletext/react';
import { motion, useInView } from 'framer-motion';
import { useRef } from 'react';
import styles from './SanityTable.module.css';

const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.15,
        },
    },
};

const headerVariants = {
    hidden: { opacity: 0, y: -20 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 150,
            damping: 25,
            staggerChildren: 0.1,
        },
    },
};

const bodyVariants = {
    hidden: {},
    visible: {
        transition: {
            staggerChildren: 0.12,
        },
    },
};

const rowVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 200,
            damping: 30,
            staggerChildren: 0.07,
        },
    },
};

const cellVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
        opacity: 1,
        scale: 1,
        transition: {
            type: 'spring' as const, // THE DEFINITIVE FIX
            stiffness: 250,
            damping: 20,
        },
    },
};

const CellContent = ({ content }: { content: any[] }) => {
    return (
        <motion.div variants={cellVariants}>
            <PortableText value={content} />
        </motion.div>
    );
};

export default function SanityTable({ value }: { value: any }) {
    const tableRef = useRef(null);
    const isInView = useInView(tableRef, { once: true, amount: 0.3 });

    if (!value || !value.rows || value.rows.length === 0) {
        return null;
    }

    const hasHeaderRow = value.rows[0]?.cells.every((cell: any) => cell.isHeader);
    const bodyRows = hasHeaderRow ? value.rows.slice(1) : value.rows;

    return (
        <motion.div
            ref={tableRef}
            className={styles.tableContainer}
            variants={containerVariants}
            initial="hidden"
            animate={isInView ? 'visible' : 'hidden'}
        >
            <table className={styles.table}>
                {hasHeaderRow && (
                    <motion.thead variants={headerVariants}>
                        <tr>
                            {value.rows[0].cells.map((cell: any) => (
                                <th key={cell._key}>
                                    <CellContent content={cell.content} />
                                </th>
                            ))}
                        </tr>
                    </motion.thead>
                )}
                <motion.tbody variants={bodyVariants}>
                    {bodyRows.map((row: any) => (
                        <motion.tr key={row._key} variants={rowVariants}>
                            {row.cells.map((cell: any) => (
                                <td key={cell._key}>
                                    <CellContent content={cell.content} />
                                </td>
                            ))}
                        </motion.tr>
                    ))}
                </motion.tbody>
            </table>
        </motion.div>
    );
}




--- END OF FILE components/custom/SanityTable.tsx ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.module.css ---

/* components/custom/TwoImageGrid.module.css */
.grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    margin: 2rem 0;
}

.imageWrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
}







--- END OF FILE components/custom/TwoImageGrid.module.css ---

================================================================================

--- START OF FILE components/custom/TwoImageGrid.tsx ---

// components/custom/TwoImageGrid.tsx
'use client';

import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import { useLightboxStore } from '@/lib/lightboxStore';
import { sanityLoader } from '@/lib/sanity.loader'; 
import styles from './TwoImageGrid.module.css';

export default function TwoImageGrid({ value }: { value: any }) {
    const { image1, image2 } = value;
    const openLightbox = useLightboxStore((state) => state.openLightbox);

    const images = [image1, image2].filter(img => img?.asset);
    if (images.length === 0) return null;

    const imageUrls = images.map(img => urlFor(img.asset).auto('format').url());

    return (
        <div className={styles.grid}>
            {images.map((image, index) => (
                <div 
                    key={image.asset._id || index}
                    className={`${styles.imageWrapper} image-lightbox-trigger`}
                    onClick={(e) => {
                        e.stopPropagation(); // Stop bubbling
                        openLightbox(imageUrls, index);
                    }}
                >
                    <Image
                        loader={sanityLoader} 
                        src={urlFor(image.asset).width(800).auto('format').url()}
                        alt={image.alt || `Grid Image ${index + 1}`}
                        fill
                        sizes="(max-width: 768px) 50vw, 33vw"
                        draggable={false}
                        style={{ objectFit: 'cover' }}
                    />
                </div>
            ))}
        </div>
    );
}

--- END OF FILE components/custom/TwoImageGrid.tsx ---

================================================================================

--- START OF FILE components/effects/KineticGlyphs.module.css ---

/* components/effects/KineticGlyphs.module.css */
.glyphContainer {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 2;
}

.glyphSvg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    overflow: visible;
}

.glyphPath {
    stroke: var(--accent);
    stroke-width: 1;
    fill: none;
}







--- END OF FILE components/effects/KineticGlyphs.module.css ---

================================================================================

--- START OF FILE components/effects/KineticGlyphs.tsx ---

// components/effects/KineticGlyphs.tsx
'use client';

import { motion, Variants } from 'framer-motion';
import styles from './KineticGlyphs.module.css';

const draw: Variants = {
  hidden: { pathLength: 0, opacity: 0 },
  visible: {
    pathLength: 1,
    opacity: 1,
    transition: {
      pathLength: { type: "spring", duration: 1.5, bounce: 0 },
      opacity: { duration: 0.01 }
    }
  },
  exit: {
    pathLength: 0,
    opacity: 0,
    transition: { duration: 0.3, ease: "easeInOut" }
  }
};

export default function KineticGlyphs() {
    return (
        <div className={styles.glyphContainer}>
            <motion.svg 
                className={styles.glyphSvg} 
                viewBox="0 0 100 100" 
                preserveAspectRatio="none"
            >
                <defs>
                    <filter id="neon-glow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="2" result="coloredBlur" />
                        <feMerge>
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>
                </defs>

                {/* Animated Glowing Frame */}
                <motion.rect
                    x="0" y="0" width="100" height="100" rx="3" ry="3"
                    fill="none"
                    stroke="var(--accent)"
                    strokeWidth="3"
                    vectorEffect="non-scaling-stroke"
                    variants={draw}
                    initial="hidden"
                    animate="visible"
                    exit="exit"
                    style={{ filter: 'url(#neon-glow)' }}
                />
            </motion.svg>
        </div>
    );
}




--- END OF FILE components/effects/KineticGlyphs.tsx ---

================================================================================

--- START OF FILE components/effects/KineticGrid.module.css ---




--- END OF FILE components/effects/KineticGrid.module.css ---

================================================================================

--- START OF FILE components/effects/KineticGrid.tsx ---

// components/effects/KineticGrid.tsx
'use client';

import React, { useRef, createContext, useContext } from 'react';
import { motion, useMotionValue, useSpring, useTransform } from 'framer-motion';
import styles from './KineticGrid.module.css';

// Create a context to pass motion values down to child cards
const KineticGridContext = createContext<{
    mouseX: any;
    mouseY: any;
} | null>(null);

export const useKineticGrid = () => {
    const context = useContext(KineticGridContext);
    if (!context) {
        throw new Error('useKineticGrid must be used within a KineticGrid provider');
    }
    return context;
};

const gridContainerVariants = {
  hidden: { opacity: 0 },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.08,
    },
  },
};

export const KineticGrid = ({ children }: { children: React.ReactNode }) => {
    const gridRef = useRef<HTMLDivElement>(null);

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);

    const springConfig = { stiffness: 150, damping: 20, mass: 0.5 };
    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);

    const rotateX = useTransform(smoothMouseY, [0, 1], ['12deg', '-12deg']);
    const rotateY = useTransform(smoothMouseX, [0, 1], ['-12deg', '12deg']);
    const scale = useSpring(1, springConfig);

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        if (!gridRef.current) return;
        const { left, top, width, height } = gridRef.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const handleMouseEnter = () => {
        scale.set(1.02);
    };

    const handleMouseLeave = () => {
        mouseX.set(0.5);
        mouseY.set(0.5);
        scale.set(1);
    };

    return (
        <KineticGridContext.Provider value={{ mouseX, mouseY }}>
            <motion.div
                ref={gridRef}
                className={styles.perspectiveContainer}
                onMouseMove={handleMouseMove}
                onMouseEnter={handleMouseEnter}
                onMouseLeave={handleMouseLeave}
                style={{
                    rotateX,
                    rotateY,
                    scale
                }}
                variants={gridContainerVariants}
                initial="hidden"
                animate="visible"
            >
                <div className="content-grid">
                    {children}
                </div>
            </motion.div>
        </KineticGridContext.Provider>
    );
};




--- END OF FILE components/effects/KineticGrid.tsx ---

================================================================================

--- START OF FILE components/effects/KineticUnveilCard.module.css ---




--- END OF FILE components/effects/KineticUnveilCard.module.css ---

================================================================================

--- START OF FILE components/effects/KineticUnveilCard.tsx ---




--- END OF FILE components/effects/KineticUnveilCard.tsx ---

================================================================================

--- START OF FILE components/effects/KonamiCode.tsx ---

// components/effects/KonamiCode.tsx
'use client';

import { useEffect, useState } from 'react';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useToast } from '@/lib/toastStore';

const KONAMI_SEQUENCE = [
  'ArrowUp', 'ArrowUp', 
  'ArrowDown', 'ArrowDown', 
  'ArrowLeft', 'ArrowRight', 
  'ArrowLeft', 'ArrowRight', 
  'b', 'a'
];

export default function KonamiCode() {
  const [inputHistory, setInputHistory] = useState<string[]>([]);
  const { setPerformanceTier } = usePerformanceStore();
  const toast = useToast();

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Add new key to history
      const newHistory = [...inputHistory, e.key];
      
      // Keep history length equal to sequence length
      if (newHistory.length > KONAMI_SEQUENCE.length) {
        newHistory.shift();
      }
      
      setInputHistory(newHistory);

      // Check if sequence matches
      if (JSON.stringify(newHistory) === JSON.stringify(KONAMI_SEQUENCE)) {
        // ACTIVATE GOD MODE
        setPerformanceTier(5); // Ultra Tier
        toast.success("🎮 GOD MODE ACTIVATED: Visuals maximized!", "right");
        
        // Play a little sound or effect here if desired? 
        // For now, let's just clear the history so they can do it again.
        setInputHistory([]);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [inputHistory, setPerformanceTier, toast]);

  return null;
}

--- END OF FILE components/effects/KonamiCode.tsx ---

================================================================================

--- START OF FILE components/filters/ArticleFilters.tsx ---

// components/filters/ArticleFilters.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import { translateTag } from '@/lib/translations';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';

export default function ArticleFilters({ 
    sortOrder, onSortChange, searchTerm, onSearchChange, 
    allGames, selectedGame, onGameSelect, 
    allGameTags, selectedGameTags, onGameTagToggle,
    allArticleTypeTags, selectedArticleType, onArticleTypeSelect,
    onClearAllFilters 
}: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const hasActiveFilters = !!selectedGame || selectedGameTags.length > 0 || !!selectedArticleType || searchTerm;

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في المقالات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
            <FilterGroup label="الفرز حسب:">
                {[{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر رواجًا', value: 'viral' }].map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${sortOrder === option.value ? styles.active : ''}`}>
                        {option.label}
                        {sortOrder === option.value && <motion.div layoutId="article-sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="نوع المقال:">
                <motion.button onClick={() => onArticleTypeSelect(null)} className={`${styles.filterButton} ${!selectedArticleType ? styles.active : ''}`}>
                    الكل
                    {!selectedArticleType && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                </motion.button>
                {allArticleTypeTags.map((tag: any) => (
                    <motion.button key={tag._id} onClick={() => onArticleTypeSelect(tag)} className={`${styles.filterButton} ${selectedArticleType?._id === tag._id ? styles.active : ''}`}>
                        {translateTag(tag.title)}
                        {selectedArticleType?._id === tag._id && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="التصفية بـ:">
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedGameTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allGameTags} selectedTags={selectedGameTags} onTagToggle={(tag) => { onGameTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAllFilters} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
             <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {[{ label: 'الأحدث', value: 'latest' }, { label: 'الأكثر رواجًا', value: 'viral' }].map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${sortOrder === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {sortOrder === option.value && <motion.div layoutId="article-sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="النوع:">
                             <motion.button onClick={() => onArticleTypeSelect(null)} className={`${styles.filterButton} ${!selectedArticleType ? styles.active : ''}`}>
                                الكل
                                {!selectedArticleType && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                            </motion.button>
                            {allArticleTypeTags.map((tag: any) => (
                                <motion.button key={tag._id} onClick={() => onArticleTypeSelect(tag)} className={`${styles.filterButton} ${selectedArticleType?._id === tag._id ? styles.active : ''}`}>
                                    {translateTag(tag.title)}
                                    {selectedArticleType?._id === tag._id && <motion.div layoutId="article-type-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="تصفية:">
                             <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedGameTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allGameTags} selectedTags={selectedGameTags} onTagToggle={(tag) => { onGameTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAllFilters}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}




--- END OF FILE components/filters/ArticleFilters.tsx ---

================================================================================

--- START OF FILE components/filters/Filters.module.css ---

/* components/filters/Filters.module.css */

/* --- Main Filter Container --- */
.filtersContainer {
  display: flex;
  flex-direction: column;
  gap: 2.5rem;
  padding: 2.5rem;
  margin-bottom: 4rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  position: relative;
  z-index: 2;
}

.desktopFilters {
  display: flex;
  flex-direction: column;
  gap: 1.8rem; /* Reduced vertical gap between filter groups on desktop */
}

.filterGroup {
  display: flex;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}

.filterLabel {
  font-family: var(--font-main);
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.6rem;
  flex-shrink: 0;
  margin-left: 1.5rem; /* RTL spacing */
}

.filterButtonsGroup {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
}

/* --- THE DEFINITIVE, CENTRALIZED FILTER BUTTON STYLES --- */
.filterButton {
  background-color: transparent;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
  padding: 0.8rem 1.8rem;
  border-radius: 999px;
  font-family: var(--font-main), sans-serif;
  font-weight: 500;
  font-size: 1.4rem;
  cursor: pointer;
  transition: background-color 0.15s ease-out, color 0.15s ease-out, border-color 0.15s ease-out;
  position: relative;
  overflow: hidden;
}
@media (hover: hover) {
  .filterButton:hover  {
    border-color: var(--accent);
    color: var(--accent);
  }
  .filterButton:active  {
    border-color: var(--accent);
    color: var(--accent);
  }
}
.filterButton:active {
  border-color: var(--accent);
  color: var(--accent);
}


.filterButton.active {
  color: var(--bg-secondary);
  background-color: var(--accent);
  border-color: var(--accent);
}

.filterButton.clear {
  color: var(--text-secondary);
  border-color: var(--border-color);
  display: flex;
  align-items: center;
  gap: 0.75rem;
}
@media (hover: hover) {
  .filterButton.clear:hover  {
    background-color: var(--border-color);
    color: var(--text-primary);
  }
  .filterButton.clear:active  {
    background-color: var(--border-color);
    color: var(--text-primary);
  }
}
.filterButton.clear:active {
  background-color: var(--border-color);
  color: var(--text-primary);
}


.filterHighlight {
  position: absolute;
  inset: 0;
  background-color: var(--accent);
  border-radius: 999px;
  z-index: -1;
}

/* --- Search Input (used in both filter bars) --- */
.searchInput {
  flex-grow: 1;
  min-width: 250px;
  padding: 1rem 1.5rem;
  font-size: 1.6rem;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  text-align: right; /* RTL */
  font-family: var(--font-main);
}
.searchInput:focus {
  outline: none;
  border-color: var(--accent);
}

/* --- Popover Container --- */
.filterPopover {
  position: absolute;
  top: calc(100% + 8px);
  right: 0; /* RTL */
  left: auto;
  width: 300px;
  z-index: 10;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 8px;
  box-shadow: 0 10px 30px -5px rgba(0,0,0,0.2);
  padding: 0.75rem;
  display: flex;
  flex-direction: column;
}

.popoverBackdrop {
    position: fixed;
    inset: 0;
    z-index: 5;
    background: transparent;
}

.popoverSearchInput {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1.5rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  margin-bottom: 0.5rem;
  text-align: right; /* RTL */
  font-family: var(--font-main);
}
.popoverSearchInput:focus {
  outline: none;
  border-color: var(--accent);
}

.popoverResultsList {
  max-height: 250px;
  overflow-y: auto;
  text-align: right; /* RTL */
}

.popoverItemButton {
  display: block;
  width: 100%;
  text-align: right; /* RTL */
  padding: 0.75rem 1rem;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-primary);
  border-radius: 4px;
  font-size: 1.5rem;
  font-family: var(--font-main);
  transition: background-color 0.1s ease-out;
}
@media (hover: hover) {
  .popoverItemButton:hover  {
    background-color: var(--bg-primary);
  }
  .popoverItemButton:active  {
    background-color: var(--bg-primary);
  }
}
.popoverItemButton:active {
  background-color: var(--bg-primary);
}

.popoverItemButton.selected {
  background-color: color-mix(in srgb, var(--accent) 15%, transparent);
  color: var(--accent);
  font-weight: 600;
}

/* --- Selected Game Button --- */
.gameSelectedButton {
  display: flex;
  align-items: center; 
  justify-content: space-between;
  max-width: 250px;
}
.gameClearButton {
  background: none;
  border: none;
  padding: 0;
  margin-right: 0.5rem; /* RTL */
  margin-left: 0;
  flex-shrink: 0;
  cursor: pointer;
  color: currentColor; 
  opacity: 0.8;
  transition: opacity 0.2s ease-out;
  display: flex; 
  align-items: center;
  justify-content: center;
  z-index: 2;
}
@media (hover: hover) {
  .gameClearButton:hover  {
    opacity: 1;
  }
  .gameClearButton:active  {
    opacity: 1;
  }
}
.gameClearButton:active {
  opacity: 1;
}

.gameSelectedButton.active {
  background-color: transparent;
  border-color: var(--accent);
  color: #fff;
}
[data-theme="dark"] .gameSelectedButton.active {
  color: var(--bg-primary);
}

.mobileTriggerBar {
    display: none;
}

.collapsibleFilterContent {
    transform-origin: top;
    display: flex;
    flex-direction: column;
    gap: 2rem;
    padding-top: 2rem;
}

@media (max-width: 768px) {
  .desktopFilters {
    display: none;
  }
  .filtersContainer {
    padding: 1.5rem;
    gap: 1.5rem;
  }
  .mobileTriggerBar {
    display: flex;
    gap: 1rem;
    align-items: center;
    width: 100%;
  }
  .filterGroup {
    flex-direction: row;
    align-items: center;
    gap: 1rem;
  }
  .filterLabel {
    margin-left: 0;
    margin-right: 1rem; /* RTL */
  }
  .filterPopover {
    right: auto;
    left: 0;
  }
  /* Fix overflow of search input on mobile */
  .searchInput {
      min-width: 0;
  }
}




--- END OF FILE components/filters/Filters.module.css ---

================================================================================

--- START OF FILE components/filters/GameFilterPopover.tsx ---

// components/filters/GameFilterPopover.tsx
'use client';
import { useState, useMemo } from 'react';
import { motion } from 'framer-motion';
import type { SanityGame } from '@/types/sanity';
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: 10 }, visible: { opacity: 1, x: 0 } };

export default function GameFilterPopover({ allGames, selectedGame, onGameSelect, onClose }: { allGames: SanityGame[], selectedGame: SanityGame | null, onGameSelect: (game: SanityGame | null) => void, onClose: () => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  
  const results = useMemo(() => {
    if (searchTerm.trim() === '') {
        return allGames;
    }
    return allGames.filter(game => 
        game.title.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [searchTerm, allGames]);


  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="ابحث عن لعبة..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {results.map((game, index) => (
          <motion.button 
            key={game._id} 
            variants={itemVariants}
            initial={index < 10 ? "hidden" : "visible"} // <-- THE FIX IS HERE
            animate="visible" // Ensure all items are driven to the 'visible' state
            className={`${styles.popoverItemButton} ${selectedGame?._id === game._id ? styles.selected : ''}`} 
            onClick={() => { onGameSelect(game); onClose(); }}
          >
            {game.title}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}




--- END OF FILE components/filters/GameFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/NewsFilters.tsx ---

// components/filters/NewsFilters.tsx
'use client';

import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';
import type { SanityGame, SanityTag } from '@/types/sanity';

interface NewsFiltersProps {
    activeSort: 'latest' | 'viral';
    onSortChange: (sort: 'latest' | 'viral') => void;
    searchTerm: string;
    onSearchChange: (term: string) => void;
    allGames: SanityGame[];
    selectedGame: SanityGame | null;
    onGameSelect: (game: SanityGame | null) => void;
    allTags: SanityTag[];
    selectedTags: SanityTag[];
    onTagToggle: (tag: SanityTag) => void;
    onClearAll: () => void;
}

export default function NewsFilters({
    activeSort, onSortChange,
    searchTerm, onSearchChange, allGames, selectedGame, onGameSelect,
    allTags, selectedTags, onTagToggle, onClearAll
}: NewsFiltersProps) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);
    
    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const hasActiveFilters = !!searchTerm || !!selectedGame || selectedTags.length > 0 || activeSort !== 'latest';

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في الأخبار بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
            
            <FilterGroup label="الفرز حسب:">
                {[{ label: 'الأحدث', value: 'latest' as 'latest' | 'viral' }, { label: 'الأكثر رواجًا', value: 'viral' as 'latest' | 'viral' }].map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                        {option.label}
                        {activeSort === option.value && <motion.div layoutId="news-sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            
            <FilterGroup label="التصفية بـ:">
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game as SanityGame | null); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
             <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {[{ label: 'الأحدث', value: 'latest' as 'latest' | 'viral' }, { label: 'الأكثر رواجًا', value: 'viral' as 'latest' | 'viral' }].map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {activeSort === option.value && <motion.div layoutId="news-sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="تصفية:">
                             <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game as SanityGame | null); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll}><span>مسح المرشحات</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}




--- END OF FILE components/filters/NewsFilters.tsx ---

================================================================================

--- START OF FILE components/filters/ReviewFilters.tsx ---

// components/filters/ReviewFilters.tsx
'use client';
import { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { FilterRemoveIcon } from '@/components/icons/index';
import GameFilterPopover from './GameFilterPopover';
import TagFilterPopover from './TagFilterPopover';
import ScoreFilterPopover from './ScoreFilterPopover';
import PopoverTriggerButton from './ui/PopoverTriggerButton';
import SelectedGameButton from './ui/SelectedGameButton';
import SelectedTagsButton from './ui/SelectedTagsButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import styles from './Filters.module.css';
import FilterContainer from './ui/FilterContainer';
import FilterGroup from './ui/FilterGroup';

export type SortOption = 'latest' | 'score';
export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';

const sortOptions: { label: string; value: SortOption }[] = [ { label: 'الأحدث', value: 'latest' }, { label: 'الأعلى تقييمًا', value: 'score' }, ];
const scoreRangeMap: Record<ScoreFilter, string> = { 'All': 'الكل', '9-10': '9-10', '8-8.9': '8-8.9', '7-7.9': '7-7.9', '<7': '<7' };

export default function ReviewFilters({ activeSort, onSortChange, selectedScoreRange, onScoreSelect, allGames, selectedGame, onGameSelect, allTags, selectedTags, onTagToggle, onClearAll, searchTerm, onSearchChange }: any) {
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    const scoreButtonLabel = selectedScoreRange === 'All' ? 'التقييم' : `التقييم: ${scoreRangeMap[selectedScoreRange as ScoreFilter]}`;
    const hasActiveFilters = selectedScoreRange !== 'All' || !!selectedGame || selectedTags.length > 0 || searchTerm;

    const desktopFilters = (
        <div className={styles.desktopFilters}>
            <input type="search" placeholder="ابحث في المراجعات بالعنوان..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} style={{ width: '100%', marginBottom: '1.5rem', marginTop: '0.5rem' }} />
            <FilterGroup label="الفرز حسب:">
                {sortOptions.map(option => (
                    <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                        {option.label}
                        {activeSort === option.value && <motion.div layoutId="sort-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                ))}
            </FilterGroup>
            <FilterGroup label="التصفية حسب:">
                <div style={{ position: 'relative' }}>
                    <PopoverTriggerButton label={scoreButtonLabel} isActive={selectedScoreRange !== 'All'} onClick={() => togglePopover('score')} layoutId="review-score-highlight" />
                    <AnimatePresence>{openPopover === 'score' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><ScoreFilterPopover selectedScoreRange={selectedScoreRange} onScoreSelect={(score) => { onScoreSelect(score); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </div>
                <motion.div style={{ position: 'relative' }} layout>
                    <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                    <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                </motion.div>
                <div style={{ position: 'relative' }}>
                    <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                    <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                </div>
                <AnimatePresence>{hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll} initial={{ opacity: 0, scale: 0.8 }} animate={{ opacity: 1, scale: 1 }} exit={{ opacity: 0, scale: 0.8 }}><span>مسح الكل</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}</AnimatePresence>
            </FilterGroup>
        </div>
    );
    
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                <input type="search" placeholder="ابحث..." className={styles.searchInput} value={searchTerm} onChange={(e) => onSearchChange(e.target.value)} />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>
            <AnimatePresence>
                {isMobileFiltersOpen && (
                    <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                        <FilterGroup label="الفرز حسب:">
                            {sortOptions.map(option => (
                                <motion.button key={option.value} onClick={() => onSortChange(option.value)} className={`${styles.filterButton} ${activeSort === option.value ? styles.active : ''}`}>
                                    {option.label}
                                    {activeSort === option.value && <motion.div layoutId="sort-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </FilterGroup>
                        <FilterGroup label="التصفية حسب:">
                           <div style={{ position: 'relative' }}>
                                <PopoverTriggerButton label={scoreButtonLabel} isActive={selectedScoreRange !== 'All'} onClick={() => togglePopover('score')} layoutId="review-score-highlight" />
                                <AnimatePresence>{openPopover === 'score' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><ScoreFilterPopover selectedScoreRange={selectedScoreRange} onScoreSelect={(score) => { onScoreSelect(score); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </div>
                            <motion.div style={{ position: 'relative' }} layout>
                                <SelectedGameButton selectedGame={selectedGame} onClearGame={onGameSelect} onOpenPopover={() => togglePopover('game')} />
                                <AnimatePresence>{openPopover === 'game' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><GameFilterPopover allGames={allGames} selectedGame={selectedGame} onGameSelect={(game) => { onGameSelect(game); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </motion.div>
                            <div style={{ position: 'relative' }}>
                                <SelectedTagsButton selectedTags={selectedTags} onOpenPopover={() => togglePopover('tags')} />
                                <AnimatePresence>{openPopover === 'tags' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><TagFilterPopover allTags={allTags} selectedTags={selectedTags} onTagToggle={(tag) => { onTagToggle(tag); }} /></>}</AnimatePresence>
                            </div>
                        </FilterGroup>
                        {hasActiveFilters && (<motion.button className={`${styles.filterButton} ${styles.clear}`} onClick={onClearAll}><span>مسح الكل</span><FilterRemoveIcon height={18} width={18} /></motion.button>)}
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}




--- END OF FILE components/filters/ReviewFilters.tsx ---

================================================================================

--- START OF FILE components/filters/ScoreFilterPopover.tsx ---

// components/filters/ScoreFilterPopover.tsx
'use client';
import { motion } from 'framer-motion';
import styles from './Filters.module.css';

export type ScoreFilter = 'All' | '9-10' | '8-8.9' | '7-7.9' | '<7';
const scoreFilters: { label: string; value: ScoreFilter }[] = [
    { label: 'كل التقييمات', value: 'All' },
    { label: 'تحفة فنية (9-10)', value: '9-10' },
    { label: 'رائعة (8-8.9)', value: '8-8.9' },
    { label: 'جيدة (7-7.9)', value: '7-7.9' },
    { label: 'متفاوتة (<7)', value: '<7' },
];
const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1, transition: { staggerChildren: 0.05 } }, exit: { opacity: 0, y: -10, scale: 0.95 }, };
const itemVariants = { hidden: { opacity: 0, x: 10 }, visible: { opacity: 1, x: 0 } }; // RTL: from right

export default function ScoreFilterPopover({ selectedScoreRange, onScoreSelect, onClose }: { selectedScoreRange: ScoreFilter, onScoreSelect: (score: ScoreFilter) => void, onClose: () => void }) {
  return (
    <motion.div className={styles.filterPopover} style={{ width: '220px' }} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <div className={styles.popoverResultsList}>
        {scoreFilters.map(filter => (
          <motion.button key={filter.value} variants={itemVariants} className={`${styles.popoverItemButton} ${selectedScoreRange === filter.value ? styles.selected : ''}`} onClick={() => { onScoreSelect(filter.value); onClose(); }}>
            {filter.label}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}










--- END OF FILE components/filters/ScoreFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/TagFilterPopover.tsx ---

// components/filters/TagFilterPopover.tsx
'use client';
import { useState } from 'react';
import { motion } from 'framer-motion';
import type { SanityTag } from '@/types/sanity';
import { translateTag } from '@/lib/translations'; // Import the translator
import styles from './Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: -10, scale: 0.95 }, };

export default function TagFilterPopover({ allTags, selectedTags, onTagToggle }: { allTags: SanityTag[], selectedTags: SanityTag[], onTagToggle: (tag: SanityTag) => void }) {
  const [searchTerm, setSearchTerm] = useState('');
  const selectedTagIds = new Set(selectedTags.map(t => t._id));

  // DEFINITIVE FIX: Search both the original English title and the translated Arabic title.
  const filteredTags = allTags.filter(tag => 
    tag.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
    translateTag(tag.title).toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <motion.div className={styles.filterPopover} variants={popoverVariants} initial="hidden" animate="visible" exit="exit" onClick={(e) => e.stopPropagation()}>
      <input type="search" placeholder="ابحث عن وسم..." className={styles.popoverSearchInput} value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} autoFocus />
      <div className={styles.popoverResultsList}>
        {filteredTags.map(tag => (
          <motion.button key={tag._id} className={`${styles.popoverItemButton} ${selectedTagIds.has(tag._id) ? styles.selected : ''}`} onClick={() => onTagToggle(tag)}>
            {translateTag(tag.title)}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}










--- END OF FILE components/filters/TagFilterPopover.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterContainer.tsx ---

// components/filters/ui/FilterContainer.tsx
import React from 'react';
import styles from '../Filters.module.css';

interface FilterContainerProps {
    children: React.ReactNode;
}

const FilterContainer = React.forwardRef<HTMLDivElement, FilterContainerProps>(({ children }, ref) => {
    return (
        <div className={styles.filtersContainer} ref={ref}>
            {children}
        </div>
    );
});

FilterContainer.displayName = 'FilterContainer';
export default FilterContainer;

--- END OF FILE components/filters/ui/FilterContainer.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterGroup.tsx ---

// components/filters/ui/FilterGroup.tsx
import React from 'react';
import styles from '../Filters.module.css';

interface FilterGroupProps {
    label?: string;
    children: React.ReactNode;
}

export default function FilterGroup({ label, children }: FilterGroupProps) {
    return (
        <div className={styles.filterGroup}>
            {label && <span className={styles.filterLabel}>{label}</span>}
            <div className={styles.filterButtonsGroup}>
                {children}
            </div>
        </div>
    );
}

--- END OF FILE components/filters/ui/FilterGroup.tsx ---

================================================================================

--- START OF FILE components/filters/ui/FilterToggleButton.tsx ---

// components/filters/ui/FilterToggleButton.tsx
'use client';

import { motion } from 'framer-motion';
import { FilterHorizontalIcon } from '@/components/icons/index';
import styles from '../Filters.module.css';

export default function FilterToggleButton({ onClick, hasActiveFilters }: { onClick: () => void, hasActiveFilters: boolean }) {
    return (
        <motion.button
            onClick={onClick}
            className={`${styles.filterButton} ${hasActiveFilters ? styles.active : ''}`}
            style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', flexShrink: 0, zIndex: 1 }}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
        >
            <span style={{ zIndex: 1, position: 'relative' }}>الفلاتر</span>
            <FilterHorizontalIcon height={20} width={20} />
        </motion.button>
    );
}

--- END OF FILE components/filters/ui/FilterToggleButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

// components/filters/ui/PopoverTriggerButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';

interface PopoverTriggerButtonProps {
    label: string;
    isActive: boolean;
    onClick: () => void;
    className?: string;
    layoutId?: string; // Prop is now used to pass a UNIQUE ID
}

export default function PopoverTriggerButton({ label, isActive, onClick, className = '', layoutId }: PopoverTriggerButtonProps) {
    return (
        <motion.button
            onClick={onClick}
            className={`${styles.filterButton} ${isActive ? styles.active : ''} ${className}`}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
        >
            {/* The highlight is only rendered if a layoutId is provided */}
            {isActive && layoutId && <motion.div layoutId={layoutId} className={styles.filterHighlight} />}
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.button>
    );
}













--- END OF FILE components/filters/ui/PopoverTriggerButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedGameButton.tsx ---

// components/filters/ui/SelectedGameButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityGame } from '@/types/sanity';

interface SelectedGameButtonProps {
    selectedGame: SanityGame | null;
    onClearGame: (game: null) => void;
    onOpenPopover: () => void;
}

export default function SelectedGameButton({ selectedGame, onClearGame, onOpenPopover }: SelectedGameButtonProps) {
    if (!selectedGame) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>
                اللعبة
            </button>
        );
    }
    
    return (
        <motion.div layout className={`${styles.filterButton} ${styles.gameSelectedButton} ${styles.active}`} onClick={onOpenPopover}>
            <motion.div layoutId="game-filter-highlight" className={styles.filterHighlight} />
            <span style={{ zIndex: 1, position: 'relative', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', paddingLeft: '1.5rem' }}>
                {selectedGame.title}
            </span>
            {/* FIX: Changed button to motion.button to support whileTap */}
            <motion.button 
                className={styles.gameClearButton}
                onClick={(e) => {
                    e.stopPropagation(); 
                    onClearGame(null);
                }}
                whileTap={{ scale: 0.9 }}
            >
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </motion.button>
        </motion.div>
    );
}

--- END OF FILE components/filters/ui/SelectedGameButton.tsx ---

================================================================================

--- START OF FILE components/filters/ui/SelectedTagsButton.tsx ---

// components/filters/ui/SelectedTagsButton.tsx
'use client';

import { motion } from 'framer-motion';
import styles from '../Filters.module.css';
import type { SanityTag } from '@/types/sanity';
import { translateTag } from '@/lib/translations';

interface SelectedTagsButtonProps {
    selectedTags: SanityTag[];
    onOpenPopover: () => void;
}

export default function SelectedTagsButton({ selectedTags, onOpenPopover }: SelectedTagsButtonProps) {
    const isActive = selectedTags.length > 0;
    const label = isActive ? `الوسوم (${selectedTags.length})` : "الوسوم";

    if (!isActive) {
        return (
            <button onClick={onOpenPopover} className={styles.filterButton}>
                {label}
            </button>
        );
    }
    
    return (
        <motion.div
            layout
            className={`${styles.filterButton} ${styles.active}`}
            onClick={onOpenPopover}
        >
            <motion.div layoutId="tags-filter-highlight" className={styles.filterHighlight} />
            <span style={{ zIndex: 1, position: 'relative' }}>{label}</span>
        </motion.div>
    );
}

--- END OF FILE components/filters/ui/SelectedTagsButton.tsx ---

================================================================================

--- START OF FILE components/homepage/HomepageFeeds.module.css ---

/* components/homepage/HomepageFeeds.module.css */
.feedsGrid {
    display: grid;
    /* Adjusted from 1.35fr to 1.15fr to shrink the articles block further */
    grid-template-columns: 1.15fr 1fr;
    gap: 4rem;
    margin-top: 6rem;
}

@media (max-width: 1024px) {
    .feedsGrid {
        grid-template-columns: 1fr;
        gap: 6rem;
        margin-top: 4rem;
    }
}




--- END OF FILE components/homepage/HomepageFeeds.module.css ---

================================================================================

--- START OF FILE components/homepage/HomepageFeeds.tsx ---

// components/homepage/HomepageFeeds.tsx
'use client';

import React, { useRef, useState } from "react";
import { motion, useScroll, useTransform } from "framer-motion";
import Feed from "./feed/Feed";
import { CardProps } from "@/types";
import { ContentBlock } from "../ContentBlock";
import { ArticleIcon, NewsIcon } from "@/components/icons/index";
import PaginatedCarousel from "../PaginatedCarousel";
import KineticSpotlightNews from "./kinetic-news/KineticSpotlightNews";
import NewsfeedStream from "./kinetic-news/NewsfeedStream";
import ArticleCard from "@/components/ArticleCard";
import gridStyles from './HomepageFeeds.module.css';
import feedStyles from './feed/Feed.module.css';
import { useContentStore } from "@/lib/contentStore"; 

interface HomepageFeedsProps {
    topArticles: CardProps[];
    latestArticles: CardProps[];
    pinnedNews: CardProps[];
    newsList: CardProps[];
}

export default function HomepageFeeds({ topArticles, latestArticles, pinnedNews, newsList }: HomepageFeedsProps) {
    const containerRef = useRef<HTMLDivElement>(null);
    const { scrollYProgress } = useScroll({ target: containerRef, offset: ['start end', 'end start'] });
    const articlesY = useTransform(scrollYProgress, [0, 1], [0, -80]);
    const newsY = useTransform(scrollYProgress, [0, 1], [0, -50]);

    const [isNewsExpanded, setIsNewsExpanded] = useState(false);
    const { openIndexOverlay } = useContentStore();

    return (
        <div className={gridStyles.feedsGrid} ref={containerRef}>
            <motion.div style={{ y: articlesY }}>
                <ContentBlock title="موجز المقالات" Icon={ArticleIcon}>
                    <Feed
                        topSectionLabel="الأكثر رواجًا"
                        latestSectionLabel="الأحدث"
                        topItems={topArticles}
                        viewAllText="عرض كل المقالات"
                        onViewAll={() => openIndexOverlay('articles')}
                        
                        topItemsContainerClassName={`${feedStyles.topArticlesGrid} gpu-cull`}
                        renderTopItem={(item) => (
                            <ArticleCard 
                                key={item.id} 
                                article={item} 
                                // PREFIX 1: Top Articles (Most Popular)
                                layoutIdPrefix="homepage-top-articles"
                                isPriority={true}
                                smallTags={false} 
                            />
                        )}
                        enableTopSectionHoverEffect={false}
                        latestSectionContent={
                            <div style={{ marginTop: '1.5rem' }}>
                                {/* PREFIX 2: Latest Articles (Paginated Carousel) */}
                                <PaginatedCarousel 
                                    items={latestArticles} 
                                    layoutIdPrefix="homepage-latest-articles"
                                />
                            </div>
                        }
                    />
                </ContentBlock>
            </motion.div>
            <motion.div style={{ y: newsY }}>
                <ContentBlock title="موجز الأخبار" Icon={NewsIcon}>
                    <Feed
                        topSectionLabel="الأكثر رواجًا"
                        latestSectionLabel="الأحدث"
                        topItems={pinnedNews}
                        
                        viewAllText={isNewsExpanded ? "عرض كل الأخبار" : "المزيد من الأخبار"}
                        onViewAll={() => {
                            if (!isNewsExpanded) {
                                setIsNewsExpanded(true);
                            } else {
                                openIndexOverlay('news');
                            }
                        }}
                        
                        topItemsContainerClassName={feedStyles.pinnedNewsList}
                        renderTopItem={() => null}
                        topSectionContent={
                            // PREFIX 3: Pinned News (Spotlight)
                            <KineticSpotlightNews 
                                items={pinnedNews} 
                                layoutIdPrefix="homepage-pinned-news" 
                            />
                        }
                        latestSectionContent={
                            <div style={{ marginTop: '1.5rem' }}>
                                {/* PREFIX 4: Latest News (Stream) */}
                                <NewsfeedStream 
                                    items={newsList} 
                                    isExpanded={isNewsExpanded} 
                                    layoutIdPrefix="homepage-news-stream" 
                                />
                            </div>
                        }
                        enableTopSectionHoverEffect={true}
                    />
                </ContentBlock>
            </motion.div>
        </div>
    );
}

--- END OF FILE components/homepage/HomepageFeeds.tsx ---

================================================================================

--- START OF FILE components/homepage/PaginatedLatestArticles.module.css ---

/* components/homepage/PaginatedLatestArticles.module.css */

.paginatedContainer {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.paginatedContent {
    /* flex-grow: 1; <-- This property was pushing the controls to the bottom, it has been removed. */
    position: relative;
    min-height: 380px; /* Adjust based on item height to prevent layout shift */
}

.itemList {
    display: flex;
    flex-direction: column;
    
    /* GPU CULL FIX: Expand render boundary */
    padding: 10rem;
    margin: -10rem;
    /* Adjust width to compensate for horizontal padding */
    width: calc(100% + 20rem);
    
    /* FIX: Prevent padding from capturing mouse events */
    pointer-events: none;
}

/* Restore interaction */
.itemList > * {
    pointer-events: auto;
}

.paginationControls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    padding-top: 1rem; /* Reduced top padding to bring controls closer to content */
    padding-bottom: 1.5rem; /* Added bottom padding for spacing from elements below */
    
    /* Ensure controls stay on top of the expanded negative margins */
    position: relative;
    z-index: 10;
}

.paginationDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: var(--border-color);
    border: none;
    cursor: pointer;
    padding: 0;
    transition: all 0.3s ease;
}
@media (hover: hover) {
  .paginationDot:hover  {
    background-color: var(--text-secondary);
  }
  .paginationDot:active  {
    background-color: var(--text-secondary);
  }
}
.paginationDot:active {
    background-color: var(--text-secondary);
}


.paginationDot.active {
    background-color: var(--accent);
    transform: scale(1.2);
    box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 50%, transparent);
}

@media (max-width: 768px) {
    /* TIGHTEN MOBILE SPACING */
    .paginatedContent {
        min-height: auto; /* Allow auto height on mobile to reduce gaps */
    }
    .paginationControls {
        padding-top: 0.5rem; /* Pull dots up */
        padding-bottom: 1rem;
    }
    .itemList {
        gap: 1rem !important; /* Force smaller gap between items in list */
        
        /* Reset Expansion on mobile to prevent overflow issues */
    }
}

--- END OF FILE components/homepage/PaginatedLatestArticles.module.css ---

================================================================================

--- START OF FILE components/homepage/PaginatedLatestArticles.tsx ---

// components/homepage/PaginatedLatestArticles.tsx
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import { CardProps } from '@/types';
import styles from './PaginatedLatestArticles.module.css';
import NewsGridCard from '@/components/news/NewsGridCard';
import { useActiveCardStore } from '@/lib/activeCardStore';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useContentStore } from '@/lib/contentStore'; // IMPORTED

type PaginatedCarouselProps = {
    items: CardProps[];
    itemsPerPage?: number;
};

export default function PaginatedCarousel({ items, itemsPerPage = 5 }: PaginatedCarouselProps) {
    const [currentPage, setCurrentPage] = useState(0);
    const [isHovered, setIsHovered] = useState(false);
    const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);
    
    const timeoutRef = useRef<NodeJS.Timeout | null>(null);
    const totalPages = Math.ceil(items.length / itemsPerPage);
    
    const { activeCardId } = useActiveCardStore();
    // Use Store
    const { isCarouselAutoScrollEnabled } = usePerformanceStore();
    const isOverlayOpen = useContentStore((s) => s.isOverlayOpen); // MODIFIED

    const containerRef = useRef<HTMLDivElement>(null);
    const isInView = useInView(containerRef, { amount: 0.1 });

    const resetTimeout = () => { if (timeoutRef.current) { clearTimeout(timeoutRef.current); } };

    useEffect(() => {
        resetTimeout();
        // MODIFIED: Check isOverlayOpen
        if (!isHovered && isInView && totalPages > 1 && isCarouselAutoScrollEnabled && !isOverlayOpen) {
            timeoutRef.current = setTimeout(
                () => setCurrentPage((prevPage) => (prevPage + 1) % totalPages),
                3800
            );
        }
        return () => resetTimeout();
    }, [currentPage, isHovered, totalPages, isInView, isCarouselAutoScrollEnabled, isOverlayOpen]);

    const startIndex = currentPage * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = items.slice(startIndex, endIndex);
    
    const interactionHandlers = {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => {
            setIsHovered(false);
            setHoveredIndex(null); 
        },
        onTouchStart: () => setIsHovered(true),
        onTouchEnd: () => setIsHovered(false),
        onTouchCancel: () => setIsHovered(false),
    };

    return (
        <div 
            ref={containerRef}
            className={styles.paginatedContainer}
            {...interactionHandlers}
        >
            <div className={styles.paginatedContent}>
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentPage}
                        initial={{ opacity: 0, x: -50 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 50 }} 
                        transition={{ duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                        className={`${styles.itemList} gpu-cull`} 
                        style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}
                    >
                        {currentItems.map((item, index) => (
                            <motion.div
                                key={item.legacyId}
                                style={{ 
                                    height: 'auto', 
                                    position: 'relative', 
                                    zIndex: (activeCardId === item.id || hoveredIndex === index) ? 100 : 1 
                                }}
                                onMouseEnter={() => setHoveredIndex(index)}
                                onMouseLeave={() => setHoveredIndex(null)}
                            >
                                <NewsGridCard 
                                    item={item} 
                                    layoutIdPrefix="homepage-latest-articles"
                                    variant="compact"
                                />
                            </motion.div>
                        ))}
                    </motion.div>
                </AnimatePresence>
            </div>
            {totalPages > 1 && (
                <div className={styles.paginationControls}>
                    {Array.from({ length: totalPages }).map((_, index) => (
                        <button
                            key={index}
                            className={`${styles.paginationDot} ${currentPage === index ? styles.active : ''}`}
                            onClick={() => setCurrentPage(index)}
                            aria-label={`Go to page ${index + 1}`}
                        />
                    ))}
                </div>
            )}
        </div>
    );
}

--- END OF FILE components/homepage/PaginatedLatestArticles.tsx ---

================================================================================

--- START OF FILE components/homepage/feed/Feed.module.css ---

/* components/homepage/feed/Feed.module.css */
@keyframes pulse-live {
    0%, 100% { box-shadow: 0 0 5px 1px color-mix(in srgb, var(--accent) 60%, transparent); transform: scale(1); }
    50% { box-shadow: 0 0 10px 2px color-mix(in srgb, var(--accent) 80%, transparent); transform: scale(1.1); }
}

/* --- Generic Feed Container --- */
.feedContainer {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    height: 100%;
    display: flex;
    flex-direction: column;
    /* CRITICAL FIX: Allow cards to fly out */
    overflow: visible !important;
    position: relative;
    z-index: 1;
}

.topSection {
    padding: 1.5rem 2rem;
    position: relative;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: flex-start;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
    overflow: visible !important;
    z-index: 5;
}

.sectionLabel {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    font-family: var(--font-ui);
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--accent);
    padding: 0.4rem 1.2rem;
    border: 1px solid var(--accent);
    border-radius: 999px;
    position: relative;
    z-index: 2;
}

/* Reverted to single indicator style */
.liveIndicator {
    width: 8px;
    height: 8px;
    background-color: var(--accent);
    border-radius: 50%;
    animation: pulse-live 1.5s infinite ease-in-out;
}

.topItemsContainer {
    position: relative;
    width: 100%;
    order: 2; 
    margin-top: 1.5rem;
    overflow: visible !important;
    z-index: 10;
}

.latestSection {
    padding: 1.5rem 2rem 0 2rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    z-index: 1;
    position: relative;
}

.latestItemsList {
    flex-grow: 1;
}

.listDivider {
    height: 1px;
    background: linear-gradient(to left, transparent, var(--border-color) 20%, var(--border-color) 80%, transparent);
}

.viewAllLink {
    display: flex;
    direction: rtl; 
    flex-direction: row-reverse;
    gap: 0.5rem; 
    
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 1.25rem;
    margin-top: auto;
    border-top: 1px solid var(--border-color);
    font-family: var(--font-ui);
    font-weight: 600;
    color: var(--text-secondary);
    transition: background-color 0.2s ease, color 0.2s ease;
    position: relative;
    z-index: 2;
}

.viewAllLink span {
    font-size: 1.6rem;
}

.viewAllLink svg {
    width: 2rem;
    height: 2rem;
    color: var(--accent); 
    transform: scaleX(-1); 
    transition: transform 0.2s ease, color 0.2s ease;
}
@media (hover: hover) {
  .viewAllLink:hover  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
  }
  .viewAllLink:hover svg  {
    transform: translateX(4px) scaleX(-1); 
    color: var(--accent);
  }
}

.viewAllLink:active {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}
.viewAllLink:active svg {
    transform: translateX(4px) scaleX(-1); 
    color: var(--accent);
}

/* --- Article Feed Specifics --- */
.topArticlesGrid {
    display: grid;
    /* FIX: Desktop uses 2 columns (1fr 1fr) */
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    overflow: visible !important;
    
    /* GPU CULL FIX: MASSIVE expansion of render boundary */
    padding: 10rem;
    margin: -10rem;
    width: calc(100% + 20rem);
    
    /* FIX: Prevent padding from capturing mouse events */
    pointer-events: none;
}

/* Restore pointer events for grid items */
.topArticlesGrid > * {
    pointer-events: auto;
}

.topArticleCard {
    display: block;
    text-decoration: none;
    position: relative;
    overflow: visible !important; 
    border-radius: 12px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    transform-style: preserve-3d;
    will-change: transform;
    cursor: pointer;
    transform: translateZ(0px);
    height: 100%;
}

.topArticleImage {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    overflow: hidden; 
}

.topArticleImage img {
    transition: transform 0.4s ease-out;
}
@media (hover: hover) {
  .topArticleCard:hover .topArticleImage img  { transform: scale(1.03); }
  .topArticleCard:active .topArticleImage img  { transform: scale(1.03); }
}

.topArticleContent {
    padding: 1.2rem;
    text-align: right;
    border-top: 1px solid var(--border-color);
    transform: translateZ(20px);
}

.topArticleTitle {
    font-family: var(--font-heading);
    font-size: 1.6rem;
    color: var(--text-primary);
    line-height: 1.3;
    margin: 0 0 0.5rem 0;
    transition: color 0.2s ease;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}
@media (hover: hover) {
  .topArticleCard:hover .topArticleTitle  { color: var(--accent); }
  .topArticleCard:active .topArticleTitle  { color: var(--accent); }
}

.topArticleMeta {
    font-size: 1.2rem;
    color: var(--text-secondary);
}

.topArticleCardInner {
    height: 100%;
    display: flex;
    flex-direction: column;
    border-radius: 12px;
}

.latestArticleItem {
    display: grid;
    grid-template-columns: 85px 1fr; 
    gap: 1.2rem; 
    align-items: center;
    position: relative;
    padding: 1rem 0;
    border-radius: 8px;
    cursor: pointer;
    flex-grow: 1; 
}


.latestArticleThumbnail {
    width: 85px;
    height: 55px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
    transition: border-color 0.3s ease;
}
@media (hover: hover) {
  .latestArticleItem:hover .latestArticleThumbnail  { border-color: var(--accent); }
  .latestArticleItem:hover .latestArticleThumbnail img  { transform: scale(1.05); }
}
.latestArticleItem:active .latestArticleThumbnail { border-color: var(--accent); }
.latestArticleItem:active .latestArticleThumbnail img { transform: scale(1.05); }


.latestArticleThumbnail img {
    transition: transform 0.3s ease-out;
}

.latestArticleInfo {
    text-align: right;
}

.latestArticleTitle {
    font-size: 1.5rem;
    font-weight: 600;
    line-height: 1.35;
    color: var(--text-primary);
    margin: 0 0 0.4rem 0;
    transition: color 0.2s ease;
    position: relative;
    display: inline-block;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}
@media (hover: hover) {
  .latestArticleItem:hover .latestArticleTitle  { color: var(--accent); }
  .latestArticleItem:hover .latestArticleTitle::after  { transform: scaleX(1); }
}
.latestArticleItem:active .latestArticleTitle { color: var(--accent); }
.latestArticleItem:active .latestArticleTitle::after { transform: scaleX(1); }


.latestArticleTitle::after {
    content: '';
    position: absolute;
    bottom: -4px;
    right: 0;
    width: 100%;
    height: 1px;
    background: var(--accent);
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    filter: drop-shadow(0 0 4px var(--accent));
}

.latestArticleMeta {
    font-size: 1.2rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
}

.latestArticleDate {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* --- News Feed Specifics --- */
.pinnedNewsList {
    display: flex;
    flex-direction: column;
    overflow: visible !important;
}

.pinnedNewsDivider {
    height: 1px;
    background-color: color-mix(in srgb, var(--accent) 30%, transparent);
    margin: 0.75rem 0;
}

.pinnedNewsItem {
    display: grid;
    grid-template-columns: 80px 1fr;
    gap: 1.5rem;
    align-items: center;
    text-decoration: none;
    cursor: pointer;
    padding: 0.5rem;
    margin: -0.5rem;
    border-radius: 8px;
    transition: background-color 0.2s ease;
    min-height: 80px; 
    overflow: visible !important;
}
@media (hover: hover) {
  .pinnedNewsItem:hover  { background-color: var(--bg-primary); }
  .pinnedNewsItem:hover .pinnedNewsThumbnail img  { transform: scale(1.05); }
  .pinnedNewsItem:hover .pinnedNewsTitle  { color: var(--accent); }
}
.pinnedNewsItem:active { background-color: var(--bg-primary); }
.pinnedNewsItem:active .pinnedNewsThumbnail img { transform: scale(1.05); }
.pinnedNewsItem:active .pinnedNewsTitle { color: var(--accent); }

.pinnedNewsThumbnail {
    width: 80px;
    height: 50px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: 1px solid transparent;
}

.pinnedNewsThumbnail img {
    transition: transform 0.3s ease-out;
}

.pinnedNewsInfo {
    text-align: right;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.25rem;
}

.pinnedNewsTitle {
    font-size: 1.7rem;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.2s ease;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;  
    overflow: hidden;
    text-overflow: ellipsis;
}

.pinnedNewsDate {
    font-size: 1.3rem;
    color: var(--text-secondary);
    margin: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.pinnedNewsCategory {
    font-size: 1.3rem;
    font-weight: 500;
    color: var(--accent);
    margin: 0;
}

.newsListDivider {
    height: 1px;
    background: var(--border-color);
}

.newsListItem {
    display: grid;
    grid-template-columns: 60px 1fr;
    gap: 1.5rem;
    align-items: center;
    text-decoration: none;
    padding: 1.25rem 1rem;
    border-radius: 8px;
    margin: 0 -1rem;
    transition: background-color 0.2s ease;
    cursor: pointer;
}
@media (hover: hover) {
  .newsListItem:hover  { background-color: var(--bg-primary); }
  .newsListItem:hover .newsListTitle  { color: var(--accent); }
  .newsListItem:hover .newsListThumbnail  { border-color: var(--accent); }
  .newsListItem:hover .newsListThumbnail img  { transform: scale(1.05); }
}
.newsListItem:active { background-color: var(--bg-primary); }
.newsListItem:active .newsListTitle { color: var(--accent); }
.newsListItem:active .newsListThumbnail { border-color: var(--accent); }
.newsListItem:active .newsListThumbnail img { transform: scale(1.05); }

.newsListThumbnail {
    width: 60px;
    height: 40px;
    border-radius: 6px;
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
    transition: border-color 0.3s ease;
}
.newsListThumbnail img {
    transition: transform 0.3s ease-out;
}

.newsListInfo {
    text-align: right;
}

.newsListCategory {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin: 0 0 0.25rem 0;
}

.newsListTitle {
    font-size: 1.4rem;
    line-height: 1.4;
    color: var(--text-primary);
    margin: 0;
    transition: color 0.2s ease;
}

@media (max-width: 768px) {
    .topArticlesGrid {
        /* FIX: Mobile uses 1 column (Stacked) */
        grid-template-columns: 1fr;
        gap: 1.5rem;
        /* Reset margins on mobile if needed, though the hack is usually safe */
        /* Restore pointer events on mobile */
    }
    .topSection, .latestSection {
        padding-left: 1.5rem; 
        padding-right: 1.5rem; 
    }
}

--- END OF FILE components/homepage/feed/Feed.module.css ---

================================================================================

--- START OF FILE components/homepage/feed/Feed.tsx ---

'use client';

import { motion, AnimatePresence } from 'framer-motion';
import React, { useState } from 'react';
import Link from 'next/link';
import { CardProps } from '@/types';
import KineticGlyphs from '@/components/effects/KineticGlyphs';
import styles from './Feed.module.css';

const ArrowIcon = () => <svg width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>;

interface FeedProps {
    topSectionLabel: string;
    latestSectionLabel: string;
    topItems: CardProps[];
    latestItems?: CardProps[];
    viewAllLink?: string; // Made optional
    viewAllText: string;
    onViewAll?: () => void; // New prop for custom action
    topItemsContainerClassName?: string;
    renderTopItem: (item: CardProps, index: number) => React.ReactNode;
    renderListItem?: (item: CardProps, index: number) => React.ReactNode;
    listDividerClassName?: string;
    enableTopSectionHoverEffect?: boolean;
    latestSectionContent?: React.ReactNode;
    topSectionContent?: React.ReactNode;
}

const kineticCardVariant = {
    hidden: { 
        opacity: 0, 
        y: 50, 
        rotateX: -20
    },
    visible: { 
        opacity: 1, 
        y: 0, 
        rotateX: 0,
        transition: { 
            duration: 0.8, 
            ease: [0.22, 1, 0.36, 1] as const 
        }
    }
};

export default function Feed({
    topSectionLabel, latestSectionLabel, topItems, latestItems = [],
    viewAllLink, viewAllText, onViewAll, topItemsContainerClassName = '',
    renderTopItem, renderListItem, listDividerClassName = styles.listDivider,
    enableTopSectionHoverEffect = false, latestSectionContent, topSectionContent
}: FeedProps) {
    const [isTopSectionHovered, setIsTopSectionHovered] = useState(false);

    return (
        <div className={styles.feedContainer}>
            {topItems.length > 0 && (
                <div
                    className={styles.topSection}
                    onMouseEnter={() => { if (enableTopSectionHoverEffect) setIsTopSectionHovered(true); }}
                    onMouseLeave={() => { if (enableTopSectionHoverEffect) setIsTopSectionHovered(false); }}
                >
                    <AnimatePresence>{isTopSectionHovered && enableTopSectionHoverEffect && <KineticGlyphs />}</AnimatePresence>
                    <span className={styles.sectionLabel}>{topSectionLabel}</span>
                    <motion.div 
                        layout 
                        className={`${styles.topItemsContainer} ${topItemsContainerClassName}`} 
                        style={{ perspective: '800px' }}
                    >
                        {topSectionContent ? (
                            <motion.div variants={kineticCardVariant}>{topSectionContent}</motion.div>
                        ) : (
                            topItems.map((item, index) => (
                                <motion.div key={item.id} variants={kineticCardVariant} style={{ height: '100%' }}>
                                    {renderTopItem(item, index)}
                                </motion.div>
                            ))
                        )}
                    </motion.div>
                </div>
            )}

            <div className={styles.latestSection}>
                <span className={styles.sectionLabel} style={{ alignSelf: 'flex-start' }}>
                    <div className={styles.liveIndicator}></div>
                    <span>{latestSectionLabel}</span>
                </span>
                <motion.div className={styles.latestItemsList} variants={kineticCardVariant}>
                    {latestSectionContent ? (
                        latestSectionContent
                    ) : (
                        latestItems.map((item, index) => (
                            renderListItem && (
                                <React.Fragment key={item.id}>
                                    {renderListItem(item, index)}
                                    {index < latestItems.length - 1 && <div className={listDividerClassName} />}
                                </React.Fragment>
                            )
                        ))
                    )}
                </motion.div>
            </div>
            
            <motion.div variants={kineticCardVariant}>
                {onViewAll ? (
                    <button 
                        onClick={onViewAll} 
                        className={`${styles.viewAllLink} no-underline`}
                        style={{ width: '100%', background: 'none', border: 'none', borderTop: '1px solid var(--border-color)', cursor: 'pointer', fontSize: 'inherit' }}
                    >
                         <ArrowIcon />
                         <span>{viewAllText}</span>
                    </button>
                ) : (
                    <Link href={viewAllLink || '#'} className={`${styles.viewAllLink} no-underline`} prefetch={false}>
                        <ArrowIcon />
                        <span>{viewAllText}</span>
                    </Link>
                )}
            </motion.div>
        </div>
    );
}




--- END OF FILE components/homepage/feed/Feed.tsx ---

================================================================================

--- START OF FILE components/homepage/feed/FeedSkeleton.module.css ---

/* components/homepage/feed/FeedSkeleton.module.css */
@keyframes pulse-skeleton {
    0%, 100% {
        background-color: var(--border-color);
    }
    50% {
        background-color: color-mix(in srgb, var(--border-color) 60%, var(--bg-secondary));
    }
}

.skeletonBlock {
    animation: pulse-skeleton 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    border-radius: 6px;
}

.feedsGridSkeleton {
    display: grid;
    grid-template-columns: 2fr 1.2fr;
    gap: 4rem;
    margin-top: 6rem;
}

.feedColumnSkeleton {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.topSectionSkeleton {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2.5rem;
}

.articleCardSkeleton {
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    background-color: var(--bg-secondary);
}

.imageSkeleton {
    aspect-ratio: 16 / 10;
    border-bottom: 1px solid var(--border-color);
}

.contentSkeleton {
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.latestSectionSkeleton {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
}

.newsItemSkeleton {
    display: flex;
    gap: 1.5rem;
    align-items: center;
}

.newsContentSkeleton {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

@media (max-width: 1024px) {
    .feedsGridSkeleton {
        grid-template-columns: 1fr;
        gap: 6rem;
        margin-top: 4rem;
    }
}







--- END OF FILE components/homepage/feed/FeedSkeleton.module.css ---

================================================================================

--- START OF FILE components/homepage/feed/FeedSkeleton.tsx ---

// components/homepage/feed/FeedSkeleton.tsx
import React from 'react';
import styles from './FeedSkeleton.module.css';

const SkeletonBlock = ({ className, style }: { className?: string, style?: React.CSSProperties }) => (
    <div className={`${styles.skeletonBlock} ${className || ''}`} style={style}></div>
);

const ArticleCardSkeleton = () => (
    <div className={styles.articleCardSkeleton}>
        <SkeletonBlock className={styles.imageSkeleton} />
        <div className={styles.contentSkeleton}>
            <SkeletonBlock style={{ width: '80%', height: '24px' }} />
            <SkeletonBlock style={{ width: '50%', height: '16px' }} />
        </div>
    </div>
);

const NewsItemSkeleton = () => (
    <div className={styles.newsItemSkeleton}>
        <SkeletonBlock style={{ width: '80px', height: '50px', borderRadius: '6px' }} />
        <div className={styles.newsContentSkeleton}>
            <SkeletonBlock style={{ width: '40%', height: '12px' }} />
            <SkeletonBlock style={{ width: '90%', height: '16px' }} />
        </div>
    </div>
);

const FeedSkeleton = () => {
    return (
        <div className={styles.feedsGridSkeleton}>
            {/* Left Column (Articles) */}
            <div className={styles.feedColumnSkeleton}>
                <SkeletonBlock style={{ height: '40px', width: '200px', marginBottom: '2rem' }} />
                <div className={styles.topSectionSkeleton}>
                    <ArticleCardSkeleton />
                    <ArticleCardSkeleton />
                </div>
                <div className={styles.latestSectionSkeleton}>
                    <SkeletonBlock style={{ height: '20px', width: '150px', marginBottom: '1.5rem' }} />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
            </div>
            {/* Right Column (News) */}
            <div className={styles.feedColumnSkeleton}>
                <SkeletonBlock style={{ height: '40px', width: '200px', marginBottom: '2rem' }} />
                <div className={styles.topSectionSkeleton}>
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
                <div className={styles.latestSectionSkeleton}>
                    <SkeletonBlock style={{ height: '20px', width: '150px', marginBottom: '1.5rem' }} />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                    <NewsItemSkeleton />
                </div>
            </div>
        </div>
    );
};

export default FeedSkeleton;







--- END OF FILE components/homepage/feed/FeedSkeleton.tsx ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/KineticSpotlightNews.module.css ---

/* components/homepage/kinetic-news/KineticSpotlightNews.module.css */

.spotlightGrid {
    display: grid;
    /* 1 Column for the spotlight to make them big and impactful */
    grid-template-columns: 1fr; 
    gap: 2rem;
    
    /* GPU CULL FIX: Expand render boundary */
    padding: 10rem;
    
    /* Apply negative margins to offset padding */
    margin-top: -10rem;
    margin-left: -10rem;
    margin-right: -10rem;
    
    /* FIX: Fully negate the bottom padding to remove excess space */
    margin-bottom: -10rem;
    
    width: calc(100% + 20rem);
    
    /* FIX: Prevent padding from capturing mouse events */
    pointer-events: none;
}

/* Restore interactions for the cards */
.spotlightGrid > * {
    pointer-events: auto;
}

@media (max-width: 768px) {
    .spotlightGrid {
        gap: 2rem;
        /* REMOVED: margin-bottom: 3rem; -> This was causing the huge gap on mobile because it overrode the negative margin while keeping the positive padding. */
        
        /* Reset on mobile */
        /* width: 100%; <- Removed width reset to keep expansion hack working */
        /* Reset pointer events on mobile where cull hack is disabled */
        pointer-events: auto;
    }
}

--- END OF FILE components/homepage/kinetic-news/KineticSpotlightNews.module.css ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/KineticSpotlightNews.tsx ---

// components/homepage/kinetic-news/KineticSpotlightNews.tsx
'use client';

import React from 'react';
import { motion } from 'framer-motion';
import { CardProps } from '@/types';
import styles from './KineticSpotlightNews.module.css';
import NewsGridCard from '@/components/news/NewsGridCard';

interface KineticSpotlightNewsProps {
    items: CardProps[];
    layoutIdPrefix?: string; // Add prop
}

export default function KineticSpotlightNews({ items, layoutIdPrefix = "homepage-spotlight" }: KineticSpotlightNewsProps) {
    if (!items || items.length === 0) return null;

    return (
        <div className={`${styles.spotlightGrid} gpu-cull`}>
            {items.map((item, index) => (
                <motion.div
                    key={item.legacyId}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1, duration: 0.5 }}
                >
                    <NewsGridCard 
                        item={item} 
                        isPriority={index === 0} 
                        // Use dynamic prefix + ID for uniqueness
                        layoutIdPrefix={`${layoutIdPrefix}-${item.legacyId}`}
                        variant="compact"
                    />
                </motion.div>
            ))}
        </div>
    );
}

--- END OF FILE components/homepage/kinetic-news/KineticSpotlightNews.tsx ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/NewsfeedStream.module.css ---

/* components/homepage/kinetic-news/NewsfeedStream.module.css */

.streamContainer {
    display: flex;
    flex-direction: column;
    gap: 1.5rem; /* Tighter gap for the list feel */
    width: 100%;
    position: relative;
    
    /* GPU CULL FIX: MASSIVE expansion of render boundary */
    /* Add extra padding to ensure flying elements don't get clipped by containment */
    padding: 10rem 12rem 10rem 10rem; /* Top Right(Extra) Bottom Left */
    margin: -10rem -10rem -10rem -10rem; /* Negative margin to pull back */
    width: calc(100% + 20rem); /* Compensate width */

    /* FIX: Prevent padding from capturing mouse events */
    pointer-events: none;
}

/* Restore interaction for items */
.streamContainer > * {
    pointer-events: auto;
}

/* Optional: Add a connector line for the "Stream" feel */
.streamContainer::before {
    content: '';
    position: absolute;
    /* Adjust right position based on new padding. */
    right: 10rem; 
    
    top: 10rem; /* Match Top Padding */
    bottom: 10rem; /* Match Bottom Padding */
    width: 1px;
    background: linear-gradient(to bottom, transparent, var(--border-color) 20%, var(--border-color) 80%, transparent);
}

/* Add dots to the timeline for each card */
.streamItemWrapper {
    position: relative;
}

.streamItemWrapper::before {
    content: '';
    position: absolute;
    right: -2.4rem; 
    
    top: 50%;
    width: 9px;
    height: 9px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    transform: translateY(-50%);
    transition: all 0.3s ease;
    z-index: 1;
}

.streamItemWrapper:hover::before {
    background-color: var(--accent);
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent);
}

@media (max-width: 768px) {
    .streamContainer {
        /* Reset hack for mobile to avoid horizontal scroll if not handled */
        gap: 2rem;
    }
    .streamContainer::before {
        display: none;
    }
    .streamItemWrapper::before {
        display: none;
    }
}

--- END OF FILE components/homepage/kinetic-news/NewsfeedStream.module.css ---

================================================================================

--- START OF FILE components/homepage/kinetic-news/NewsfeedStream.tsx ---

// components/homepage/kinetic-news/NewsfeedStream.tsx
'use client';

import React, { useState, useEffect, useRef, useMemo } from 'react';
import { motion, AnimatePresence, useInView } from 'framer-motion';
import { CardProps } from '@/types';
import styles from './NewsfeedStream.module.css';
import NewsGridCard from '@/components/news/NewsGridCard';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useContentStore } from '@/lib/contentStore'; 

interface NewsfeedStreamProps {
    items: CardProps[];
    isExpanded?: boolean;
    layoutIdPrefix?: string; // New Prop
}

export default function NewsfeedStream({ items, isExpanded = false, layoutIdPrefix = "newsfeed-stream" }: NewsfeedStreamProps) {
    const [listItems, setListItems] = useState(items);
    const [isHovered, setIsHovered] = useState(false);
    const intervalRef = useRef<NodeJS.Timeout | null>(null);
    
    // Use Store
    const { isCarouselAutoScrollEnabled } = usePerformanceStore();
    const isOverlayOpen = useContentStore((s) => s.isOverlayOpen); 
    
    const containerRef = useRef<HTMLDivElement>(null);
    const isInView = useInView(containerRef, { amount: 0.1 });

    useEffect(() => {
        setListItems(items);
    }, [items]);

    useEffect(() => {
        // MODIFIED: Check isOverlayOpen
        if (!isExpanded && !isHovered && isInView && listItems.length > 5 && isCarouselAutoScrollEnabled && !isOverlayOpen) {
            intervalRef.current = setInterval(() => {
                setListItems((prevItems) => {
                    const newItems = [...prevItems];
                    const firstItem = newItems.shift();
                    if (firstItem) {
                        newItems.push(firstItem);
                    }
                    return newItems;
                });
            }, 3500);
        }

        return () => {
            if (intervalRef.current) clearInterval(intervalRef.current);
        };
    }, [isHovered, listItems.length, isExpanded, isInView, isCarouselAutoScrollEnabled, isOverlayOpen]);

    const displayItems = useMemo(() => 
        isExpanded ? items.slice(0, 15) : listItems.slice(0, 5),
    [isExpanded, items, listItems]);

    const interactionHandlers = {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        onTouchStart: () => setIsHovered(true),
        onTouchEnd: () => setIsHovered(false),
        onTouchCancel: () => setIsHovered(false),
    };

    return (
        <div 
            ref={containerRef}
            className={`${styles.streamContainer} gpu-cull`}
            {...interactionHandlers}
            style={{ minHeight: isExpanded ? 'auto' : '150px' }}
        >
            <AnimatePresence mode="popLayout" initial={false}>
                {displayItems.map((item) => (
                    <motion.div
                        key={item.legacyId}
                        layout 
                        className={styles.streamItemWrapper}
                        initial={{ opacity: 0, scale: 0.98, y: 10 }}
                        animate={{ opacity: 1, scale: 1, y: 0 }}
                        exit={{ opacity: 0, scale: 0.98, y: -10 }}
                        transition={{ 
                            type: "spring", 
                            stiffness: 120, 
                            damping: 25, 
                            mass: 1
                        }}
                    >
                        <NewsGridCard 
                            item={item} 
                            // Update layout ID to match prefix
                            layoutIdPrefix={`${layoutIdPrefix}-${item.legacyId}`}
                            variant="mini"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </div>
    );
}

--- END OF FILE components/homepage/kinetic-news/NewsfeedStream.tsx ---

================================================================================

--- START OF FILE components/icons/AuthIcons.tsx ---

// components/icons/AuthIcons.tsx
// This file is the single source of truth for all authentication provider SVG icons.
// By defining them as direct React components in one file, we eliminate multiple
// module lookups and reduce JavaScript bundle overhead, leading to faster rendering.

import React from 'react';

export const GitHubIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 16 16" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
    </svg>
);

export const GoogleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 48 48" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M45.12 24.5c0-1.56-.14-3.06-.4-4.5H24v8.51h11.84c-.51 2.75-2.06 5.08-4.39 6.64v5.52h7.11c4.16-3.83 6.56-9.47 6.56-16.17z" />
        <path d="M24 46c5.94 0 10.92-1.96 14.56-5.3l-7.11-5.52c-1.97 1.32-4.49 2.1-7.45 2.1-5.73 0-10.58-3.87-12.31-9.07H4.34v5.7C7.96 40.5 15.4 46 24 46z" />
        <path d="M11.69 28.18c-.38-1.13-.6-2.33-.6-3.58s.22-2.45.6-3.58v-5.7H4.34C2.96 18.05 2 20.9 2 24.6c0 3.7.96 6.55 2.34 9.28l7.35-5.7z" />
        <path d="M24 10.75c3.23 0 6.13 1.11 8.41 3.29l6.31-6.31C34.91 4.18 29.93 2 24 2 15.4 2 7.96 7.5 4.34 13.37l7.35 5.7c1.73-5.2 6.58-9.02 12.31-9.02z" />
    </svg>
);

export const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 1200 1227" fill="currentColor" aria-hidden="true" {...props}>
        <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.924L144.011 79.6944H306.615L611.412 515.685L658.88 583.589L1058.05 1150.3H895.452L569.165 687.854V687.828Z" />
    </svg>
);

// MODIFIED: Updated EternalGames Icon with Clean SVG path
export const EternalGamesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 892 1617" fill="currentColor" aria-hidden="true" {...props}>
        <path fill="#0dffff" d="M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z" />
    </svg>
);

--- END OF FILE components/icons/AuthIcons.tsx ---

================================================================================

--- START OF FILE components/icons/index.tsx ---

// components/icons/index.tsx
'use client';

import React from 'react';

export const ReviewIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
    </svg>
);

export const StarIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
    </svg>
);

export const ArticleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
    </svg>
);

export const NewsIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="2" y1="12" x2="22" y2="12"></line>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
    </svg>
);

export const ReleaseIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M17.2014 2H6.79876C5.341 2 4.06202 2.9847 4.0036 4.40355C3.93009 6.18879 5.18564 7.37422 6.50435 8.4871C8.32861 10.0266 9.24075 10.7964 9.33642 11.7708C9.35139 11.9233 9.35139 12.0767 9.33642 12.2292C9.24075 13.2036 8.32862 13.9734 6.50435 15.5129C5.14932 16.6564 3.9263 17.7195 4.0036 19.5964C4.06202 21.0153 5.341 22 6.79876 22L17.2014 22C18.6591 22 19.9381 21.0153 19.9965 19.5964C20.043 18.4668 19.6244 17.342 18.7352 16.56C18.3298 16.2034 17.9089 15.8615 17.4958 15.5129C15.6715 13.9734 14.7594 13.2036 14.6637 12.2292C14.6487 12.0767 14.6487 11.9233 14.6637 11.7708C14.7594 10.7964 15.6715 10.0266 17.4958 8.4871C18.8366 7.35558 20.0729 6.25809 19.9965 4.40355C19.9381 2.9847 18.6591 2 17.2014 2Z" stroke="currentColor" strokeWidth="2"></path>
    </svg>
);

export const AllBookmarkIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M3 7C3 6.0335 3.7835 5.25 4.75 5.25H15.75C16.7165 5.25 17.5 6.0335 17.5 7V22C17.5 22.2717 17.353 22.5222 17.1159 22.6547C16.8787 22.7873 16.5883 22.7811 16.3569 22.6387L10.25 18.8806L4.14307 22.6387C3.91167 22.7811 3.62134 22.7873 3.38415 22.6547C3.14696 22.5222 3 22.2717 3 22V7Z" fill="currentColor"></path>
        <path fillRule="evenodd" clipRule="evenodd" d="M6.75 3C6.75 2.44772 7.19772 2 7.75 2H17.75C19.4069 2 20.75 3.34315 20.75 5V19C20.75 19.5523 20.3023 20 19.75 20C19.1977 20 18.75 19.5523 18.75 19V5C18.75 4.44772 18.3023 4 17.75 4H7.75C7.19772 4 6.75 3.55228 6.75 3Z" fill="currentColor"></path>
    </svg>
);

export const UserSettings01Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M17.7498 12.25C18.3021 12.25 18.7498 12.6977 18.7498 13.25L18.7498 13.895C19.2875 14.0551 19.7708 14.3409 20.1657 14.7176L20.7537 14.3816C21.2332 14.1076 21.8441 14.2742 22.1181 14.7537C22.3921 15.2332 22.2255 15.8441 21.746 16.1181L21.1586 16.4537C21.2183 16.7099 21.2498 16.9765 21.2498 17.25C21.2498 17.5234 21.2183 17.7899 21.1587 18.046L21.746 18.3816C22.2255 18.6556 22.3921 19.2665 22.1181 19.746C21.8441 20.2255 21.2332 20.3921 20.7537 20.1181L20.1659 19.7822C19.7709 20.1591 19.2876 20.4449 18.7498 20.605L18.7498 21.25C18.7498 21.8023 18.3021 22.25 17.7498 22.25C17.1975 22.25 16.7498 21.8023 16.7498 21.25L16.7498 20.605C16.2121 20.4449 15.7287 20.159 15.3338 19.7822L14.746 20.1181C14.2665 20.3921 13.6556 20.2255 13.3816 19.746C13.1076 19.2665 13.2742 18.6556 13.7537 18.3816L14.341 18.046C14.2814 17.7899 14.2498 17.5234 14.2498 17.25C14.2498 16.9765 14.2814 16.7099 14.341 16.4537L13.7537 16.1181C13.2742 15.8441 13.1076 15.2332 13.3816 14.7537C13.6556 14.2742 14.2665 14.1076 14.746 14.3816L15.334 14.7176C15.7289 14.3409 16.2122 14.0551 16.7498 13.895L16.7498 13.25C16.7498 12.6977 17.1975 12.25 17.7498 12.25ZM17.7498 15.75C17.1936 15.75 16.7067 16.0523 16.4467 16.5063C16.3216 16.7246 16.2498 16.9774 16.2498 17.25C16.2498 17.5225 16.3216 17.7753 16.4466 17.9935C16.7066 18.4477 17.1935 18.75 17.7498 18.75C18.3061 18.75 18.7931 18.4477 19.0531 17.9935C19.1781 17.7753 19.2498 17.5225 19.2498 17.25C19.2498 16.9774 19.178 16.7246 19.053 16.5063C18.793 16.0523 18.3061 15.75 17.7498 15.75Z" fill="currentColor"></path>
        <path d="M12.2343 20.25H2.5C2.08579 20.25 1.75 19.9142 1.75 19.5C1.75 15.8234 4.31022 12.7447 7.7451 11.9495C5.70857 11.2274 4.25 9.28405 4.25 7C4.25 4.10051 6.6005 1.75 9.5 1.75C12.3995 1.75 14.75 4.10051 14.75 7C14.75 9.28405 13.2914 11.2274 11.2549 11.9495C12.1744 12.1624 13.0312 12.5389 13.793 13.0467C13.1837 13.1733 12.6294 13.5507 12.2964 14.1335C11.7057 15.1672 12.025 16.4721 13.0016 17.1219L13.0016 17.3778C12.0612 18.0035 11.7303 19.2365 12.2343 20.25Z" fill="currentColor"></path>
    </svg>
);

export const UserCircleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M6.75 8C6.75 5.1005 9.1005 2.75 12 2.75C14.8995 2.75 17.25 5.1005 17.25 8C17.25 10.8995 14.8995 13.25 12 13.25C9.1005 13.25 6.75 10.8995 6.75 8Z" fill="currentColor"></path>
        <path d="M4.25 20.5C4.25 16.2198 7.71979 12.75 12 12.75C16.2802 12.75 19.75 16.2198 19.75 20.5C19.75 20.9142 19.4142 21.25 19 21.25H5C4.58579 21.25 4.25 20.9142 4.25 20.5Z" fill="currentColor"></path>
    </svg>
);

export const Calendar03Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M7 13.2734C7 12.7212 7.44772 12.2734 8 12.2734H8.00897C8.56126 12.2734 9.00897 12.7212 9.00897 13.2734C9.00897 13.8257 8.56126 14.2734 8.00897 14.2734H8C7.44772 14.2734 7 13.8257 7 13.2734ZM10.9955 13.2734C10.9955 12.7212 11.4432 12.2734 11.9955 12.2734H12.0045C12.5568 12.2734 13.0045 12.7212 13.0045 13.2734C13.0045 13.8257 12.5568 14.2734 12.0045 14.2734H11.9955C11.4432 14.2734 10.9955 13.8257 10.9955 13.2734ZM14.991 13.2734C14.991 12.7212 15.4387 12.2734 15.991 12.2734H16C16.5523 12.2734 17 12.7212 17 13.2734C17 13.8257 16.5523 14.2734 16 14.2734H15.991C15.4387 14.2734 14.991 13.8257 14.991 13.2734Z" fill="currentColor"></path>
        <path fillRule="evenodd" clipRule="evenodd" d="M7 17.2734C7 16.7212 7.44772 16.2734 8 16.2734H8.00897C8.56126 16.2734 9.00897 16.7212 9.00897 17.2734C9.00897 17.8257 8.56126 18.2734 8.00897 18.2734H8C7.44772 18.2734 7 17.8257 7 17.2734ZM10.9955 17.2734C10.9955 16.7212 11.4432 16.2734 11.9955 16.2734H12.0045C12.5568 16.2734 13.0045 16.7212 13.0045 17.2734C13.0045 17.8257 12.5568 18.2734 12.0045 18.2734H11.9955C11.4432 18.2734 10.9955 17.8257 10.9955 17.2734Z" fill="currentColor"></path>
        <path fillRule="evenodd" clipRule="evenodd" d="M7.6125 1.25C8.15098 1.25 8.5875 1.68754 8.5875 2.22727V3.20455H15.4125V2.22727C15.4125 1.68754 15.849 1.25 16.3875 1.25C16.926 1.25 17.3625 1.68754 17.3625 2.22727V3.20455H18.825C20.4404 3.20455 21.75 4.51717 21.75 6.13636V19.8182C21.75 21.4374 20.4404 22.75 18.825 22.75H5.175C3.55957 22.75 2.25 21.4374 2.25 19.8182V6.13636C2.25 4.51717 3.55957 3.20455 5.175 3.20455H6.6375V2.22727C6.6375 1.68754 7.07403 1.25 7.6125 1.25ZM19.7999 9.75H4.19995V19.8182C4.19995 20.3579 4.63647 20.7955 5.17495 20.7955H18.8249C19.3634 20.7955 19.7999 20.3579 19.7999 19.8182V9.75Z" fill="currentColor"></path>
    </svg>
);

export const FilterHorizontalIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line>
        <line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line>
        <line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line>
        <line x1="17" y1="16" x2="23" y2="16"></line>
    </svg>
);

export const FilterRemoveIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M14.1679 6.56033C14.5584 6.1698 15.1916 6.1698 15.5821 6.56033L17.875 8.85322L20.1679 6.56033C20.5584 6.1698 21.1916 6.1698 21.5821 6.56033C21.9726 6.95085 21.9726 7.58402 21.5821 7.97454L19.2892 10.2674L21.5821 12.5603C21.9726 12.9509 21.9726 13.584 21.5821 13.9745C21.1916 14.3651 20.5584 14.3651 20.1679 13.9745L17.875 11.6816L15.5821 13.9745C15.1916 14.3651 14.5584 14.3651 14.1679 13.9745C13.7774 13.584 13.7774 12.9509 14.1679 12.5603L16.4608 10.2674L14.1679 7.97454C13.7774 7.58402 13.7774 6.95085 14.1679 6.56033Z" fill="currentColor"></path>
        <path d="M3.875 2.51743C2.9085 2.51743 2.125 3.30093 2.125 4.26743V6.79906C2.125 7.31842 2.35569 7.81096 2.75468 8.14345L8.08562 12.5859C8.13522 12.6272 8.16691 12.6862 8.17404 12.7503L8.97114 19.9242C9.10563 21.1347 10.4047 21.841 11.4937 21.2959L13.7296 20.1768C14.2447 19.9189 14.5999 19.4242 14.6795 18.8537L15.0997 15.8419C15.104 15.8112 15.1139 15.7816 15.129 15.7546C14.4074 15.8278 13.6601 15.588 13.1072 15.0352C12.1309 14.0589 12.1309 12.476 13.1072 11.4997L14.3395 10.2674L13.1072 9.0352C12.1309 8.05889 12.1309 6.47598 13.1072 5.49967C14.0835 4.52336 15.6665 4.52336 16.6428 5.49967L17.875 6.7319L19.1072 5.49967C19.7775 4.82938 20.7337 4.61928 21.5833 4.86936C21.6109 4.74515 21.625 4.61776 21.625 4.48939V4.26743C21.625 3.30093 20.8415 2.51743 19.875 2.51743H3.875Z" fill="currentColor"></path>
    </svg>
);

export const PenEdit02Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M18.7116 3.40901C17.833 2.53033 16.4083 2.53033 15.5296 3.40901L13.4997 5.43906L18.5604 10.4997L20.5903 8.46965C21.469 7.59098 21.469 6.16637 20.5903 5.28769L18.7116 3.40901ZM17.4997 11.5604L12.4391 6.49975L3.40899 15.5303C2.98705 15.9523 2.75 16.5246 2.75 17.1213V20.5C2.75 20.9142 3.08579 21.25 3.5 21.25H6.87868C7.47542 21.25 8.04773 21.0129 8.46969 20.591L17.4997 11.5604Z" fill="currentColor"></path>
    </svg>
);

export const ColorPaletteIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M11.75 1C8.02208 1 5 4.02208 5 7.75C5 10.1303 6.23205 12.2228 8.09321 13.4246C9.08931 10.1405 12.1405 7.75 15.75 7.75C16.71 7.75 17.6304 7.91908 18.4833 8.22909C18.4944 8.07084 18.5 7.91108 18.5 7.75C18.5 4.02208 15.4779 1 11.75 1ZM9 15.75C9 12.0221 12.0221 9 15.75 9C19.4779 9 22.5 12.0221 22.5 15.75C22.5 19.4779 19.4779 22.5 15.75 22.5C12.0221 22.5 9 19.4779 9 15.75ZM7.81601 14.7173C6.04546 13.7155 4.69468 12.0583 4.09321 10.0752C2.23204 11.277 1 13.3695 1 15.7498C1 19.4777 4.02208 22.4998 7.75 22.4998C8.76796 22.4998 9.7333 22.2745 10.5988 21.871C8.8568 20.4035 7.75 18.2059 7.75 15.7498C7.75 15.4 7.77246 15.0553 7.81601 14.7173Z" fill="currentColor"></path>
    </svg>
);

export const SparklesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M15 1.25C15.3507 1.25 15.6546 1.49305 15.7317 1.83518L16.2704 4.22676C16.6637 5.97278 18.0272 7.33629 19.7732 7.7296L22.1648 8.26833C22.507 8.3454 22.75 8.64929 22.75 9C22.75 9.35071 22.507 9.6546 22.1648 9.73167L19.7732 10.2704C18.0272 10.6637 16.6637 12.0272 16.2704 13.7732L15.7317 16.1648C15.6546 16.507 15.3507 16.75 15 16.75C14.6493 16.75 14.3454 16.507 14.2683 16.1648L13.7296 13.7732C13.3363 12.0272 11.9728 10.6637 10.2268 10.2704L7.83518 9.73167C7.49305 9.6546 7.25 9.35071 7.25 9C7.25 8.64929 7.49305 8.3454 7.83518 8.26833L10.2268 7.7296C11.9728 7.33629 13.3363 5.97278 13.7296 4.22676L14.2683 1.83518C14.3454 1.49305 14.6493 1.25 15 1.25Z" fill="currentColor"></path>
        <path d="M7 11.25C7.35071 11.25 7.6546 11.493 7.73167 11.8352L8.11647 13.5435C8.37923 14.7099 9.29012 15.6208 10.4565 15.8835L12.1648 16.2683C12.507 16.3454 12.75 16.6493 12.75 17C12.75 17.3507 12.507 17.6546 12.1648 17.7317L10.4565 18.1165C9.29012 18.3792 8.37923 19.2901 8.11647 20.4565L7.73167 22.1648C7.6546 22.507 7.35071 22.75 7 22.75C6.64929 22.75 6.3454 22.507 6.26833 22.1648L5.88353 20.4565C5.62077 19.2901 4.70988 18.3792 3.54345 18.1165L1.83518 17.7317C1.49305 17.6546 1.25 17.3507 1.25 17C1.25 16.6493 1.49305 16.3454 1.83518 16.2683L3.54345 15.8835C4.70988 15.6208 5.62077 14.7099 5.88353 13.5435L6.26833 11.8352C6.3454 11.493 6.64929 11.25 7 11.25Z" fill="currentColor"></path>
    </svg>
);

export const Logout03Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M16.75 5.49986V4.24986C16.75 3.69758 16.3023 3.24986 15.75 3.24986H6.25C5.69772 3.24986 5.25 3.69758 5.25 4.24986V19.7499C5.25 20.3022 5.69772 20.7499 6.25 20.7499H15.75C16.3023 20.7499 16.75 20.3022 16.75 19.7499V18.4999C16.75 17.9476 17.1977 17.4999 17.75 17.4999C18.3023 17.4999 18.75 17.9476 18.75 18.4999V19.7499C18.75 21.4067 17.4069 22.7499 15.75 22.7499H6.25C4.59315 22.7499 3.25 21.4067 3.25 19.7499V4.24986C3.25 2.59301 4.59315 1.24986 6.25 1.24986H15.75C17.4069 1.24986 18.75 2.59301 18.75 4.24986V5.49986C18.75 6.05215 18.3023 6.49986 17.75 6.49986C17.1977 6.49986 16.75 6.05215 16.75 5.49986Z" fill="currentColor"></path>
        <path d="M14.9746 6.91992C14.7503 6.73641 14.4406 6.69817 14.1787 6.82227C13.9169 6.94638 13.75 7.21025 13.75 7.5V9.75H9C8.58579 9.75 8.25 10.0858 8.25 10.5V13.5C8.25 13.6989 8.32907 13.8896 8.46973 14.0303C8.61038 14.1709 8.80109 14.25 9 14.25H13.75V16.5C13.75 16.7898 13.9169 17.0536 14.1787 17.1777C14.4406 17.3018 14.7503 17.2636 14.9746 17.0801L20.4746 12.5801C20.6487 12.4376 20.75 12.2249 20.75 12C20.75 11.7751 20.6487 11.5624 20.4746 11.4199L14.9746 6.91992Z" fill="currentColor"></path>
    </svg>
);

export const CheckIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path fillRule="evenodd" clipRule="evenodd" d="M15.9571 9.45711C16.3476 9.06658 16.3476 8.43342 15.9571 8.04289C15.5666 7.65237 14.9334 7.65237 14.5429 8.04289L11.25 11.3358L9.95711 10.0429C9.56658 9.65237 8.93342 9.65237 8.54289 10.0429C8.15237 10.4334 8.15237 11.0666 8.54289 11.4571L10.5429 13.4571C10.9334 13.8476 11.5666 13.8476 11.9571 13.4571L15.9571 9.45711Z" fill="currentColor"></path>
    </svg>
);

export const CancelIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M17.4131 4.46973C17.2725 4.32919 17.0815 4.25012 16.8828 4.25C16.7336 4.25 16.5891 4.29444 16.4668 4.37598L16.3525 4.46973L11.997 8.81934L7.65037 4.46973C7.50975 4.32906 7.31899 4.25005 7.1201 4.25C6.97096 4.24998 6.82638 4.29448 6.70408 4.37598L6.58982 4.46973L4.46971 6.58984C4.17696 6.88269 4.17697 7.3575 4.46971 7.65039L8.81639 11.999L4.46971 16.3467C4.17687 16.6395 4.17698 17.1143 4.46971 17.4072L6.58982 19.5273C6.73047 19.668 6.92119 19.7471 7.1201 19.7471C7.31894 19.747 7.50976 19.668 7.65037 19.5273L11.997 15.1797L16.3437 19.5264C16.6365 19.8191 17.1113 19.8199 17.4043 19.5273L19.5254 17.4082C19.666 17.2676 19.745 17.0768 19.7451 16.8779C19.7451 16.679 19.666 16.4883 19.5254 16.3477L15.1777 12L19.5312 7.65234C19.8242 7.35974 19.8246 6.88489 19.5322 6.5918L17.4131 4.46973Z" fill="currentColor"></path>
    </svg>
);

export const StudioIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M22.0002 5.14752V18.8525C22.0002 19.2465 21.7696 19.6037 21.4113 19.7649L16.6643 21.9003C16.6184 21.9275 16.5692 21.9498 16.5175 21.9663C16.4489 21.9882 16.3759 22 16.3001 22C16.1195 22 15.9455 21.9315 15.8131 21.8081L2.31506 9.20638C1.90446 8.81995 1.89411 8.16933 2.29222 7.76997L2.94181 7.11833C3.29478 6.76425 3.85441 6.72665 4.2513 7.03035L17.0159 16.5V7.5L11.723 11.38L8.49192 9.01144L15.8131 2.19186C15.9455 2.06854 16.1195 2 16.3001 2C16.3759 2 16.4489 2.01181 16.5175 2.0337C16.5692 2.05022 16.6184 2.07248 16.6643 2.09974L21.4113 4.23506C21.7696 4.39626 22.0002 4.75353 22.0002 5.14752Z" fill="currentColor"></path>
        <path d="M2.94181 16.8817L2.29222 16.23C1.89411 15.8307 1.90446 15.18 2.31506 14.7936L4.55397 12.6866L6.94156 14.911L4.2513 16.9696C3.85441 17.2733 3.29478 17.2357 2.94181 16.8817Z" fill="currentColor"></path>
    </svg>
);

export const PreviewIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <circle cx="12" cy="12" r="3"></circle>
    </svg>
);

export const NotificationIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}>
        <path d="M19 18V9.5C19 5.63401 15.866 2.5 12 2.5C8.13401 2.5 5 5.63401 5 9.5V18"></path>
        <path d="M20.5 18H3.5"></path>
        <path d="M13.5 20C13.5 20.8284 12.8284 21.5 12 21.5M10.5 20C10.5 20.8284 11.1716 21.5 12 21.5M12 21.5V20"></path>
    </svg>
);

--- END OF FILE components/icons/index.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PCIcon.tsx ---

// components/icons/platforms/PCIcon.tsx
export default function PCIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 24 24" fill="currentColor" {...props}>
            <path d="M4 2H20C21.1 2 22 2.9 22 4V16C22 17.1 21.1 18 20 18H13V20H15V22H9V20H11V18H4C2.9 18 2 17.1 2 16V4C2 2.9 2.9 2 4 2M4 4V16H20V4H4Z" />
        </svg>
    );
}













--- END OF FILE components/icons/platforms/PCIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/PS5Icon.tsx ---

// components/icons/platforms/PS5Icon.tsx
export default function PS5Icon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M3.262 24.248c-2.374-0.681-2.767-2.084-1.69-2.899 0.776-0.51 1.668-0.954 2.612-1.288l0.087-0.027 7.017-2.516v2.89l-5.030 1.839c-0.881 0.339-1.031 0.79-0.299 1.032 0.365 0.093 0.783 0.147 1.214 0.147 0.615 0 1.204-0.109 1.749-0.308l-0.035 0.011 2.422-0.882v2.592c-0.15 0.037-0.32 0.055-0.487 0.091-0.775 0.136-1.667 0.214-2.577 0.214-1.778 0-3.486-0.298-5.078-0.846l0.11 0.033zM18.049 24.544l7.868-2.843c0.893-0.322 1.032-0.781 0.307-1.022-0.363-0.089-0.779-0.14-1.208-0.14-0.622 0-1.22 0.108-1.774 0.305l0.037-0.011-5.255 1.874v-2.983l0.3-0.106c1.050-0.349 2.284-0.62 3.557-0.761l0.083-0.008c0.468-0.050 1.010-0.078 1.559-0.078 1.877 0 3.677 0.331 5.343 0.939l-0.108-0.035c2.309 0.751 2.549 1.839 1.969 2.589-0.559 0.557-1.235 0.998-1.988 1.282l-0.039 0.013-10.677 3.883v-2.869zM12.231 4.248v21.927l4.892 1.576v-18.39c0-0.862 0.38-1.438 0.992-1.238 0.795 0.225 0.95 1.017 0.95 1.881v7.342c3.050 1.491 5.451-0.003 5.451-3.939 0-4.045-1.407-5.842-5.546-7.282-1.785-0.648-4.040-1.294-6.347-1.805l-0.389-0.072z" />
        </svg>
    );
}













--- END OF FILE components/icons/platforms/PS5Icon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/SwitchIcon.tsx ---

// components/icons/platforms/SwitchIcon.tsx
export default function SwitchIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M18.901 32h4.901c4.5 0 8.198-3.698 8.198-8.198v-15.604c0-4.5-3.698-8.198-8.198-8.198h-5c-0.099 0-0.203 0.099-0.203 0.198v31.604c0 0.099 0.099 0.198 0.302 0.198zM25 14.401c1.802 0 3.198 1.5 3.198 3.198 0 1.802-1.5 3.198-3.198 3.198-1.802 0-3.198-1.396-3.198-3.198-0.104-1.797 1.396-3.198 3.198-3.198zM15.198 0h-7c-4.5 0-8.198 3.698-8.198 8.198v15.604c0 4.5 3.698 8.198 8.198 8.198h7c0.099 0 0.203-0.099 0.203-0.198v-31.604c0-0.099-0.099-0.198-0.203-0.198zM12.901 29.401h-4.703c-3.099 0-5.599-2.5-5.599-5.599v-15.604c0-3.099 2.5-5.599 5.599-5.599h4.604zM5 9.599c0 1.698 1.302 3 3 3s3-1.302 3-3c0-1.698-1.302-3-3-3s-3 1.302-3 3z"/>
        </svg>
    );
}













--- END OF FILE components/icons/platforms/SwitchIcon.tsx ---

================================================================================

--- START OF FILE components/icons/platforms/XboxIcon.tsx ---

// components/icons/platforms/XboxIcon.tsx
export default function XboxIcon(props: React.SVGProps<SVGSVGElement>) {
    return (
        <svg viewBox="0 0 32 32" fill="currentColor" {...props}>
            <path d="M16 5.425c-1.888-1.125-4.106-1.922-6.473-2.249l-0.092-0.010c-0.070-0.005-0.152-0.008-0.234-0.008-0.613 0-1.188 0.16-1.687 0.441l0.017-0.009c2.357-1.634 5.277-2.61 8.426-2.61 0.008 0 0.016 0 0.024 0h0.019c0.005 0 0.011 0 0.018 0 3.157 0 6.086 0.976 8.501 2.642l-0.050-0.033c-0.478-0.272-1.051-0.433-1.662-0.433-0.085 0-0.169 0.003-0.252 0.009l0.011-0.001c-2.459 0.336-4.677 1.13-6.648 2.297l0.082-0.045zM5.554 5.268c-0.041 0.014-0.077 0.032-0.11 0.054l0.002-0.001c-2.758 2.723-4.466 6.504-4.466 10.684 0 3.584 1.256 6.875 3.353 9.457l-0.022-0.028c-1.754-3.261 4.48-12.455 7.61-16.159-3.53-3.521-5.277-4.062-6.015-4.062-0.010-0-0.021-0.001-0.032-0.001-0.115 0-0.225 0.021-0.326 0.060l0.006-0.002zM20.083 9.275c3.129 3.706 9.367 12.908 7.605 16.161 2.075-2.554 3.332-5.845 3.332-9.43 0-4.181-1.709-7.962-4.467-10.684l-0.002-0.002c-0.029-0.021-0.063-0.039-0.1-0.052l-0.003-0.001c-0.1-0.036-0.216-0.056-0.336-0.056-0.005 0-0.011 0-0.016 0h0.001c-0.741-0-2.485 0.543-6.014 4.063zM6.114 27.306c2.627 2.306 6.093 3.714 9.888 3.714s7.261-1.407 9.905-3.728l-0.017 0.015c2.349-2.393-5.402-10.901-9.89-14.29-4.483 3.39-12.24 11.897-9.886 14.29z" />
        </svg>
    );
}













--- END OF FILE components/icons/platforms/XboxIcon.tsx ---

================================================================================

--- START OF FILE components/kinetic/KineticLink.tsx ---

// components/kinetic/KineticLink.tsx
'use client';

import React from 'react';
import Link from 'next/link';
import { useContentStore } from '@/lib/contentStore';
import { startNavigation } from '@/components/ui/ProgressBar';

interface KineticLinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
    href: string;
    slug: string;
    type: 'reviews' | 'articles' | 'news' | 'releases' | 'games' | 'creators' | 'tags';
    layoutId?: string;
    children: React.ReactNode;
    className?: string;
    imageSrc?: string; 
    overrideUrl?: string; 
    preloadedData?: any; 
    onClick?: (e: React.MouseEvent) => void;
}

export default function KineticLink({ 
    href, 
    slug, 
    type, 
    layoutId, 
    children, 
    className, 
    onClick, 
    imageSrc, 
    overrideUrl,
    preloadedData,
    ...props 
}: KineticLinkProps) {
    const { contentMap, openOverlay, fetchFullContent } = useContentStore();

    const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {
        if (onClick) onClick(e);

        // Check if we should open in overlay
        let hasData = false;
        if (type === 'creators' || type === 'tags') {
            hasData = true; 
        } else {
            hasData = contentMap.has(slug);
        }

        if (hasData) {
            e.preventDefault();
            e.stopPropagation(); 
            openOverlay(slug, type, layoutId, imageSrc, overrideUrl, preloadedData);
        } else {
            // Standard Navigation - Trigger Loading Bar
            startNavigation();
        }
    };

    // UX OPTIMIZATION: Prefetch full content on hover.
    // This bridges the gap between "Light Data" (Bandwidth Saver) and "Instant Click" (UX).
    // Only fetches if not already loaded.
    const handleMouseEnter = () => {
        if (['reviews', 'articles', 'news'].includes(type)) {
            const item = contentMap.get(slug);
            // Only fetch if it exists in store (from list) but body isn't loaded
            if (item && !item.contentLoaded) {
                fetchFullContent(slug);
            }
        }
    };

    return (
        <Link 
            href={href} 
            className={className} 
            onClick={handleClick}
            onMouseEnter={handleMouseEnter} // Trigger smart prefetch
            {...props} 
            // FIX: Disable prefetch to prevent massive bandwidth usage on home/list pages.
            // Since we manually prefetch on hover, automatic viewport prefetch is redundant/wasteful.
            prefetch={false} 
        >
            {children}
        </Link>
    );
}

--- END OF FILE components/kinetic/KineticLink.tsx ---

================================================================================

--- START OF FILE components/kinetic/KineticOverlayManager.module.css ---

/* components/kinetic/KineticOverlayManager.module.css */

.overlayScrollContainer {
    /* Firefox */
    scrollbar-width: thin;
    scrollbar-color: var(--accent) transparent;
    
    /* Native Smooth Scrolling for anchors */
    scroll-behavior: smooth;
}

/* Chrome, Edge, Safari */
.overlayScrollContainer::-webkit-scrollbar {
    width: 8px;
}

.overlayScrollContainer::-webkit-scrollbar-track {
    background: transparent;
}

.overlayScrollContainer::-webkit-scrollbar-thumb {
    background-color: var(--accent);
    border-radius: 4px;
}

--- END OF FILE components/kinetic/KineticOverlayManager.module.css ---

================================================================================

--- START OF FILE components/kinetic/KineticOverlayManager.tsx ---

// components/kinetic/KineticOverlayManager.tsx
'use client';

import { useEffect, useLayoutEffect, useRef, useMemo, Suspense } from 'react';
import { useContentStore } from '@/lib/contentStore';
import { motion, AnimatePresence } from 'framer-motion';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useLenis } from 'lenis/react';
import Lenis from 'lenis'; // Import Lenis class for manual instantiation
import SpaceBackground from '@/components/ui/SpaceBackground';
import { pageview } from '@/lib/gtm'; 
import { useUIStore } from '@/lib/uiStore';
import { usePerformanceStore } from '@/lib/performanceStore';
import styles from './KineticOverlayManager.module.css';
import Footer from '@/components/Footer'; 
import { usePathname } from 'next/navigation';
import dynamic from 'next/dynamic';
import { translateTag } from '@/lib/translations'; 

const ReviewsPageClient = dynamic(() => import('@/app/reviews/ReviewsPageClient'), { ssr: false });
const ArticlesPageClient = dynamic(() => import('@/app/articles/ArticlesPageClient'), { ssr: false });
const NewsPageClient = dynamic(() => import('@/app/news/NewsPageClient'), { ssr: false });
const ReleasePageClient = dynamic(() => import('@/app/releases/ReleasePageClient'), { ssr: false });
const ContentPageClient = dynamic(() => import('@/components/content/ContentPageClient'), { ssr: false });
const CommentSection = dynamic(() => import('@/components/comments/CommentSection'), { ssr: false });
const GameHubClient = dynamic(() => import('@/components/GameHubClient'), { ssr: false });
const CreatorHubClient = dynamic(() => import('@/components/CreatorHubClient'), { ssr: false });
const HubPageClient = dynamic(() => import('@/components/HubPageClient'), { ssr: false });

const sectionTitles: Record<string, string> = {
    reviews: 'المراجعات',
    articles: 'المقالات',
    news: 'الأخبار',
    releases: 'الإصدارات',
};

function KineticOverlayManagerContent({ colorDictionary }: { colorDictionary: any[] }) {
    const { 
        isOverlayOpen, 
        activeSlug, 
        activeType, 
        contentMap, 
        creatorMap, 
        tagMap, 
        pageMap, 
        indexSection,
        closeOverlay, 
        forceCloseOverlay,
        navigateInternal,
        sourceLayoutId, 
        activeImageSrc,
        savedScrollPosition,
        fetchLinkedContent,
        fetchCreatorContent,
        fetchTagContent,
        fetchFullContent,
        fetchCreatorByUsername 
    } = useContentStore();
    
    const setPrefix = useLayoutIdStore((s) => s.setPrefix);
    const setOverlayScrollRef = useUIStore((s) => s.setOverlayScrollRef);
    const { isSmoothScrollingEnabled } = usePerformanceStore();
    const overlayRef = useRef<HTMLDivElement>(null);
    // FIX: Ref to hold the local Lenis instance for the overlay
    const overlayLenisRef = useRef<Lenis | null>(null); 
    const mainLenis = useLenis(); // The root Lenis instance
    
    const pathname = usePathname();

    // Auto-close overlay if navigation moves to /studio
    useEffect(() => {
        if (pathname?.startsWith('/studio') && isOverlayOpen) {
            forceCloseOverlay();
        }
    }, [pathname, isOverlayOpen, forceCloseOverlay]);

    // Initialize scoped Lenis for the overlay
    useEffect(() => {
        if (isOverlayOpen && overlayRef.current && isSmoothScrollingEnabled) {
            const container = overlayRef.current;
            const content = container.firstElementChild as HTMLElement;

            const overlayLenis = new Lenis({
                wrapper: container,
                content: content,
                duration: 1.2,
                easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
                orientation: 'vertical',
                gestureOrientation: 'vertical',
                smoothWheel: true,
                wheelMultiplier: 1,
                touchMultiplier: 2,
            });

            // FIX: Store instance in ref for access in other effects
            overlayLenisRef.current = overlayLenis;

            function raf(time: number) {
                overlayLenis.raf(time);
                requestAnimationFrame(raf);
            }
            
            const rafId = requestAnimationFrame(raf);

            return () => {
                cancelAnimationFrame(rafId);
                overlayLenis.destroy();
                // FIX: Cleanup ref
                overlayLenisRef.current = null;
            };
        }
    }, [isOverlayOpen, isSmoothScrollingEnabled]);

    useEffect(() => {
        if (typeof document === 'undefined') return;

        if (isOverlayOpen) {
            const previousTitle = document.title;
            let newTitle = '';

            if (activeType === 'index' && indexSection) {
                newTitle = sectionTitles[indexSection] || 'EternalGames';
            } else if (activeType === 'creators' && activeSlug) {
                const creator = creatorMap.get(activeSlug);
                if (creator) newTitle = `أعمال ${creator.name}`;
                else newTitle = activeSlug; 
            } else if (activeType === 'tags' && activeSlug) {
                const tag = tagMap.get(activeSlug);
                if (tag) newTitle = `وسم: ${translateTag(tag.title)}`;
                else newTitle = activeSlug; 
            } else if (activeSlug) {
                const item = contentMap.get(activeSlug);
                if (item) {
                     newTitle = item.title;
                     if (activeType === 'games') newTitle = `محور لعبة: ${item.title}`;
                }
            }

            if (newTitle) {
                document.title = `${newTitle} | EternalGames`;
            }

            return () => {
                document.title = previousTitle;
            };
        }
    }, [isOverlayOpen, activeSlug, activeType, indexSection, contentMap, creatorMap, tagMap]);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.history.state?.overlay) {
            const cleanState = { ...window.history.state };
            delete cleanState.overlay;
            delete cleanState.slug;
            delete cleanState.type;
            window.history.replaceState(cleanState, '', window.location.href);
        }
    }, []);

    useEffect(() => {
        if (isOverlayOpen && sourceLayoutId) {
            setPrefix(sourceLayoutId);
        }
    }, [isOverlayOpen, sourceLayoutId, setPrefix]);

    useEffect(() => {
        const handlePopState = (event: PopStateEvent) => {
            if (event.state && event.state.overlay === true) {
                navigateInternal(event.state.slug || event.state.section, event.state.type);
            } else if (isOverlayOpen) {
                closeOverlay();
            }
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
    }, [isOverlayOpen, closeOverlay, navigateInternal]);

    useEffect(() => {
        if (isOverlayOpen && activeSlug && activeType) {
            if (activeType === 'index' && indexSection) {
                 pageview(`/${indexSection}`);
            } else if (activeType === 'creators') {
                const creator = creatorMap.get(activeSlug);
                if (!creator || !creator.contentLoaded) {
                    const id = creator && (creator.prismaUserId || creator._id);
                    if (id) fetchCreatorContent(activeSlug, id);
                    else fetchCreatorByUsername(activeSlug);
                }
                pageview(`/creators/${activeSlug}`);
            } else if (activeType === 'tags') {
                fetchTagContent(activeSlug);
                pageview(`/tags/${activeSlug}`);
            } else {
                const virtualUrl = `/${activeType}/${activeSlug}`;
                pageview(virtualUrl);
                if (activeType === 'releases' || (activeType as string) === 'games') {
                    fetchLinkedContent(activeSlug);
                } else if (activeType === 'reviews' || activeType === 'articles' || activeType === 'news') {
                    fetchFullContent(activeSlug);
                }
            }
        }
    }, [isOverlayOpen, activeSlug, activeType, fetchLinkedContent, fetchCreatorContent, fetchTagContent, fetchFullContent, indexSection, creatorMap, tagMap, fetchCreatorByUsername]);

    // FIX: Scroll Reset Effect (Compatible with Lenis)
    useLayoutEffect(() => {
        if (isOverlayOpen) {
            if (overlayLenisRef.current) {
                // If Lenis is active, use its API for instant reset
                overlayLenisRef.current.scrollTo(0, { immediate: true });
            } else if (overlayRef.current) {
                // Fallback to native
                overlayRef.current.scrollTop = 0;
            }
        }
    }, [activeSlug, activeType, indexSection, isOverlayOpen]);

    useEffect(() => {
        const html = document.documentElement;
        const body = document.body;
        const mainFooter = document.querySelector('body > footer') as HTMLElement; 

        if (isOverlayOpen) {
            const rafId = requestAnimationFrame(() => {
                const scrollbarWidth = window.innerWidth - html.clientWidth;
                // STOP Main Lenis
                if (mainLenis) mainLenis.stop();
                
                body.style.paddingRight = `${scrollbarWidth}px`; 
                html.style.overflow = 'hidden';
                body.style.overflow = 'hidden';
                if (mainFooter) mainFooter.style.display = 'none';
                if (overlayRef.current) {
                    setOverlayScrollRef(overlayRef.current);
                    // Initial reset on open (native works here before lenis mounts)
                    overlayRef.current.scrollTop = 0;
                }
            });
            return () => cancelAnimationFrame(rafId);
        } else {
            body.style.paddingRight = '';
            html.style.overflow = '';
            body.style.overflow = '';
            if (mainFooter) mainFooter.style.display = '';
            requestAnimationFrame(() => {
                // START Main Lenis
                if (mainLenis) {
                    mainLenis.start();
                    if (savedScrollPosition > 0) {
                        mainLenis.scrollTo(savedScrollPosition, { immediate: true, force: true, lock: false });
                    }
                } else {
                    if (savedScrollPosition > 0) {
                        window.scrollTo({ top: savedScrollPosition, behavior: 'instant' });
                    }
                }
            });
            setOverlayScrollRef(null);
        }
    }, [isOverlayOpen, savedScrollPosition, mainLenis, setOverlayScrollRef]);

    const renderContent = useMemo(() => {
        if (!isOverlayOpen) return null;

        const activeItem = activeSlug ? contentMap.get(activeSlug) : null;
        const activeIndexData = indexSection ? pageMap.get(indexSection) : null;
        const activeCreator = (activeSlug && activeType === 'creators') ? creatorMap.get(activeSlug) : null;
        const activeTag = (activeSlug && activeType === 'tags') ? tagMap.get(activeSlug) : null;

        if (activeType === 'index' && activeIndexData) {
            let content = null;
            let paddingTop = '0';
            switch(indexSection) {
                case 'reviews': content = <ReviewsPageClient heroReview={activeIndexData.hero} initialGridReviews={activeIndexData.grid} allGames={activeIndexData.allGames} allTags={activeIndexData.allTags} />; break;
                case 'articles': content = <ArticlesPageClient featuredArticles={activeIndexData.featured} initialGridArticles={activeIndexData.grid} allGames={activeIndexData.allGames} allGameTags={activeIndexData.allGameTags} allArticleTypeTags={activeIndexData.allArticleTypeTags} />; break;
                case 'news': content = <NewsPageClient heroArticles={activeIndexData.hero} initialGridArticles={activeIndexData.grid} allGames={activeIndexData.allGames} allTags={activeIndexData.allTags} />; break;
                case 'releases': paddingTop = 'calc(var(--nav-height-scrolled) + 4rem)'; content = <ReleasePageClient releases={activeIndexData.releases} />; break;
            }
            return { content, paddingTop };
        } 
        
        if (activeType === 'creators') {
            if (activeCreator) {
                const isLoading = !activeCreator.contentLoaded;
                return {
                    content: <CreatorHubClient creatorName={activeCreator.name} username={activeCreator.username} image={activeCreator.image} bio={activeCreator.bio} items={activeCreator.linkedContent || []} scrollContainerRef={overlayRef} isLoading={isLoading} />,
                    paddingTop: '0'
                };
            }
            return { content: <CreatorHubClient creatorName={activeSlug!} username={activeSlug!} items={[]} scrollContainerRef={overlayRef} isLoading={true} />, paddingTop: '0' };
        } 
        
        if (activeType === 'tags') {
            if (activeTag) {
                const isLoading = !activeTag.contentLoaded;
                 return {
                    content: <HubPageClient 
                        initialItems={activeTag.items || []} 
                        hubTitle={activeTag.title} 
                        hubType="وسم" 
                        scrollContainerRef={overlayRef} 
                        isLoading={isLoading} 
                        fallbackImage={activeImageSrc} // Pass fallback image for tags too
                    />,
                    paddingTop: '0'
                 };
            }
             return {
                content: <HubPageClient initialItems={[]} hubTitle={activeSlug || '...'} hubType="وسم" scrollContainerRef={overlayRef} isLoading={true} fallbackImage={activeImageSrc} />,
                paddingTop: '0'
             };
        } 
        
        if (activeItem) {
             if (activeType === 'releases' || (activeType as string) === 'games') {
                const layoutPrefix = sourceLayoutId || undefined;
                // FIX: Use activeImageSrc if mainImage is missing (fallback for smooth transition)
                const imageToUse = activeItem.mainImage || activeImageSrc;

                return {
                    content: <GameHubClient 
                        gameTitle={activeItem.title} 
                        items={activeItem.linkedContent || []} 
                        synopsis={activeItem.synopsis} 
                        releaseTags={activeItem.tags || []} 
                        mainImage={imageToUse} // Updated Prop
                        price={activeItem.price} 
                        developer={activeItem.developer?.title} 
                        publisher={activeItem.publisher?.title} 
                        platforms={activeItem.platforms} 
                        onGamePass={activeItem.onGamePass} 
                        onPSPlus={activeItem.onPSPlus} 
                        forcedLayoutIdPrefix={layoutPrefix} 
                        scrollContainerRef={overlayRef} 
                    />,
                    paddingTop: '0'
                };
             } else {
                 const layoutPrefix = sourceLayoutId || undefined;
                 return {
                    content: (
                        <ContentPageClient key={activeSlug} item={activeItem} type={activeType as any} colorDictionary={colorDictionary} forcedLayoutIdPrefix={layoutPrefix} initialImageSrc={activeImageSrc || undefined} scrollContainerRef={overlayRef}> 
                            <div style={{ marginTop: '4rem' }}> <CommentSection slug={activeSlug || ''} contentType={activeType === 'reviews' ? 'reviews' : activeType === 'articles' ? 'articles' : 'news'} /> </div> 
                        </ContentPageClient>
                    ),
                    paddingTop: '0'
                };
             }
        }
        
        return { content: <div className="container" style={{height:'80vh', display:'flex', justifyContent:'center', alignItems:'center'}}><div className="spinner"></div></div>, paddingTop: '0' };

    }, [isOverlayOpen, activeSlug, activeType, indexSection, contentMap, creatorMap, tagMap, pageMap, colorDictionary, sourceLayoutId, activeImageSrc]);

    return (
        <AnimatePresence mode="wait">
            {isOverlayOpen && renderContent && (
                <motion.div 
                    key="overlay-root"
                    initial={{ opacity: 0 }} 
                    animate={{ opacity: 1 }} 
                    exit={{ opacity: 0 }} 
                    transition={{ duration: 0.3 }} 
                    style={{ 
                        position: 'fixed', 
                        inset: 0, 
                        /* FIX: Set z-index to 2050 to sit above Search (2040) but below Navbar (2060) */
                        zIndex: 2050,
                        transform: 'translateZ(0)',
                        pointerEvents: 'auto'
                    }}
                >
                    <div style={{ position: 'absolute', inset: 0, zIndex: 0, backgroundColor: 'var(--bg-primary)', pointerEvents: 'auto' }}>
                         <SpaceBackground />
                    </div>

                    <div 
                        ref={overlayRef} 
                        className={styles.overlayScrollContainer} 
                        style={{ 
                            position: 'absolute', 
                            inset: 0, 
                            zIndex: 1, 
                            paddingTop: 0, 
                            overflowY: 'auto', 
                            overflowX: 'hidden', 
                            isolation: 'isolate', 
                            WebkitOverflowScrolling: 'touch', 
                            overscrollBehavior: 'contain', 
                            direction: 'ltr', 
                            pointerEvents: 'auto' 
                        }}
                    >
                        <div style={{ direction: 'rtl', minHeight: '100%', width: '100%', display: 'flex', flexDirection: 'column', paddingTop: renderContent.paddingTop }}>
                            <div style={{ flexGrow: 1 }}>
                                {renderContent.content}
                            </div>
                            <Footer />
                        </div>
                    </div>
                </motion.div>
            )}
        </AnimatePresence>
    );
}

export default function KineticOverlayManager(props: { colorDictionary: any[] }) {
    return (
        <Suspense fallback={null}>
            <KineticOverlayManagerContent {...props} />
        </Suspense>
    );
}

--- END OF FILE components/kinetic/KineticOverlayManager.tsx ---

================================================================================

--- START OF FILE components/modals/Modal.tsx ---

// components/modals/Modal.tsx
'use client';

import { useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { motion, AnimatePresence } from 'framer-motion';
import styles from './Modals.module.css';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
    className?: string;
    style?: React.CSSProperties;
}

const modalVariants = {
    hidden: { opacity: 0, scale: 0.9, y: 20 },
    visible: { opacity: 1, scale: 1, y: 0, transition: { type: 'spring' as const, damping: 20, stiffness: 250 } },
    exit: { opacity: 0, scale: 0.9, y: 20, transition: { duration: 0.15 } },
};

export default function Modal({ isOpen, onClose, children, className, style }: ModalProps) {
    const [isMounted, setIsMounted] = useState(false);

    useEffect(() => {
        setIsMounted(true);
    }, []);

    const modalContent = (
        <AnimatePresence>
            {isOpen && (
                <motion.div
                    className={styles.modalOverlay}
                    onClick={onClose}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                >
                    <motion.div
                        className={`${styles.modalContent} ${className || ''}`}
                        style={style}
                        variants={modalVariants}
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        onClick={(e) => e.stopPropagation()}
                    >
                        {children}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );

    if (!isMounted) {
        return null;
    }

    return createPortal(modalContent, document.body);
}







--- END OF FILE components/modals/Modal.tsx ---

================================================================================

--- START OF FILE components/modals/Modals.module.css ---

/* components/modals/Modals.module.css */

.modalOverlay {
  position: fixed;
  inset: 0;
  background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5000;
  padding: 2rem;
}

.modalContent {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 3rem;
  max-width: 450px;
  width: 100%;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

.modalActions {
  display: flex;
  justify-content: flex-start;
  gap: 1rem;
}







--- END OF FILE components/modals/Modals.module.css ---

================================================================================

--- START OF FILE components/news/NewsGrid.module.css ---

/* components/news/NewsGrid.module.css */

.newsGrid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 3rem;
    grid-auto-rows: 1fr;

    /* GPU CULL FIX: Expand render boundary to prevent clipping */
    padding: 10rem;
    margin: -10rem;
    width: calc(100% + 20rem);
    
    /* FIX: Prevent padding from capturing mouse events */
    pointer-events: none;
}

/* Restore interaction */
.newsGrid > * {
    pointer-events: auto;
}

@media (max-width: 768px) {
    .newsGrid {
        grid-template-columns: 1fr;
        gap: 2rem;
        /* Mobile inherits the expansion hack to prevent clipping */
    }
}

--- END OF FILE components/news/NewsGrid.module.css ---

================================================================================

--- START OF FILE components/news/NewsGrid.tsx ---

// components/news/NewsGrid.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import NewsGridCard from './NewsGridCard';
import { CardProps } from '@/types';
import React from 'react'; 
import styles from './NewsGrid.module.css';
import { useActiveCardStore } from '@/lib/activeCardStore';

export default function NewsGrid({ news }: { news: CardProps[] }) {
    const { activeCardId } = useActiveCardStore();

    return (
        <div className={`${styles.newsGrid} gpu-cull`}>
            <AnimatePresence mode="popLayout">
                {news.map((item, index) => (
                    <motion.div
                        key={item.legacyId}
                        initial={false}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        whileHover={{ zIndex: 50 }} 
                        transition={{ 
                            duration: 0.2
                        }}
                        style={{ 
                            height: '100%', 
                            willChange: 'transform, opacity',
                            zIndex: activeCardId === item.id ? 100 : 1
                        }}
                    >
                        <NewsGridCard 
                            item={item} 
                            isPriority={index < 4}
                            layoutIdPrefix="news-grid"
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </div>
    );
}

--- END OF FILE components/news/NewsGrid.tsx ---

================================================================================

--- START OF FILE components/news/NewsGridCard.module.css ---

/* components/news/NewsGridCard.module.css */

.cardContainer {
    transform-style: preserve-3d;
    height: 100%;
    position: relative;
    cursor: pointer;
    background: transparent;
    z-index: 1;
    -webkit-tap-highlight-color: transparent;
    contain: layout style;
}

.cardContainer.activeState {
    z-index: 100;
}

@media (hover: hover) {
    .cardContainer:hover {
        z-index: 100;
    }
}

.newsCard {
    background-color: var(--bg-secondary);
    border-radius: 12px;
    overflow: visible; 
    
    height: 100%; /* Fill the grid cell height */
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transform-style: preserve-3d;
    transition: transform 0.4s ease-out, border-color 0.4s ease;
    position: relative;
    box-shadow: 0 10px 30px -5px rgba(0,0,0,0.5); 
}

.cardContainer:hover .newsCard,
.cardContainer.activeState .newsCard {
    will-change: transform;
}

.newsCard::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 12px;
    box-shadow: 
        0 25px 50px -12px rgba(0,0,0,0.6),
        0 0 0 1px color-mix(in srgb, var(--accent) 30%, transparent);
    opacity: 0;
    transition: opacity 0.4s ease;
    z-index: -1;
    pointer-events: none;
}

.newsCard::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    width: 30px;
    height: 30px;
    border-top: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-left: 3px solid color-mix(in srgb, var(--accent) 40%, transparent);
    border-radius: 12px 0 0 0;
    transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    z-index: 20;
    pointer-events: none;
}

:global(.noCornerAnimation) .newsCard::before {
    content: none !important;
    display: none !important;
}

.cardContainer.activeState .newsCard {
    transform: translateZ(10px) translateY(-4px);
    border-color: color-mix(in srgb, var(--accent) 50%, transparent);
}
.cardContainer.activeState .newsCard::after { opacity: 1; }
.cardContainer.activeState .newsCard::before { width: calc(100% + 2px); height: calc(100% + 2px); border-radius: 12px; border-color: var(--accent); filter: drop-shadow(0 0 5px var(--accent)); opacity: 1; }
.cardContainer.activeState .cardImage { transform: scale(1.08); }
.cardContainer.activeState .imageBadge { color: #050505; border-color: var(--badge-color); }
.cardContainer.activeState .imageBadge::before { transform: scaleX(1); }
.cardContainer.activeState .cardTitle { color: var(--accent); }
.cardContainer.activeState .creatorCapsule { background-color: var(--accent); border-color: var(--accent); }
.cardContainer.activeState .creatorCapsule :global(span) { color: #000; }
.cardContainer.activeState .capsuleIcon { background-color: #000; color: var(--accent); }
.cardContainer.activeState .techDecoration { opacity: 1; }
.cardContainer.activeState .techDot { background-color: var(--accent); box-shadow: 0 0 8px var(--accent); animation: pulse-dot 1s infinite ease-in-out; }
.cardContainer.activeState .techDot:nth-child(2) { animation-delay: 0.15s; }
.cardContainer.activeState .techDot:nth-child(3) { animation-delay: 0.3s; }

@media (hover: hover) {
    .cardContainer:hover .newsCard {
        transform: translateZ(10px) translateY(-4px);
        border-color: color-mix(in srgb, var(--accent) 50%, transparent);
    }
    .cardContainer:hover .newsCard::after { opacity: 1; }
    .cardContainer:hover .newsCard::before { width: calc(100% + 2px); height: calc(100% + 2px); border-radius: 12px; border-color: var(--accent); filter: drop-shadow(0 0 5px var(--accent)); opacity: 1; }
    .cardContainer:hover .cardImage { transform: scale(1.08); }
    .cardContainer:hover .imageBadge { color: #050505; border-color: var(--badge-color); }
    .cardContainer:hover .imageBadge::before { transform: scaleX(1); }
    .cardContainer:hover .cardTitle { color: var(--accent); }
    .cardContainer:hover .creatorCapsule { background-color: var(--accent); border-color: var(--accent); }
    .cardContainer:hover .creatorCapsule :global(span) { color: #000; }
    .cardContainer:hover .capsuleIcon { background-color: #000; color: var(--accent); }
    .cardContainer:hover .techDecoration { opacity: 1; }
    .cardContainer:hover .techDot { background-color: var(--accent); box-shadow: 0 0 8px var(--accent); animation: pulse-dot 1s infinite ease-in-out; }
    .cardContainer:hover .techDot:nth-child(2) { animation-delay: 0.15s; }
    .cardContainer:hover .techDot:nth-child(3) { animation-delay: 0.3s; }
}

.cardLink {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    color: var(--text-primary);
    position: relative;
    z-index: 5;
    transform-style: preserve-3d;
}

.imageContentWrapper {
    display: grid;
    grid-template-columns: 240px 1fr;
    gap: 0; 
    padding: 0;
    flex-grow: 1;
    height: 100%;
    transform-style: preserve-3d;
    align-items: stretch;
}

.newsCard.compact .imageContentWrapper {
    grid-template-columns: 160px 1fr; 
}

.newsCard.mini .imageContentWrapper {
    grid-template-columns: 120px 1fr; 
}

.imageContainer {
    position: relative;
    width: 100%;
    height: 100%; 
    object-fit: cover;
    overflow: hidden;
    border-radius: 12px;
    border: 1px solid var(--border-color); 
    transform: translateZ(0); 
    /* Force Aspect Ratio on mobile/list only if needed, but here we fill the grid cell height */
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1);
}

.imageBadge {
    position: absolute;
    top: 0.8rem;
    right: 0.8rem;
    padding: 0.3rem 0.8rem;
    border-radius: 4px;
    font-size: 1rem;
    font-weight: 800;
    z-index: 10;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    overflow: hidden;
    transition: color 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(8px);
}

:global(body.no-glass) .imageBadge {
    backdrop-filter: none !important;
    background-color: rgba(0, 0, 0, 0.9) !important;
}

.imageBadge.official { --badge-color: var(--accent); color: var(--badge-color); }
.imageBadge.rumor { --badge-color: #F59E0B; color: var(--badge-color); }
.imageBadge.leak { --badge-color: #DC2626; color: var(--badge-color); }
.imageBadge::before {
    content: ''; position: absolute; inset: 0; background-color: var(--badge-color); transform: scaleX(0); transform-origin: right; transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); z-index: -1;
}

.newsCard.mini .imageBadge {
    padding: 0.2rem 0.6rem;
    font-size: 0.9rem;
    top: 0.5rem;
    right: 0.5rem;
}

.cardInfoColumn {
    padding: 1.2rem 1rem 1.2rem 1.5rem;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    transform: translateZ(10px);
    height: 100%;
}

.newsCard.compact .cardInfoColumn {
    padding: 1rem;
    gap: 0.2rem;
}

.newsCard.mini .cardInfoColumn {
    padding: 0.8rem;
    gap: 0.2rem;
}

.cardTitle {
    font-size: 1.6rem;
    line-height: 1.35;
    font-weight: 700;
    margin: 0 0 0.8rem 0;
    transition: color 0.2s ease;
    overflow-wrap: break-word;
    display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
}

.newsCard.compact .cardTitle {
    font-size: 1.45rem;
    margin-bottom: 0.4rem;
    
    /* ENFORCE FIXED HEIGHT FOR UNIFORM CARDS */
    height: 4.2rem; /* Approx 2 lines (1.45rem * 1.35 * 2) */
    
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.newsCard.mini .cardTitle {
    font-size: 1.35rem; 
    margin-bottom: 0.3rem;
    -webkit-line-clamp: 2;
}

.cardMetadata {
    display: flex; align-items: center; justify-content: space-between; 
    padding-top: 0.8rem; margin-top: auto; 
    border-top: 1px solid color-mix(in srgb, var(--border-color) 40%, transparent);
}
.cardDate {
    font-size: 1.2rem; color: var(--text-secondary); display: flex; align-items: center; gap: 0.5rem; font-family: var(--font-ui); font-weight: 500;
}
.metadataIcon { width: 14px; height: 14px; color: var(--accent); }

/* ... (Rest of CSS remains same: capsules, flying tags, mobile, light mode) ... */

a.creatorCapsule { display: inline-flex; align-items: center; gap: 0.8rem; background: rgba(10, 11, 15, 0.8); border: 1px solid rgba(255,255,255,0.1); padding: 0; border-radius: 999px; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); height: 32px; backdrop-filter: blur(8px); text-decoration: none; cursor: pointer; position: relative; z-index: 20; }
div.creatorCapsule { display: inline-flex; align-items: center; gap: 0.8rem; background: rgba(10, 11, 15, 0.8); border: 1px solid rgba(255,255,255,0.1); padding: 0; border-radius: 999px; height: 32px; backdrop-filter: blur(8px); pointer-events: none; transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); z-index: 20; }

:global(body.no-glass) a.creatorCapsule:not(:hover),
:global(body.no-glass) div.creatorCapsule:not(:hover) {
    backdrop-filter: none !important;
    background-color: rgba(10, 11, 15, 0.95) !important;
}

@media (hover: hover) { 
    a.creatorCapsule:hover { 
        background-color: var(--accent);
        border-color: var(--accent); 
        transform: translateY(-4px) scale(1.05); 
        box-shadow: 0 10px 20px -5px color-mix(in srgb, var(--accent) 50%, transparent); 
        z-index: 30; 
    } 
    a.creatorCapsule:hover .capsuleIcon {
        background-color: #000;
        color: var(--accent);
        box-shadow: none;
    }
    a.creatorCapsule:hover :global(span) { 
        color: #000; 
    }
}
a.creatorCapsule:active { transform: scale(0.95); }

.capsuleIcon { width: 32px; height: 32px; border-radius: 50%; background-color: var(--accent); color: #000; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: color 0.4s ease, background-color 0.4s ease, box-shadow 0.4s ease; }
.capsuleIcon svg { width: 16px; height: 16px; }

.creatorCapsule :global(span) { font-size: 1.2rem; font-weight: 700; color: #fff; max-width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 1.2rem; padding-right: 0.8rem; transition: color 0.4s ease; }

.newsCard.compact a.creatorCapsule,
.newsCard.compact div.creatorCapsule,
.newsCard.mini a.creatorCapsule,
.newsCard.mini div.creatorCapsule {
    height: 24px;
    gap: 0.5rem;
    border-width: 1px;
}

.newsCard.compact .capsuleIcon,
.newsCard.mini .capsuleIcon {
    width: 24px;
    height: 24px;
}

.newsCard.compact .capsuleIcon svg,
.newsCard.mini .capsuleIcon svg {
    width: 12px;
    height: 12px;
}

.newsCard.compact .creatorCapsule :global(span),
.newsCard.mini .creatorCapsule :global(span) {
    font-size: 1.1rem;
    padding-left: 0.8rem;
    padding-right: 0.5rem;
    max-width: 100px;
}

.techDecoration { display: flex; gap: 4px; opacity: 0.4; transition: opacity 0.3s ease; }
.techDot { width: 3px; height: 3px; background-color: var(--text-secondary); border-radius: 50%; transition: background-color 0.3s ease, transform 0.3s ease; }

@keyframes pulse-dot { 
    0%, 100% { transform: scale(1); opacity: 0.5; } 
    50% { transform: scale(1.5); opacity: 1; } 
}

.satelliteField { position: absolute; inset: -50px; pointer-events: none; z-index: 100; overflow: visible; transform-style: preserve-3d; }
.satelliteShard { position: absolute; padding: 0; background: transparent; pointer-events: none; display: flex; align-items: center; justify-content: center; transform-style: preserve-3d; transform: translateZ(50px); }

.satelliteShardLink {
    display: flex; align-items: center; justify-content: center; 
    padding: 0.4rem 1rem; 
    font-family: var(--font-ui); 
    font-size: 1.2rem; 
    font-weight: 700; 
    border-radius: 6px; 
    white-space: nowrap; 
    box-shadow: 0 15px 40px rgba(0,0,0,0.8);
    text-decoration: none; 
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
    pointer-events: auto; 
    position: relative; 
    z-index: 101; 
    backdrop-filter: blur(4px);
    background: rgba(10, 10, 15, 0.95);
    border: 1.5px solid var(--accent); 
    color: var(--accent);
}

:global(body.no-glass) .satelliteShardLink {
    backdrop-filter: none !important;
    background: #000 !important;
}

:global(body.no-glass) .satelliteShardLink.clickable:hover {
    background-color: var(--accent) !important;
    color: #000 !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

.satelliteShardLink.small {
    padding: 0.5rem 0.6rem;
    font-size: 0.9rem;
    border-width: 1.5px;
}

.satelliteShardLink.clickable {
    cursor: pointer;
    box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
}
@media (hover: hover) {
    .satelliteShardLink.clickable:hover {
        background-color: var(--accent);
        color: #000;
        transform: scale(1.15) translateY(-3px);
        box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
        z-index: 200;
    }
}

.satelliteShardLink.clickable:active {
    background-color: var(--accent);
    color: #000;
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
    transform: scale(0.95);
}

:global(body.no-glass) .satelliteShardLink.clickable:active {
    background-color: var(--accent) !important;
    color: #000 !important;
    border-color: var(--accent) !important;
}

.satelliteShardLink.static {
    cursor: default;
}

@media (max-width: 768px) {
    .imageContentWrapper { grid-template-columns: 110px 1fr; gap: 1rem; }
    .newsCard.compact .imageContentWrapper { grid-template-columns: 110px 1fr; }
    
    .imageContainer { min-height: 100%; border-right: none; border-top-left-radius: 0; border-bottom-left-radius: 0; aspect-ratio: unset; width: 110px;}
    .cardInfoColumn { padding: 1.2rem 1rem 1.2rem 0; }
    .cardTitle { font-size: 1.5rem; line-height: 1.4; -webkit-line-clamp: 3; margin-bottom: 0.5rem; height: auto; } /* Let height be auto on mobile for flexibility */
    .newsCard.compact .cardTitle { height: auto; -webkit-line-clamp: 3; }
    
    .techDecoration { display: none; }
    
    .imageBadge { 
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(0, 0, 0, 0.95); 
    }
    .creatorCapsule { padding: 0; background: transparent; border: none; height: auto; backdrop-filter: none !important; }
    .creatorCapsule span { display: block; max-width: 100px; }
    .satelliteShardLink { backdrop-filter: none !important; background: #000; }
    
    .satelliteField { display: none; }
    .cardContainer.activeState .satelliteField { display: block; }
}

:global(body.no-glass) .cardContainer:hover .creatorCapsule,
:global(body.no-glass) .cardContainer.activeState .creatorCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
    color: #000 !important;
    box-shadow: none !important;
}

:global(body.no-glass) .cardContainer:hover .capsuleIcon,
:global(body.no-glass) .cardContainer.activeState .capsuleIcon {
    background-color: #000 !important;
    color: var(--accent) !important;
}

:global(body.no-glass) .cardContainer:hover .creatorCapsule :global(span),
:global(body.no-glass) .cardContainer.activeState .creatorCapsule :global(span) {
    color: #000 !important;
}

:global([data-theme="light"]) .imageBadge {
  background-color: rgba(255, 255, 255, 0.85);
  border-color: rgba(0,0,0,0.05);
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  color: var(--text-primary);
}
:global([data-theme="light"] body.no-glass) .imageBadge {
  background-color: rgba(255, 255, 255, 0.95) !important;
}
:global([data-theme="light"]) a.creatorCapsule,
:global([data-theme="light"]) div.creatorCapsule {
  background: #ffffff !important;
  border-color: rgba(0,0,0,0.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .creatorCapsule :global(span) {
  color: var(--accent) !important;
}
:global([data-theme="light"]) .capsuleIcon {
  color: #fff !important;
  background-color: var(--accent) !important;
}
:global([data-theme="light"]) .satelliteShardLink {
  background: #ffffff !important;
  border-color: var(--accent);
  color: var(--accent) !important;
  box-shadow: 0 5px 20px rgba(0,0,0,0.1);
}
:global([data-theme="light"]) .satelliteShardLink:hover {
  background-color: var(--accent) !important;
  color: #fff !important;
}
:global([data-theme="light"] body.no-glass) .satelliteShardLink {
  background: #ffffff !important;
  color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .satelliteShardLink:hover {
  background-color: var(--accent) !important;
  color: #ffffff !important;
}
:global([data-theme="light"]) .techDot {
  background-color: rgba(0,0,0,0.2);
}

:global([data-theme="light"]) .cardContainer:hover a.creatorCapsule,
:global([data-theme="light"]) .cardContainer.activeState a.creatorCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}

:global([data-theme="light"]) .cardContainer:hover .creatorCapsule :global(span),
:global([data-theme="light"]) .cardContainer.activeState .creatorCapsule :global(span) {
    color: #fff !important;
}

:global([data-theme="light"]) .cardContainer:hover .capsuleIcon,
:global([data-theme="light"]) .cardContainer.activeState .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

:global([data-theme="light"]) a.creatorCapsule:hover,
:global([data-theme="light"]) div.creatorCapsule:hover {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}
:global([data-theme="light"]) a.creatorCapsule:hover :global(span),
:global([data-theme="light"]) div.creatorCapsule:hover :global(span) {
    color: #fff !important;
}
:global([data-theme="light"]) a.creatorCapsule:hover .capsuleIcon,
:global([data-theme="light"]) div.creatorCapsule:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

:global([data-theme="light"] body.no-glass) a.creatorCapsule,
:global([data-theme="light"] body.no-glass) div.creatorCapsule {
    background-color: #ffffff !important;
    border-color: rgba(0,0,0,0.1) !important;
}
:global([data-theme="light"] body.no-glass) .creatorCapsule :global(span) {
    color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .capsuleIcon {
    background-color: var(--accent) !important;
    color: #fff !important;
}

:global([data-theme="light"] body.no-glass) .cardContainer:hover a.creatorCapsule,
:global([data-theme="light"] body.no-glass) .cardContainer.activeState a.creatorCapsule,
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover,
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover {
     background-color: var(--accent) !important;
     border-color: var(--accent) !important;
}

:global([data-theme="light"] body.no-glass) .cardContainer:hover .creatorCapsule :global(span),
:global([data-theme="light"] body.no-glass) .cardContainer.activeState .creatorCapsule :global(span),
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover :global(span),
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover :global(span) {
     color: #ffffff !important;
}

:global([data-theme="light"] body.no-glass) .cardContainer:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) .cardContainer.activeState .capsuleIcon,
:global([data-theme="light"] body.no-glass) a.creatorCapsule:hover .capsuleIcon,
:global([data-theme="light"] body.no-glass) div.creatorCapsule:hover .capsuleIcon {
     background-color: #ffffff !important;
     color: var(--accent) !important;
}

--- END OF FILE components/news/NewsGridCard.module.css ---

================================================================================

--- START OF FILE components/news/NewsGridCard.tsx ---

// components/news/NewsGridCard.tsx
'use client';

import React, { memo, useState, useMemo, useRef } from 'react';
import Image from 'next/image';
import { motion, AnimatePresence } from 'framer-motion';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { CardProps } from '@/types';
import { sanityLoader } from '@/lib/sanity.loader'; 
import { Calendar03Icon, PenEdit02Icon } from '@/components/icons';
import styles from './NewsGridCard.module.css';
import { translateTag } from '@/lib/translations';
import { useIsMobile } from '@/hooks/useIsMobile';
import { useActiveCardStore } from '@/lib/activeCardStore';
import { useClickOutside } from '@/hooks/useClickOutside';
import { usePerformanceStore } from '@/lib/performanceStore'; 
import KineticLink from '@/components/kinetic/KineticLink';
import { generateLayoutId } from '@/lib/layoutUtils';

type NewsGridCardProps = {
    item: CardProps;
    isPriority?: boolean;
    layoutIdPrefix: string;
    variant?: 'default' | 'compact' | 'mini';
    onClick?: (e: React.MouseEvent) => void; // Prop for handling click-to-close behavior
};

const typeLabelMap: Record<string, string> = {
    'official': 'رسمي',
    'rumor': 'إشاعة',
    'leak': 'تسريب'
};

const typeDisplayMap: Record<string, string> = {
    'news': 'خبر',
    'article': 'مقال',
    'review': 'مراجعة'
};

const NewsGridCardComponent = ({ item, isPriority = false, layoutIdPrefix, variant = 'default', onClick }: NewsGridCardProps) => {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix); 
    const isMobile = useIsMobile();
    
    const { isLivingCardEnabled, isFlyingTagsEnabled, isHeroTransitionEnabled, isCornerAnimationEnabled, isHoverDebounceEnabled } = usePerformanceStore();
    const { livingCardRef, livingCardAnimation } = useLivingCard<HTMLDivElement>();
    const { activeCardId, setActiveCardId } = useActiveCardStore();
    const [isHoveredLocal, setIsHoveredLocal] = useState(false);
    
    const hoverTimeout = useRef<NodeJS.Timeout | null>(null);
    const touchTimeout = useRef<NodeJS.Timeout | null>(null);
    const touchStartPos = useRef({ x: 0, y: 0 });

    const isHovered = isMobile ? activeCardId === item.id : isHoveredLocal;
    const effectivelyDisabledLiving = !isLivingCardEnabled;

    useClickOutside(livingCardRef, () => {
        if (isMobile && activeCardId === item.id) {
            setActiveCardId(null);
        }
    });

    const getLinkData = () => {
        switch (item.type) {
            case 'review': return { type: 'reviews' as const, path: `/reviews/${item.slug}` };
            case 'article': return { type: 'articles' as const, path: `/articles/${item.slug}` };
            default: return { type: 'news' as const, path: `/news/${item.slug}` };
        }
    };
    const { type: kineticType, path: linkPath } = getLinkData();
    
    const handleClick = (e: React.MouseEvent) => {
        // Trigger external click handler (e.g., closing Search)
        if (onClick) onClick(e);

        if ((e.target as HTMLElement).closest('a[href^="/tags/"]')) return;
        if ((e.target as HTMLElement).closest('a[href^="/creators/"]')) return;
        if (!isMobile && isHeroTransitionEnabled) {
            setPrefix(layoutIdPrefix);
        }
    };

    const imageSource = item.imageUrl;
    if (!imageSource) return null;
    
    const isNews = item.type === 'news';
    const newsType = item.newsType || 'official';
    
    // Creator Data Extraction
    const authorObj = item.authors && item.authors.length > 0 ? item.authors[0] : null;
    const authorName = authorObj ? authorObj.name : 'محرر';
    const authorUsername = authorObj ? authorObj.username : null;
    // Prepare partial data
    const creatorData = authorObj ? { name: authorObj.name, image: authorObj.image } : undefined;

    const flyingItems = useMemo(() => {
        const satellites = [];
        if (item.game && typeof item.game === 'string' && item.gameSlug) {
            satellites.push({ label: item.game, link: `/games/${item.gameSlug}`, isKinetic: false });
        } else { satellites.push(null); }

        // THE DEFINITIVE FIX: Handle all possible shapes for category and tags.
        if (item.category && typeof item.category === 'string') {
            satellites.push({ label: translateTag(item.category), link: undefined, isKinetic: false });
        } else if (Array.isArray(item.tags) && item.tags.length > 0) {
            const firstTag = item.tags[0];
            // Check if the first tag is an object with title and slug properties
            if (firstTag && typeof firstTag === 'object' && firstTag.title && firstTag.slug) {
                satellites.push({ label: translateTag(firstTag.title), link: `/tags/${firstTag.slug}`, isKinetic: false });
            } else {
                satellites.push(null);
            }
        } else {
            satellites.push(null);
        }

        satellites.push({ label: typeDisplayMap[item.type] || 'محتوى', link: undefined, isKinetic: false });
        return satellites;
    }, [item.type, item.category, item.tags, item.game, item.gameSlug]);
    
    const desktopConfig = [
        { hoverX: -180, hoverY: 65, rotate: -6 },   
        { hoverX: 90, hoverY: 70, rotate: 5 },      
        { hoverX: -50, hoverY: -100, rotate: -3 }   
    ];

    const mobileConfig = [
        { hoverX: -150, hoverY: 35, rotate: -4 },
        { hoverX: 160, hoverY: 40, rotate: 4 },
        { hoverX: 0, hoverY: -85, rotate: -2 } 
    ];

    const compactConfig = [
        { hoverX: -110, hoverY: 30, rotate: -5 },
        { hoverX: 70, hoverY: 35, rotate: 4 },
        { hoverX: -20, hoverY: -65, rotate: -2 }
    ];

    let satelliteConfig;
    if (isMobile) {
        satelliteConfig = mobileConfig;
    } else if (variant === 'compact' || variant === 'mini') {
        satelliteConfig = compactConfig;
    } else {
        satelliteConfig = desktopConfig;
    }

    const capsuleContent = (
        <>
            <div className={styles.capsuleIcon}>
                <PenEdit02Icon style={{ width: 14, height: 14 }} />
            </div>
            <span>{authorName}</span>
        </>
    );
    
    const handlers = !isMobile ? {
        onMouseEnter: () => { 
            if(!effectivelyDisabledLiving) livingCardAnimation.onMouseEnter(); 
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if (!isHoverDebounceEnabled) { setIsHoveredLocal(true); } 
            else { hoverTimeout.current = setTimeout(() => setIsHoveredLocal(true), 75); }
        },
        onMouseLeave: () => { 
            if (hoverTimeout.current) clearTimeout(hoverTimeout.current);
            if(!effectivelyDisabledLiving) livingCardAnimation.onMouseLeave(); 
            setIsHoveredLocal(false); 
        },
        onMouseMove: !effectivelyDisabledLiving ? livingCardAnimation.onMouseMove : undefined,
    } : {
        onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => {
            const touch = e.touches[0];
            touchStartPos.current = { x: touch.clientX, y: touch.clientY };
            if (touchTimeout.current) clearTimeout(touchTimeout.current);
            if (!isHoverDebounceEnabled) {
                if (activeCardId !== item.id) setActiveCardId(item.id);
            } else {
                touchTimeout.current = setTimeout(() => {
                     if (activeCardId !== item.id) setActiveCardId(item.id);
                }, 75);
            }
            if(!effectivelyDisabledLiving) livingCardAnimation.onTouchStart(e);
        },
        onTouchMove: (e: React.TouchEvent<HTMLDivElement>) => {
             const touch = e.touches[0];
             const diffX = Math.abs(touch.clientX - touchStartPos.current.x);
             const diffY = Math.abs(touch.clientY - touchStartPos.current.y);
             if (diffX > 10 || diffY > 10) {
                 if (touchTimeout.current) clearTimeout(touchTimeout.current);
             }
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchMove(e);
        },
        onTouchEnd: () => {
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchEnd();
        },
    };
    
    const safeLayoutIdPrefix = isHeroTransitionEnabled ? layoutIdPrefix : undefined;
    const animationStyles = !effectivelyDisabledLiving ? livingCardAnimation.style : {};

    return (
        <motion.div
            ref={livingCardRef} 
            {...handlers}
            className={`${styles.cardContainer} ${isHovered ? styles.activeState : ''} ${!isCornerAnimationEnabled ? 'noCornerAnimation' : ''}`}
            style={animationStyles}
        >
            <motion.div
                layoutId={!isMobile && safeLayoutIdPrefix ? generateLayoutId(safeLayoutIdPrefix, 'container', item.legacyId) : undefined}
                className={`${styles.newsCard} ${variant === 'compact' ? styles.compact : ''} ${variant === 'mini' ? styles.mini : ''}`}
            >
                <KineticLink 
                    href={linkPath}
                    slug={item.slug}
                    type={kineticType}
                    layoutId={safeLayoutIdPrefix}
                    imageSrc={imageSource}
                    className={`${styles.cardLink} no-underline`}
                    onClick={handleClick}
                >
                    <div className={styles.imageContentWrapper}>
                        <motion.div 
                            className={styles.imageContainer} 
                            layoutId={!isMobile && safeLayoutIdPrefix ? generateLayoutId(safeLayoutIdPrefix, 'image', item.legacyId) : undefined}
                        >
                            {isNews && (
                                <span className={`${styles.imageBadge} ${styles[newsType]}`}>
                                    {typeLabelMap[newsType]}
                                </span>
                            )}
                            
                            <Image 
                                loader={sanityLoader}
                                src={imageSource}
                                alt={item.title}
                                fill
                                sizes="(max-width: 768px) 130px, 260px"
                                className={styles.cardImage}
                                style={{ objectFit: 'cover' }}
                                // FIX: Conditional blur data
                                placeholder={item.blurDataURL ? 'blur' : 'empty'}
                                blurDataURL={item.blurDataURL}
                                priority={isPriority}
                            />
                        </motion.div>
                        
                        <div className={styles.cardInfoColumn}>
                            <motion.h3 
                                className={styles.cardTitle}
                                layoutId={!isMobile && safeLayoutIdPrefix ? generateLayoutId(safeLayoutIdPrefix, 'title', item.legacyId) : undefined}
                            >
                                {item.title}
                            </motion.h3>

                            <div className={styles.cardMetadata}>
                                <div style={{display:'flex', alignItems:'center', gap:'0.8rem'}}>
                                    {/* FIX: Propagate onClick to close search even when clicking creator */}
                                    {authorUsername ? (
                                        <KineticLink 
                                            href={`/creators/${authorUsername}`}
                                            slug={authorUsername}
                                            type="creators"
                                            className={`${styles.creatorCapsule} no-underline`}
                                            onClick={(e) => { 
                                                e.stopPropagation(); 
                                                if (onClick) onClick(e); 
                                            }}
                                            // PASS DATA
                                            preloadedData={creatorData}
                                        >
                                            {capsuleContent}
                                        </KineticLink>
                                    ) : (
                                        <div className={styles.creatorCapsule}>
                                            {capsuleContent}
                                        </div>
                                    )}
                                </div>

                                <div className={styles.techDecoration}>
                                    <div className={styles.techDot} />
                                    <div className={styles.techDot} />
                                    <div className={styles.techDot} />
                                </div>

                                {item.date && (
                                    <div className={styles.cardDate}>
                                        <Calendar03Icon className={styles.metadataIcon} />
                                        <span>{item.date.split(' - ')[0]}</span>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </KineticLink>

                {isFlyingTagsEnabled && (
                    <div className={styles.satelliteField} style={{ transform: 'translateZ(60px)' }}>
                        <AnimatePresence>
                             {isHovered && flyingItems.map((sat, i) => {
                                 if (!sat) return null;
                                 
                                 const config = satelliteConfig[i] || { hoverX: 0, hoverY: 0, rotate: 0 };
                                 const isLeft = config.hoverX < 0;
                                 
                                 const anchorRight = isMobile ? !isLeft : isLeft;

                                 const positionStyle = anchorRight 
                                    ? { right: '50%', left: 'auto', top: '50%', transformOrigin: 'center right' }
                                    : { left: '50%', right: 'auto', top: '50%', transformOrigin: 'center left' };

                                 return (
                                     <motion.div
                                        key={`${item.id}-sat-${i}`}
                                        className={styles.satelliteShard}
                                        initial={{ opacity: 0, scale: 0.4, x: 0, y: 50, z: 0 }}
                                        animate={{ opacity: 1, scale: 1.15, x: config.hoverX, y: config.hoverY, rotate: config.rotate, z: -30 }}
                                        exit={{ opacity: 0, scale: 0.4, x: 0, y: 0, rotate: 0, z: 0 }}
                                        transition={{ type: "spring", stiffness: 180, damping: 20, delay: i * 0.05 }}
                                        style={{ position: 'absolute', ...positionStyle, transformStyle: 'preserve-3d' }}
                                        onClick={(e) => e.stopPropagation()}
                                     >
                                         {sat.link ? (
                                             <KineticLink 
                                                href={sat.link} 
                                                slug={sat.link.split('/').pop() || ''} 
                                                type={sat.link.includes('/tags/') ? 'tags' : 'games'}
                                                onClick={(e) => { 
                                                    e.stopPropagation(); 
                                                    if(onClick) onClick(e); 
                                                }}
                                                className={`${styles.satelliteShardLink} ${styles.clickable} ${(variant === 'compact' || variant === 'mini') ? styles.small : ''} no-underline`}
                                             >
                                                 {sat.label}
                                             </KineticLink>
                                         ) : (
                                             <span className={`${styles.satelliteShardLink} ${styles.static} ${(variant === 'compact' || variant === 'mini') ? styles.small : ''}`}>
                                                 {sat.label}
                                             </span>
                                         )}
                                     </motion.div>
                                 );
                             })}
                        </AnimatePresence>
                    </div>
                )}
            </motion.div>
        </motion.div>
    );
};

const NewsGridCard = memo(NewsGridCardComponent);
export default NewsGridCard;

--- END OF FILE components/news/NewsGridCard.tsx ---

================================================================================

--- START OF FILE components/news/NewsHero.module.css ---

/* components/news/NewsHero.module.css */

.heroContainer {
    position: relative;
    height: 65vh;
    min-height: 500px;
    width: 100%;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    color: #fff;
    padding-top: var(--nav-height-scrolled);
}

.heroBackground {
    position: absolute;
    inset: 0;
    z-index: -2;
    overflow: hidden;
}

.heroOverlay {
    position: absolute;
    inset: 0;
    z-index: -1;
    background: linear-gradient(to top, rgba(0,0,0,0.95) 10%, rgba(0,0,0,0.6) 35%, transparent 100%);
}

:global([data-theme="light"]) .heroOverlay {
    background: none !important;
}

.heroContentWrapper {
    position: relative;
    z-index: 10;
    padding-bottom: 4rem;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

.activeStoryContainer {
    max-width: 650px;
    padding: 0 2rem;
    text-align: right;
    margin-left: auto; 
    margin-right: 0;
    position: relative;
}

.textContent {
    position: relative; 
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
}

/* --- Ribbon Styling --- */
.storyCategory {
    font-size: 1.6rem;
    font-weight: 700;
    letter-spacing: 1px;
    margin-bottom: 1.5rem; 
    padding: 0.4rem 1.2rem;
    display: inline-block;
    position: relative;
    z-index: 1;
    border-radius: 4px;
    transition: color 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.storyCategory::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 4px;
    z-index: -1;
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* HOVER / ACTIVE LOGIC */
.textContent.activeState .storyCategory {
    color: #fff !important; 
    transform: translateY(-3px);
    text-shadow: none;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.textContent.activeState .storyCategory::before {
    transform: scaleX(1);
}
.textContent.activeState .storyLink {
    color: var(--accent);
}

@media (hover: hover) {
    .textContent:hover .storyCategory {
        color: #fff !important;
        transform: translateY(-3px);
        text-shadow: none;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .textContent:hover .storyCategory::before { transform: scaleX(1); }
    .textContent:hover .storyLink { color: var(--accent); }
    .progressDot:hover { transform: scale(1.6); }
}

/* Colors */
.storyCategory.official { color: var(--accent); }
.storyCategory.rumor { color: #F59E0B; }
.storyCategory.leak { color: #DC2626; }

.storyCategory.official::before { background-color: var(--accent); }
.storyCategory.rumor::before { background-color: #F59E0B; }
.storyCategory.leak::before { background-color: #DC2626; }

.storyTitle {
    font-size: clamp(2.8rem, 4.5vw, 4.5rem);
    line-height: 1.25;
    margin: 0 0 1.5rem 0;
    text-shadow: 0 2px 15px rgba(0,0,0,0.5);
    display: flex;
    flex-wrap: wrap;
}

.storyMeta {
    font-size: 1.5rem;
    color: var(--text-secondary);
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
}

.storyLink {
    display: inline-block;
    color: #fff;
    text-decoration: none;
    transition: color 0.2s ease;
}

.controlsContainer {
    position: absolute;
    right: 4rem;
    left: auto;
    bottom: 50%;
    transform: translateY(50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    z-index: 20;
}

.progressDot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4);
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease-out;
    border: none;
    padding: 0;
}

.progressDot.active {
    background-color: var(--accent);
    transform: scale(1.4);
    box-shadow: 0 0 10px var(--accent);
}

@media (max-width: 1024px) {
    .heroContainer { height: 60vh; min-height: 450px; }
    .storyTitle { font-size: clamp(2.4rem, 6vw, 3.6rem); }
    .controlsContainer { flex-direction: row; left: 50%; right: auto; transform: translateX(-50%); bottom: 2rem; top: auto; }
    .activeStoryContainer { max-width: 90%; text-align: center; margin: 0 auto; }
    .storyMeta { justify-content: center; }
}

--- END OF FILE components/news/NewsHero.module.css ---

================================================================================

--- START OF FILE components/news/NewsHero.tsx ---

// components/news/NewsHero.tsx
'use client';

import React, { useState, useEffect, memo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import { CardProps } from '@/types';
import styles from './NewsHero.module.css';
import { Calendar03Icon } from '@/components/icons';
import CreatorCredit from '@/components/CreatorCredit';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { sanityLoader } from '@/lib/sanity.loader'; 
import { usePerformanceStore } from '@/lib/performanceStore';
import { useContentStore } from '@/lib/contentStore';
// IMPORT KineticLink
import KineticLink from '@/components/kinetic/KineticLink';

const transition = { type: 'spring' as const, stiffness: 400, damping: 50 };

const titleContainerVariants = {
    animate: { transition: { staggerChildren: 0.08 } },
};

const wordVariants = {
    initial: { opacity: 0, y: 20 },
    animate: { opacity: 1, y: 0, transition: { ...transition, duration: 0.8 } },
};

const typeLabelMap: Record<string, string> = {
    'official': 'رسمي',
    'rumor': 'إشاعة',
    'leak': 'تسريب'
};

const AnimatedStory = memo(({ item, isActive, layoutIdPrefix }: { item: CardProps; isActive: boolean, layoutIdPrefix: string }) => {
    const newsType = item.newsType || 'official';
    const label = typeLabelMap[newsType] || 'أخبار';
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const [isPressed, setIsPressed] = useState(false);
    
    const { isHeroTransitionEnabled } = usePerformanceStore();

    const handleClick = () => {
        if (isHeroTransitionEnabled) {
            setPrefix(layoutIdPrefix);
        }
    };

    const safeLayoutIdPrefix = isHeroTransitionEnabled ? layoutIdPrefix : undefined;

    return (
        <AnimatePresence>
            {isActive && (
                <motion.div 
                    key={item.id}
                    className={styles.activeStoryContainer}
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.5 }}
                >
                    <div 
                        className={`${styles.textContent} ${isPressed ? styles.activeState : ''}`}
                        onTouchStart={() => setIsPressed(true)}
                        onTouchEnd={() => setIsPressed(false)}
                    >
                        <p className={`${styles.storyCategory} ${styles[newsType]}`}>
                            {label}
                        </p>
                        
                        {/* CHANGED TO KINETIC LINK */}
                        <KineticLink 
                            href={`/news/${item.slug}`}
                            slug={item.slug}
                            type="news"
                            imageSrc={item.imageUrl}
                            layoutId={safeLayoutIdPrefix}
                            onClick={handleClick}
                            className={`${styles.storyLink} no-underline`}
                        >
                            <motion.h1 
                                className={styles.storyTitle} 
                                layoutId={safeLayoutIdPrefix ? `${safeLayoutIdPrefix}-card-title-${item.legacyId}` : undefined}
                                variants={titleContainerVariants}
                                initial="initial"
                                animate="animate"
                            >
                                {item.title.split(' ').map((word, index) => (
                                    <motion.span key={index} variants={wordVariants} style={{ display: 'inline-block', marginRight: '0.6rem' }}>
                                        {word}
                                    </motion.span>
                                ))}
                            </motion.h1>
                        </KineticLink>

                        <div className={styles.storyMeta}>
                            <CreatorCredit label="بواسطة" creators={item.authors} small disableLink />
                            <span className={styles.storyMetaDate}>
                                 <Calendar03Icon style={{width:'16px', height: '16px', color: 'var(--accent)'}} /> {item.date}
                            </span>
                        </div>
                    </div>
                </motion.div>
            )}
        </AnimatePresence>
    );
});
AnimatedStory.displayName = "AnimatedStory";


const HeroBackground = memo(({ imageUrl, alt, layoutId, legacyId, layoutIdPrefix }: { imageUrl: string; alt: string; layoutId: string; legacyId: number; layoutIdPrefix: string }) => {
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const { isHeroTransitionEnabled } = usePerformanceStore();
    
    const handleClick = () => {
        if (isHeroTransitionEnabled) {
            setPrefix(layoutIdPrefix);
        }
    };
    
    const safeLayoutId = isHeroTransitionEnabled ? layoutId : undefined;

    return (
        <motion.div 
            key={imageUrl} 
            className={styles.heroBackground} 
            layoutId={isHeroTransitionEnabled ? `${layoutIdPrefix}-card-container-${legacyId}` : undefined} 
            initial={{ opacity: 0, scale: 1.1 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 1.1 }}
            transition={{ duration: 1.5, ease: [0.22, 1, 0.36, 1] }}
            onClick={handleClick}
        >
             <motion.div 
                style={{ position: 'relative', width: '100%', height: '100%' }}
                layoutId={safeLayoutId} 
             >
                <Image
                    loader={sanityLoader} 
                    src={imageUrl}
                    alt={alt}
                    fill
                    priority
                    style={{ objectFit: 'cover', filter: 'grayscale(10%) brightness(0.7)'}}
                    sizes="100vw"
                />
             </motion.div>
        </motion.div>
    );
});
HeroBackground.displayName = "HeroBackground";

export default function NewsHero({ newsItems }: { newsItems: CardProps[] }) {
    const [activeIndex, setActiveIndex] = useState(0);
    const [isPaused, setIsPaused] = useState(false);
    
    const isOverlayOpen = useContentStore((s) => s.isOverlayOpen);

    useEffect(() => {
        if (isPaused || newsItems.length <= 1 || isOverlayOpen) return;
        const interval = setInterval(() => {
            setActiveIndex((prevIndex) => (prevIndex + 1) % newsItems.length);
        }, 4000);
        return () => clearInterval(interval);
    }, [isPaused, newsItems.length, isOverlayOpen]);
    
    if (newsItems.length === 0) return null;

    const activeItem = newsItems[activeIndex];
    const layoutIdPrefix = "news-hero";

    return (
        <div 
            className={styles.heroContainer}
            onMouseEnter={() => setIsPaused(true)}
            onMouseLeave={() => setIsPaused(false)}
            onTouchStart={() => setIsPaused(true)}
            onTouchEnd={() => setIsPaused(false)}
        >
            <AnimatePresence>
                 <HeroBackground 
                    key={activeItem.id} 
                    imageUrl={activeItem.imageUrl} 
                    alt={activeItem.title} 
                    layoutId={`${layoutIdPrefix}-card-image-${activeItem.legacyId}`} 
                    legacyId={activeItem.legacyId}
                    layoutIdPrefix={layoutIdPrefix}
                 />
            </AnimatePresence>
            
            <div className={styles.heroOverlay} />

            <div className={`container ${styles.heroContentWrapper}`}>
                <AnimatePresence mode="wait">
                    <AnimatedStory key={activeItem.id} item={activeItem} isActive={true} layoutIdPrefix={layoutIdPrefix} />
                </AnimatePresence>
            </div>

            <div className={styles.controlsContainer}>
                {newsItems.map((item, index) => (
                    <button
                        key={item.id}
                        className={`${styles.progressDot} ${activeIndex === index ? styles.active : ''}`}
                        onClick={() => setActiveIndex(index)}
                        aria-label={`Go to news slide ${index + 1}`}
                    />
                ))}
            </div>
        </div>
    );
}

--- END OF FILE components/news/NewsHero.tsx ---

================================================================================

--- START OF FILE components/notifications/NotificationBell.tsx ---

// components/notifications/NotificationBell.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { NotificationIcon } from '@/components/icons/index';
import { useSession } from 'next-auth/react';
import NotificationPanel from './NotificationPanel';
import { useNotificationStore } from '@/lib/notificationStore';
import styles from './Notifications.module.css';

const bellVariants = {
    rest: { rotate: 0, scale: 1 },
    hover: { 
        rotate: [0, -10, 10, -5, 5, 0],
        scale: 1.1,
        transition: { 
            duration: 0.5, 
            ease: "easeInOut" as const
        }
    },
    tap: { scale: 0.95, rotate: 0 }
};

export default function NotificationBell() {
    const { data: session } = useSession();
    const [isOpen, setIsOpen] = useState(false);
    const panelRef = useRef<HTMLDivElement>(null);

    const { 
        notifications, 
        unreadCount, 
        fetchNotifications, 
        setUnreadCount, 
        setNotifications 
    } = useNotificationStore();

    // REMOVED: The useEffect that automatically fetched on mount.
    // Data is now pre-loaded by UserStoreHydration via /api/user/init.

    // Manual refresh when opening the panel
    const handleToggle = () => {
        const nextState = !isOpen;
        setIsOpen(nextState);
        
        if (nextState) {
            // Force a fresh fetch only when explicitly interacting
            fetchNotifications(true);
        }
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (panelRef.current && !panelRef.current.contains(event.target as Node)) {
                setIsOpen(false);
            }
        };
        if (isOpen) {
            document.addEventListener('mousedown', handleClickOutside);
        }
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isOpen]);

    if (!session?.user) return null;

    return (
        <div className={styles.notificationWrapper} ref={panelRef}>
            <motion.button
                className={styles.bellButton}
                onClick={handleToggle}
                initial="rest"
                whileHover="hover"
                whileTap="tap"
                variants={bellVariants}
                style={{ transformOrigin: 'top center' }}
                title="الإشعارات"
            >
                <NotificationIcon className={styles.bellIcon} />
                <AnimatePresence>
                    {unreadCount > 0 && (
                        <motion.span
                            key="badge"
                            initial={{ scale: 0 }}
                            animate={{ scale: 1 }}
                            exit={{ scale: 0 }}
                            className={styles.notificationBadge}
                        >
                            {unreadCount > 9 ? '9+' : unreadCount}
                        </motion.span>
                    )}
                </AnimatePresence>
            </motion.button>

            <AnimatePresence>
                {isOpen && (
                    <NotificationPanel 
                        notifications={notifications} 
                        onClose={() => setIsOpen(false)}
                        setUnreadCount={setUnreadCount}
                        setNotifications={setNotifications}
                    />
                )}
            </AnimatePresence>
        </div>
    );
}




--- END OF FILE components/notifications/NotificationBell.tsx ---

================================================================================

--- START OF FILE components/notifications/NotificationPanel.tsx ---

// components/notifications/NotificationPanel.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import Image from 'next/image';
import Link from 'next/link';
import { markNotificationAsRead, markAllNotificationsAsRead } from '@/app/actions/notificationActions';
import TimeStamp from '@/components/comments/TimeStamp';
import styles from './Notifications.module.css';
import { useTransition } from 'react';

const panelVariants = {
    hidden: { opacity: 0, y: 10, scale: 0.95, filter: 'blur(10px)' },
    // THE FIX: Added 'as const' to the transition type to satisfy TypeScript/Framer Motion types
    visible: { opacity: 1, y: 0, scale: 1, filter: 'blur(0px)', transition: { type: 'spring' as const, stiffness: 350, damping: 25 } },
    exit: { opacity: 0, y: 10, scale: 0.95, filter: 'blur(10px)', transition: { duration: 0.2 } }
};

const itemVariants = {
    hidden: { opacity: 0, x: -20 },
    visible: { opacity: 1, x: 0 }
};

export default function NotificationPanel({ notifications, onClose, setUnreadCount, setNotifications }: any) {
    const [isPending, startTransition] = useTransition();

    const handleMarkRead = (id: string) => {
        // Optimistic update
        setNotifications((prev: any[]) => prev.map(n => n.id === id ? { ...n, read: true } : n));
        setUnreadCount((prev: number) => Math.max(0, prev - 1));
        
        startTransition(async () => {
            await markNotificationAsRead(id);
        });
        onClose();
    };

    const handleMarkAllRead = () => {
        setNotifications((prev: any[]) => prev.map(n => ({ ...n, read: true })));
        setUnreadCount(0);
        startTransition(async () => {
            await markAllNotificationsAsRead();
        });
    };

    return (
        <motion.div
            className={styles.notificationPanel}
            variants={panelVariants}
            initial="hidden"
            animate="visible"
            exit="exit"
        >
            <div className={styles.panelHeader}>
                <h3>الإشعارات</h3>
                {notifications.length > 0 && (
                    <button onClick={handleMarkAllRead} className={styles.markAllReadButton} disabled={isPending}>
                        تحديد الكل كمقروء
                    </button>
                )}
            </div>

            <div className={styles.notificationsList}>
                {notifications.length === 0 ? (
                    <div className={styles.emptyState}>
                        <p>لا توجد إشعارات جديدة.</p>
                    </div>
                ) : (
                    notifications.map((notification: any) => (
                        <motion.div
                            key={notification.id}
                            className={`${styles.notificationItem} ${!notification.read ? styles.unread : ''}`}
                            variants={itemVariants}
                            layout
                        >
                            <div className={styles.avatarWrapper}>
                                <Image 
                                    src={notification.sender.image || '/default-avatar.svg'} 
                                    alt={notification.sender.name} 
                                    width={40} height={40} 
                                    className={styles.notificationAvatar} 
                                />
                            </div>
                            <div className={styles.notificationContent}>
                                {/* MODIFIED: Use the explicit `link` field from DB */}
                                <Link 
                                    href={notification.link || '#'}
                                    onClick={() => handleMarkRead(notification.id)}
                                    className={styles.notificationLink}
                                >
                                    <p>
                                        <span className={styles.senderName}>{notification.sender.name}</span>
                                        {' '}رد على تعليقك.
                                    </p>
                                </Link>
                                <div className={styles.notificationMeta}>
                                    <TimeStamp date={notification.createdAt} />
                                </div>
                            </div>
                            {!notification.read && <div className={styles.unreadDot} />}
                        </motion.div>
                    ))
                )}
            </div>
        </motion.div>
    );
}




--- END OF FILE components/notifications/NotificationPanel.tsx ---

================================================================================

--- START OF FILE components/notifications/Notifications.module.css ---

/* components/notifications/Notifications.module.css */

.notificationWrapper {
    position: relative;
}

.bellButton {
    background: none;
    border: none;
    cursor: pointer;
    position: relative;
    /* THE FIX: Ensures the bell is white/bright (primary text color) instead of gray */
    color: var(--text-primary);
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: color 0.2s ease, background-color 0.2s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .bellButton:hover  {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}
}

  .bellButton:active  {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}
}
.bellButton:active {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}


.bellIcon {
    width: 24px;
    height: 24px;
}

.notificationBadge {
    position: absolute;
    top: 2px;
    right: 2px;
    background-color: #DC2626;
    color: white;
    font-size: 1rem;
    font-weight: 700;
    min-width: 16px;
    height: 16px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 4px;
    border: 2px solid var(--bg-secondary);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.notificationPanel {
    position: absolute;
    top: calc(100% + 15px);
    left: 0; /* Align left for RTL context in navbar */
    width: 320px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 10px 40px -10px rgba(0,0,0,0.3);
    z-index: 1100;
    overflow: hidden;
    transform-origin: top left;
    display: flex;
    flex-direction: column;
}

.panelHeader {
    padding: 1.2rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: color-mix(in srgb, var(--bg-primary) 50%, transparent);
    backdrop-filter: blur(10px);
}

:global(body.no-glass) .panelHeader {
    backdrop-filter: none !important;
    background-color: var(--bg-secondary) !important;
}

.panelHeader h3 {
    margin: 0;
    font-size: 1.6rem;
    font-family: var(--font-heading);
    color: var(--text-primary);
}

.markAllReadButton {
    background: none;
    border: none;
    color: var(--accent);
    font-size: 1.2rem;
    cursor: pointer;
    font-weight: 600;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .markAllReadButton:hover  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}
}

  .markAllReadButton:active  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}
}
.markAllReadButton:active {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}


.notificationsList {
    max-height: 350px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.notificationItem {
    padding: 1.2rem 1.5rem;
    display: flex;
    gap: 1.2rem;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s ease;
    position: relative;
}

.notificationItem:last-child {
    border-bottom: none;
}
@media (hover: hover) {@media (hover: hover) {
  
  .notificationItem:hover  {
    background-color: var(--bg-primary);
}
}

  .notificationItem:active  {
    background-color: var(--bg-primary);
}
}
.notificationItem:active {
    background-color: var(--bg-primary);
}


.notificationItem.unread {
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}

.notificationAvatar {
    border-radius: 50%;
    border: 1px solid var(--border-color);
}

.notificationContent {
    flex-grow: 1;
    font-size: 1.4rem;
    line-height: 1.4;
}

.notificationLink {
    text-decoration: none;
    color: var(--text-primary);
    display: block;
}

.senderName {
    font-weight: 700;
    color: var(--text-primary);
}

.notificationMeta {
    font-size: 1.2rem;
    color: var(--text-secondary);
    margin-top: 0.4rem;
}

.unreadDot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--accent);
    align-self: center;
    flex-shrink: 0;
}

.emptyState {
    padding: 3rem;
    text-align: center;
    color: var(--text-secondary);
    font-size: 1.4rem;
}

@media (max-width: 768px) {
    .notificationPanel {
        position: fixed;
        top: 70px; /* Below navbar */
        left: 1rem;
        right: 1rem;
        width: auto;
        max-height: 60vh;
    }
}

--- END OF FILE components/notifications/Notifications.module.css ---

================================================================================

--- START OF FILE components/releases/AdminPinButton.module.css ---

/* components/releases/AdminPinButton.module.css */

.pinButton {
    /* Removed absolute positioning to allow flex layout in parent */
    width: 32px;
    height: 32px;
    border-radius: 50%;
    
    /* Inactive State: Cyan Outline, Dark Glass BG, Cyan Icon */
    background-color: rgba(0, 0, 0, 0.6); /* Slightly darker glass for better contrast */
    border: 1px solid var(--accent);
    color: var(--accent);
    
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 50;
    transition: all 0.2s ease;
}

:global(body.no-glass) .pinButton {
    backdrop-filter: none !important;
    background-color: #000 !important;
}

/* THE FIX: Enforce active colors when pinned, even in no-glass mode */
:global(body.no-glass) .pinButton.pinned {
    background-color: var(--accent) !important;
    color: #000000 !important;
    border-color: var(--accent) !important;
}

/* Mobile Opt: Kill Blur */
@media (max-width: 768px) {
    .pinButton {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(0, 0, 0, 0.9);
    }
}

.pinButton:hover {
    transform: scale(1.1);
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
}

.pinButton.pinned {
    /* Active State: Cyan Fill, Black Icon */
    background-color: var(--accent);
    color: #000000;
    border-color: var(--accent);
    box-shadow: 0 0 10px var(--accent);
}

.spinner {
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}
/* --- Light Mode Overrides (No Black) --- */
:global([data-theme="light"]) .pinButton {
    background-color: rgba(255, 255, 255, 0.9) !important;
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 4px 12px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .pinButton:hover,
:global([data-theme="light"]) .pinButton.pinned {
    background-color: var(--accent) !important;
    color: #fff !important;
    border-color: var(--accent);
}


--- END OF FILE components/releases/AdminPinButton.module.css ---

================================================================================

--- START OF FILE components/releases/AdminPinButton.tsx ---

// components/releases/AdminPinButton.tsx
'use client';

import { useState, useTransition } from 'react';
import { toggleReleasePin } from '@/app/releases/actions';
import { useToast } from '@/lib/toastStore';
import styles from './AdminPinButton.module.css';

const PinIcon = () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="17" x2="12" y2="22"></line>
        <path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"></path>
    </svg>
);

export default function AdminPinButton({ releaseId, isPinned }: { releaseId: string, isPinned: boolean }) {
    const [pinned, setPinned] = useState(isPinned);
    const [isPending, startTransition] = useTransition();
    const toast = useToast();

    const handleToggle = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        startTransition(async () => {
            const result = await toggleReleasePin(releaseId, pinned);
            if (result.success) {
                setPinned(!pinned);
                toast.success(result.message);
            } else {
                toast.error(result.message);
            }
        });
    };

    return (
        <button 
            className={`${styles.pinButton} ${pinned ? styles.pinned : ''}`}
            onClick={handleToggle}
            title={pinned ? "إلغاء التثبيت" : "تثبيت في المقدمة"}
            disabled={isPending}
        >
            {isPending ? <div className={styles.spinner} /> : <PinIcon />}
        </button>
    );
}




--- END OF FILE components/releases/AdminPinButton.tsx ---

================================================================================

--- START OF FILE components/releases/MonthFilterPopover.tsx ---

// components/releases/MonthFilterPopover.tsx
'use client';
import { motion } from 'framer-motion';
import styles from '@/components/filters/Filters.module.css';

const ARABIC_MONTHS = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: -10, scale: 0.95 }, };

export default function MonthFilterPopover({ 
    selectedMonth, 
    onSelect, 
    onClose 
}: { 
    selectedMonth: number | 'all', 
    onSelect: (month: number | 'all') => void, 
    onClose: () => void 
}) {
  return (
    <motion.div 
        className={styles.filterPopover} 
        style={{ width: '200px', maxHeight: '400px' }} 
        variants={popoverVariants} 
        initial="hidden" 
        animate="visible" 
        exit="exit" 
        onClick={(e) => e.stopPropagation()}
    >
      <div className={styles.popoverResultsList}>
        <motion.button 
            className={`${styles.popoverItemButton} ${selectedMonth === 'all' ? styles.selected : ''}`} 
            onClick={() => { onSelect('all'); onClose(); }}
        >
            الكل
        </motion.button>
        {ARABIC_MONTHS.map((month, idx) => (
          <motion.button 
            key={idx} 
            className={`${styles.popoverItemButton} ${selectedMonth === idx ? styles.selected : ''}`} 
            onClick={() => { onSelect(idx); onClose(); }}
          >
            {month}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}




--- END OF FILE components/releases/MonthFilterPopover.tsx ---

================================================================================

--- START OF FILE components/releases/PinnedReleases.module.css ---

/* components/releases/PinnedReleases.module.css */

.pinnedContainer {
    width: 100%;
    margin-bottom: 4rem;
}

.sectionHeader {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    padding-right: 1rem;
}

.sectionTitle {
    font-size: 2.4rem;
    font-weight: 800;
    color: var(--text-primary);
    margin: 0;
}

.pinIcon {
    color: var(--accent);
    transform: rotate(45deg);
}

.pinnedGrid {
    display: grid;
    /* Smart responsive layout: 
       - Desktop: 3 columns.
       - If 4 items: Top 3, Bottom 1 centered.
       - If 5 items: Top 3, Bottom 2 centered.
    */
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
    width: 100%;
    align-items: start; /* FIX: Prevents cards from stretching vertically */
}

/* 
   FIX: Removed fixed height.
   Let the TimelineCard size itself. TimelineCard will now support auto-height.
*/
.pinnedItem {
    width: 100%;
}

/* Centering logic for overflowing items */
.pinnedGrid:has(> :nth-child(4):last-child) > :nth-child(4) {
    grid-column: 2 / 3;
}

/* If there are 5 items, items 4 & 5 are centered below */
.pinnedGrid:has(> :nth-child(5):last-child) > :nth-child(4) {
    grid-column: 1 / span 1;
    transform: translateX(50%); /* Push right by half a column */
}
.pinnedGrid:has(> :nth-child(5):last-child) > :nth-child(5) {
    grid-column: 2 / span 1;
    transform: translateX(50%); /* Push right by half a column */
}

@media (max-width: 1024px) {
    .pinnedGrid {
        grid-template-columns: 1fr 1fr; /* 2 columns on tablet */
    }
    .pinnedGrid:has(> :nth-child(4):last-child) > :nth-child(4) {
        grid-column: auto; /* Reset */
    }
}

@media (max-width: 768px) {
    .pinnedGrid {
        grid-template-columns: 1fr; /* Stack on mobile */
    }
    /* Reset all specialized grid placement */
    .pinnedGrid:has(> :nth-child(5):last-child) > :nth-child(4),
    .pinnedGrid:has(> :nth-child(5):last-child) > :nth-child(5) {
        grid-column: auto;
        transform: none;
    }
}




--- END OF FILE components/releases/PinnedReleases.module.css ---

================================================================================

--- START OF FILE components/releases/PinnedReleases.tsx ---

// components/releases/PinnedReleases.tsx
'use client';

import { motion } from 'framer-motion';
import type { SanityGameRelease } from '@/types/sanity';
import TimelineCard from '@/components/TimelineCard';
import styles from './PinnedReleases.module.css';

const PinIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="17" x2="12" y2="22"></line>
        <path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"></path>
    </svg>
);

const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            staggerChildren: 0.1
        }
    }
};

const itemVariants = {
    hidden: { opacity: 0, y: 30 },
    visible: { opacity: 1, y: 0, transition: { type: 'spring', stiffness: 300, damping: 25 } as const }
};

interface PinnedReleasesProps {
    items: SanityGameRelease[];
    showAdminControls?: boolean; // Added Prop
}

export default function PinnedReleases({ items, showAdminControls = false }: PinnedReleasesProps) {
    if (items.length === 0) return null;

    return (
        <div className={styles.pinnedContainer}>
            <div className={styles.sectionHeader}>
                <div className={styles.pinIcon}><PinIcon /></div>
                <h2 className={styles.sectionTitle}>أهم الإصدارات</h2>
            </div>
            
            <motion.div 
                className={styles.pinnedGrid}
                variants={containerVariants}
                initial="hidden"
                animate="visible"
            >
                {items.map((release) => (
                    <motion.div 
                        key={release._id} 
                        className={styles.pinnedItem}
                        variants={itemVariants}
                    >
                        {/* Pass showAdminControls down to TimelineCard */}
                        <TimelineCard 
                            release={release} 
                            autoHeight={true} 
                            showAdminControls={showAdminControls} 
                        />
                    </motion.div>
                ))}
            </motion.div>
        </div>
    );
}




--- END OF FILE components/releases/PinnedReleases.tsx ---

================================================================================

--- START OF FILE components/releases/ReleasesControlBar.module.css ---

/* components/releases/ReleasesControlBar.module.css */

/* Custom layout for the Search + Year row */
.searchYearRow {
    display: flex;
    gap: 1.5rem;
    width: 100%;
    align-items: center;
}

/* Make search take available space, Year take necessary space */
.searchInputWrapper {
    flex-grow: 1;
}

.yearInputWrapper {
    flex-shrink: 0;
    width: 120px; /* Fixed width for year button */
}

/* Container for the scrollable month strip on Desktop */
.monthStripContainer {
    width: 100%;
    overflow-x: auto;
    padding-bottom: 5px; /* Space for focus rings/shadows */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
    /* REMOVED: mask-image to eliminate edge darkening/fade */
}
.monthStripContainer::-webkit-scrollbar {
    display: none;
}

.monthGroup {
    display: flex;
    gap: 0.8rem;
    padding: 0 0.5rem; /* Slight padding for visual balance */
    min-width: max-content;
}

/* New class for mobile action buttons to fix width and layout */
.actionButtonMobile {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.8rem;
    width: 100%; /* Make them take full available width in the group */
    white-space: nowrap; /* Prevent text wrapping */
    font-family: var(--font-main);
    padding: 1.2rem;
}

/* Hide the strip on mobile, show popover logic instead */
@media (max-width: 768px) {
    .monthStripContainer {
        display: none;
    }
    .searchYearRow {
        flex-direction: column; /* Stack on very small screens if needed, or keep row */
        gap: 1rem;
    }
    .yearInputWrapper {
        width: 100%; /* Full width on mobile */
    }
}




--- END OF FILE components/releases/ReleasesControlBar.module.css ---

================================================================================

--- START OF FILE components/releases/ReleasesControlBar.tsx ---

// components/releases/ReleasesControlBar.tsx
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { usePopoverManager } from '@/hooks/usePopoverManager';
import FilterContainer from '@/components/filters/ui/FilterContainer';
import FilterGroup from '@/components/filters/ui/FilterGroup';
import PopoverTriggerButton from '@/components/filters/ui/PopoverTriggerButton';
import FilterToggleButton from '@/components/filters/ui/FilterToggleButton';
import YearFilterPopover from './YearFilterPopover';
import MonthFilterPopover from './MonthFilterPopover';
import { PlatformIcons } from '@/components/TimelineCard'; 
import styles from '@/components/filters/Filters.module.css'; // Standard Site Styles
import releaseStyles from './ReleasesControlBar.module.css'; // Layout specific overrides

// --- ICONS ---
const ArrowDownIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19"></line>
        <polyline points="19 12 12 19 5 12"></polyline>
    </svg>
);

const AddToListStrokeIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <path d="M3.5 9V20C3.5 21.1046 4.39543 22 5.5 22H18.5C19.6046 22 20.5 21.1046 20.5 20V4C20.5 2.89543 19.6046 2 18.5 2H12"></path>
        <path d="M13.5 17H17.5"></path>
        <path d="M13.5 7H17.5"></path>
        <path d="M13.5 12H17.5"></path>
        <path d="M6.5 16.5L8 18L11 14"></path>
        <path d="M10 5H3.5M10 5L7.08333 2M10 5L7.08333 8"></path>
    </svg>
);

const AddToListSolidIcon = () => (
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
        <path fillRule="evenodd" clipRule="evenodd" d="M8.05033 1.55292C7.66534 1.15694 7.03224 1.14802 6.63626 1.53301C6.24027 1.91799 6.23135 2.55109 6.61634 2.94708L7.88307 4.25H3.75C3.19772 4.25 2.75 4.69772 2.75 5.25C2.75 5.80229 3.19772 6.25 3.75 6.25H7.88307L6.61634 7.55292C6.23135 7.94891 6.24027 8.58201 6.63625 8.967C7.03224 9.35198 7.66534 9.34306 8.05033 8.94708L10.967 5.94708C11.3443 5.55896 11.3443 4.94104 10.967 4.55292L8.05033 1.55292ZM2.75 20V7.5H5.21144C4.92844 8.30226 5.11492 9.23131 5.76491 9.86324C6.65587 10.7295 8.08035 10.7094 8.94657 9.81843L11.8632 6.81843C12.7123 5.94516 12.7123 4.55485 11.8632 3.68158L9.49921 1.25H18.5C20.0188 1.25 21.25 2.48122 21.25 4V20C21.25 21.5188 20.0188 22.75 18.5 22.75H5.5C3.98122 22.75 2.75 21.5188 2.75 20ZM13.5 16.25C13.0858 16.25 12.75 16.5858 12.75 17C12.75 17.4142 13.0858 17.75 13.5 17.75H17.5C17.9142 17.75 18.25 17.4142 18.25 17C18.25 16.5858 17.9142 16.25 17.5 16.25H13.5ZM12.75 7C12.75 6.58579 13.0858 6.25 13.5 6.25H17.5C17.9142 6.25 18.25 6.58579 18.25 7C18.25 7.41421 17.9142 7.75 17.5 7.75H13.5C13.0858 7.75 12.75 7.41421 12.75 7ZM13.5 11.25C13.0858 11.25 12.75 11.5858 12.75 12C12.75 12.4142 13.0858 12.75 13.5 12.75H17.5C17.9142 12.75 18.25 12.4142 18.25 12C18.25 11.5858 17.9142 11.25 17.5 11.25H13.5ZM11.45 13.4C11.7814 13.6486 11.8485 14.1187 11.6 14.45L8.6 18.45C8.46955 18.624 8.27004 18.7327 8.05317 18.7482C7.8363 18.7636 7.62341 18.6841 7.46967 18.5304L5.96967 17.0304C5.67678 16.7375 5.67678 16.2626 5.96967 15.9697C6.26256 15.6768 6.73744 15.6768 7.03033 15.9697L7.91885 16.8582L10.4 13.55C10.6485 13.2187 11.1186 13.1515 11.45 13.4Z" fill="currentColor"></path>
    </svg>
);

const ARABIC_MONTHS = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
const PLATFORMS = ['PC', 'PlayStation', 'Xbox', 'Switch'];

interface ReleasesControlBarProps {
    searchTerm: string;
    onSearchChange: (val: string) => void;
    showWishlistOnly: boolean;
    onToggleWishlist: () => void;
    onJumpToNow: () => void;
    isAuthenticated: boolean;
    selectedYear: number | 'TBA';
    onYearChange: (year: number | 'TBA') => void;
    selectedMonth: number | 'all';
    onMonthChange: (month: number | 'all') => void;
    selectedPlatform: string | 'all';
    onPlatformChange: (platform: string | 'all') => void;
    availableYears: number[];
}

export default function ReleasesControlBar({ 
    searchTerm, onSearchChange, 
    showWishlistOnly, onToggleWishlist, onJumpToNow, isAuthenticated,
    selectedYear, onYearChange,
    selectedMonth, onMonthChange,
    selectedPlatform, onPlatformChange,
    availableYears
}: ReleasesControlBarProps) {
    
    const { popoverRef, openPopover, togglePopover, closePopover } = usePopoverManager();
    const [isMobile, setIsMobile] = useState(false);
    const [isMobileFiltersOpen, setIsMobileFiltersOpen] = useState(false);
    const monthStripRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const checkMobile = () => setIsMobile(window.innerWidth <= 768);
        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);
    
    // Auto-scroll the month strip to active month on Desktop
    useEffect(() => {
        if (!isMobile && selectedMonth !== 'all' && typeof selectedMonth === 'number' && monthStripRef.current) {
            const button = monthStripRef.current.children[selectedMonth + 1] as HTMLElement; // +1 for "All" button
            if (button) {
                button.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
        }
    }, [selectedMonth, isMobile]);

    const handleJump = () => {
        onJumpToNow();
        const now = new Date();
        const monthIdx = now.getMonth();
        const el = document.getElementById(`month-header-${monthIdx}`);
        if (el) {
            const rect = el.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const offset = 180; 
            const targetY = rect.top + scrollTop - offset;
            
            window.scrollTo({
                top: targetY,
                behavior: 'smooth'
            });
        }
    };

    const hasActiveFilters = !!(selectedMonth !== 'all' || selectedPlatform !== 'all' || searchTerm || showWishlistOnly);

    // --- Desktop Layout ---
    const desktopFilters = (
        <div className={styles.desktopFilters}>
            
            {/* ROW 1: Search + Year */}
            <div className={releaseStyles.searchYearRow}>
                <div className={releaseStyles.searchInputWrapper}>
                    <input 
                        type="search" 
                        placeholder="ابحث عن لعبة..." 
                        className={styles.searchInput} 
                        value={searchTerm} 
                        onChange={(e) => onSearchChange(e.target.value)} 
                        style={{ width: '100%', margin: 0 }}
                    />
                </div>
                <div className={releaseStyles.yearInputWrapper} style={{ position: 'relative' }}>
                    <PopoverTriggerButton 
                        label={`${selectedYear}`} 
                        isActive={true} 
                        onClick={() => togglePopover('year')} 
                        layoutId="year-highlight"
                        className={styles.filterButton}
                    />
                    <AnimatePresence>
                        {openPopover === 'year' && (
                            <>
                                <div className={styles.popoverBackdrop} onClick={closePopover}></div>
                                <YearFilterPopover 
                                    availableYears={availableYears} 
                                    selectedYear={selectedYear} 
                                    onSelect={(y) => { onYearChange(y); closePopover(); }} 
                                    onClose={closePopover} 
                                />
                            </>
                        )}
                    </AnimatePresence>
                </div>
            </div>

            {/* ROW 2: Platform + Actions */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <FilterGroup label="المنصة:">
                    <motion.button 
                        onClick={() => onPlatformChange('all')}
                        className={`${styles.filterButton} ${selectedPlatform === 'all' ? styles.active : ''}`}
                    >
                        الكل
                        {selectedPlatform === 'all' && <motion.div layoutId="plat-highlight" className={styles.filterHighlight} />}
                    </motion.button>
                    
                    {PLATFORMS.map(p => {
                        const isActive = selectedPlatform === p;
                        const Icon = PlatformIcons[p];
                        return (
                            <motion.button 
                                key={p} 
                                onClick={() => onPlatformChange(p)} 
                                className={`${styles.filterButton} ${isActive ? styles.active : ''}`}
                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                            >
                                {isActive && <motion.div layoutId="plat-highlight" className={styles.filterHighlight} />}
                                <span>{p === 'PlayStation' ? 'PS5' : p}</span>
                                <Icon width={16} height={16} />
                            </motion.button>
                        );
                    })}
                </FilterGroup>

                <FilterGroup>
                    <motion.button 
                        onClick={handleJump} 
                        className={styles.filterButton}
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                        style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                    >
                        <span>الإنتقال لهذا الشهر</span>
                        <div style={{ transform: 'translateY(2px)' }}>
                            <ArrowDownIcon />
                        </div>
                    </motion.button>

                    <motion.button 
                        onClick={onToggleWishlist}
                        className={`${styles.filterButton} ${showWishlistOnly ? styles.active : ''}`}
                        disabled={!isAuthenticated}
                        title={!isAuthenticated ? 'سجّل الدخول لتستخدم قائمة الأمنيات' : ''}
                        style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                    >
                        {showWishlistOnly && <motion.div layoutId="wishlist-highlight" className={styles.filterHighlight} />}
                        <span>قائمة الأمنيات</span>
                        <div style={{ transform: 'translateY(2px)' }}>
                            {showWishlistOnly ? <AddToListSolidIcon /> : <AddToListStrokeIcon />}
                        </div>
                    </motion.button>
                </FilterGroup>
            </div>

            {/* ROW 3: Months Strip (Only show if not TBA) */}
            {selectedYear !== 'TBA' && (
                <FilterGroup label="الأشهر:">
                    <div className={releaseStyles.monthStripContainer} ref={monthStripRef}>
                        <div className={releaseStyles.monthGroup}>
                            <motion.button 
                                className={`${styles.filterButton} ${selectedMonth === 'all' ? styles.active : ''}`}
                                onClick={() => onMonthChange('all')}
                            >
                                الكل
                                {selectedMonth === 'all' && <motion.div layoutId="month-highlight" className={styles.filterHighlight} />}
                            </motion.button>
                            
                            {ARABIC_MONTHS.map((month, idx) => (
                                <motion.button 
                                    key={idx}
                                    onClick={() => onMonthChange(idx)}
                                    className={`${styles.filterButton} ${selectedMonth === idx ? styles.active : ''}`}
                                >
                                    {month}
                                    {selectedMonth === idx && <motion.div layoutId="month-highlight" className={styles.filterHighlight} />}
                                </motion.button>
                            ))}
                        </div>
                    </div>
                </FilterGroup>
            )}
        </div>
    );

    // --- Mobile Layout ---
    const mobileFilters = (
        <>
            <div className={styles.mobileTriggerBar}>
                 <input 
                    type="search" 
                    placeholder="ابحث..." 
                    className={styles.searchInput} 
                    value={searchTerm} 
                    onChange={(e) => onSearchChange(e.target.value)} 
                />
                <FilterToggleButton onClick={() => setIsMobileFiltersOpen(prev => !prev)} hasActiveFilters={hasActiveFilters} />
            </div>

            <AnimatePresence>
                {isMobileFiltersOpen && (
                     <motion.div
                        className={styles.collapsibleFilterContent}
                        initial={{ scaleY: 0, opacity: 0 }}
                        animate={{ scaleY: 1, opacity: 1 }}
                        exit={{ scaleY: 0, opacity: 0 }}
                        transition={{ duration: 0.3, ease: 'easeOut' }}
                    >
                         <FilterGroup label="الزمن:">
                            {/* Mobile Year Popover */}
                            <div style={{ position: 'relative' }}>
                                <PopoverTriggerButton 
                                    label={`السنة: ${selectedYear}`} 
                                    isActive={true} 
                                    onClick={() => togglePopover('year')} 
                                    layoutId="mobile-year"
                                />
                                <AnimatePresence>{openPopover === 'year' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><YearFilterPopover availableYears={availableYears} selectedYear={selectedYear} onSelect={(y) => { onYearChange(y); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                            </div>

                            {/* Mobile Month Popover (Only if not TBA) */}
                            {selectedYear !== 'TBA' && (
                                <div style={{ position: 'relative' }}>
                                    <PopoverTriggerButton 
                                        label={selectedMonth === 'all' ? 'الشهر: الكل' : `الشهر: ${ARABIC_MONTHS[selectedMonth]}`} 
                                        isActive={selectedMonth !== 'all'} 
                                        onClick={() => togglePopover('month')} 
                                        layoutId="mobile-month"
                                    />
                                    <AnimatePresence>{openPopover === 'month' && <><div className={styles.popoverBackdrop} onClick={closePopover}></div><MonthFilterPopover selectedMonth={selectedMonth} onSelect={(m) => { onMonthChange(m); closePopover(); }} onClose={closePopover} /></>}</AnimatePresence>
                                </div>
                            )}
                        </FilterGroup>

                        <FilterGroup label="المنصة:">
                             <motion.button onClick={() => onPlatformChange('all')} className={`${styles.filterButton} ${selectedPlatform === 'all' ? styles.active : ''}`}>
                                الكل
                                {selectedPlatform === 'all' && <motion.div layoutId="mobile-plat-hl" className={styles.filterHighlight} />}
                            </motion.button>
                             {PLATFORMS.map(p => {
                                const Icon = PlatformIcons[p];
                                return (
                                    <motion.button key={p} onClick={() => onPlatformChange(p)} className={`${styles.filterButton} ${selectedPlatform === p ? styles.active : ''}`} style={{display:'flex',gap:'0.5rem',alignItems:'center'}}>
                                        {selectedPlatform === p && <motion.div layoutId="mobile-plat-hl" className={styles.filterHighlight} />}
                                        <span>{p === 'PlayStation' ? 'PS5' : p}</span>
                                        <Icon width={16} height={16}/>
                                    </motion.button>
                                );
                            })}
                        </FilterGroup>

                        <FilterGroup label="إجراءات:">
                            <motion.button 
                                onClick={() => { handleJump(); setIsMobileFiltersOpen(false); }} 
                                className={`${styles.filterButton} ${releaseStyles.actionButtonMobile}`}
                            >
                                <span>الإنتقال لهذا الشهر</span>
                                <div style={{ transform: 'translateY(2px)' }}><ArrowDownIcon /></div>
                            </motion.button>
                            <motion.button 
                                onClick={onToggleWishlist} 
                                disabled={!isAuthenticated} 
                                className={`${styles.filterButton} ${releaseStyles.actionButtonMobile} ${showWishlistOnly ? styles.active : ''}`}
                            >
                                {showWishlistOnly && <motion.div layoutId="mobile-wish-hl" className={styles.filterHighlight} />}
                                <span>قائمة الأمنيات</span>
                                <div style={{ transform: 'translateY(2px)' }}>
                                    {showWishlistOnly ? <AddToListSolidIcon /> : <AddToListStrokeIcon />}
                                </div>
                            </motion.button>
                        </FilterGroup>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );

    return (
        <FilterContainer ref={popoverRef}>
            {isMobile ? mobileFilters : desktopFilters}
        </FilterContainer>
    );
}




--- END OF FILE components/releases/ReleasesControlBar.tsx ---

================================================================================

--- START OF FILE components/releases/ReleasesCredits.module.css ---

/* components/releases/ReleasesCredits.module.css */

.creditsContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    width: 100%;
    position: relative;
    z-index: 50; /* High z-index to ensure clickability */
    margin-bottom: 1.5rem;
    pointer-events: none; /* Let clicks pass through container gaps */
    
    /* FIX: Flickering Stability */
    transform: translateZ(0);
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}

@media (min-width: 769px) {
    .creditsContainer {
        justify-content: flex-start;
    }
}

/* Styled to match the ArticleCard/NewsGridCard capsule EXACTLY */
.creditsCapsule {
    display: inline-flex;
    align-items: center;
    gap: 0.8rem;
    background: rgba(10, 11, 15, 0.8);
    border: 1px solid rgba(255,255,255,0.1);
    padding: 0;
    border-radius: 999px;
    height: 32px;
    backdrop-filter: blur(8px);
    transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    padding-left: 1.2rem;
    pointer-events: auto; /* Enable clicks on the capsule */
    cursor: default;
    
    /* FIX: Stability */
    transform: translateZ(0);
}

:global(body.no-glass) .creditsCapsule {
    backdrop-filter: none !important;
    background-color: #0A0B0F !important;
}

/* Mobile Opt: Kill Blur */
@media (max-width: 768px) {
    .creditsCapsule {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        background-color: rgba(10, 11, 15, 0.95);
    }
}

@media (hover: hover) {
    .creditsCapsule:hover {
        background-color: var(--accent);
        border-color: var(--accent);
        box-shadow: 0 0 15px color-mix(in srgb, var(--accent) 30%, transparent);
        transform: translateY(-4px) scale(1.05);
        z-index: 100;
    }
    /* Invert colors on hover (Dark Mode -> Icon becomes Black) */
    .creditsCapsule:hover .capsuleIcon {
        background-color: #000;
        color: var(--accent);
        box-shadow: none;
    }
    .creditsCapsule:hover .label,
    .creditsCapsule:hover .creatorName,
    .creditsCapsule:hover .creatorLink,
    .creditsCapsule:hover .separator {
        color: #000;
    }
}

.capsuleIcon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: var(--accent);
    color: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: color 0.4s ease, background-color 0.4s ease, box-shadow 0.4s ease;
}

.capsuleIcon svg {
    width: 16px;
    height: 16px;
}

.namesWrapper {
    display: flex;
    align-items: center;
    font-size: 1.2rem;
    font-weight: 700;
    white-space: nowrap;
    color: #fff;
    padding-right: 0.5rem;
}

.label {
    color: var(--text-secondary);
    margin-left: 0.4rem;
    transition: color 0.4s ease;
}

.creatorLink {
    color: #fff;
    text-decoration: none;
    transition: color 0.4s ease;
    position: relative;
    z-index: 10; /* Ensure link sits above capsule base */
}
.creatorLink:hover {
    text-decoration: underline;
}

.creatorName {
    color: #fff;
    transition: color 0.4s ease;
}

.separator {
    color: var(--text-secondary);
    margin: 0 0.3rem;
    transition: color 0.4s ease;
}

/* Edit Button */
.editButton {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    pointer-events: auto;
}

@media (hover: hover) {
    .editButton:hover {
        border-color: var(--accent);
        color: var(--accent);
        background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    }
}

/* Modal Styles */
.modalHeader { margin-bottom: 2rem; text-align: center; }
.modalTitle { font-size: 2rem; font-family: var(--font-heading); margin: 0; }
.searchContainer { margin-bottom: 1.5rem; }
.resultsList { max-height: 250px; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem; border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem; background: var(--bg-primary); }
.resultItem { display: flex; align-items: center; justify-content: space-between; padding: 0.8rem; background: var(--bg-secondary); border-radius: 6px; cursor: pointer; transition: background 0.2s; }
.resultItem:hover { background: color-mix(in srgb, var(--accent) 10%, transparent); }
.resultUser { display: flex; align-items: center; gap: 1rem; }
.addLabel { color: var(--accent); font-size: 1.8rem; line-height: 0; }
.selectedList { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 2rem; padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 1px solid var(--border-color); }
.selectedChip { display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 1rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 999px; font-size: 1.3rem; }
.removeBtn { background: none; border: none; color: #DC2626; cursor: pointer; padding: 0; display: flex; align-items: center; }

@media (max-width: 768px) {
    .creditsContainer {
        margin-top: 0;
        margin-bottom: 2rem;
    }
}
/* --- Light Mode Overrides (General) --- */
:global([data-theme="light"]) .creditsCapsule {
    background-color: rgba(255, 255, 255, 0.9);
    border-color: rgba(0, 0, 0, 0.1);
    box-shadow: 0 2px 10px rgba(0,0,0,0.05);
}
:global([data-theme="light"]) .creatorName,
:global([data-theme="light"]) .label,
:global([data-theme="light"]) .separator,
:global([data-theme="light"]) .creatorLink {
    color: var(--text-primary);
}
:global([data-theme="light"]) .capsuleIcon {
    background-color: var(--accent);
    color: #fff;
}

/* --- LIGHT MODE + NO GLASS SPECIAL (Requested Fix) --- */
:global([data-theme="light"] body.no-glass) .creditsCapsule {
    background-color: #ffffff !important;
    border-color: rgba(0,0,0,0.1) !important;
}

/* Idle State: Author Name Black */
:global([data-theme="light"] body.no-glass) .creatorName,
:global([data-theme="light"] body.no-glass) .label,
:global([data-theme="light"] body.no-glass) .separator,
:global([data-theme="light"] body.no-glass) .creatorLink {
    color: #000000 !important;
}

/* Hover State: Pill Cyan, Name White, Circle White, Pen Cyan */
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover .creatorName,
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover .label,
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover .separator,
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover .creatorLink {
    color: #ffffff !important;
}
:global([data-theme="light"] body.no-glass) .creditsCapsule:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

/* Default Hover (for Glass mode or Dark mode if not overridden above) */
:global([data-theme="light"]) .creditsCapsule:hover {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 5px 20px color-mix(in srgb, var(--accent) 40%, transparent);
}
:global([data-theme="light"]) .creditsCapsule:hover .creatorName,
:global([data-theme="light"]) .creditsCapsule:hover .label,
:global([data-theme="light"]) .creditsCapsule:hover .separator,
:global([data-theme="light"]) .creditsCapsule:hover .creatorLink {
    color: #fff !important;
}
:global([data-theme="light"]) .creditsCapsule:hover .capsuleIcon {
    background-color: #fff !important;
    color: var(--accent) !important;
}

--- END OF FILE components/releases/ReleasesCredits.module.css ---

================================================================================

--- START OF FILE components/releases/ReleasesCredits.tsx ---

// components/releases/ReleasesCredits.tsx
'use client';

import { useState, useTransition, useEffect, useMemo } from 'react';
import { useSession } from 'next-auth/react';
import { motion, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import { PenEdit02Icon } from '@/components/icons/index';
import { updateReleasesCreditsAction, getAllStaffAction } from '@/app/actions/homepageActions';
import { useToast } from '@/lib/toastStore';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import styles from './ReleasesCredits.module.css';
import { sanityLoader } from '@/lib/sanity.loader';
import Image from 'next/image';
import { urlFor } from '@/sanity/lib/image';
import KineticLink from '@/components/kinetic/KineticLink'; // IMPORT

type Creator = {
    _id: string;
    name: string;
    username?: string;
    image?: any;
};

const EditIcon = () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
    </svg>
);

export default function ReleasesCredits({ initialCredits }: { initialCredits: Creator[] }) {
    const { data: session } = useSession();
    const userRoles = (session?.user as any)?.roles || [];
    const canEdit = userRoles.includes('ADMIN') || userRoles.includes('DIRECTOR');
    
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [credits, setCredits] = useState<Creator[]>(initialCredits || []);
    
    const [searchQuery, setSearchQuery] = useState('');
    const [allStaff, setAllStaff] = useState<Creator[]>([]);
    const [hasFetchedStaff, setHasFetchedStaff] = useState(false);
    
    const [isSaving, startSave] = useTransition();
    const [isFetching, startFetch] = useTransition();
    const toast = useToast();

    useEffect(() => {
        if (isModalOpen && !hasFetchedStaff) {
            startFetch(async () => {
                const staff = await getAllStaffAction();
                setAllStaff(staff);
                setHasFetchedStaff(true);
            });
        }
    }, [isModalOpen, hasFetchedStaff]);

    const filteredStaff = useMemo(() => {
        if (!searchQuery) return allStaff;
        const lowerQ = searchQuery.toLowerCase();
        return allStaff.filter(s => s.name.toLowerCase().includes(lowerQ));
    }, [allStaff, searchQuery]);

    const handleAddCreator = (creator: Creator) => {
        if (!credits.find(c => c._id === creator._id)) {
            setCredits([...credits, creator]);
        }
        setSearchQuery('');
    };

    const handleRemoveCreator = (id: string) => {
        setCredits(credits.filter(c => c._id !== id));
    };

    const handleSave = () => {
        startSave(async () => {
            const ids = credits.map(c => c._id);
            const result = await updateReleasesCreditsAction(ids);
            if (result.success) {
                toast.success(result.message);
                setIsModalOpen(false);
            } else {
                toast.error(result.message);
            }
        });
    };
    
    if (credits.length === 0 && !canEdit) return null;

    return (
        <>
            <motion.div 
                className={styles.creditsContainer}
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.3 }}
            >
                <div className={styles.creditsCapsule}>
                    <div className={styles.capsuleIcon}>
                        <PenEdit02Icon style={{ width: 14, height: 14 }} />
                    </div>
                    
                    <div className={styles.namesWrapper}>
                        <span className={styles.label}>إعداد:</span>
                        {credits.map((creator, index) => {
                            const profileLink = creator.username ? `/creators/${creator.username}` : null;
                            const creatorData = { name: creator.name, image: creator.image };

                            return (
                                <span key={creator._id} style={{ display: 'inline-flex', alignItems: 'center' }}>
                                    {index > 0 && <span className={styles.separator}>،</span>}
                                    {profileLink ? (
                                        <KineticLink 
                                            href={profileLink} 
                                            slug={creator.username!}
                                            type="creators"
                                            className={`${styles.creatorLink} no-underline`} 
                                            onClick={(e) => e.stopPropagation()} 
                                            // PASS DATA
                                            preloadedData={creatorData}
                                        >
                                            {creator.name}
                                        </KineticLink>
                                    ) : (
                                        <span className={styles.creatorName}>{creator.name}</span>
                                    )}
                                </span>
                            );
                        })}
                        {credits.length === 0 && <span className={styles.separator}>--</span>}
                    </div>
                </div>

                {canEdit && (
                    <button onClick={() => setIsModalOpen(true)} className={styles.editButton} title="تعديل القائمة">
                        <EditIcon />
                    </button>
                )}
            </motion.div>

            <AnimatePresence>
                {isModalOpen && (
                    <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} style={{ maxWidth: '500px' }}>
                        <div className={styles.modalHeader}>
                            <h3 className={styles.modalTitle}>إدارة فريق التحرير</h3>
                            <p style={{ color: 'var(--text-secondary)' }}>اختر الأعضاء المسؤولين عن هذا القسم.</p>
                        </div>

                        <div className={styles.selectedList}>
                            {credits.map(c => (
                                <div key={c._id} className={styles.selectedChip}>
                                    <span>{c.name}</span>
                                    <button onClick={() => handleRemoveCreator(c._id)} className={styles.removeBtn}>
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                                    </button>
                                </div>
                            ))}
                            {credits.length === 0 && <p style={{color:'#666', fontSize:'1.2rem', margin:'auto'}}>القائمة فارغة.</p>}
                        </div>

                        <div className={styles.searchContainer}>
                            <input 
                                type="text" 
                                placeholder="ابحث عن عضو..." 
                                className="profile-input" 
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                autoFocus
                            />
                        </div>

                        <div className={styles.resultsList}>
                            {isFetching ? (
                                <div className="spinner" style={{margin:'1rem auto', width:'20px', height:'20px'}} />
                            ) : (
                                filteredStaff.map(user => {
                                    const isSelected = credits.some(c => c._id === user._id);
                                    if (isSelected) return null;
                                    
                                    const imgUrl = user.image 
                                        ? urlFor(user.image).width(48).height(48).fit('crop').url() 
                                        : '/default-avatar.svg';

                                    return (
                                        <div key={user._id} className={styles.resultItem} onClick={() => handleAddCreator(user)}>
                                            <div className={styles.resultUser}>
                                                <Image 
                                                    loader={sanityLoader}
                                                    src={imgUrl} 
                                                    alt={user.name} 
                                                    width={24} height={24} 
                                                    style={{borderRadius:'50%', objectFit:'cover'}} 
                                                />
                                                <span>{user.name}</span>
                                            </div>
                                            <span className={styles.addLabel}>+</span>
                                        </div>
                                    );
                                })
                            )}
                            {!isFetching && filteredStaff.length === 0 && (
                                <p style={{textAlign:'center', color:'#666', marginTop:'1rem'}}>لا نتائج.</p>
                            )}
                        </div>

                        <div className={modalStyles.modalActions} style={{ marginTop: '2rem' }}>
                            <button onClick={() => setIsModalOpen(false)} className="outline-button">إلغاء</button>
                            <button onClick={handleSave} className="primary-button" disabled={isSaving}>
                                {isSaving ? 'جارٍ الحفظ...' : 'حفظ التغييرات'}
                            </button>
                        </div>
                    </Modal>
                )}
            </AnimatePresence>
        </>
    );
}

--- END OF FILE components/releases/ReleasesCredits.tsx ---

================================================================================

--- START OF FILE components/releases/TimelineCredits.module.css ---




--- END OF FILE components/releases/TimelineCredits.module.css ---

================================================================================

--- START OF FILE components/releases/TimelineCredits.tsx ---




--- END OF FILE components/releases/TimelineCredits.tsx ---

================================================================================

--- START OF FILE components/releases/YearFilterPopover.tsx ---

// components/releases/YearFilterPopover.tsx
'use client';
import { motion } from 'framer-motion';
import styles from '@/components/filters/Filters.module.css';

const popoverVariants = { hidden: { opacity: 0, y: -10, scale: 0.95 }, visible: { opacity: 1, y: 0, scale: 1 }, exit: { opacity: 0, y: -10, scale: 0.95 }, };

export default function YearFilterPopover({ 
    availableYears, 
    selectedYear, 
    onSelect, 
    onClose 
}: { 
    availableYears: number[], 
    selectedYear: number | 'TBA', 
    onSelect: (year: number | 'TBA') => void, 
    onClose: () => void 
}) {
  return (
    <motion.div 
        className={styles.filterPopover} 
        style={{ width: '180px', maxHeight: '300px' }} 
        variants={popoverVariants} 
        initial="hidden" 
        animate="visible" 
        exit="exit" 
        onClick={(e) => e.stopPropagation()}
    >
      <div className={styles.popoverResultsList}>
        {/* ADD TBA OPTION */}
        <motion.button 
            className={`${styles.popoverItemButton} ${selectedYear === 'TBA' ? styles.selected : ''}`} 
            onClick={() => { onSelect('TBA'); onClose(); }}
        >
            يُعلن لاحقاً
        </motion.button>
        
        {availableYears.map(year => (
          <motion.button 
            key={year} 
            className={`${styles.popoverItemButton} ${selectedYear === year ? styles.selected : ''}`} 
            onClick={() => { onSelect(year); onClose(); }}
          >
            {year}
          </motion.button>
        ))}
      </div>
    </motion.div>
  );
}




--- END OF FILE components/releases/YearFilterPopover.tsx ---

================================================================================

--- START OF FILE components/security/BanEnforcer.module.css ---

/* components/security/BanEnforcer.module.css */

.banOverlay {
    position: fixed;
    inset: 0;
    z-index: 99999; /* Highest possible priority */
    background-color: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(20px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    overflow: hidden;
}

.banCard {
    background-color: #0f0f0f;
    border: 1px solid #333;
    border-right: 4px solid #DC2626; /* Red accent for "Danger/Ban" */
    padding: 4rem;
    max-width: 500px;
    width: 100%;
    text-align: center;
    border-radius: 8px;
    box-shadow: 0 0 50px rgba(220, 38, 38, 0.2);
}

.banIcon {
    color: #DC2626;
    width: 64px;
    height: 64px;
    margin-bottom: 2rem;
}

.banTitle {
    font-family: var(--font-heading);
    font-size: 3.2rem;
    color: #fff;
    margin: 0 0 1.5rem 0;
}

.banMessage {
    font-family: var(--font-main);
    font-size: 1.6rem;
    color: #a1a1aa;
    margin-bottom: 3rem;
    line-height: 1.6;
}

.reasonContainer {
    background-color: rgba(220, 38, 38, 0.1);
    border: 1px solid rgba(220, 38, 38, 0.3);
    padding: 1.5rem;
    border-radius: 6px;
    text-align: right;
}

.reasonLabel {
    display: block;
    font-family: var(--font-ui);
    font-weight: 700;
    color: #DC2626;
    margin-bottom: 0.5rem;
    font-size: 1.3rem;
}

.reasonText {
    margin: 0;
    font-family: var(--font-main);
    color: #fff;
    font-size: 1.5rem;
}




--- END OF FILE components/security/BanEnforcer.module.css ---

================================================================================

--- START OF FILE components/security/BanEnforcer.tsx ---

// components/security/BanEnforcer.tsx
'use client';

import { useEffect } from 'react';
import { signOut } from 'next-auth/react';
import styles from './BanEnforcer.module.css';

const LockIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={styles.banIcon}>
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
    </svg>
);

interface BanEnforcerProps {
    isBanned: boolean;
    reason?: string | null;
}

export default function BanEnforcer({ isBanned, reason }: BanEnforcerProps) {
    
    // Simple effect to lock the body scroll if the user is banned upon page load
    useEffect(() => {
        if (isBanned) {
            document.body.style.overflow = 'hidden';
        } else {
            document.body.style.overflow = '';
        }
        
        return () => {
            document.body.style.overflow = '';
        };
    }, [isBanned]);

    if (!isBanned) return null;

    return (
        <div className={styles.banOverlay}>
            <div className={styles.banCard}>
                <LockIcon />
                <h1 className={styles.banTitle}>حساب محظور</h1>
                <p className={styles.banMessage}>
                    تم تعليق وصولك إلى منصة EternalGames. لا يمكنك التفاعل أو تصفح المحتوى الخاص أثناء سريان هذا الحظر.
                </p>
                
                {reason && (
                    <div className={styles.reasonContainer}>
                        <span className={styles.reasonLabel}>سبب الحظر:</span>
                        <p className={styles.reasonText}>{reason}</p>
                    </div>
                )}

                <button 
                    onClick={() => signOut({ callbackUrl: '/' })}
                    className="outline-button"
                    style={{ marginTop: '3rem', width: '100%', borderColor: '#333', color: '#888' }}
                >
                    تسجيل الخروج
                </button>
            </div>
        </div>
    );
}




--- END OF FILE components/security/BanEnforcer.tsx ---

================================================================================

--- START OF FILE components/seo/AboutPageJsonLd.tsx ---

// components/seo/AboutPageJsonLd.tsx
import React from 'react';

export default function AboutPageJsonLd() {
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  
  const schema = {
    "@context": "https://schema.org",
    "@type": "AboutPage",
    "mainEntity": {
      "@type": "Organization",
      "name": "EternalGames",
      "url": siteUrl,
      "logo": {
          "@type": "ImageObject",
          "url": `${siteUrl}/icon.png`
      },
      "foundingDate": "2023",
      "description": "منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار.",
      "contactPoint": {
        "@type": "ContactPoint",
        "contactType": "editorial",
        "email": "me@EternalGamesWeb.com"
      }
    }
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  );
}

--- END OF FILE components/seo/AboutPageJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/BreadcrumbJsonLd.tsx ---

import React from 'react';

type BreadcrumbItem = {
  name: string;
  item: string;
};

export default function BreadcrumbJsonLd({ items }: { items: BreadcrumbItem[] }) {
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgamesweb.com';

  const breadcrumbList = {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": items.map((item, index) => ({
      "@type": "ListItem",
      "position": index + 1,
      "name": item.name,
      "item": item.item.startsWith('http') ? item.item : `${siteUrl}${item.item}`
    }))
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(breadcrumbList) }}
    />
  );
}

--- END OF FILE components/seo/BreadcrumbJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/CarouselJsonLd.tsx ---

// components/seo/CarouselJsonLd.tsx
import React from 'react';

type CarouselItem = {
    url: string;
    position: number;
    name?: string;
    image?: string;
};

export default function CarouselJsonLd({ data }: { data: CarouselItem[] }) {
    const schema = {
        "@context": "https://schema.org",
        "@type": "ItemList",
        "itemListElement": data.map((item) => ({
            "@type": "ListItem",
            "position": item.position,
            "url": item.url,
            "name": item.name,
            "image": item.image
        }))
    };

    return (
        <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
        />
    );
}

--- END OF FILE components/seo/CarouselJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/CollectionPageJsonLd.tsx ---

// components/seo/CollectionPageJsonLd.tsx
import React from 'react';

type CollectionPageProps = {
    name: string;
    description: string;
    url: string;
    hasPart?: {
        headline: string;
        url: string;
        datePublished?: string;
    }[];
};

export default function CollectionPageJsonLd({ name, description, url, hasPart = [] }: CollectionPageProps) {
    const schema = {
        "@context": "https://schema.org",
        "@type": "CollectionPage",
        "name": name,
        "description": description,
        "url": url,
        "mainEntity": {
            "@type": "ItemList",
            "itemListElement": hasPart.map((item, index) => ({
                "@type": "ListItem",
                "position": index + 1,
                "url": item.url,
                "name": item.headline
            }))
        }
    };

    return (
        <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
        />
    );
}

--- END OF FILE components/seo/CollectionPageJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/FAQJsonLd.tsx ---

// components/seo/FAQJsonLd.tsx
import React from 'react';

type FAQItem = {
    question: string;
    answer: string;
};

export default function FAQJsonLd({ faqs }: { faqs: FAQItem[] }) {
    const schema = {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": faqs.map(faq => ({
            "@type": "Question",
            "name": faq.question,
            "acceptedAnswer": {
                "@type": "Answer",
                "text": faq.answer
            }
        }))
    };

    return (
        <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
        />
    );
}

--- END OF FILE components/seo/FAQJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/GoogleAnalytics.tsx ---

// components/seo/GoogleAnalytics.tsx
'use client';

import Script from 'next/script';
import { usePathname, useSearchParams } from 'next/navigation';
import { useEffect, Suspense } from 'react';
import { pageview } from '@/lib/gtm';

// We split the logic into an inner component.
// This inner component uses the hook that requires a Suspense boundary.
function GoogleAnalyticsInner({ gaId }: { gaId?: string }) {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  // Track pageviews on route change
  useEffect(() => {
    if (pathname) {
      pageview(pathname);
    }
  }, [pathname, searchParams]);

  if (!gaId) return null;

  return (
    <>
      <Script
        id="google-analytics-init"
        strategy="afterInteractive"
        dangerouslySetInnerHTML={{
          __html: `
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            
            // 1. Set default consent to 'denied' immediately
            gtag('consent', 'default', {
              'ad_storage': 'denied',
              'analytics_storage': 'denied',
              'ad_user_data': 'denied',
              'ad_personalization': 'denied'
            });

            gtag('js', new Date());
            gtag('config', '${gaId}', {
              page_path: window.location.pathname,
            });
          `,
        }}
      />
      <Script
        id="google-analytics-script"
        strategy="afterInteractive"
        src={`https://www.googletagmanager.com/gtag/js?id=${gaId}`}
      />
    </>
  );
}

// The default export now wraps the logic in Suspense.
// This satisfies the build requirement for static pages like /404.
export default function GoogleAnalytics(props: { gaId?: string }) {
  return (
    <Suspense fallback={null}>
      <GoogleAnalyticsInner {...props} />
    </Suspense>
  );
}

--- END OF FILE components/seo/GoogleAnalytics.tsx ---

================================================================================

--- START OF FILE components/seo/HomeJsonLd.tsx ---

// components/seo/HomeJsonLd.tsx
import React from 'react';

export default function HomeJsonLd() {
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  
  const schema = {
    "@context": "https://schema.org",
    "@graph": [
      {
        "@type": "WebSite",
        "name": "EternalGames",
        "url": siteUrl,
        "potentialAction": {
          "@type": "SearchAction",
          "target": {
            "@type": "EntryPoint",
            "urlTemplate": `${siteUrl}/api/search?q={search_term_string}`
          },
          "query-input": "required name=search_term_string"
        }
      },
      {
        "@type": "Organization",
        "name": "EternalGames",
        "url": siteUrl,
        "logo": {
            "@type": "ImageObject",
            "url": `${siteUrl}/icon.png`,
            "width": 512,
            "height": 512
        },
        "sameAs": [
          "https://x.com/1EternalGames",
          "https://www.youtube.com/@1eternalgames",
          "https://www.instagram.com/1eternalgames",
          "https://www.tiktok.com/@1eternalgames"
        ]
      }
    ]
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  );
}

--- END OF FILE components/seo/HomeJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/JsonLd.tsx ---

// components/seo/JsonLd.tsx
import React from 'react';

type JsonLdProps = {
  data: Record<string, any>;
};

export default function JsonLd({ data }: JsonLdProps) {
  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(data) }}
    />
  );
}

--- END OF FILE components/seo/JsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/OrganizationJsonLd.tsx ---

// components/seo/OrganizationJsonLd.tsx
import React from 'react';

export default function OrganizationJsonLd() {
  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://eternalgames.vercel.app';
  
  const schema = {
    "@context": "https://schema.org",
    "@type": "Organization",
    "name": "EternalGames",
    "url": siteUrl,
    "logo": {
        "@type": "ImageObject",
        "url": `${siteUrl}/icon.png`,
        "width": 512,
        "height": 512
    },
    "sameAs": [
      "https://x.com/1EternalGames",
      "https://www.youtube.com/@1eternalgames",
      "https://www.instagram.com/1eternalgames",
      "https://www.tiktok.com/@1eternalgames"
    ],
    "description": "منصة محتوى متخصصة في عالم الألعاب، تقدم مراجعات عميقة، مقالات تحليلية، وآخر الأخبار."
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  );
}

--- END OF FILE components/seo/OrganizationJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/ProfilePageJsonLd.tsx ---

// components/seo/ProfilePageJsonLd.tsx
import React from 'react';

type ProfilePageProps = {
  name: string;
  username: string;
  image?: string;
  description?: string;
  url: string;
  sameAs?: string[];
  mainEntityOfPage?: string;
};

export default function ProfilePageJsonLd({ 
  name, 
  username, 
  image, 
  description, 
  url, 
  sameAs = [],
  mainEntityOfPage 
}: ProfilePageProps) {
  const schema = {
    "@context": "https://schema.org",
    "@type": "ProfilePage",
    "mainEntity": {
      "@type": "Person",
      "name": name,
      "alternateName": username,
      "identifier": username,
      "image": image,
      "description": description,
      "url": url,
      "sameAs": sameAs
    },
    "mainEntityOfPage": mainEntityOfPage
  };

  return (
    <script
      type="application/ld+json"
      dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
    />
  );
}

--- END OF FILE components/seo/ProfilePageJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/SpeakableJsonLd.tsx ---

// components/seo/SpeakableJsonLd.tsx
import React from 'react';

type SpeakableProps = {
    cssSelectors: string[];
};

export default function SpeakableJsonLd({ cssSelectors }: SpeakableProps) {
    const schema = {
        "@context": "https://schema.org",
        "@type": "SpeakableSpecification",
        "cssSelector": cssSelectors
    };

    return (
        <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
        />
    );
}

--- END OF FILE components/seo/SpeakableJsonLd.tsx ---

================================================================================

--- START OF FILE components/seo/VideoGameJsonLd.tsx ---

// components/seo/VideoGameJsonLd.tsx
import React from 'react';

type VideoGameProps = {
    name: string;
    description: string;
    image?: string;
    releaseDate?: string;
    genre?: string[];
    platforms?: string[];
    playMode?: string[]; // e.g., SinglePlayer, MultiPlayer
    publisher?: string;
    developer?: string;
};

export default function VideoGameJsonLd({ 
    name, 
    description, 
    image, 
    releaseDate, 
    genre, 
    platforms, 
    publisher, 
    developer 
}: VideoGameProps) {
    const schema = {
        "@context": "https://schema.org",
        "@type": "VideoGame",
        "name": name,
        "description": description,
        "image": image,
        "datePublished": releaseDate,
        "genre": genre,
        "operatingSystem": platforms,
        "publisher": publisher ? { "@type": "Organization", "name": publisher } : undefined,
        "author": developer ? { "@type": "Organization", "name": developer } : undefined,
        "applicationCategory": "Game"
    };

    return (
        <script
            type="application/ld+json"
            dangerouslySetInnerHTML={{ __html: JSON.stringify(schema) }}
        />
    );
}

--- END OF FILE components/seo/VideoGameJsonLd.tsx ---

================================================================================

--- START OF FILE components/studio/social/InstagramNewsCanvas.tsx ---

// components/studio/social/InstagramNewsCanvas.tsx
'use client';

import React, { useRef, useState, useEffect } from 'react';
import SocialNewsBodyEditor from './SocialNewsBodyEditor';
import SpaceBackground from './shared/SpaceBackground';

export interface TemplateData {
    titleTop: string;
    titleBottom: string;
    subTitle: string; 
    body: string;
    source: string;
    image: string; 
    type: 'official' | 'rumor' | 'leak';
    footerHandle: string;
    imageSettings?: { x: number; y: number; scale: number };
}

interface InstagramNewsCanvasProps {
    data: TemplateData;
    onDataChange: (newData: Partial<TemplateData>) => void;
    scale?: number;
    currentSlide: number;
    totalSlides: number;
}

const TYPE_CONFIG = {
    official: { color: '#00FFF0', label: 'رسمي', iconPath1: "M 12 0 L 24 7 L 24 21 L 12 28 L 0 21 L 0 7 Z", iconPath2: "M 7 14 L 11 18 L 17 10" },
    rumor: { color: '#F59E0B', label: 'إشاعة', iconPath1: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z", iconPath2: "" }, 
    leak: { color: '#DC2626', label: 'تسريب', iconPath1: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z", iconPath2: "" } 
};

const DEFAULT_ACCENT = '#00FFF0';

// --- Font Scaling Logic ---
const calculateFontSize = (text: string, maxWidth: number, maxFontSize: number, minFontSize: number) => {
    if (!text) return maxFontSize;
    const plainText = text.replace(/<[^>]*>?/gm, '');
    const estimatedSize = maxWidth / (plainText.length * 0.55); 
    return Math.min(maxFontSize, Math.max(minFontSize, estimatedSize));
};

const calculateBodyFontSize = (text: string, width: number, height: number, maxFontSize: number) => {
    if (!text) return maxFontSize;
    const plainText = text.replace(/<[^>]*>?/gm, '');
    const area = width * height;
    const charCount = plainText.length || 1;
    const estimatedSize = Math.sqrt(area / (charCount * 1.5)); 
    return Math.min(maxFontSize, Math.max(16, estimatedSize));
};

// --- Seamless Editable Text Component ---
const EditableText = ({ 
    x, y, text, fontSize, align, style, onChange, isEditing, setEditing, width = 800,
    strokeWidth = 0, strokeColor = 'transparent', shadowStyle = {}
}: { 
    x: number, y: number, text: string, fontSize: number, align: 'start' | 'middle' | 'end', 
    style?: React.CSSProperties, onChange: (val: string) => void,
    isEditing: boolean, setEditing: (v: boolean) => void, width?: number,
    strokeWidth?: number, strokeColor?: string, shadowStyle?: React.CSSProperties
}) => {
    const inputRef = useRef<HTMLInputElement>(null);
    const [isFocused, setIsFocused] = useState(false);

    useEffect(() => {
        if (isEditing && inputRef.current) {
            inputRef.current.focus();
        }
    }, [isEditing]);

    let foreignX = x;
    const textAlign = align === 'middle' ? 'center' : (align === 'start' ? 'right' : 'left'); 

    if (align === 'middle') foreignX = x - (width / 2);
    if (align === 'start') foreignX = x - width; 
    if (align === 'end') foreignX = x; 
    
    // Adjusted vertical alignment for input
    const foreignY = y - (fontSize * 1.62); 

    const inputColor = isFocused ? (style?.fill as string || '#FFFFFF') : 'transparent';

    return (
        <g onClick={(e) => { e.stopPropagation(); setEditing(true); }} style={{ cursor: 'text' }}>
            {!isFocused && (
                <g style={{ opacity: 1 }}>
                    {strokeWidth > 0 && (
                        <text 
                            x={x} y={y} 
                            textAnchor={align} 
                            style={{ ...shadowStyle, pointerEvents: 'none' }}
                            stroke={strokeColor}
                            strokeWidth={strokeWidth}
                            fill={strokeColor}
                            fontSize={fontSize}
                            fontWeight={900}
                            fontFamily="'Cairo', sans-serif"
                        >
                            {text}
                        </text>
                    )}
                    <text 
                        x={x} y={y} 
                        textAnchor={align} 
                        style={{ ...style, pointerEvents: 'none' }}
                        fontSize={fontSize}
                        fontWeight={900}
                        fontFamily="'Cairo', sans-serif"
                    >
                        {text}
                    </text>
                </g>
            )}

            <foreignObject 
                x={foreignX} 
                y={foreignY} 
                width={width} 
                height={fontSize * 2.5} 
                style={{ pointerEvents: 'all' }} 
            >
                <input
                    ref={inputRef}
                    value={text}
                    onChange={(e) => onChange(e.target.value)}
                    onFocus={() => {
                        setIsFocused(true);
                        setEditing(true);
                    }}
                    onBlur={() => {
                        setIsFocused(false);
                        setEditing(false);
                    }}
                    style={{
                        width: '100%',
                        height: '100%',
                        background: 'transparent',
                        border: 'none',
                        outline: 'none',
                        color: inputColor,
                        fontSize: `${fontSize}px`,
                        fontFamily: "'Cairo', sans-serif",
                        fontWeight: 900,
                        textAlign: textAlign,
                        direction: 'rtl',
                        padding: 0,
                        margin: 0,
                        caretColor: '#fff',
                        textShadow: isFocused ? '0 2px 10px rgba(0,0,0,0.5)' : 'none',
                        lineHeight: '1.2',
                        opacity: isFocused ? 1 : 0, 
                        cursor: 'text'
                    }}
                />
            </foreignObject>
        </g>
    );
};

export default function InstagramNewsCanvas({ data, onDataChange, scale = 1, currentSlide, totalSlides }: InstagramNewsCanvasProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const config = TYPE_CONFIG[data.type as keyof typeof TYPE_CONFIG] || TYPE_CONFIG.official;
    const [editingField, setEditingField] = useState<string | null>(null);
    
    // Pan/Zoom State
    const [isDragging, setIsDragging] = useState(false);
    const dragStart = useRef({ x: 0, y: 0 });
    const initialImgPos = useRef({ x: 0, y: 0 });
    
    const [imgDims, setImgDims] = useState({ width: 1080, height: 850 });
    const [baseScale, setBaseScale] = useState(1);

    useEffect(() => {
        const img = new Image();
        img.src = data.image;
        img.onload = () => {
            const w = img.naturalWidth || 1080;
            const h = img.naturalHeight || 850;
            setImgDims({ width: w, height: h });
            const scaleW = 1080 / w;
            const scaleH = 850 / h;
            setBaseScale(Math.max(scaleW, scaleH));
        };
    }, [data.image]);

    // Handlers...
    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if(ev.target?.result) {
                    onDataChange({ 
                        image: ev.target.result as string,
                        imageSettings: { x: 0, y: 0, scale: 1 } 
                    });
                }
            };
            reader.readAsDataURL(file);
        }
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        if (e.dataTransfer.files?.[0]?.type.startsWith('image/')) {
             const reader = new FileReader();
            reader.onload = (ev) => { if(ev.target?.result) onDataChange({ image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } }); };
            reader.readAsDataURL(e.dataTransfer.files[0]);
        }
    };

    const toggleType = (e: React.MouseEvent) => {
        e.stopPropagation();
        const types: Array<'official' | 'rumor' | 'leak'> = ['official', 'rumor', 'leak'];
        const currentIndex = types.indexOf(data.type);
        const nextIndex = (currentIndex + 1) % types.length;
        onDataChange({ type: types[nextIndex] });
    };

    const titleTopSize = calculateFontSize(data.titleTop, 1000, 110, 50);
    const titleBottomSize = calculateFontSize(data.titleBottom, 700, 65, 35);
    const bodySize = calculateBodyFontSize(data.body, 880, 260, 30); 
    const titleTopStroke = Math.max(3, titleTopSize * 0.05); 

    const renderDots = () => {
        const dots = [];
        const spacing = 35; 
        const totalWidth = (totalSlides - 1) * spacing;
        const startX = -totalWidth / 2;
        for (let i = 0; i < totalSlides; i++) {
            const isActive = i === currentSlide;
            const x = startX + (i * spacing);
            dots.push(
                <g key={i} transform={`translate(${x}, 0)`}>
                    <rect x="-6" y="-6" width="12" height="12" fill={isActive ? config.color : "none"} stroke={isActive ? "none" : "#556070"} strokeWidth="2" transform="rotate(45)" style={{ transition: 'all 0.3s ease' }} />
                    {isActive && <rect x="-6" y="-6" width="12" height="12" fill={config.color} transform="rotate(45)" filter="url(#glowEffect)" opacity="0.5" />}
                </g>
            );
        }
        return dots;
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        setIsDragging(true);
        dragStart.current = { x: e.clientX, y: e.clientY };
        const settings = data.imageSettings || { x: 0, y: 0, scale: 1 };
        initialImgPos.current = { x: settings.x, y: settings.y };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;
        e.preventDefault(); e.stopPropagation();
        const dx = (e.clientX - dragStart.current.x) / scale;
        const dy = (e.clientY - dragStart.current.y) / scale;
        const settings = data.imageSettings || { x: 0, y: 0, scale: 1 };
        onDataChange({ imageSettings: { ...settings, x: initialImgPos.current.x + dx, y: initialImgPos.current.y + dy } });
    };

    const handleMouseUp = (e: React.MouseEvent) => {
        if (!isDragging) return;
        e.stopPropagation(); setIsDragging(false);
    };

    const handleWheel = (e: React.WheelEvent) => {
        e.stopPropagation();
        const settings = data.imageSettings || { x: 0, y: 0, scale: 1 };
        const newScale = Math.max(0.1, Math.min(5, settings.scale - e.deltaY * 0.001));
        onDataChange({ imageSettings: { ...settings, scale: newScale } });
    };

    const imgSettings = data.imageSettings || { x: 0, y: 0, scale: 1 };
    const totalScale = baseScale * imgSettings.scale;
    const imageTransform = `translate(${540 + imgSettings.x} ${425 + imgSettings.y}) scale(${totalScale}) translate(${-imgDims.width / 2} ${-imgDims.height / 2})`;

    const clipPathData = "M 0,0 L 1080,0 L 1080,850 L 1000,800 L 80,800 L 0,850 Z";

    // DEFINE CLIP PATH FOR BOTTOM AREA (Where text resides)
    // Starts below the image cut (y=850) and goes down to 1350
    const bottomAreaClipPath = "M 0,850 L 80,800 L 1000,800 L 1080,850 L 1080,1350 L 0,1350 Z";

    return (
        <div 
            className="canvas-container"
            id="instagram-news-canvas"
            style={{ 
                width: `${1080 * scale}px`, 
                height: `${1350 * scale}px`,
                transformOrigin: 'top left',
                position: 'relative',
                boxShadow: `0 0 40px ${config.color}20`
            }}
            onDragOver={(e) => e.preventDefault()}
            onDrop={handleDrop}
        >
            <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />

            <svg 
                viewBox="0 0 1080 1350" 
                width="100%" 
                height="100%" 
                xmlns="http://www.w3.org/2000/svg" 
                preserveAspectRatio="xMidYMid slice"
                style={{ backgroundColor: '#000', direction: 'rtl' }}
            >
                <defs>
                    <linearGradient id="imageFade" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="60%" stopColor="#000" stopOpacity="0" />
                        <stop offset="100%" stopColor="#000" stopOpacity="1" />
                    </linearGradient>
                    
                    <pattern id="diagScan" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
                        <line x1="0" y1="0" x2="0" y2="10" stroke="#000" strokeWidth="4" opacity="0.2" />
                    </pattern>

                    <filter id="glowEffect" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                        <feMerge>
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>

                    <filter id="titleShadow">
                        <feDropShadow dx="0" dy="4" stdDeviation="4" floodColor="#000" floodOpacity="0.8" />
                    </filter>

                    <filter id="grain">
                        <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch" />
                        <feColorMatrix type="saturate" values="0" />
                        <feComponentTransfer>
                            <feFuncA type="linear" slope="0.05" />
                        </feComponentTransfer>
                    </filter>

                    <clipPath id="newsImageClip">
                        <path d={clipPathData} />
                    </clipPath>
                    
                    <clipPath id="bottomAreaClip">
                        <path d={bottomAreaClipPath} />
                    </clipPath>
                </defs>

                {/* BACKGROUND: Default dark */}
                <rect width="100%" height="100%" fill="#10121A" />
                
                {/* SPACE BACKGROUND: RESTRICTED TO BOTTOM AREA */}
                <g clipPath="url(#bottomAreaClip)">
                     <SpaceBackground />
                </g>

                <text x="540" y="600" textAnchor="middle" fontFamily="'Cairo', sans-serif" fontWeight="900" fontSize="600" fill="#10121A" opacity="0.5" style={{ pointerEvents: 'none' }}>أخبار</text>

                {/* STATIC MASK GROUP FOR IMAGE */}
                <g clipPath="url(#newsImageClip)">
                    <g 
                        id="image-layer" 
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        onDoubleClick={(e) => { e.stopPropagation(); fileInputRef.current?.click(); }}
                        style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
                    >
                        <image 
                            href={data.image} 
                            width={imgDims.width}
                            height={imgDims.height}
                            preserveAspectRatio="none"
                            transform={imageTransform}
                        />
                    </g>
                    
                    {/* STATIC OVERLAYS - Inside Clip */}
                    <rect x="0" y="500" width="1080" height="350" fill="url(#imageFade)" pointerEvents="none" />
                    <rect width="1080" height="850" fill="url(#diagScan)" opacity="0.3" pointerEvents="none" />
                </g>

                {/* TYPE BADGE */}
                <g onClick={toggleType} onDoubleClick={(e) => e.stopPropagation()} style={{ cursor: 'pointer' }}>
                    <g transform="translate(1080, 100) scale(-1, 1)">
                        <path d="M 0,0 L 260,0 L 290,60 L 0,60 Z" fill="#0B0D12" stroke="#1A202C" strokeWidth="2" />
                        <rect x="0" y="0" width="12" height="60" fill={config.color} filter="url(#glowEffect)" />
                    </g>
                    
                    <g transform="translate(1045, 140)">
                        <text x="0" y="0" textAnchor="start" fontFamily="'Cairo', sans-serif" fontWeight="900" fontSize="36" fill="#FFF" letterSpacing="0" style={{ userSelect: 'none' }}>
                            {config.label}
                        </text>
                        <g transform="translate(-210, -22)">
                            <path d={config.iconPath1} fill="none" stroke={config.color} strokeWidth="1.5" />
                            {config.iconPath2 && <path d={config.iconPath2} fill="none" stroke={config.color} strokeWidth="2" />}
                        </g>
                    </g>
                </g>

                {/* FRAME PATH - RENDERED BEFORE TEXT */}
                <g pointerEvents="none">
                    <path d="M 0,1350 L 1080,1350 L 1080,850 L 1000,800 L 80,800 L 0,850 Z" fill="none" stroke="#1A202C" strokeWidth="2" /> {/* Removed opaque fill here to let BG show */}
                    <path d="M 0,850 L 80,800 L 80,900 L 100,920 L 420,920" fill="none" stroke={DEFAULT_ACCENT} strokeWidth="3" strokeLinecap="square" style={{ filter: `drop-shadow(0 0 5px ${DEFAULT_ACCENT})` }} />
                    <path d="M 1080,850 L 1000,800 L 1000,900 L 980,920 L 660,920" fill="none" stroke={DEFAULT_ACCENT} strokeWidth="3" strokeLinecap="square" style={{ filter: `drop-shadow(0 0 5px ${DEFAULT_ACCENT})` }} />

                    <g transform="translate(480, 1340)">
                        <path d="M 0,0 L 120,0 L 130,10 L -10,10 Z" fill="#151820" stroke="#333" strokeWidth="1" />
                        <g transform="translate(60, -15)">
                            {renderDots()}
                        </g>
                    </g>
                </g>

                {/* TITLE GROUP - RENDERED AFTER FRAME */}
                <g transform="translate(540, 780)">
                    {/* Title Top - Positioned relative to separator */}
                    <EditableText 
                        x={0} y={-25} 
                        text={data.titleTop} 
                        fontSize={titleTopSize}
                        width={1000} 
                        align="middle"
                        style={{ fill: "#FFFFFF", filter: "url(#titleShadow)" }}
                        strokeColor="#000"
                        strokeWidth={titleTopStroke}
                        shadowStyle={{ opacity: 0.8 }}
                        onChange={(val) => onDataChange({ titleTop: val })}
                        isEditing={editingField === 'titleTop'}
                        setEditing={(val) => setEditingField(val ? 'titleTop' : null)}
                    />
                    
                    {/* Title Bottom - Positioned explicitly below separator - Dragged down slightly */}
                    <EditableText 
                        x={0} y={80} 
                        text={data.titleBottom} 
                        fontSize={titleBottomSize}
                        width={700}
                        align="middle"
                        style={{ 
                            fill: DEFAULT_ACCENT, 
                            textTransform: 'uppercase', 
                            filter: `drop-shadow(0 0 10px ${DEFAULT_ACCENT}80)` 
                        }}
                        onChange={(val) => onDataChange({ titleBottom: val })}
                        isEditing={editingField === 'titleBottom'}
                        setEditing={(val) => setEditingField(val ? 'titleBottom' : null)}
                    />

                    {/* Separator Line */}
                    <rect x="-400" y="-10" width="800" height="2" fill={DEFAULT_ACCENT} opacity="0.5" />
                </g>

                {/* BODY CONTENT */}
                <g transform="translate(0, 950)">
                    <rect x="980" y="0" width="4" height="30" fill="#556070" />
                    
                    <EditableText
                        x={965} y={20}
                        text={data.source || 'المصدر: خاص'}
                        fontSize={18}
                        width={600}
                        align="start" 
                        style={{ fill: DEFAULT_ACCENT, letterSpacing: 0 }}
                        onChange={(val) => onDataChange({ source: val })}
                        isEditing={editingField === 'source'}
                        setEditing={(val) => setEditingField(val ? 'source' : null)}
                    />

                    {/* Rich Text Editor Container */}
                    <foreignObject x="100" y="50" width="880" height="350">
                         <SocialNewsBodyEditor 
                            content={data.body} 
                            onChange={(html) => onDataChange({ body: html })}
                            fontSize={bodySize}
                            isEditing={editingField === 'body'}
                            setEditing={(val) => setEditingField(val ? 'body' : null)}
                         />
                    </foreignObject>
                </g>

                <rect width="100%" height="100%" filter="url(#grain)" opacity="0.08" pointerEvents="none" style={{ mixBlendMode: 'overlay' }} />
                
            </svg>
        </div>
    );
}




--- END OF FILE components/studio/social/InstagramNewsCanvas.tsx ---

================================================================================

--- START OF FILE components/studio/social/SmartFiller.tsx ---

'use client';

import { useState, useTransition, useEffect } from 'react';
import { searchContentForTemplateAction } from '@/app/studio/social-templates/actions';
import Modal from '@/components/modals/Modal';
import { useDebounce } from '@/hooks/useDebounce';
import styles from './SocialEditor.module.css';
import Image from 'next/image';

interface SmartFillerProps {
    isOpen: boolean;
    onClose: () => void;
    onSelect: (data: any) => void;
}

export default function SmartFiller({ isOpen, onClose, onSelect }: SmartFillerProps) {
    const [query, setQuery] = useState('');
    const debouncedQuery = useDebounce(query, 500);
    const [results, setResults] = useState<any[]>([]);
    const [isPending, startTransition] = useTransition();

    // Combined effect: Fetches initially (empty query) and on search change
    useEffect(() => {
        if (!isOpen) return;

        startTransition(async () => {
            const data = await searchContentForTemplateAction(debouncedQuery);
            setResults(data);
        });
    }, [debouncedQuery, isOpen]);

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '600px', width: '100%' }}>
            {/* REMOVED (Smart Fill) English text as requested */}
            <h3 style={{ marginTop: 0, fontFamily: 'var(--font-main)', fontSize: '2rem' }}>الملء الذكي</h3>
            <p style={{ color: 'var(--text-secondary)', marginBottom: '2rem' }}>
                اختر محتوى لملء القالب تلقائيًا. يتم عرض الأحدث افتراضيًا.
            </p>
            
            <input 
                type="search" 
                placeholder="ابحث بالعنوان أو المحتوى..." 
                className="profile-input" 
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                autoFocus
            />

            <div style={{ marginTop: '2rem', display: 'flex', flexDirection: 'column', gap: '1rem', maxHeight: '400px', overflowY: 'auto' }}>
                {isPending ? (
                    <div className="spinner" style={{ margin: '2rem auto' }} />
                ) : (
                    <>
                        {results.length === 0 && (
                            <p style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>لا نتائج.</p>
                        )}
                        {results.map((item) => (
                            <div key={item._id} className={styles.searchResultItem} onClick={() => { onSelect(item); onClose(); }}>
                                {item.imageUrl && (
                                    <Image src={item.imageUrl} alt={item.title} width={50} height={50} className={styles.searchResultImg} />
                                )}
                                <div className={styles.searchResultInfo}>
                                    <h4>{item.title}</h4>
                                    <p>{item.publishedAt ? new Date(item.publishedAt).toLocaleDateString('ar-EG') : 'مسودة'}</p>
                                </div>
                            </div>
                        ))}
                    </>
                )}
            </div>
        </Modal>
    );
}




--- END OF FILE components/studio/social/SmartFiller.tsx ---

================================================================================

--- START OF FILE components/studio/social/SocialEditor.module.css ---

/* components/studio/social/SocialEditor.module.css */

.editorContainer {
  display: flex;
  flex-direction: column;
  height: calc(100vh - var(--nav-height-scrolled));
  margin-top: var(--nav-height-scrolled); 
  background-color: #050505;
  color: #fff;
  overflow: hidden;
  position: relative;
  z-index: 1; 
}

.mainArea {
  flex-grow: 1;
  display: flex;
  position: relative;
  height: 100%;
  overflow: hidden;
}

.canvasWrapper {
  flex-grow: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background-image: 
    linear-gradient(45deg, #111 25%, transparent 25%), 
    linear-gradient(-45deg, #111 25%, transparent 25%), 
    linear-gradient(45deg, transparent 75%, #111 75%), 
    linear-gradient(-45deg, transparent 75%, #111 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  background-color: #0a0a0a;
  overflow: hidden;
  padding: 0; 
  position: relative;
}

.sidebar {
  width: 360px;
  background-color: var(--bg-secondary);
  border-right: 1px solid var(--border-color);
  padding: 2rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
  overflow-y: auto;
  z-index: 10;
  height: 100%;
  flex-shrink: 0;
  transition: transform 0.3s ease;
}

.sidebarHeader {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color);
}

.sidebarTitle {
  font-family: var(--font-heading);
  font-size: 1.8rem;
  font-weight: 700;
  margin: 0;
  color: var(--text-primary);
}

.controlGroup {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.label {
  font-size: 1.3rem;
  color: var(--text-secondary);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.input {
  background-color: var(--bg-primary);
  border: 1px solid var(--border-color);
  padding: 1.2rem;
  border-radius: 8px;
  color: #fff;
  font-family: var(--font-main);
  text-align: right;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  font-size: 1.5rem;
}

.input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 15%, transparent);
}

.textarea {
  resize: vertical;
  min-height: 120px;
  line-height: 1.6;
}

.typeGrid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.8rem;
}

.typeButton {
  padding: 0.8rem;
  border: 1px solid var(--border-color);
  background: transparent;
  color: var(--text-secondary);
  border-radius: 6px;
  cursor: pointer;
  font-size: 1.3rem;
  font-family: var(--font-main);
  font-weight: 500;
  transition: all 0.2s ease;
}
@media (hover: hover) {@media (hover: hover) {
  
  .typeButton:hover  {
  background: var(--bg-primary);
  color: #fff;
  border-color: var(--text-secondary);
}
}

  .typeButton:active  {
  background: var(--bg-primary);
  color: #fff;
  border-color: var(--text-secondary);
}
}
.typeButton:active {
  background: var(--bg-primary);
  color: #fff;
  border-color: var(--text-secondary);
}


.typeButton.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
  font-weight: 700;
  box-shadow: 0 4px 12px color-mix(in srgb, var(--accent) 30%, transparent);
}
.typeButton.active[data-type="official"] { background: #00FFF0; border-color: #00FFF0; color: #000; box-shadow: 0 4px 12px rgba(0, 255, 240, 0.3); }
.typeButton.active[data-type="rumor"] { background: #F59E0B; border-color: #F59E0B; color: #000; box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3); }
.typeButton.active[data-type="leak"] { background: #DC2626; border-color: #DC2626; color: #fff; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3); }

/* --- Smart Fill Button --- */
.smartFillButton {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-primary);
    padding: 0 2rem;
    height: 44px;
    border-radius: 8px;
    font-family: var(--font-main);
    font-size: 1.4rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    width: 100%;
}
@media (hover: hover) {@media (hover: hover) {
  
  .smartFillButton:hover  {
    border-color: var(--accent);
    color: var(--accent);
    background: color-mix(in srgb, var(--accent) 5%, transparent);
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
}

  .smartFillButton:active  {
    border-color: var(--accent);
    color: var(--accent);
    background: color-mix(in srgb, var(--accent) 5%, transparent);
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
}
.smartFillButton:active {
    border-color: var(--accent);
    color: var(--accent);
    background: color-mix(in srgb, var(--accent) 5%, transparent);
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}


.smartFillButton svg {
    color: var(--accent);
}

/* --- Download Group --- */
.downloadGroup {
    display: flex;
    align-items: center;
    width: 100%;
}

.downloadButton {
    background-color: var(--accent);
    color: #fff;
    border: none;
    padding: 0 1rem;
    height: 44px;
    font-family: var(--font-main);
    font-weight: 800;
    font-size: 1.5rem;
    cursor: pointer;
    border-top-right-radius: 8px;
    border-bottom-right-radius: 8px;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    border-left: 1px solid rgba(0,0,0,0.1);
    transition: background-color 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-grow: 1;
}
[data-theme="dark"] .downloadButton {
    color: var(--bg-primary);
}
@media (hover: hover) {@media (hover: hover) {
  
  .downloadButton:hover  {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}
}

  .downloadButton:active  {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}
}
.downloadButton:active {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}


.downloadButton:disabled, .dropdownTrigger:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    filter: grayscale(0.5);
}

.dropdownTrigger {
    background-color: var(--accent);
    color: #fff;
    border: none;
    width: 44px;
    height: 44px;
    cursor: pointer;
    border-top-left-radius: 8px;
    border-bottom-left-radius: 8px;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    position: relative;
    flex-shrink: 0;
}
[data-theme="dark"] .dropdownTrigger {
    color: var(--bg-primary);
}
@media (hover: hover) {@media (hover: hover) {
  
  .dropdownTrigger:hover  {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}
}

  .dropdownTrigger:active  {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}
}
.dropdownTrigger:active {
    background-color: color-mix(in srgb, var(--accent) 85%, white);
}


.dropdownMenu {
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-top: 0.5rem;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.dropdownItem {
    background: none;
    border: none;
    padding: 1rem;
    text-align: right;
    cursor: pointer;
    color: var(--text-primary);
    font-family: var(--font-main);
    font-size: 1.3rem;
    transition: all 0.2s ease;
    width: 100%;
}
@media (hover: hover) {@media (hover: hover) {
  
  .dropdownItem:hover  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}
}

  .dropdownItem:active  {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}
}
.dropdownItem:active {
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
    color: var(--accent);
}


/* --- Search Styles --- */
.searchResultItem {
  display: flex;
  gap: 1.5rem;
  padding: 1.2rem;
  border-radius: 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  cursor: pointer;
  transition: all 0.2s;
  text-align: right;
  align-items: center;
}
@media (hover: hover) {@media (hover: hover) {
  
  .searchResultItem:hover  {
  border-color: var(--accent);
  transform: translateX(-3px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
}

  .searchResultItem:active  {
  border-color: var(--accent);
  transform: translateX(-3px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
}
.searchResultItem:active {
  border-color: var(--accent);
  transform: translateX(-3px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.searchResultImg {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
  flex-shrink: 0;
  border: 1px solid var(--border-color);
}
.searchResultInfo {
    flex-grow: 1;
}
.searchResultInfo h4 {
  margin: 0 0 0.5rem 0;
  font-size: 1.5rem;
  color: var(--text-primary);
  line-height: 1.3;
}
.searchResultInfo p {
  margin: 0;
  font-size: 1.2rem;
  color: var(--text-secondary);
  font-family: var(--font-ui);
}

/* Mobile Toggle Bar */
.mobileToggleBar {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background-color: var(--bg-secondary);
    border-top: 1px solid var(--border-color);
    z-index: 100;
    justify-content: space-around;
    align-items: center;
}

.mobileToggleButton {
    flex: 1;
    height: 100%;
    background: none;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    font-family: var(--font-main);
    font-size: 1.4rem;
    color: var(--text-secondary);
}

.mobileToggleButton.active {
    color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}

.mobileDivider {
    width: 1px;
    height: 24px;
    background-color: var(--border-color);
}

/* --- Bubble Menu Styles (Ported from Editor.module.css) --- */
.formattingToolbar {
    display: flex;
    align-items: center;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--text-primary) 15%, transparent);
    padding: 0.4rem;
    z-index: 100;
    gap: 0.25rem;
}

.bubbleMenuButton {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 32px;
    width: 32px;
    border-radius: 4px;
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    transition: background-color 0.15s ease-out, color 0.15s ease-out;
}
@media (hover: hover) {@media (hover: hover) {
  
  .bubbleMenuButton:hover  {
    background-color: var(--bg-primary);
    color: var(--accent);
}
}

  .bubbleMenuButton:active  {
    background-color: var(--bg-primary);
    color: var(--accent);
}
}
.bubbleMenuButton:active {
    background-color: var(--bg-primary);
    color: var(--accent);
}


.bubbleMenuButton.active {
    background-color: color-mix(in srgb, var(--accent) 15%, transparent);
    color: var(--accent);
}

/* Mobile Media Queries */
@media (max-width: 1024px) {
    .editorContainer {
        height: calc(100vh - var(--nav-height-scrolled));
        margin-top: var(--nav-height-scrolled);
    }
    .sidebar {
        width: 100%;
        padding-bottom: 80px;
    }
    
    .mobileToggleBar {
        display: flex;
    }
    
    .canvasWrapper {
        padding: 0;
        padding-bottom: 80px;
    }
}




--- END OF FILE components/studio/social/SocialEditor.module.css ---

================================================================================

--- START OF FILE components/studio/social/SocialNewsBodyEditor.tsx ---

// components/studio/social/SocialNewsBodyEditor.tsx
'use client';

import { useEditor, EditorContent, BubbleMenu } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import TextStyle from '@tiptap/extension-text-style';
import { Color } from '@tiptap/extension-color';
import { TextStrokeMark } from './extensions/TextStrokeMark';
import { RandomEnglishStyleExtension } from './extensions/RandomEnglishStyleExtension';
import { SocialDeactivateMarks } from './extensions/SocialDeactivateMarks'; 
import { FirstWordColorExtension } from './extensions/FirstWordColorExtension';
import { useEffect, useState } from 'react';
import styles from './SocialEditor.module.css';
import { motion } from 'framer-motion';

// Icons for Bubble Menu
const WhiteIcon = () => (
    <div style={{width: 16, height: 16, background: '#FFFFFF', borderRadius: '4px', border: '1px solid #555', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
        <span style={{color: '#000', fontSize: '10px', fontWeight: 900}}>A</span>
    </div>
);
const CyanIcon = () => (
    <div style={{width: 16, height: 16, background: '#00FFF0', borderRadius: '4px', border: '1px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center'}}>
        <span style={{color: '#000', fontSize: '10px', fontWeight: 900}}>A</span>
    </div>
);
const ClearIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

type StylingVariant = 'none' | 'hero' | 'card';

interface SocialNewsBodyEditorProps {
    content: string;
    onChange: (html: string) => void;
    fontSize?: number; 
    isEditing: boolean;
    setEditing: (val: boolean) => void;
    customStyle?: React.CSSProperties;
    disableAutoEnglish?: boolean;
    textAlign?: 'left' | 'right' | 'center' | 'justify';
    autoHeight?: boolean;
    enableFirstWordColor?: boolean; 
    firstWordColor?: string;
    stylingVariant?: StylingVariant; 
}

export default function SocialNewsBodyEditor({ 
    content, 
    onChange, 
    fontSize = 24, 
    isEditing, 
    setEditing,
    customStyle = {},
    disableAutoEnglish = false,
    textAlign = 'right',
    autoHeight = false,
    enableFirstWordColor = false,
    firstWordColor = '#00FFF0',
    stylingVariant = 'none'
}: SocialNewsBodyEditorProps) {
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
    }, []);

    const extensions = [
        StarterKit.configure({ 
            heading: false, 
            bulletList: false, 
            orderedList: false, 
            blockquote: false, 
            bold: false,
        }),
        TextStyle,
        Color,
        SocialDeactivateMarks, 
    ];

    if (!disableAutoEnglish) {
        extensions.push(RandomEnglishStyleExtension);
    }
    
    // Configure extension with color
    if (enableFirstWordColor) {
        extensions.push(FirstWordColorExtension.configure({ color: firstWordColor }));
    }

    const editor = useEditor({
        extensions: extensions,
        content: content,
        editorProps: {
            attributes: {
                class: `social-editor-content variant-${stylingVariant}`,
                style: `outline: none; width: 100%; overflow: hidden; ${autoHeight ? 'min-height: 0;' : 'height: 100%;'}` 
            }
        },
        onUpdate: ({ editor }) => {
            onChange(editor.getHTML());
        },
    }, [firstWordColor, enableFirstWordColor]); // Re-create if these props change

    // --- FORCE COLOR UPDATE ---
    // This effect manually reapplies the first-word coloring when the color prop changes.
    useEffect(() => {
        if (!editor || !enableFirstWordColor || !firstWordColor || editor.isDestroyed) return;

        const { tr, doc } = editor.state;
        const textStyleMark = editor.schema.marks.textStyle;
        let modified = false;
        let firstTextNodeFound = false;

        doc.descendants((node, pos) => {
            if (firstTextNodeFound) return false;
            if (node.isText && node.text) {
                firstTextNodeFound = true;
                const match = node.text.match(/^(\s*)([^\s]+)/);
                if (match) {
                    const [_, leadingSpace, firstWord] = match;
                    const start = pos + leadingSpace.length;
                    const end = start + firstWord.length;

                    // Remove old marks and apply new color
                    tr.removeMark(start, end, textStyleMark);
                    tr.addMark(start, end, textStyleMark.create({ color: firstWordColor }));
                    modified = true;
                }
            }
            return true;
        });

        if (modified) {
            editor.view.dispatch(tr);
        }
    }, [editor, firstWordColor, enableFirstWordColor]);


    useEffect(() => {
        if (editor && content !== editor.getHTML()) {
             if (!editor.isFocused) {
                 editor.commands.setContent(content);
             }
        }
    }, [content, editor]);

    useEffect(() => {
        if (isEditing && editor && !editor.isFocused) {
            editor.commands.focus();
        }
    }, [isEditing, editor]);

    if (!editor) return null;

    const combinedStyle: React.CSSProperties = {
        fontSize: `${fontSize}px`,
        lineHeight: 1.2,
        fontWeight: 700,
        textAlign: textAlign,
        textAlignLast: textAlign === 'justify' ? 'right' : undefined,
        direction: 'rtl',
        fontFamily: "'Dystopian', 'Cairo', sans-serif",
        color: '#A0AEC0', 
        ...customStyle
    };

    return (
        <div 
            style={{ position: 'relative', width: '100%', height: '100%', ...combinedStyle }} 
            onClick={(e) => { e.stopPropagation(); setEditing(true); }}
        >
            <style jsx global>{`
                /* HERO VARIANT */
                .variant-hero p {
                    margin: 0;
                    font-size: 0.55em !important; 
                    color: #00FFF0 !important;
                    line-height: 1.4 !important;
                    font-weight: 700;
                }
                .variant-hero p::first-line {
                    font-size: 1.81em !important; 
                    color: #FFFFFF !important;
                    line-height: 1.1 !important;
                    font-weight: 900;
                }

                /* CARD VARIANT */
                .variant-card p {
                    margin: 0;
                    font-size: 0.85em !important;
                    color: #FFFFFF !important;
                    opacity: 0.9;
                    font-weight: 500;
                    line-height: 1.3 !important;
                }
                .variant-card p::first-line {
                    font-size: 1.17em !important; 
                    color: #FFFFFF !important;
                    opacity: 1;
                    font-weight: 700;
                    line-height: 1.2 !important;
                }
            `}</style>

            {mounted && (
                <BubbleMenu 
                    editor={editor} 
                    tippyOptions={{ 
                        duration: 100, 
                        appendTo: document.body,
                        zIndex: 99999,
                        maxWidth: 'none'
                    }} 
                    shouldShow={({ state }) => !state.selection.empty}
                    className={styles.formattingToolbar}
                >
                    <motion.button 
                        onClick={() => editor.chain().focus().setColor('#FFFFFF').run()} 
                        className={`${styles.bubbleMenuButton} ${editor.isActive('textStyle', { color: '#FFFFFF' }) ? styles.active : ''}`} 
                        whileTap={{ scale: 0.9 }}
                        title="White"
                    >
                        <WhiteIcon />
                    </motion.button>
                    <motion.button 
                        onClick={() => editor.chain().focus().setColor('#00FFF0').run()} 
                        className={`${styles.bubbleMenuButton} ${editor.isActive('textStyle', { color: '#00FFF0' }) ? styles.active : ''}`} 
                        whileTap={{ scale: 0.9 }}
                        title="Cyan"
                    >
                        <CyanIcon />
                    </motion.button>
                    <motion.button 
                        onClick={() => editor.chain().focus().unsetAllMarks().run()} 
                        className={styles.bubbleMenuButton} 
                        whileTap={{ scale: 0.9 }} 
                        title="Reset Color"
                    >
                        <ClearIcon />
                    </motion.button>
                </BubbleMenu>
            )}
            <EditorContent editor={editor} style={{ width: '100%', height: autoHeight ? 'auto' : '100%' }} />
        </div>
    );
}

--- END OF FILE components/studio/social/SocialNewsBodyEditor.tsx ---

================================================================================

--- START OF FILE components/studio/social/extensions/FirstWordColorExtension.ts ---

// components/studio/social/extensions/FirstWordColorExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';

export interface FirstWordColorOptions {
    color: string;
}

export const FirstWordColorExtension = Extension.create<FirstWordColorOptions>({
    name: 'firstWordColor',

    addOptions() {
        return {
            color: '#00FFF0', // Default Cyan
        };
    },

    addProseMirrorPlugins() {
        const { editor, options } = this;

        return [
            new Plugin({
                key: new PluginKey('firstWordColor'),
                appendTransaction: (transactions, oldState, newState) => {
                    const docChanged = transactions.some(transaction => transaction.docChanged);
                    if (!docChanged) return null;

                    const tr = newState.tr;
                    const textStyleMark = editor.schema.marks.textStyle;
                    
                    let firstTextNodeFound = false;
                    let modified = false;

                    newState.doc.descendants((node, pos) => {
                        if (firstTextNodeFound) return false; 

                        if (node.isText && node.text) {
                            firstTextNodeFound = true;
                            
                            // Regex to find the first word (non-whitespace sequence)
                            const match = node.text.match(/^(\s*)([^\s]+)/);
                            
                            if (match) {
                                const [fullMatch, leadingSpace, firstWord] = match;
                                const start = pos + leadingSpace.length;
                                const end = start + firstWord.length;

                                // Check if it already has the CORRECT color
                                const hasCorrectColor = node.marks.some(m => 
                                    m.type.name === 'textStyle' && m.attrs.color === options.color
                                );

                                if (!hasCorrectColor) {
                                    if (textStyleMark) {
                                        // Remove any existing textStyle marks on this range first
                                        tr.removeMark(start, end, textStyleMark);
                                        // Add the new color mark
                                        tr.addMark(start, end, textStyleMark.create({ color: options.color }));
                                        modified = true;
                                    }
                                }
                            }
                        }
                        return true;
                    });

                    if (!modified) return null;

                    return tr;
                },
            }),
        ];
    },
});




--- END OF FILE components/studio/social/extensions/FirstWordColorExtension.ts ---

================================================================================

--- START OF FILE components/studio/social/extensions/RandomEnglishStyleExtension.ts ---

// components/studio/social/extensions/RandomEnglishStyleExtension.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';

// Simple hash function to deterministically pick a style based on the phrase content
const getStyleForPhrase = (text: string) => {
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
        hash = text.charCodeAt(i) + ((hash << 5) - hash);
    }
    const styles = ['white', 'cyan'];
    return styles[Math.abs(hash) % styles.length];
};

export const RandomEnglishStyleExtension = Extension.create({
    name: 'randomEnglishStyle',

    addProseMirrorPlugins() {
        const { editor } = this;

        return [
            new Plugin({
                key: new PluginKey('randomEnglishStyle'),
                appendTransaction: (transactions, oldState, newState) => {
                    const docChanged = transactions.some(transaction => transaction.docChanged);
                    if (!docChanged) return null;

                    const tr = newState.tr;
                    let modified = false;

                    const textStyleMark = editor.schema.marks.textStyle;
                    
                    // Regex for English Sequences:
                    // Matches a word, optionally followed by (space + word) repeatedly.
                    // This groups "Dead Space" into one match, but "Dead العربية Space" into two separate matches.
                    const englishSequenceRegex = /\b[a-zA-Z0-9]+(?:['’][a-zA-Z0-9]+)?(?:\s+[a-zA-Z0-9]+(?:['’][a-zA-Z0-9]+)?)*\b/g;

                    newState.doc.descendants((node, pos) => {
                        if (!node.isText) return;
                        
                        const text = node.text;
                        if (!text) return;
                        
                        let match;
                        while ((match = englishSequenceRegex.exec(text)) !== null) {
                            const start = pos + match.index;
                            const end = start + match[0].length;
                            const phrase = match[0];
                            
                            // Check if this range already has a color mark (manual override)
                            // If the user manually colored it, we generally skip to avoid fighting them.
                            // However, since this is "Automatic", we rely on the editor's behavior.
                            // We check the first character of the match to see if it has the mark.
                            const hasColor = textStyleMark.isInSet(node.marks);
                            
                            if (!hasColor) {
                                // Determine style for the entire phrase
                                const styleType = getStyleForPhrase(phrase);
                                
                                if (styleType === 'white') {
                                    tr.addMark(start, end, textStyleMark.create({ color: '#FFFFFF' }));
                                } else if (styleType === 'cyan') {
                                    tr.addMark(start, end, textStyleMark.create({ color: '#00FFF0' }));
                                }
                                modified = true;
                            }
                        }
                    });

                    if (!modified) return null;

                    return tr;
                },
            }),
        ];
    },
});




--- END OF FILE components/studio/social/extensions/RandomEnglishStyleExtension.ts ---

================================================================================

--- START OF FILE components/studio/social/extensions/SocialDeactivateMarks.ts ---

// components/studio/social/extensions/SocialDeactivateMarks.ts
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { EditorView } from 'prosemirror-view';

export const SocialDeactivateMarks = Extension.create({
    name: 'socialDeactivateMarks',

    addProseMirrorPlugins() {
        return [
            new Plugin({
                key: new PluginKey('socialDeactivateMarks'),
                props: {
                    // Handle Space
                    handleTextInput: (view: EditorView, from: number, to: number, text: string) => {
                        if (text === ' ' && view.state.selection.empty) {
                            const currentMarks = view.state.storedMarks || view.state.selection.$from.marks();
                            if (currentMarks && currentMarks.length > 0) {
                                const tr = view.state.tr.insertText(text, from, to);
                                tr.setStoredMarks([]); // Clear marks for next char
                                view.dispatch(tr);
                                return true;
                            }
                        }
                        return false;
                    },
                    // Handle Enter
                    handleKeyDown: (view: EditorView, event: KeyboardEvent) => {
                        if (event.key === 'Enter' && !event.shiftKey) {
                            const tr = view.state.tr.setStoredMarks([]);
                            view.dispatch(tr);
                            return false; // Allow default Enter behavior to proceed
                        }
                        return false;
                    }
                },
            }),
        ];
    },
});




--- END OF FILE components/studio/social/extensions/SocialDeactivateMarks.ts ---

================================================================================

--- START OF FILE components/studio/social/extensions/TextStrokeMark.ts ---

// components/studio/social/extensions/TextStrokeMark.ts
import { Mark, mergeAttributes } from '@tiptap/core';

export const TextStrokeMark = Mark.create({
  name: 'textStroke',

  addOptions() {
    return {
      HTMLAttributes: {},
    };
  },

  parseHTML() {
    return [
      {
        tag: 'span',
        getAttrs: (element) => (element as HTMLElement).classList.contains('text-stroke-effect') && null,
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { class: 'text-stroke-effect' }), 0];
  },
});




--- END OF FILE components/studio/social/extensions/TextStrokeMark.ts ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/GameSlot.tsx ---

// components/studio/social/monthly-games/GameSlot.tsx
'use client';

import React, { useRef, useState, useEffect, useMemo } from 'react';
import { GameSlotData } from './types';
import { PLATFORM_ICONS } from './utils';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import EditableText from '../shared/EditableText';

interface GameSlotProps {
    slot: GameSlotData;
    onChange: (newData: Partial<GameSlotData>) => void;
    x: number;
    y: number;
    scale: number; // for pointer calculations
    sizeScale?: number; // Scaling factor for the card itself
}

// Config: GamePass/PSPlus (English, Cyan), Exclusive (Arabic, Red), Price (Gold)
const BADGE_CONFIG = {
    gamePass: { color: '#00FFF0', text: 'GamePass', icon: 'GP', minWidth: 110 },
    psPlus: { color: '#00FFF0', text: 'PS Plus', icon: 'PS', minWidth: 100 },
    exclusive: { color: '#FF0000', text: 'حصرية', icon: 'EX', minWidth: 90 },
    price: { color: '#FFD700', text: '$', icon: '$', minWidth: 60 },
};

// Fixed Order: GamePass -> PS Plus -> Exclusive -> Price
const BADGE_KEYS = ['gamePass', 'psPlus', 'exclusive', 'price'] as const;

export default function GameSlot({ slot, onChange, x, y, scale, sizeScale = 1 }: GameSlotProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [editingField, setEditingField] = useState<string | null>(null);
    
    const [isDragging, setIsDragging] = useState(false);
    const dragStart = useRef({ x: 0, y: 0 });
    const initialImgPos = useRef({ x: 0, y: 0 });
    const [isHovered, setIsHovered] = useState(false);
    
    const [imgDims, setImgDims] = useState({ width: 300, height: 380 });
    const [baseScale, setBaseScale] = useState(1);
    
    useEffect(() => {
        const img = new Image();
        img.src = slot.image;
        img.onload = () => {
            const w = img.naturalWidth || 300;
            const h = img.naturalHeight || 380;
            setImgDims({ width: w, height: h });
            const scaleW = 300 / w;
            const scaleH = 380 / h;
            setBaseScale(Math.max(scaleW, scaleH));
        };
    }, [slot.image]);
    
    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if(ev.target?.result) {
                    onChange({ 
                        image: ev.target.result as string,
                        imageSettings: { x: 0, y: 0, scale: 1 } 
                    });
                }
            };
            reader.readAsDataURL(file);
        }
    };
    
    const handleMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        setIsDragging(true);
        dragStart.current = { x: e.clientX, y: e.clientY };
        initialImgPos.current = { x: slot.imageSettings.x, y: slot.imageSettings.y };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;
        e.preventDefault(); e.stopPropagation();
        const dx = (e.clientX - dragStart.current.x) / (scale * sizeScale);
        const dy = (e.clientY - dragStart.current.y) / (scale * sizeScale);
        onChange({ imageSettings: { ...slot.imageSettings, x: initialImgPos.current.x + dx, y: initialImgPos.current.y + dy } });
    };

    const handleMouseUp = (e: React.MouseEvent) => {
        if (!isDragging) return;
        e.stopPropagation(); setIsDragging(false);
    };

    const handleWheel = (e: React.WheelEvent) => {
        e.stopPropagation();
        const settings = slot.imageSettings;
        const newScale = Math.max(0.1, Math.min(5, settings.scale - e.deltaY * 0.001));
        onChange({ imageSettings: { ...settings, scale: newScale } });
    };

    const handleDrop = (e: React.DragEvent<SVGGElement>) => {
        e.preventDefault(); e.stopPropagation();
        if (e.dataTransfer.files?.[0]?.type.startsWith('image/')) {
             const reader = new FileReader();
            reader.onload = (ev) => { if(ev.target?.result) onChange({ image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } }); };
            reader.readAsDataURL(e.dataTransfer.files[0]);
        }
    };
    
    const handlePlatformToggle = (e: React.MouseEvent, key: keyof typeof slot.platforms) => {
        e.stopPropagation(); 
        onChange({ platforms: { ...slot.platforms, [key]: !slot.platforms[key] } });
    };

    // --- Badge Logic ---
    const toggleBadge = (key: string) => {
        if (key === 'price') {
            onChange({ badges: { ...slot.badges, price: { ...slot.badges.price, active: !slot.badges.price.active } } });
        } else {
            onChange({ badges: { ...slot.badges, [key]: !slot.badges[key as keyof typeof slot.badges] } });
        }
    };

    const updatePriceText = (text: string) => {
        onChange({ badges: { ...slot.badges, price: { ...slot.badges.price, text } } });
    };

    // --- Dynamic Width Calculation (Top-Down Cascade) ---
    const calculatedBadges = useMemo(() => {
        const DIAGONAL_OFFSET = 20; // Step for diagonal cut

        // 1. Filter active badges in fixed order
        const activeBadges = BADGE_KEYS.map(key => {
            if (key === 'price') {
                return slot.badges.price.active ? { ...BADGE_CONFIG.price, text: slot.badges.price.text, key } : null;
            }
            return slot.badges[key as keyof typeof slot.badges] ? { ...BADGE_CONFIG[key], key } : null;
        }).filter((b): b is NonNullable<typeof b> => b !== null);

        if (activeBadges.length === 0) return [];

        const processedBadges: any[] = [];
        
        // 2. Calculate Top Badge Width (The Anchor)
        const firstBadge = activeBadges[0];
        let topWidth = firstBadge.minWidth;

        // If price is the top badge, adjust width to fit text exactly + padding
        if (firstBadge.key === 'price') {
            const charCount = firstBadge.text.length;
            topWidth = Math.max(70, 50 + (charCount * 12));
        }

        processedBadges.push({
            ...firstBadge,
            topWidth: topWidth,
            bottomWidth: topWidth - DIAGONAL_OFFSET
        });

        // 3. Calculate subsequent widths (Strictly decreasing)
        let previousBottomWidth = topWidth - DIAGONAL_OFFSET;

        for (let i = 1; i < activeBadges.length; i++) {
            const badge = activeBadges[i];
            const currentTopWidth = previousBottomWidth;
            const currentBottomWidth = currentTopWidth - DIAGONAL_OFFSET;
            
            processedBadges.push({
                ...badge,
                topWidth: currentTopWidth,
                bottomWidth: currentBottomWidth
            });
            
            previousBottomWidth = currentBottomWidth;
        }
        
        return processedBadges;
    }, [slot.badges]);

    const imgSettings = slot.imageSettings || { x: 0, y: 0, scale: 1 };
    const totalScale = baseScale * imgSettings.scale;
    const imageTransform = `translate(${150 + imgSettings.x} ${190 + imgSettings.y}) scale(${totalScale}) translate(${-imgDims.width / 2} ${-imgDims.height / 2})`;

    // Badge Geometry Constants
    const BADGE_HEIGHT = 30; 

    return (
        <g 
            transform={`translate(${x}, ${y}) scale(${sizeScale})`}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
        >
            <foreignObject width="0" height="0">
                 <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
            </foreignObject>
            
            <g 
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                onWheel={handleWheel}
                onDoubleClick={(e) => { e.stopPropagation(); fileInputRef.current?.click(); }}
                onDragOver={(e) => e.preventDefault()}
                onDrop={handleDrop}
                style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
                clipPath="url(#mg-towerClip)"
            >
                 <image 
                    href={slot.image} 
                    width={imgDims.width}
                    height={imgDims.height}
                    transform={imageTransform}
                    preserveAspectRatio="none"
                    style={{ transition: isDragging ? 'none' : 'transform 0.2s ease' }}
                />
            </g>

            <rect width="300" height="380" fill="url(#mg-glassGradient)" clipPath="url(#mg-towerClip)" pointerEvents="none"></rect>
            
            <path d="M 0,0 L 300,0 L 300,120 L 290,125 L 300,130 L 300,250 L 290,260 L 290,290 L 300,300 L 300,350 L 270,380 L 30,380 L 0,350 L 0,300 L 10,290 L 10,260 L 0,250 L 0,130 L 10,125 L 0,120 Z" 
                  fill="none" stroke="#556070" strokeWidth="2" pointerEvents="none" />
            
            <path d="M 0,300 L 0,350 L 30,380" fill="none" stroke="#00FFF0" strokeWidth="4" filter="url(#mg-activeGlow)" />
            <path d="M 300,300 L 300,350 L 270,380" fill="none" stroke="#00FFF0" strokeWidth="4" filter="url(#mg-activeGlow)" />
            <path d="M 10,260 L 10,290" fill="none" stroke="#00FFF0" strokeWidth="4" filter="url(#mg-activeGlow)" />
            <path d="M 290,260 L 290,290" fill="none" stroke="#00FFF0" strokeWidth="4" filter="url(#mg-activeGlow)" />

            {/* --- DATE TAG (RIGHT SIDE, FLIPPED) --- */}
            <g 
                transform="translate(240,0)" 
                onMouseDown={(e) => e.stopPropagation()}
                onClick={() => setEditingField('day')} // Explicit trigger
                style={{ cursor: 'text' }}
            >
                <g transform="scale(-1, 1) translate(-60, 0)">
                    <use href="#mg-cyberDateTag"></use>
                </g>
                <EditableText
                    x={30} 
                    y={35} 
                    text={slot.day}
                    // --- ADJUST FONT HERE (DATE) ---
                    fontSize={36}
                    fontWeight={900}
                    fontFamily="'Dystopian', 'Cairo', sans-serif"
                    // ------------------------------
                    align="middle"
                    style={{ fill: "#050505" }}
                    inputStyle={{ direction: 'ltr', fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                    onChange={(val) => onChange({ day: val })}
                    isEditing={editingField === 'day'}
                    setEditing={(val) => setEditingField(val ? 'day' : null)}
                    width={60}
                    inputDy={-5}
                />
            </g>
            
            {/* --- CASCADING BADGE STACK (LEFT SIDE) --- */}
            <g transform="translate(0, 0)">
                {calculatedBadges.map((badge, i) => {
                    const topY = i * BADGE_HEIGHT;
                    const bottomY = (i + 1) * BADGE_HEIGHT;
                    
                    const path = `
                        M 0,${topY} 
                        L ${badge.topWidth},${topY} 
                        L ${badge.bottomWidth},${bottomY} 
                        L 0,${bottomY} 
                        Z
                    `;
                    
                    const centerX = (badge.topWidth + badge.bottomWidth) / 4; 
                    const centerY = topY + (BADGE_HEIGHT / 2) + 5;
                    
                    const textColor = badge.color;

                    return (
                        <g 
                            key={badge.key} 
                            onClick={(e) => { 
                                e.stopPropagation(); 
                                if(badge.key === 'price') setEditingField('price');
                            }}
                            style={{ cursor: badge.key === 'price' ? 'text' : 'default' }}
                        >
                            <path d={path} fill="#050505" stroke={badge.color} strokeWidth="1.5"></path>
                            <path d={path} fill={badge.color} fillOpacity="0.15" stroke="none"></path>
                            
                            {badge.key === 'price' ? (
                                <EditableText
                                    x={centerX} y={centerY}
                                    text={badge.text}
                                    // --- ADJUST FONT HERE (PRICE BADGE) ---
                                    fontSize={19}
                                    fontWeight={700}
                                    fontFamily="'Dystopian', 'Cairo', sans-serif"
                                    // -------------------------------------
                                    align="middle"
                                    style={{ fill: badge.color }}
                                    inputStyle={{ direction: 'ltr' }}
                                    onChange={updatePriceText}
                                    isEditing={editingField === 'price'}
                                    setEditing={(val) => setEditingField(val ? 'price' : null)}
                                    width={badge.topWidth}
                                />
                            ) : (
                                <text 
                                    x={centerX} y={centerY} 
                                    textAnchor="middle" 
                                    // --- ADJUST FONT HERE (STATIC BADGES) ---
                                    fontWeight="bold" 
                                    fontSize="16" 
                                    fontFamily="'Dystopian', 'Cairo', sans-serif" 
                                    // ----------------------------------------
                                    fill={textColor}
                                    pointerEvents="none"
                                >
                                    {badge.text}
                                </text>
                            )}
                        </g>
                    );
                })}
            </g>
            
            {/* --- BADGE TOGGLE CONTROLS (Visible on Hover) --- */}
            <g 
                transform="translate(80, -30)" 
                opacity={isHovered ? 1 : 0} 
                style={{ transition: 'opacity 0.2s' }}
            >
                {BADGE_KEYS.map((key, i) => {
                    const config = BADGE_CONFIG[key];
                    const isActive = key === 'price' ? slot.badges.price.active : slot.badges[key as keyof typeof slot.badges];
                    
                    return (
                        <g 
                            key={key} 
                            transform={`translate(${i * 35}, 0)`}
                            onClick={(e) => { e.stopPropagation(); toggleBadge(key); }}
                            style={{ cursor: 'pointer' }}
                        >
                            <rect width="30" height="20" rx="4" fill={isActive ? config.color : "#1A202C"} stroke={config.color} strokeWidth="1" />
                            <text x="15" y="14" textAnchor="middle" fill={isActive ? "#000" : config.color} fontSize="10" fontWeight="bold">
                                {config.icon}
                            </text>
                        </g>
                    );
                })}
            </g>

            <foreignObject x="10" y="260" width="280" height="60" onMouseDown={(e) => e.stopPropagation()}>
                 <SocialNewsBodyEditor 
                    content={slot.title} 
                    onChange={(val) => onChange({ title: val })}
                    isEditing={editingField === 'title'}
                    setEditing={(val) => setEditingField(val ? 'title' : null)}
                    // --- ADJUST FONT HERE (GAME TITLE) ---
                    fontSize={30}
                    // -------------------------------------
                    textAlign="center"
                    customStyle={{ 
                        color: "#FFFFFF", 
                        fontFamily: "'Dystopian', 'Cairo', sans-serif",
                        fontWeight: 900,
                        textTransform: "none",
                        filter: "drop-shadow(0 2px 4px #000)",
                        lineHeight: 1.1,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        height: '100%'
                    }}
                    disableAutoEnglish={true}
                    autoHeight={true} 
                />
            </foreignObject>

            <g 
                transform="translate(20, 325)"
                onMouseDown={(e) => e.stopPropagation()}
                onDoubleClick={(e) => e.stopPropagation()}
            >
                <use href="#mg-glassDock" pointerEvents="none"></use>
                <g transform="translate(13, 8)">
                    {[
                        { key: 'PC', x: 0 },
                        { key: 'PS5', x: 70 },
                        { key: 'XSX', x: 140 },
                        { key: 'NSW', x: 210 },
                    ].map((p) => {
                        const Icon = PLATFORM_ICONS[p.key];
                        const isActive = slot.platforms[p.key as keyof typeof slot.platforms];
                        return (
                            <g 
                                key={p.key} 
                                transform={`translate(${p.x}, 0)`} 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handlePlatformToggle(e, p.key as keyof typeof slot.platforms);
                                }}
                                style={{ cursor: 'pointer' }}
                            >
                                <rect x="-10" y="-10" width="44" height="44" fill="transparent" />
                                <g 
                                    color={isActive ? (p.key === 'NSW' ? '#FF0055' : '#00FFF0') : '#AAA'} 
                                    style={{ opacity: isActive ? 1 : 0.3 }}
                                    filter={isActive ? "url(#mg-activeGlow)" : "none"}
                                >
                                    <Icon width={24} height={24} pointerEvents="none" />
                                    {isActive && <rect x="0" y="28" width="24" height="2" fill="currentColor" pointerEvents="none"></rect>}
                                </g>
                            </g>
                        );
                    })}
                </g>
            </g>
        </g>
    );
}

--- END OF FILE components/studio/social/monthly-games/GameSlot.tsx ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/MonthlyGamesCanvas.tsx ---

// components/studio/social/monthly-games/MonthlyGamesCanvas.tsx
'use client';

import React, { useState } from 'react';
import { MonthlyGamesCanvasProps } from './types';
import MonthlyGamesDefs from './MonthlyGamesDefs';
import GameSlot from './GameSlot';
import SpaceBackground from '../shared/SpaceBackground';
import EditableText from '../shared/EditableText';

const CARD_SCALE = 0.85;

const LOGO_PATH = "M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z";

export default function MonthlyGamesCanvas({ data, onDataChange, scale = 1 }: MonthlyGamesCanvasProps) {
    const [editingField, setEditingField] = useState<string | null>(null);

    const handleSlotChange = (index: number, newSlotData: Partial<typeof data.slots[0]>) => {
        const newSlots = [...data.slots];
        newSlots[index] = { ...newSlots[index], ...newSlotData };
        onDataChange({ slots: newSlots });
    };

    // Recalculated positions for smaller cards and a smaller header
    const X_POS = [79, 413, 746];
    const Y_POS = [250, 613, 976];

    // Default vibrance to 100 (1.0)
    const vibranceValue = (data.vibrance ?? 100) / 100;

    return (
        <div 
            className="canvas-container"
            id="monthly-games-canvas"
            style={{ 
                width: `${1080 * scale}px`, 
                height: `${1350 * scale}px`,
                transformOrigin: 'top left',
                position: 'relative',
                boxShadow: '0 0 50px rgba(0,0,0,0.5)',
                overflow: 'hidden'
            }}
        >
            <svg 
                viewBox="0 0 1080 1350" 
                width="100%" 
                height="100%" 
                xmlns="http://www.w3.org/2000/svg" 
                preserveAspectRatio="xMidYMid slice"
                style={{ 
                    backgroundColor: '#050505', 
                    direction: 'rtl',
                    // Apply Saturation Filter to the entire SVG
                    filter: `saturate(${vibranceValue})` 
                }}
            >
                <MonthlyGamesDefs />
                
                {/* SHARED BACKGROUND - Scanlines removed inside component */}
                <SpaceBackground />
                {/* REMOVED GRID OVERLAY */}
                {/* <rect width="100%" height="100%" fill="url(#mg-techGrid)"></rect> */}

                {/* SIMPLIFIED HEADER DESIGN */}
                <g transform="translate(540, 150) scale(0.8)">
                    <defs>
                        <linearGradient id="titleGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#FFFFFF" />
                            <stop offset="40%" stopColor="#00FFF0" />
                            <stop offset="100%" stopColor="#008F86" />
                        </linearGradient>

                        <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="3.5" result="blur" />
                            <feColorMatrix in="blur" type="matrix" values="
                                0 0 0 0 0
                                0 0 0 0 1
                                0 0 0 0 0.94
                                0 0 0 1 0" result="coloredBlur" />
                            <feMerge>
                                <feMergeNode in="coloredBlur" />
                                <feMergeNode in="SourceGraphic" />
                            </feMerge>
                        </filter>
                    </defs>
    
                    {/* BACKGROUND LOGO STROKE */}
                    <g transform="translate(-80, -170) scale(0.17)">
                        <path 
                            d={LOGO_PATH} 
                            fill="none" 
                            stroke="#00FFF0" 
                            strokeWidth="12" 
                            opacity="0.5" 
                        />
                    </g>

                    {/* TEXT GROUP */}
                    <EditableText
                        x={0} y={-70}
                        text="أهم ألعاب"
                        fontSize={35}
                        align="middle"
                        onChange={() => {}}
                        isEditing={false}
                        setEditing={() => {}}
                        style={{ fill: "#FFFFFF", letterSpacing: '2px', filter: "drop-shadow(0 0 10px rgba(255,255,255,0.4))", fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                        width={400}
                    />
                    
                    <EditableText
                        x={0} y={25}
                        text={data.month}
                        fontSize={90}
                        align="middle"
                        onChange={(val) => onDataChange({ month: val })}
                        isEditing={editingField === 'month'}
                        setEditing={(val) => setEditingField(val ? 'month' : null)}
                        style={{ fill: "url(#titleGradient)", textTransform: 'uppercase', filter: "url(#neonGlow)", fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                        width={600}
                    />
    
                    {/* Bottom Structure */}
                    <g transform="translate(0, 60)">
                        <rect x="-80" y="13" width="160" height="4" fill="#00FFF0" filter="url(#neonGlow)" />
                    </g>
                </g>
                
                {/* --- SLOTS --- */}
                <GameSlot slot={data.slots[0]} onChange={(d) => handleSlotChange(0, d)} x={X_POS[0]} y={Y_POS[0]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[1]} onChange={(d) => handleSlotChange(1, d)} x={X_POS[1]} y={Y_POS[0]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[2]} onChange={(d) => handleSlotChange(2, d)} x={X_POS[2]} y={Y_POS[0]} scale={scale} sizeScale={CARD_SCALE} />
                
                <GameSlot slot={data.slots[3]} onChange={(d) => handleSlotChange(3, d)} x={X_POS[0]} y={Y_POS[1]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[4]} onChange={(d) => handleSlotChange(4, d)} x={X_POS[1]} y={Y_POS[1]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[5]} onChange={(d) => handleSlotChange(5, d)} x={X_POS[2]} y={Y_POS[1]} scale={scale} sizeScale={CARD_SCALE} />
                
                <GameSlot slot={data.slots[6]} onChange={(d) => handleSlotChange(6, d)} x={X_POS[0]} y={Y_POS[2]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[7]} onChange={(d) => handleSlotChange(7, d)} x={X_POS[1]} y={Y_POS[2]} scale={scale} sizeScale={CARD_SCALE} />
                <GameSlot slot={data.slots[8]} onChange={(d) => handleSlotChange(8, d)} x={X_POS[2]} y={Y_POS[2]} scale={scale} sizeScale={CARD_SCALE} />


                {/* WATERMARK */}
                <g transform="translate(540, 1345)">
                    <text x="0" y="-12" textAnchor="middle" fontWeight="bold" fontSize="16" fill="#00FFF0" fontFamily="'Dystopian', 'Cairo', sans-serif">1EternalGames // @MovisionX@</text>
                </g>

                <rect width="100%" height="100%" filter="url(#mg-grain)" opacity="0.06" style={{ mixBlendMode: 'overlay' }} pointerEvents="none"></rect>
            </svg>
        </div>
    );
}

--- END OF FILE components/studio/social/monthly-games/MonthlyGamesCanvas.tsx ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/MonthlyGamesDefs.tsx ---

// components/studio/social/monthly-games/MonthlyGamesDefs.tsx
import React from 'react';

export default function MonthlyGamesDefs() {
    return (
        <defs>
            <linearGradient id="mg-abyssalDepth" x1="50%" y1="0%" x2="50%" y2="100%">
                <stop offset="0%" stopColor="#0B0D12"></stop>
                <stop offset="40%" stopColor="#10121A"></stop>
                <stop offset="100%" stopColor="#1A1E29"></stop>
            </linearGradient>
            
            <pattern id="mg-techGrid" x="0" y="0" width="40" height="40" patternUnits="userSpaceOnUse">
                <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#556070" strokeWidth="0.5" opacity="0.1"></path>
                <circle cx="0" cy="0" r="1" fill="#00FFF0" opacity="0.3"></circle>
            </pattern>

            <filter id="mg-grain">
                <feTurbulence type="fractalNoise" baseFrequency="0.6" numOctaves="3" stitchTiles="stitch"></feTurbulence>
                <feColorMatrix type="matrix" values="0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 -1.5 1.5"></feColorMatrix>
            </filter>

            <filter id="mg-activeGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                    <feMergeNode in="coloredBlur"></feMergeNode>
                    <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
            </filter>

            <linearGradient id="mg-glassGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#050505" stopOpacity="0"></stop>
                <stop offset="50%" stopColor="#050505" stopOpacity="0.2"></stop>
                <stop offset="85%" stopColor="#050505" stopOpacity="0.9"></stop>
                <stop offset="100%" stopColor="#050505" stopOpacity="0.98"></stop>
            </linearGradient>

            <clipPath id="mg-towerClip">
                {/* Updated path: removed top-left cut (M 0,0) */}
                <path d="M 0,0 L 300,0 L 300,120 L 290,125 L 300,130 L 300,250 L 290,260 L 290,290 L 300,300 L 300,350 L 270,380 L 30,380 L 0,350 L 0,300 L 10,290 L 10,260 L 0,250 L 0,130 L 10,125 L 0,120 Z"></path>
            </clipPath>
            
             <g id="mg-glassDock">
                <line x1="10" y1="0" x2="250" y2="0" stroke="#00FFF0" strokeWidth="1" opacity="0.3"></line>
                <path d="M 10,0 L 10,5" stroke="#00FFF0" strokeWidth="1"></path>
                <path d="M 250,0 L 250,5" stroke="#00FFF0" strokeWidth="1"></path>
                <line x1="52" y1="8" x2="52" y2="28" stroke="#556070" strokeWidth="1" opacity="0.3"></line>
                <line x1="104" y1="8" x2="104" y2="28" stroke="#556070" strokeWidth="1" opacity="0.3"></line>
                <line x1="156" y1="8" x2="156" y2="28" stroke="#556070" strokeWidth="1" opacity="0.3"></line>
                <line x1="208" y1="8" x2="208" y2="28" stroke="#556070" strokeWidth="1" opacity="0.3"></line>
            </g>

            <g id="mg-cyberDateTag">
                <path d="M 0,0 L 60,0 L 60,35 L 45,50 L 0,50 Z" fill="#00FFF0"></path>
                <rect x="0" y="0" width="5" height="50" fill="#050505" opacity="0.3"></rect>
                <rect x="42" y="44" width="8" height="2" fill="#050505" opacity="0.6"></rect>
            </g>
        </defs>
    );
}




--- END OF FILE components/studio/social/monthly-games/MonthlyGamesDefs.tsx ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/SmartFillerMonthly.tsx ---

// components/studio/social/monthly-games/SmartFillerMonthly.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { getReleasesForMonthAction, SmartFillRelease } from '@/app/studio/social-templates/monthly-games/actions';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader';

interface SmartFillerMonthlyProps {
    isOpen: boolean;
    onClose: () => void;
    onApply: (selectedReleases: SmartFillRelease[], monthName: string) => void;
}

const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];

export default function SmartFillerMonthly({ isOpen, onClose, onApply }: SmartFillerMonthlyProps) {
    // Default to current month
    const now = new Date();
    const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    
    const [selectedMonth, setSelectedMonth] = useState(currentMonthStr);
    const [releases, setReleases] = useState<SmartFillRelease[]>([]);
    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
    const [isPending, startTransition] = useTransition();

    useEffect(() => {
        if (isOpen && selectedMonth) {
            handleFetch(selectedMonth);
        }
    }, [isOpen]);

    const handleFetch = (dateVal: string) => {
        startTransition(async () => {
            const data = await getReleasesForMonthAction(dateVal);
            setReleases(data);
            // Auto-select first 9 if available
            const preSelect = new Set(data.slice(0, 9).map(r => r._id));
            setSelectedIds(preSelect);
        });
    };

    const handleMonthChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const val = e.target.value;
        setSelectedMonth(val);
        handleFetch(val);
    };

    const toggleSelection = (id: string) => {
        const newSet = new Set(selectedIds);
        if (newSet.has(id)) {
            newSet.delete(id);
        } else {
            if (newSet.size >= 9) return; // Limit to 9
            newSet.add(id);
        }
        setSelectedIds(newSet);
    };

    const handleApply = () => {
        // Filter releases to maintain original sort order (by date)
        const selectedReleases = releases.filter(r => selectedIds.has(r._id));
        
        // Get Arabic month name
        const [year, month] = selectedMonth.split('-');
        // CHANGED: Replaced "ألعاب" with "شهر"
        const monthName = `شهر ${arabicMonths[parseInt(month) - 1]}`; // e.g. "شهر نوفمبر"

        onApply(selectedReleases, monthName);
        onClose();
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '700px', width: '100%' }}>
            <h3 style={{ marginTop: 0, marginBottom: '0.5rem', fontFamily: 'var(--font-main)' }}>الملء الذكي للإصدارات</h3>
            <p style={{ color: 'var(--text-secondary)', fontSize: '1.4rem', marginBottom: '2rem' }}>
                اختر الشهر وحدد حتى 9 ألعاب لملء القالب تلقائيًا.
            </p>

            <div style={{ marginBottom: '2rem', display: 'flex', gap: '1rem', alignItems: 'center' }}>
                <input 
                    type="month" 
                    value={selectedMonth} 
                    onChange={handleMonthChange} 
                    className="profile-input" 
                    style={{ maxWidth: '200px' }}
                />
                {isPending && <span className="spinner" style={{ width: '20px', height: '20px' }}></span>}
            </div>

            <div style={{ 
                maxHeight: '400px', 
                overflowY: 'auto', 
                display: 'grid', 
                gridTemplateColumns: 'repeat(auto-fill, minmax(140px, 1fr))', 
                gap: '1rem',
                padding: '0.5rem'
            }}>
                {releases.length === 0 && !isPending && (
                    <p style={{ gridColumn: '1 / -1', textAlign: 'center', color: 'var(--text-secondary)' }}>لا توجد إصدارات مسجلة لهذا الشهر.</p>
                )}

                {releases.map(release => {
                    const isSelected = selectedIds.has(release._id);
                    const isFull = selectedIds.size >= 9 && !isSelected;
                    
                    return (
                        <div 
                            key={release._id}
                            onClick={() => !isFull && toggleSelection(release._id)}
                            style={{
                                position: 'relative',
                                borderRadius: '8px',
                                overflow: 'hidden',
                                border: isSelected ? '2px solid var(--accent)' : '1px solid var(--border-color)',
                                cursor: isFull ? 'not-allowed' : 'pointer',
                                opacity: isFull ? 0.5 : 1,
                                transition: 'all 0.2s ease',
                                aspectRatio: '3/4'
                            }}
                        >
                            {release.imageUrl ? (
                                <Image 
                                    loader={sanityLoader} 
                                    src={release.imageUrl} 
                                    alt={release.title} 
                                    fill 
                                    style={{ objectFit: 'cover' }}
                                    sizes="150px"
                                />
                            ) : (
                                <div style={{ width: '100%', height: '100%', background: '#111' }} />
                            )}
                            
                            <div style={{
                                position: 'absolute',
                                bottom: 0, left: 0, right: 0,
                                background: 'rgba(0,0,0,0.8)',
                                padding: '0.5rem',
                                fontSize: '1.1rem',
                                color: '#fff',
                                textAlign: 'center'
                            }}>
                                <div style={{ fontWeight: 'bold', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{release.title}</div>
                                <div style={{ fontSize: '1rem', color: 'var(--accent)' }}>{release.releaseDate.split('-')[2]}</div>
                            </div>

                            {isSelected && (
                                <div style={{
                                    position: 'absolute', top: '5px', right: '5px',
                                    background: 'var(--accent)', borderRadius: '50%',
                                    width: '20px', height: '20px', display: 'flex', alignItems: 'center', justifyContent: 'center'
                                }}>
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#000" strokeWidth="4"><polyline points="20 6 9 17 4 12"></polyline></svg>
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>

            <div className={modalStyles.modalActions} style={{ marginTop: '2rem', justifyContent: 'space-between', alignItems: 'center' }}>
                <span style={{ color: selectedIds.size === 9 ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: 'bold' }}>
                    تم تحديد {selectedIds.size} / 9
                </span>
                <div style={{ display: 'flex', gap: '1rem' }}>
                    <button onClick={onClose} className="outline-button">إلغاء</button>
                    <button onClick={handleApply} className="primary-button" disabled={selectedIds.size === 0}>
                        تطبيق ({selectedIds.size})
                    </button>
                </div>
            </div>
        </Modal>
    );
}

--- END OF FILE components/studio/social/monthly-games/SmartFillerMonthly.tsx ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/types.ts ---

// components/studio/social/monthly-games/types.ts

export interface GameSlotData {
    id: number;
    title: string;
    day: string;
    image: string;
    platforms: {
        PC: boolean;
        PS5: boolean;
        XSX: boolean;
        NSW: boolean;
    };
    badges: {
        gamePass: boolean;
        psPlus: boolean;
        exclusive: boolean;
        price: {
            active: boolean;
            text: string;
        };
    };
    imageSettings: { x: number; y: number; scale: number };
}

export interface MonthlyGamesTemplateData {
    month: string;
    slots: GameSlotData[];
    // NEW: Vibrance level (0-200, default 100)
    vibrance?: number;
}

export interface MonthlyGamesCanvasProps {
    data: MonthlyGamesTemplateData;
    onDataChange: (newData: Partial<MonthlyGamesTemplateData>) => void;
    scale?: number;
}

--- END OF FILE components/studio/social/monthly-games/types.ts ---

================================================================================

--- START OF FILE components/studio/social/monthly-games/utils.tsx ---

// components/studio/social/monthly-games/utils.tsx
'use client';

import React from 'react';
import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

export const PLATFORM_ICONS: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    PC: PCIcon,
    PS5: PS5Icon,
    XSX: XboxIcon,
    NSW: SwitchIcon,
};

--- END OF FILE components/studio/social/monthly-games/utils.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardCanvas.tsx ---

// components/studio/social/review-card/ReviewCardCanvas.tsx
'use client';

import React, { useState } from 'react';
import { ReviewCardCanvasProps } from './types';
import ReviewCardDefs from './ReviewCardDefs';
import ReviewCardFrame from './ReviewCardFrame';
import ReviewCardImage from './ReviewCardImage';
import ReviewCardTitle from './ReviewCardTitle';
import ReviewCardScore from './ReviewCardScore';
import ReviewCardVerdict from './ReviewCardVerdict';
import ReviewCardProsCons from './ReviewCardProsCons';
import ReviewCardPlatforms from './ReviewCardPlatforms';
import SpaceBackground from '../shared/SpaceBackground';

const LOGO_PATH = "M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z";

export default function ReviewCardCanvas({ data, onDataChange, scale = 1, editMode = 'image' }: ReviewCardCanvasProps) {
    const [editingField, setEditingField] = useState<string | null>(null);

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
        if (e.dataTransfer.files?.[0]?.type.startsWith('image/')) {
             const reader = new FileReader();
            reader.onload = (ev) => { if(ev.target?.result) onDataChange({ image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } }); };
            reader.readAsDataURL(e.dataTransfer.files[0]);
        }
    };
    
    // Default Vibrance: 100 (1.0)
    const vibranceValue = (data.vibrance ?? 100) / 100;
    
    // Default Opacity: 100 (1.0)
    const creditsOpacityValue = (data.creditsOpacity ?? 100) / 100;

    // Diamond Path Helper
    // Draws a diamond shape centered at cx, cy with size s
    const drawDiamond = (cx: number, cy: number, s: number) => {
        const h = s / 2;
        return `M ${cx},${cy - h} L ${cx + h},${cy} L ${cx},${cy + h} L ${cx - h},${cy} Z`;
    };

    return (
        <div 
            className="canvas-container"
            id="review-card-canvas"
            style={{ 
                width: `${1080 * scale}px`, 
                height: `${1350 * scale}px`,
                transformOrigin: 'top left',
                position: 'relative',
                boxShadow: '0 0 50px rgba(0,0,0,0.5)',
                overflow: 'hidden'
            }}
            onDragOver={(e) => e.preventDefault()}
            onDrop={handleDrop}
        >
            <svg 
                viewBox="0 0 1080 1350" 
                width="100%" 
                height="100%" 
                xmlns="http://www.w3.org/2000/svg" 
                preserveAspectRatio="xMidYMid slice"
                style={{ 
                    backgroundColor: '#050505', 
                    direction: 'ltr',
                    // Apply Global Saturation Here
                    filter: `saturate(${vibranceValue})` 
                }}
            >
                <ReviewCardDefs />
                
                {/* Global Background */}
                <SpaceBackground />
                
                <ReviewCardFrame enChar={data.gameTitleEnBottom ? data.gameTitleEnBottom.charAt(0) : 'R'} />
                
                <ReviewCardImage 
                    data={data} 
                    onDataChange={onDataChange} 
                    scale={scale} 
                    editMode={editMode}
                />

                <ReviewCardTitle 
                    data={data} 
                    onDataChange={onDataChange} 
                    editingField={editingField} 
                    setEditingField={setEditingField} 
                />
                
                <ReviewCardScore 
                    data={data} 
                    onDataChange={onDataChange} 
                    editingField={editingField} 
                    setEditingField={setEditingField} 
                />

                <ReviewCardVerdict 
                    data={data} 
                    onDataChange={onDataChange} 
                    editingField={editingField} 
                    setEditingField={setEditingField} 
                />

                <ReviewCardProsCons 
                    data={data} 
                    onDataChange={onDataChange} 
                    editingField={editingField} 
                    setEditingField={setEditingField} 
                />

                <ReviewCardPlatforms 
                    data={data} 
                    onDataChange={onDataChange} 
                    editingField={editingField} 
                    setEditingField={setEditingField} 
                />
                
                {/* --- CREDITS FOOTER (Option 1: Cyber Diamonds) --- */}
                {/* FIXED: Removed rotation transforms. Used explicit diamond paths. */}
                <g transform="translate(45, 1295)" style={{ opacity: creditsOpacityValue }}>
                    {/* Left Diamond: Positioned relative to text start */}
                    <path 
                        d={drawDiamond(35, 25, 12)} 
                        fill="#00FFF0" 
                        filter="url(#review-cyanGlow)" 
                    />
                    
                    {/* Right Diamond: Positioned relative to text end */}
                    <path 
                        d={drawDiamond(385, 25, 12)} 
                        fill="#00FFF0" 
                    />

                    <text 
                        x="210" 
                        y="30" 
                        textAnchor="middle"
                        fill="#00FFF0" 
                        fontSize="16" 
                        fontFamily="'Cairo', sans-serif" 
                        fontWeight="bold" 
                        letterSpacing="1"
                        style={{ filter: "drop-shadow(0 0 5px rgba(0, 255, 240, 0.5))" }}
                    >
                        @1EternalGames // @MoVisionX تصميم
                    </text>
                </g>

                {/* --- BRANDING CORNER (TOP LEFT) --- */}
                <g>
                    <defs>
                        <clipPath id="brandCornerClip">
                            {/* Shape: 125x125 Box with chamfered bottom-right */}
                            <path d="M 0,0 L 125,0 L 125,90 L 90,125 L 0,125 Z" />
                        </clipPath>
                        {/* Modified Gradient: Originates from Top Right (125, 0) */}
                        <radialGradient id="logoBacklight" cx="125" cy="0" r="140" gradientUnits="userSpaceOnUse">
                            <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.3" />
                            <stop offset="100%" stopColor="#000000" stopOpacity="0" />
                        </radialGradient>
                    </defs>

                    {/* 0. Occlusion Layer (Hides card frame borders underneath) */}
                    <path d="M 0,0 L 125,0 L 125,90 L 90,125 L 0,125 Z" fill="#000000" />

                    {/* 1. Background Masked to Shape */}
                    <g clipPath="url(#brandCornerClip)">
                        {/* Scaled SpaceBackground to increase density of stars/nebula */}
                        <g transform="scale(0.6)" style={{ filter: 'brightness(1.6) saturate(1.4)' }}>
                            <SpaceBackground />
                        </g>
                        
                        {/* Cyan Backlight (Top-Right Source) */}
                        <rect x="0" y="0" width="125" height="125" fill="url(#logoBacklight)" />
                    </g>

                    {/* 2. The Border Frame (Bottom & Right Only - Top/Left Borderless) */}
                    <path 
                        d="M 0,125 L 90,125 L 125,90 L 125,0" 
                        fill="none" 
                        stroke="#00FFF0" 
                        strokeWidth="3"
                        filter="url(#review-cyanGlow)"
                    />
                    
                    {/* Inner Tech Accent Line (Inset) */}
                    <path 
                        d="M 6,119 L 88,119 L 119,88 L 119,6" 
                        fill="none" 
                        stroke="#00FFF0" 
                        strokeWidth="1"
                        opacity="0.6"
                    />

                    {/* 3. The Logo */}
                    <g transform="translate(38, 25) scale(0.045)">
                        <path fill="#00FFF0" d={LOGO_PATH} filter="url(#review-cyanGlow)" />
                    </g>
                </g>

            </svg>
        </div>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardCanvas.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardDefs.tsx ---

// components/studio/social/review-card/ReviewCardDefs.tsx
import React from 'react';

export default function ReviewCardDefs() {
    return (
        <defs>
            <linearGradient id="review-monolithFade" x1="0%" y1="100%" x2="0%" y2="0%">
                <stop offset="0%" stopColor="#000" stopOpacity="0.9"></stop>
                <stop offset="60%" stopColor="#000" stopOpacity="0.1"></stop>
                <stop offset="100%" stopColor="#000" stopOpacity="0"></stop>
            </linearGradient>
            <linearGradient id="review-glassGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="#151820" stopOpacity="0.95"></stop>
                <stop offset="100%" stopColor="#080A0F" stopOpacity="0.98"></stop>
            </linearGradient>
            <linearGradient id="review-titleHeaderGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stopColor="#151820"></stop>
                <stop offset="100%" stopColor="#0B0D12"></stop>
            </linearGradient>
            <linearGradient id="review-proGradient" x1="100%" y1="0%" x2="0%" y2="0%">
                <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.2"></stop>
                <stop offset="100%" stopColor="#00FFF0" stopOpacity="0"></stop>
            </linearGradient>
            
            <linearGradient id="review-conGradient" x1="100%" y1="0%" x2="0%" y2="0%">
                <stop offset="0%" stopColor="#FF0055" stopOpacity="0.2"></stop>
                <stop offset="100%" stopColor="#FF0055" stopOpacity="0"></stop>
            </linearGradient>
            <linearGradient id="review-activeModule" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#0F1115"></stop>
                <stop offset="100%" stopColor="#050608"></stop>
            </linearGradient>
            <linearGradient id="review-beamGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#00FFF0" stopOpacity="0"></stop>
                <stop offset="100%" stopColor="#00FFF0" stopOpacity="0.15"></stop>
            </linearGradient>
                <pattern id="review-inactiveModule" x="0" y="0" width="10" height="10" patternUnits="userSpaceOnUse">
                    <line x1="0" y1="0" x2="10" y2="10" stroke="#1A202C" strokeWidth="1" />
            </pattern>
            <pattern id="review-microGrid" x="0" y="0" width="40" height="40" patternUnits="userSpaceOnUse">
                <rect x="0" y="0" width="40" height="40" fill="none" stroke="#1A202C" strokeWidth="1" opacity="0.3"></rect>
                <circle cx="20" cy="20" r="1" fill="#00FFF0" opacity="0.3"></circle>
            </pattern>
            <pattern id="review-hexTech" x="0" y="0" width="20" height="34.64" patternUnits="userSpaceOnUse">
                <path d="M10 0 L20 5 L20 15 L10 20 L0 15 L0 5 Z" fill="none" stroke="#00FFF0" strokeWidth="0.5" opacity="0.1"></path>
            </pattern>
            <pattern id="review-holoScan" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse">
                <rect x="0" y="0" width="2" height="2" fill="#000" opacity="0.3"/>
                <rect x="2" y="2" width="2" height="2" fill="#000" opacity="0.3"/>
            </pattern>
            <filter id="review-cyanGlow">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                    <feMergeNode in="coloredBlur"></feMergeNode>
                    <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
            </filter>
                <filter id="review-redGlow">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                    <feMergeNode in="coloredBlur"></feMergeNode>
                    <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
            </filter>
            <filter id="review-grain">
                <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"></feTurbulence>
                <feColorMatrix type="saturate" values="0"></feColorMatrix>
            </filter>
            <filter id="platformGlow">
                <feGaussianBlur stdDeviation="2" result="blur" />
                <feFlood floodColor="#00FFF0" result="color" />
                <feComposite in="color" in2="blur" operator="in" result="glow" />
                <feMerge>
                    <feMergeNode in="glow" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>
            <mask id="review-holoMask">
                 <rect x="-100" y="-100" width="200" height="200" fill="white"/>
                 <rect x="-100" y="-100" width="200" height="200" fill="url(#review-holoScan)"/>
            </mask>
            <clipPath id="review-monolithClip">
                <path d="M 0,0 L 500,0 L 540,40 L 540,400 L 500,440 L 500,900 L 540,940 L 540,1310 L 500,1350 L 0,1350 Z"></path>
            </clipPath>
            <clipPath id="review-prismClip">
                <path d="M 40,0 L 460,0 L 460,180 L 420,220 L 0,220 L 0,40 Z"></path>
            </clipPath>
            <clipPath id="review-moduleClip">
                <path d="M 0,0 L 70,0 L 80,10 L 80,50 L 10,50 L 0,40 Z"></path>
            </clipPath>
            <clipPath id="review-titleBodyClip">
                <path d="M 0,0 L 480,0 L 480,90 L 460,110 L 0,110 Z"></path>
            </clipPath>
            <clipPath id="review-baseClip">
                 <path d="M 0,0 L 600,0 L 600,40 L 580,60 L 20,60 L 0,40 Z" />
            </clipPath>
        </defs>
    );
}




--- END OF FILE components/studio/social/review-card/ReviewCardDefs.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardFrame.tsx ---

// components/studio/social/review-card/ReviewCardFrame.tsx
import React from 'react';

export default function ReviewCardFrame({ enChar }: { enChar: string }) {
    const cyanFramePath = "M 500,0 L 540,40 L 540,400 L 500,440 L 500,900 L 540,940 L 540,1310 L 500,1350";
    const framePathD = "M 0,0 L 500,0 L 540,40 L 540,400 L 500,440 L 500,900 L 540,940 L 540,1310 L 500,1350 L 0,1350";

    return (
        <>
            {/* Background elements are handled by SpaceBackground in parent */}
            
            <path 
                d={framePathD} 
                fill="none" 
                stroke="#00FFF0" 
                strokeWidth="9" 
                filter="url(#review-cyanGlow)"
                pointerEvents="none"
            />
            
            <path 
                d={cyanFramePath} 
                stroke="#00FFF0" 
                strokeWidth="4" 
                fill="none" 
                filter="drop-shadow(0 0 15px #00FFF0)"
                pointerEvents="none"
            />
            
            <g stroke="#556070" strokeWidth="1">
                <line x1="500" y1="440" x2="580" y2="440"></line> <rect x="530" y="435" width="10" height="10" fill="#00FFF0"></rect>
                <line x1="500" y1="900" x2="580" y2="900"></line> <rect x="530" y="895" width="10" height="10" fill="#00FFF0"></rect>
            </g>

            <rect width="100%" height="100%" filter="url(#review-grain)" opacity="0.2" pointerEvents="none" style={{ mixBlendMode: 'overlay' }}></rect>
        </>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardFrame.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardImage.tsx ---

// components/studio/social/review-card/ReviewCardImage.tsx
'use client';

import React, { useRef, useState, useEffect } from 'react';
import { ReviewTemplateData } from './types';

interface ReviewCardImageProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    scale: number;
    editMode?: 'image' | 'gradient'; // Added prop
}

export default function ReviewCardImage({ data, onDataChange, scale, editMode = 'image' }: ReviewCardImageProps) {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const dragStart = useRef({ x: 0, y: 0 });
    const initialPos = useRef({ x: 0, y: 0 }); // Shared ref for starting pos
    const [imgDims, setImgDims] = useState({ width: 700, height: 1350 });
    const [baseScale, setBaseScale] = useState(1);

    useEffect(() => {
        const img = new Image();
        img.src = data.image;
        img.onload = () => {
            const w = img.naturalWidth || 700;
            const h = img.naturalHeight || 1350;
            setImgDims({ width: w, height: h });
            const scaleW = 700 / w; 
            const scaleH = 1350 / h;
            setBaseScale(Math.max(scaleW, scaleH));
        };
    }, [data.image]);

    const handleMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 0) return;
        e.preventDefault(); e.stopPropagation();
        setIsDragging(true);
        dragStart.current = { x: e.clientX, y: e.clientY };
        
        if (editMode === 'gradient') {
             // Use gradient settings
             const gSettings = data.gradientSettings || { x: 0, y: 0 };
             initialPos.current = { x: gSettings.x, y: gSettings.y };
        } else {
             // Use image settings
             initialPos.current = { x: data.imageSettings.x, y: data.imageSettings.y };
        }
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;
        e.preventDefault(); e.stopPropagation();
        const dx = (e.clientX - dragStart.current.x) / scale;
        const dy = (e.clientY - dragStart.current.y) / scale;
        
        if (editMode === 'gradient') {
            const gSettings = data.gradientSettings || { active: true, x: 0, y: 0, opacity: 50, scale: 1.5 };
            onDataChange({ 
                gradientSettings: { 
                    ...gSettings, 
                    x: initialPos.current.x + dx, 
                    y: initialPos.current.y + dy 
                } 
            });
        } else {
            onDataChange({ 
                imageSettings: { 
                    ...data.imageSettings, 
                    x: initialPos.current.x + dx, 
                    y: initialPos.current.y + dy 
                } 
            });
        }
    };

    const handleMouseUp = () => setIsDragging(false);

    const handleWheel = (e: React.WheelEvent) => {
        e.stopPropagation();
        const delta = e.deltaY * 0.001;
        
        if (editMode === 'gradient') {
             const gSettings = data.gradientSettings || { active: true, x: 0, y: 0, opacity: 50, scale: 1.5 };
             const newScale = Math.max(0.1, Math.min(5, gSettings.scale - delta));
             onDataChange({ gradientSettings: { ...gSettings, scale: newScale }});
        } else {
             const settings = data.imageSettings;
             const newScale = Math.max(0.5, Math.min(5, settings.scale - delta));
             onDataChange({ imageSettings: { ...settings, scale: newScale } });
        }
    };

    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if(ev.target?.result) {
                    onDataChange({ image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } });
                }
            };
            reader.readAsDataURL(file);
        }
    };

    const imgSettings = data.imageSettings;
    const totalScale = baseScale * imgSettings.scale;
    const imageTransform = `translate(${270 + imgSettings.x} ${675 + imgSettings.y}) scale(${totalScale}) translate(${-imgDims.width / 2} ${-imgDims.height / 2})`;

    // TINT LOGIC
    // Global Tint (Linear Wash)
    const tintOpacity = (data.tintStrength ?? 0) / 100;
    const atmosphereOpacity = tintOpacity; // 0 to 1

    // GRADIENT LOGIC (The "Spotlight")
    const gradSettings = data.gradientSettings || { x: 0, y: 0, opacity: 50, scale: 1.5 };
    const gradOpacity = gradSettings.opacity / 100;
    
    // We define a unique ID for the gradient to allow moving it
    const gradId = `spotlight-${data.id}`;
    
    // Center of the viewBox is 540, 675. 
    // We start the gradient there, then translate it by user's X/Y.
    const gradCx = 540 + gradSettings.x;
    const gradCy = 675 + gradSettings.y;
    // Scale is applied to the radius
    const gradRadius = 800 * gradSettings.scale; 

    return (
        <>
            <defs>
                <radialGradient id={gradId} gradientUnits="userSpaceOnUse" cx={gradCx} cy={gradCy} r={gradRadius}>
                    <stop offset="0%" stopColor="#00FFF0" stopOpacity={gradOpacity} />
                    <stop offset="100%" stopColor="#00FFF0" stopOpacity="0" />
                </radialGradient>
            </defs>
            
            <foreignObject width="0" height="0">
                 <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
            </foreignObject>
            
            <g clipPath="url(#review-monolithClip)">
                    <g 
                        id="upload-zone" 
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onWheel={handleWheel}
                        onDoubleClick={() => fileInputRef.current?.click()}
                        style={{ cursor: isDragging ? 'grabbing' : 'pointer' }}
                    >
                        {/* 1. THE IMAGE ITSELF */}
                        <image 
                            href={data.image} 
                            width={imgDims.width}
                            height={imgDims.height}
                            preserveAspectRatio="none" 
                            style={{transition: (isDragging && editMode === 'image') ? 'none' : 'transform 0.2s ease'}}
                            transform={imageTransform} 
                        />
                        
                        {/* 2. ATMOSPHERE TINT (Global Wash) */}
                        <rect 
                            width="1080" height="1350" 
                            fill="#00FFF0" 
                            opacity={atmosphereOpacity} 
                            style={{ mixBlendMode: 'overlay', pointerEvents: 'none' }} 
                        />
                        
                        {/* 3. MOVABLE GRADIENT SPOTLIGHT (New Layer) */}
                        <rect 
                            width="1080" height="1350" 
                            fill={`url(#${gradId})`}
                            style={{ mixBlendMode: 'overlay', pointerEvents: 'none', transition: (isDragging && editMode === 'gradient') ? 'none' : 'all 0.1s ease' }} 
                        />
                    </g>
                    
                    {/* Shadow Overlay */}
                    <rect width="540" height="1350" fill="url(#review-monolithFade)" pointerEvents="none"></rect>
            </g>
        </>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardImage.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardPlatforms.tsx ---

// components/studio/social/review-card/ReviewCardPlatforms.tsx
'use client';

import React from 'react';
import { ReviewTemplateData } from './types';
import { PLATFORM_ICONS } from './utils';

interface ReviewCardPlatformsProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    editingField: string | null;
    setEditingField: (field: string | null) => void;
}

export default function ReviewCardPlatforms({ data, onDataChange }: ReviewCardPlatformsProps) {
    
    // --- LAYOUT CONFIGURATION ---
    const SIZE_SCALE = 1.25;
    const START_X_POS = 625;
    const ITEM_SPACING = 100;
    const Y_POS = 1270;
    
    // Controls the horizontal centering of the icon within its slot
    const ICON_X_OFFSET = -19; 
    
    // Controls how high the light beam goes and where the icon sits
    const LIGHT_FARNESS = 55; 

    const handlePlatformToggle = (key: keyof typeof data.platforms) => {
        onDataChange({ platforms: { ...data.platforms, [key]: !data.platforms[key] } });
    };

    const platformsList = ['PC', 'PS5', 'XSX', 'NSW'] as const;

    // Derived geometry based on farness
    const beamHeight = LIGHT_FARNESS + 10;
    const scanlineY = LIGHT_FARNESS / 2;

    return (
        <g transform={`translate(${START_X_POS}, ${Y_POS}) scale(${SIZE_SCALE})`}>
            <g>
                {platformsList.map((key, index) => {
                    const isActive = data.platforms[key];
                    const Icon = PLATFORM_ICONS[key];
                    const opacity = isActive ? 1 : 0.3;
                    
                    // FIXED: Icons should be White when active, Grey when inactive
                    const fillColor = isActive ? "#FFFFFF" : "#556070";
                    
                    // Calculate X position based on spacing
                    const x = index * ITEM_SPACING;

                    return (
                        <g 
                            key={key} 
                            transform={`translate(${x}, 0)`} 
                            onClick={() => handlePlatformToggle(key)} 
                            style={{ cursor: 'pointer', transition: 'opacity 0.2s' }}
                        >
                            {/* --- EMITTER BASE --- */}
                            {/* Mechanical Housing */}
                            <path 
                                d="M -30,20 L -25,10 L 25,10 L 30,20 L 25,30 L -25,30 Z" 
                                fill="#0B0D12" 
                                stroke={isActive ? "#00FFF0" : "#333"} 
                                strokeWidth={isActive ? "2" : "1"}
                            />
                            
                            {/* Glowing Lens Center */}
                            <ellipse 
                                cx="0" cy="10" rx="15" ry="3" 
                                fill={isActive ? "#00FFF0" : "#556070"} 
                                opacity={isActive ? 1 : 0.2}
                                filter={isActive ? "url(#review-cyanGlow)" : "none"}
                            />

                            {/* --- PROJECTION BEAM --- */}
                            <path 
                                d={`M -15,10 L 15,10 L 25,-${beamHeight} L -25,-${beamHeight} Z`}
                                fill="url(#review-beamGradient)" 
                                opacity={isActive ? 0.8 : 0}
                                style={{ mixBlendMode: 'screen' }}
                            />
                            
                            {/* Scanline Effect in Beam */}
                            {isActive && (
                                <path 
                                    d={`M -20,-${scanlineY} L 20,-${scanlineY}`}
                                    stroke="#00FFF0" 
                                    strokeWidth="1" 
                                    opacity="0.3"
                                />
                            )}

                            {/* --- HOLOGRAPHIC ICON --- */}
                            <g 
                                transform={`translate(${ICON_X_OFFSET}, -${LIGHT_FARNESS}) scale(1.6)`} 
                                opacity={opacity}
                                // FIXED: Apply Cyan Drop Shadow for Hologram Effect
                                filter={isActive ? "drop-shadow(0 0 8px rgba(0,255,240,0.8))" : "none"}
                                // FIXED: Explicitly set color style to ensure export picks up the fill correctly
                                style={{ color: fillColor }}
                            >
                                <g fill={fillColor}>
                                    <Icon width="24" height="24" />
                                </g>

                                {/* Brackets (Active Only - Cyan) */}
                                {isActive && (
                                    <g>
                                        {/* Top Left Bracket - Expanded & Refined */}
                                        <path 
                                            d="M -7,5 L -7,-1 L -1,-7 L 5,-7" 
                                            fill="none" 
                                            stroke="#00FFF0" 
                                            strokeWidth="2" 
                                            strokeLinecap="square" 
                                            strokeLinejoin="miter"
                                        />
                                        {/* Bottom Right Bracket - Expanded & Refined */}
                                        <path 
                                            d="M 31,19 L 31,25 L 25,31 L 19,31" 
                                            fill="none" 
                                            stroke="#00FFF0" 
                                            strokeWidth="2" 
                                            strokeLinecap="square" 
                                            strokeLinejoin="miter"
                                        />
                                    </g>
                                )}
                            </g>

                            {/* Active Indicator (Square on corner) */}
                            {isActive && (
                                <rect 
                                    x="-3" y="40" 
                                    width="6" height="6" 
                                    fill="#00FFF0" 
                                    filter="url(#review-cyanGlow)" 
                                    transform="rotate(45 0 43)"
                                />
                            )}
                        </g>
                    );
                })}
            </g>
        </g>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardPlatforms.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardProsCons.tsx ---

// components/studio/social/review-card/ReviewCardProsCons.tsx
'use client';

import React, { useMemo } from 'react';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import { ReviewTemplateData } from './types';
import { calculateWrappedLines } from '../shared/canvas-utils';

interface ReviewCardProsConsProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    editingField: string | null;
    setEditingField: (field: string | null) => void;
}

export default function ReviewCardProsCons({ data, onDataChange, editingField, setEditingField }: ReviewCardProsConsProps) {
    const prosConsFontSize = 18;
    const prosConsLineHeight = 32;
    // Reduced width from 455 to 445 to create space between text and the vertical line (at x=457)
    const prosConsWidth = 445; 
    
    // Recalculate layout to determine startY positions
    const verdictFontSize = 20;
    const verdictWidth = 420;
    const verdictLines = useMemo(() => calculateWrappedLines(data.verdict, verdictFontSize, verdictWidth, 600), [data.verdict]);
    const verdictHeight = verdictLines.length * 26;

    // Tightened GAP from 100 to 80
    const GAP = 50;
    // Lifted startY from 320 to 290 to match Verdict
    const startY_Verdict = 250;
    const startY_Pros = startY_Verdict + verdictHeight + GAP; 

    const prosLayout = useMemo(() => {
        let currentY = 0;
        return data.pros.map(pro => {
            const lines = calculateWrappedLines(pro, prosConsFontSize, prosConsWidth);
            const height = lines.length * prosConsLineHeight;
            const y = currentY;
            currentY += height + 15;
            return { lines, y, height };
        });
    }, [data.pros]);
    
    const totalProsHeight = prosLayout.reduce((acc, item) => Math.max(acc, item.y + item.height), 0);
    const startY_Cons = startY_Pros + totalProsHeight + GAP;

    const consLayout = useMemo(() => {
        let currentY = 0;
        return data.cons.map(con => {
            const lines = calculateWrappedLines(con, prosConsFontSize, prosConsWidth);
            const height = lines.length * prosConsLineHeight;
            const y = currentY;
            currentY += height + 15;
            return { lines, y, height };
        });
    }, [data.cons]);

    return (
        <>
            {/* PROS */}
            <g transform={`translate(580, ${startY_Pros})`}>
                <text x="460" y="-13" textAnchor="end" fontFamily="'Dystopian', 'Cairo', sans-serif" fontWeight="900" fontSize="22" fill="#00FFF0">الإيجابيات</text>
                {prosLayout.map((item, index) => (
                    <g key={`pro-${index}`} transform={`translate(0, ${item.y})`}>
                        {/* Modified path: Full rectangular block */}
                        <path d={`M 0,0 L 460,0 L 460,${item.height} L 0,${item.height} Z`} fill="url(#review-proGradient)"></path>
                        <rect x="457" y="0" width="3" height={item.height} fill="#00FFF0" filter="url(#review-cyanGlow)"></rect>
                        
                        <foreignObject x="0" y="0" width={prosConsWidth} height={item.height + 10}>
                             <SocialNewsBodyEditor
                                content={data.pros[index]}
                                onChange={(html) => {
                                    const newPros = [...data.pros];
                                    newPros[index] = html;
                                    onDataChange({ pros: newPros });
                                }}
                                fontSize={prosConsFontSize}
                                isEditing={editingField === `pro-${index}`}
                                setEditing={(val) => setEditingField(val ? `pro-${index}` : null)}
                                textAlign="justify"
                                customStyle={{
                                    lineHeight: `${prosConsLineHeight}px`,
                                    color: '#FFFFFF',
                                    paddingTop: '2px',
                                    fontFamily: "'Dystopian', 'Cairo', sans-serif"
                                }}
                                enableFirstWordColor={true}
                                firstWordColor="#00FFF0"
                            />
                        </foreignObject>
                    </g>
                ))}
            </g>

            {/* CONS */}
            <g transform={`translate(580, ${startY_Cons})`}>
                <text x="460" y="-13" textAnchor="end" fontFamily="'Dystopian', 'Cairo', sans-serif" fontWeight="900" fontSize="22" fill="#FF0055">السلبيات</text>
                {consLayout.map((item, index) => (
                    <g key={`con-${index}`} transform={`translate(0, ${item.y})`}>
                        {/* Modified path: Full rectangular block */}
                        <path d={`M 0,0 L 460,0 L 460,${item.height} L 0,${item.height} Z`} fill="url(#review-conGradient)"></path>
                        <rect x="457" y="0" width="3" height={item.height} fill="#FF0055" filter="url(#review-redGlow)"></rect>
                        
                        <foreignObject x="0" y="0" width={prosConsWidth} height={item.height + 10}>
                             <SocialNewsBodyEditor
                                content={data.cons[index]}
                                onChange={(html) => {
                                    const newCons = [...data.cons];
                                    newCons[index] = html;
                                    onDataChange({ cons: newCons });
                                }}
                                fontSize={prosConsFontSize}
                                isEditing={editingField === `con-${index}`}
                                setEditing={(val) => setEditingField(val ? `con-${index}` : null)}
                                textAlign="justify"
                                customStyle={{
                                    lineHeight: `${prosConsLineHeight}px`,
                                    color: '#FFFFFF',
                                    paddingTop: '2px',
                                    fontFamily: "'Dystopian', 'Cairo', sans-serif"
                                }}
                                enableFirstWordColor={true}
                                firstWordColor="#FF0055"
                            />
                        </foreignObject>
                    </g>
                ))}
            </g>
        </>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardProsCons.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardScore.tsx ---

// components/studio/social/review-card/ReviewCardScore.tsx
'use client';

import React, { useMemo } from 'react';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import { ReviewTemplateData } from './types';
import { stripHtml } from '../shared/canvas-utils';

interface ReviewCardScoreProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    editingField: string | null;
    setEditingField: (field: string | null) => void;
}

export default function ReviewCardScore({ data, onDataChange, editingField, setEditingField }: ReviewCardScoreProps) {
    // --- CONFIGURATION ---
    
    // 1. POSITION ON CANVAS
    const SCORE_GROUP_Y_POSITION = 95;
    
    // 2. PLANET (Center Shape) DIMENSIONS - COMPACT
    const PLANET_WIDTH_MULTIPLIER = 1.1; 
    const PLANET_HEIGHT_MULTIPLIER = 1.6;
    
    // 3. ORBIT (Star Ring) DIMENSIONS
    const ORBIT_WIDTH_MULTIPLIER = 1.0;
    const ORBIT_HEIGHT_MULTIPLIER = 1.0;

    // 4. FONT SIZE
    const FONT_SIZE_MULTIPLIER = 1.6;

    // ------------------------------------------------

    const rawScoreText = stripHtml(data.score).trim();
    const scoreNum = parseFloat(rawScoreText) || 0;
    
    // Base Values
    const BASE_RX = 220;
    const BASE_RY = 60;
    const BASE_FONT_SIZE = 60;

    // Calculated Dimensions
    const rx = BASE_RX * ORBIT_WIDTH_MULTIPLIER;
    const ry = BASE_RY * ORBIT_HEIGHT_MULTIPLIER;
    
    const fontSize = BASE_FONT_SIZE * FONT_SIZE_MULTIPLIER;

    // Text Box Layout
    const boxWidth = 180 * PLANET_WIDTH_MULTIPLIER;
    const boxHeight = 90 * PLANET_HEIGHT_MULTIPLIER;
    const boxX = -boxWidth / 2;
    const boxY = -boxHeight / 2;

    // Orbital Configuration
    const starCount = Math.floor(scoreNum * 2);
    
    const stars = useMemo(() => {
        const generatedStars = [];
        for (let i = 0; i < starCount; i++) {
            const angle = (i / starCount) * Math.PI * 2;
            const x = Math.cos(angle) * rx;
            const y = Math.sin(angle) * ry;
            generatedStars.push({ x, y });
        }
        return generatedStars;
    }, [starCount, rx, ry]);

    const starsBack = stars.filter(s => s.y < 0);
    const starsFront = stars.filter(s => s.y >= 0);

    // --- NEW DESIGN: Minimalist HUD Frame (Sharpened) ---
    
    // [CONTROL] DYNAMIC WIDTH LOGIC
    // If text length > 1 (e.g. "10" or "9.5"), use wide width (85).
    // If text length <= 1 (e.g. "9"), use narrow width (65).
    const isWideScore = rawScoreText.length > 1;
    const BASE_FRAME_WIDTH = isWideScore ? 85 : 65; 
    
    const BASE_FRAME_HEIGHT = 65; // Distance from center to top/bottom

    const frameX = BASE_FRAME_WIDTH * PLANET_WIDTH_MULTIPLIER; 
    const frameY = BASE_FRAME_HEIGHT; 

    const chamfer = 12; // Tighter, sharper cut 

    // Leg lengths
    const bigLeg = 22;   

    // 1. Neon Accents (Top-Left & Bottom-Right Only) - Standard Brackets
    const accentTL = `M ${-frameX},${-frameY + chamfer + bigLeg} L ${-frameX},${-frameY + chamfer} L ${-frameX + chamfer},${-frameY} L ${-frameX + chamfer + bigLeg},${-frameY}`;
    const accentBR = `M ${frameX},${frameY - chamfer - bigLeg} L ${frameX},${frameY - chamfer} L ${frameX - chamfer},${frameY} L ${frameX - chamfer - bigLeg},${frameY}`;
    
    return (
        // Position: Centered in the right column (approx x=810)
        <g transform={`translate(810, ${SCORE_GROUP_Y_POSITION})`}>
            <defs>
                <filter id="orbital-starGlow">
                    <feGaussianBlur stdDeviation="1.5" result="blur"></feGaussianBlur>
                    <feComposite in="SourceGraphic" in2="blur" operator="over"></feComposite>
                </filter>
                <filter id="orbital-neonBloom" x="-50%" y="-50%" width="200%" height="200%">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur"></feGaussianBlur>
                    <feMerge>
                        <feMergeNode in="coloredBlur"></feMergeNode>
                        <feMergeNode in="SourceGraphic"></feMergeNode>
                    </feMerge>
                </filter>
            </defs>

            {/* Static Rings */}
            <ellipse cx="0" cy="0" rx={rx} ry={ry} fill="none" stroke="#556070" strokeWidth="1" opacity="0.2" />
            <ellipse cx="0" cy="0" rx={rx} ry={ry} fill="none" stroke="#00FFF0" strokeWidth="1" strokeDasharray="10 60" opacity="0.4" />

            {/* Layer Back (Behind Planet) */}
            {starsBack.map((s, i) => (
                <circle 
                    key={`back-${i}`} 
                    cx={s.x} cy={s.y} 
                    r="1.5" 
                    fill="#FFF" stroke="#00FFF0" strokeWidth="1" 
                    filter="url(#orbital-starGlow)" 
                    opacity="0.6" 
                />
            ))}

            {/* The Main Score Container */}
            <g>
                {/* 1. Neon Corner Accents (Big - TL/BR Only) */}
                <path 
                    d={accentTL} 
                    fill="none" 
                    stroke="#00FFF0" 
                    strokeWidth="3" 
                    strokeLinecap="square"
                    strokeLinejoin="miter" 
                    filter="url(#orbital-neonBloom)" 
                />
                <path 
                    d={accentBR} 
                    fill="none" 
                    stroke="#00FFF0" 
                    strokeWidth="3" 
                    strokeLinecap="square"
                    strokeLinejoin="miter"
                    filter="url(#orbital-neonBloom)" 
                />

                {/* Editable Score Text */}
                <foreignObject x={boxX} y={boxY} width={boxWidth} height={boxHeight}>
                    <SocialNewsBodyEditor 
                        content={data.score} 
                        onChange={(val) => onDataChange({ score: val })}
                        isEditing={editingField === 'score'}
                        setEditing={(val) => setEditingField(val ? 'score' : null)}
                        fontSize={fontSize} 
                        textAlign="center"
                        customStyle={{ 
                            fill: "#00FFF0", 
                            color: "#00FFF0", 
                            fontFamily: "'Dystopian', 'Cairo', sans-serif",
                            fontWeight: 500,
                            lineHeight: 1.4,
                            textShadow: "0 0 20px rgba(0,255,240,0.6)",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            height: "100%"
                        }}
                        disableAutoEnglish={true}
                    />
                </foreignObject>
            </g>

            {/* Layer Front (In Front of Planet) */}
            {starsFront.map((s, i) => (
                <circle 
                    key={`front-${i}`} 
                    cx={s.x} cy={s.y} 
                    r="2.5" 
                    fill="#FFF" stroke="#00FFF0" strokeWidth="1" 
                    filter="url(#orbital-starGlow)" 
                    opacity="1" 
                />
            ))}
        </g>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardScore.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardTitle.tsx ---

// components/studio/social/review-card/ReviewCardTitle.tsx
'use client';

import React from 'react';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import { ReviewTemplateData } from './types';

interface ReviewCardTitleProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    editingField: string | null;
    setEditingField: (field: string | null) => void;
}

export default function ReviewCardTitle({ data, onDataChange, editingField, setEditingField }: ReviewCardTitleProps) {
    
    // --- CONFIGURATION ---
    const ARABIC_X_OFFSET = -120; 
    const ARABIC_WIDTH = 600;
    // Calculate the position of the decoration relative to the text box end
    const DECORATION_X_POS = ARABIC_X_OFFSET + ARABIC_WIDTH + 10; 

    return (
        <g transform="translate(40, 1100)">
            
            {/* --- DECORATIVE ANCHORS --- */}
            
            {/* 1. Left Vertical Bracket (Anchors English Text) */}
            <g transform="translate(-25, 45)">
                {/* Main Bracket Path - Cleaner */}
                <path 
                    d="M 15,0 L 0,0 L 0,135 L 15,135" 
                    fill="none" 
                    stroke="#00FFF0" 
                    strokeWidth="4" 
                    filter="url(#review-cyanGlow)"
                    strokeLinecap="square"
                />

                {/* Top/Bottom Anchor Blocks */}
                <rect x="-5" y="-5" width="10" height="20" fill="#00FFF0" filter="url(#review-cyanGlow)" />
                <rect x="-5" y="120" width="10" height="20" fill="#00FFF0" filter="url(#review-cyanGlow)" />
                
                {/* Center Accent - Solid Cyan */}
                <rect x="-2" y="60" width="4" height="15" fill="#00FFF0" filter="url(#review-cyanGlow)" />
            </g>

            {/* 2. Right Horizontal Anchor (Linked to Arabic Title Position) */}
            <g transform={`translate(${DECORATION_X_POS}, 48)`}>
                 <defs>
                    <linearGradient id="arabic-underline-fade" x1="100%" y1="0%" x2="0%" y2="0%">
                        <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.9" />
                        <stop offset="100%" stopColor="#00FFF0" stopOpacity="0" />
                    </linearGradient>
                 </defs>
                 
                 {/* Main Line */}
                 <rect x="-300" y="0" width="300" height="2" fill="url(#arabic-underline-fade)" />
                 
                 {/* Accent Line Below */}
                 <rect x="-200" y="8" width="200" height="1" fill="url(#arabic-underline-fade)" opacity="0.5" />
                 
                 {/* End Cap Graphic */}
                 <path d="M 0,-8 L 12,-8 L 12,12 L 0,12 L -8,2 Z" fill="#00FFF0" filter="url(#review-cyanGlow)" />
            </g>

            {/* Arabic Title (Small, Top) */}
            <foreignObject x={ARABIC_X_OFFSET} y={10} width={ARABIC_WIDTH} height={40}>
                <SocialNewsBodyEditor 
                    content={data.gameTitleAr} 
                    onChange={(val) => onDataChange({ gameTitleAr: val })}
                    isEditing={editingField === 'gameTitleAr'}
                    setEditing={(val) => setEditingField(val ? 'gameTitleAr' : null)}
                    fontSize={22} 
                    textAlign="right" 
                    customStyle={{ 
                        color: "#E2E8F0", 
                        lineHeight: 1.2,
                        textShadow: "0 2px 8px rgba(0,0,0,0.9)",
                        fontWeight: 700,
                        direction: 'rtl',
                        fontFamily: "'Dystopian', 'Cairo', sans-serif"
                    }}
                    disableAutoEnglish={true}
                />
            </foreignObject>
            
            <g transform="translate(0, 45)">
                 {/* English Top */}
                 <foreignObject x={-10} y={-15} width={600} height={90}>
                     <SocialNewsBodyEditor 
                        content={data.gameTitleEnTop} 
                        onChange={(val) => onDataChange({ gameTitleEnTop: val })}
                        isEditing={editingField === 'gameTitleEnTop'}
                        setEditing={(val) => setEditingField(val ? 'gameTitleEnTop' : null)}
                        fontSize={80}
                        textAlign="left"
                        customStyle={{ 
                            color: "#FFFFFF", 
                            letterSpacing: "0px", // FIXED: Increased letter spacing
                            wordSpacing: "-10px",  // FIXED: Decreased word spacing
                            fontFamily: "'Dystopian', 'Cairo', sans-serif",
                            fontWeight: 900,
                            direction: 'ltr',
                            textShadow: "0 4px 20px rgba(0,0,0,0.8)"
                        }}
                        disableAutoEnglish={true}
                    />
                 </foreignObject>
                
                {/* English Bottom */}
                <foreignObject x={-10} y={45} width={600} height={120}>
                    <SocialNewsBodyEditor 
                        content={data.gameTitleEnBottom} 
                        onChange={(val) => onDataChange({ gameTitleEnBottom: val })}
                        isEditing={editingField === 'gameTitleEnBottom'}
                        setEditing={(val) => setEditingField(val ? 'gameTitleEnBottom' : null)}
                        fontSize={75}
                        textAlign="left"
                        customStyle={{ 
                            color: "#00FFF0", 
                            letterSpacing: "2px", // FIXED: Increased letter spacing
                            wordSpacing: "-12px",   // FIXED: Decreased word spacing
                            filter: "drop-shadow(0 0 15px rgba(0,255,240,0.6))",
                            fontFamily: "'Dystopian', 'Cairo', sans-serif",
                            fontWeight: 900,
                            direction: 'ltr'
                        }}
                        disableAutoEnglish={true}
                    />
                </foreignObject>
            </g>
        </g>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardTitle.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/ReviewCardVerdict.tsx ---

// components/studio/social/review-card/ReviewCardVerdict.tsx
'use client';

import React, { useMemo } from 'react';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import { ReviewTemplateData } from './types';
import { calculateWrappedLines } from '../shared/canvas-utils';

interface ReviewCardVerdictProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    editingField: string | null;
    setEditingField: (field: string | null) => void;
}

export default function ReviewCardVerdict({ data, onDataChange, editingField, setEditingField }: ReviewCardVerdictProps) {
    const verdictFontSize = 20;
    const verdictLineHeight = 30; // px
    const verdictWidth = 450;
    
    const verdictLines = useMemo(() => calculateWrappedLines(data.verdict, verdictFontSize, verdictWidth, 600), [data.verdict]);
    const verdictHeight = verdictLines.length * verdictLineHeight;
    // Lifted from 320 to 290
    const startY_Verdict = 205;

    return (
        <g transform={`translate(580, ${startY_Verdict})`}>
            <rect x="456" y="0" width="4" height={verdictHeight} fill="#00FFF0" filter="url(#review-cyanGlow)"></rect>
            <text x="445" y="-10" textAnchor="end" fontFamily="'Dystopian', 'Cairo', sans-serif" fontWeight="900" fontSize="22" fill="#00FFF0">الملخص</text>
            
            <foreignObject x="-5" y="0" width={verdictWidth} height={verdictHeight + 50}>
                <SocialNewsBodyEditor
                    content={data.verdict}
                    onChange={(html) => onDataChange({ verdict: html })}
                    fontSize={verdictFontSize}
                    isEditing={editingField === 'verdict'}
                    setEditing={(val) => setEditingField(val ? 'verdict' : null)}
                    textAlign="justify"
                    customStyle={{
                        lineHeight: `${verdictLineHeight}px`,
                        color: '#A0AEC0',
                        fontWeight: 700,
                        fontFamily: "'Dystopian', 'Cairo', sans-serif"
                    }}
                />
            </foreignObject>
        </g>
    );
}

--- END OF FILE components/studio/social/review-card/ReviewCardVerdict.tsx ---

================================================================================

--- START OF FILE components/studio/social/review-card/types.ts ---

// components/studio/social/review-card/types.ts

export interface ReviewTemplateData {
    id: string;
    gameTitleAr: string;
    gameTitleEnTop: string;
    gameTitleEnBottom: string;
    score: string;
    rank: string;
    status: string;
    verdict: string;
    pros: string[];
    cons: string[];
    platforms: {
        PC: boolean;
        PS5: boolean;
        XSX: boolean;
        NSW: boolean;
    };
    techSpecs: {
        res: string;
        fps: string;
        hdr: string;
    };
    image: string;
    imageSettings: { x: number; y: number; scale: number };
    
    // VISUAL SETTINGS
    vibrance?: number; // 0-200
    tintStrength?: number; // 0-100 (Global Wash)
    creditsOpacity?: number; // 0-100 (New)
    
    // NEW: Movable Gradient Settings
    gradientSettings?: {
        active: boolean;
        x: number;
        y: number;
        opacity: number;
        scale: number;
    };
}

export interface ReviewCardCanvasProps {
    data: ReviewTemplateData;
    onDataChange: (newData: Partial<ReviewTemplateData>) => void;
    scale?: number;
    // New prop to control what is being dragged
    editMode?: 'image' | 'gradient'; 
}

--- END OF FILE components/studio/social/review-card/types.ts ---

================================================================================

--- START OF FILE components/studio/social/review-card/utils.ts ---

// components/studio/social/review-card/utils.ts
'use client';

import React from 'react';
import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

export const PLATFORM_ICONS: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    PC: PCIcon,
    PS5: PS5Icon,
    XSX: XboxIcon,
    NSW: SwitchIcon
};




--- END OF FILE components/studio/social/review-card/utils.ts ---

================================================================================

--- START OF FILE components/studio/social/shared/EditableText.tsx ---

// components/studio/social/shared/EditableText.tsx
'use client';

import React, { useState, useRef, useEffect } from 'react';

export default function EditableText({ 
    x, y, text, fontSize, align, style, onChange, isEditing, setEditing, width = 400,
    fontFamily = "'Dystopian', 'Cairo', sans-serif", fontWeight = 700, lineHeight = 1.2,
    strokeWidth = 0, strokeColor = 'transparent', shadowStyle = {},
    inputStyle = {},
    inputDy = 0 
}: { 
    x: number, y: number, text: string, fontSize: number, align: 'start' | 'middle' | 'end', 
    style?: React.CSSProperties, onChange: (val: string) => void,
    isEditing: boolean, setEditing: (v: boolean) => void, width?: number,
    fontFamily?: string, fontWeight?: number, lineHeight?: number,
    strokeWidth?: number, strokeColor?: string, shadowStyle?: React.CSSProperties,
    inputStyle?: React.CSSProperties,
    inputDy?: number
}) {
    const inputRef = useRef<HTMLInputElement>(null);
    const [isFocused, setIsFocused] = useState(false);

    useEffect(() => {
        if (isEditing && inputRef.current) {
            inputRef.current.focus();
        }
    }, [isEditing]);

    let foreignX = x;
    const textAlign = align === 'middle' ? 'center' : (align === 'start' ? 'right' : 'left'); 

    if (align === 'middle') foreignX = x - (width / 2);
    if (align === 'start') foreignX = x - width; 
    if (align === 'end') foreignX = x; 
    
    // Vertical centering adjustment with manual delta
    const foreignY = y - (fontSize * 1.15) + inputDy; 

    const inputColor = isFocused ? (style?.fill as string || '#FFFFFF') : 'transparent';

    return (
        <g onClick={(e) => { e.stopPropagation(); setEditing(true); }} style={{ cursor: 'text' }}>
            {!isFocused && (
                <g style={{ opacity: 1 }}>
                    {strokeWidth > 0 && (
                        <text 
                            x={x} y={y} 
                            textAnchor={align} 
                            style={{ ...shadowStyle, pointerEvents: 'none' }}
                            stroke={strokeColor}
                            strokeWidth={strokeWidth}
                            fill={strokeColor}
                            fontSize={fontSize}
                            fontWeight={fontWeight}
                            fontFamily={fontFamily}
                        >
                            {text}
                        </text>
                    )}
                    <text 
                        x={x} y={y} 
                        textAnchor={align} 
                        style={{ ...style, pointerEvents: 'none' }}
                        fontSize={fontSize}
                        fontWeight={fontWeight}
                        fontFamily={fontFamily}
                    >
                        {text}
                    </text>
                </g>
            )}

            <foreignObject 
                x={foreignX} 
                y={foreignY} 
                width={width} 
                height={fontSize * 2.5} 
                style={{ pointerEvents: (isEditing || isFocused) ? 'auto' : 'none' }}
            >
                {(isEditing || isFocused) && (
                    <input
                        ref={inputRef}
                        value={text}
                        onChange={(e) => onChange(e.target.value)}
                        onFocus={() => {
                            setIsFocused(true);
                            setEditing(true);
                        }}
                        onBlur={() => {
                            setIsFocused(false);
                            setEditing(false);
                        }}
                        dir="auto"
                        style={{
                            width: '100%',
                            height: '100%',
                            background: 'transparent',
                            border: 'none',
                            outline: 'none',
                            color: inputColor,
                            fontSize: `${fontSize}px`,
                            fontFamily: fontFamily,
                            fontWeight: fontWeight,
                            textAlign: textAlign,
                            padding: 0,
                            margin: 0,
                            caretColor: '#00FFF0',
                            textShadow: isFocused ? '0 2px 10px rgba(0,0,0,0.5)' : 'none',
                            lineHeight: lineHeight,
                            direction: 'rtl',
                            ...inputStyle
                        }}
                    />
                )}
            </foreignObject>
        </g>
    );
}

--- END OF FILE components/studio/social/shared/EditableText.tsx ---

================================================================================

--- START OF FILE components/studio/social/shared/JustifiedTextBlock.tsx ---

// components/studio/social/review-card/JustifiedTextBlock.tsx
'use client';

import React from 'react';

export default function JustifiedTextBlock({ 
    text, x, y, width, height, lineHeight, fontSize, color, firstWordColor, style 
}: { 
    text: string, x: number, y: number, width: number, height: number, lineHeight: number, fontSize: number, color: string, firstWordColor?: string, style?: React.CSSProperties
}) {
    const renderContent = () => {
        if (!firstWordColor) return text;
        const words = text.split(' ');
        const first = words[0];
        const rest = words.slice(1).join(' ');
        return (
            <>
                <span style={{ color: firstWordColor }}>{first}</span>{' '}{rest}
            </>
        );
    };

    return (
        <foreignObject x={x} y={y} width={width} height={height} style={{ pointerEvents: 'none' }}>
            <div style={{
                width: '100%',
                height: '100%',
                fontFamily: "'Cairo', sans-serif",
                fontSize: `${fontSize}px`,
                fontWeight: 700,
                lineHeight: `${lineHeight}px`,
                color: color,
                textAlign: 'justify',
                textAlignLast: 'right', 
                direction: 'rtl',
                ...style
            }}>
                {renderContent()}
            </div>
        </foreignObject>
    );
}




--- END OF FILE components/studio/social/shared/JustifiedTextBlock.tsx ---

================================================================================

--- START OF FILE components/studio/social/shared/SpaceBackground.tsx ---

// components/studio/social/shared/SpaceBackground.tsx
import React from 'react';

// Configuration
const BACKGROUND_BRIGHTNESS = 1.0; 

export default function SpaceBackground() {
    return (
        <g style={{ filter: `brightness(${BACKGROUND_BRIGHTNESS})` }}>
            <defs>
                {/* 1. FILTERS & GRADIENTS */}
                <filter id="sb_stellarBloom">
                    <feGaussianBlur stdDeviation="2" result="blur"></feGaussianBlur>
                    <feComposite in="SourceGraphic" in2="blur" operator="over"></feComposite>
                </filter>

                <linearGradient id="sb_shardGradWhite" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.30"></stop>
                    <stop offset="40%" stopColor="#FFFFFF" stopOpacity="0.10"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                </linearGradient>

                <linearGradient id="sb_shardGradCyan" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.35"></stop>
                    <stop offset="50%" stopColor="#00FFF0" stopOpacity="0.1"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                </linearGradient>

                <radialGradient id="sb_nebulaTop" cx="50%" cy="0%" r="80%">
                    <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.12"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                </radialGradient>
                <radialGradient id="sb_nebulaBottom" cx="10%" cy="100%" r="60%">
                    <stop offset="0%" stopColor="#556070" stopOpacity="0.2"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                </radialGradient>
                <radialGradient id="sb_nebulaRight" cx="95%" cy="50%" r="50%">
                    <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.08"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                </radialGradient>

                {/* REMOVED: Scanline Pattern Definition */}

                <pattern id="sb_scratchPattern" x="0" y="0" width="500" height="500" patternUnits="userSpaceOnUse">
                    <path d="M 50 50 L 80 80 M 200 100 L 220 90 M 350 300 L 360 320 M 100 300 L 80 320" stroke="#FFF" strokeWidth="0.5" opacity="0.15" strokeLinecap="square"></path>
                    <path d="M 400 50 L 420 80 M 10 400 L 30 380" stroke="#FFF" strokeWidth="0.5" opacity="0.1"></path>
                </pattern>

                <g id="sb_star"><circle r="1.5" fill="#F0F0FF"></circle></g>
                <g id="sb_c_A"><path d="M0,0 L30,40 L-20,30" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="40"></use><use href="#sb_star" x="-20" y="30"></use></g>
                <g id="sb_c_B"><path d="M0,0 L40,0 L80,0" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="40" y="0"></use><use href="#sb_star" x="80" y="0"></use></g>
                <g id="sb_c_C"><path d="M0,0 L0,40 L30,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="0" y="40"></use><use href="#sb_star" x="30" y="60"></use></g>
                <g id="sb_c_D"><path d="M0,0 L20,30 M20,30 L0,60 M20,30 L40,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="20" y="30"></use><use href="#sb_star" x="0" y="60"></use><use href="#sb_star" x="40" y="60"></use></g>
                <g id="sb_c_E"><path d="M0,0 L40,10 L30,50 L-10,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="40" y="10"></use><use href="#sb_star" x="30" y="50"></use><use href="#sb_star" x="-10" y="40"></use></g>
                <g id="sb_c_F"><path d="M0,0 L30,20 L0,40 L30,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="20"></use><use href="#sb_star" x="0" y="40"></use><use href="#sb_star" x="30" y="60"></use></g>
                <g id="sb_c_G"><path d="M0,20 L40,20 M40,20 L20,0 M40,20 L20,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="20"></use><use href="#sb_star" x="40" y="20"></use><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="20" y="40"></use></g>
                <g id="sb_c_H"><path d="M0,0 L30,10 L60,30 L90,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="10"></use><use href="#sb_star" x="60" y="30"></use><use href="#sb_star" x="90" y="60"></use></g>
                <g id="sb_c_I"><path d="M0,0 L20,0 L10,15" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="10" y="15"></use></g>
                <g id="sb_c_J"><path d="M20,0 L20,40 M0,20 L40,20" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="20" y="40"></use><use href="#sb_star" x="0" y="20"></use><use href="#sb_star" x="40" y="20"></use><use href="#sb_star" x="20" y="20"></use></g>
                <g id="sb_c_K"><path d="M0,0 L30,10 L60,10 L80,30 L50,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="10"></use><use href="#sb_star" x="60" y="10"></use><use href="#sb_star" x="80" y="30"></use><use href="#sb_star" x="50" y="40"></use></g>
                <g id="sb_c_L"><path d="M10,0 L30,0 L40,17 L30,34 L10,34" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="10" y="0"></use><use href="#sb_star" x="30" y="0"></use><use href="#sb_star" x="40" y="17"></use><use href="#sb_star" x="30" y="34"></use><use href="#sb_star" x="10" y="34"></use></g>

                <symbol id="sb_stars_Layer1">
                    <g fill="#F0F0FF" opacity="0.2">
                        <circle cx="20" cy="20" r="1.5"></circle> <circle cx="400" cy="10" r="1.2"></circle>
                        <circle cx="600" cy="80" r="1.5"></circle> <circle cx="100" cy="400" r="1.2"></circle>
                        <circle cx="500" cy="420" r="0.8"></circle> <circle cx="20" cy="700" r="1.5"></circle>
                        <circle cx="550" cy="700" r="1"></circle> <circle cx="400" cy="200" r="1.2"></circle>
                        <circle cx="750" cy="50" r="1"></circle> <circle cx="150" cy="600" r="1.4"></circle>
                        <circle cx="300" cy="100" r="1"></circle> <circle cx="680" cy="350" r="1.3"></circle>
                    </g>
                    <use href="#sb_c_A" x="50" y="50" opacity="0.6"></use>
                    <use href="#sb_c_B" x="500" y="50" opacity="0.5"></use>
                    <use href="#sb_c_D" x="200" y="300" opacity="0.6" transform="rotate(20 200 300)"></use>
                    <use href="#sb_c_G" x="600" y="600" opacity="0.5"></use>
                    <use href="#sb_c_H" x="100" y="700" opacity="0.6" transform="rotate(-15 100 700)"></use>
                </symbol>

                <symbol id="sb_stars_Layer2">
                    <g fill="#F0F0FF" opacity="0.15">
                        <circle cx="50" cy="100" r="1"></circle> <circle cx="250" cy="20" r="0.8"></circle>
                        <circle cx="700" cy="120" r="1"></circle> <circle cx="350" cy="650" r="0.8"></circle>
                        <circle cx="150" cy="550" r="1.1"></circle> <circle cx="450" cy="300" r="1"></circle>
                        <circle cx="650" cy="450" r="0.8"></circle> <circle cx="50" cy="350" r="1"></circle>
                        <circle cx="780" cy="780" r="0.9"></circle> <circle cx="250" cy="400" r="1.1"></circle>
                        <circle cx="10" cy="600" r="1"></circle> <circle cx="550" cy="100" r="0.8"></circle>
                    </g>
                    <use href="#sb_c_C" x="50" y="150" opacity="0.5"></use>
                    <use href="#sb_c_E" x="350" y="100" opacity="0.5"></use>
                    <use href="#sb_c_F" x="650" y="180" transform="rotate(60 650 180)" opacity="0.5"></use>
                    <use href="#sb_c_L" x="300" y="350" opacity="0.5"></use>
                    <use href="#sb_c_A" x="500" y="500" opacity="0.4" transform="rotate(180 500 500)"></use>
                    <use href="#sb_c_B" x="100" y="500" opacity="0.5" transform="rotate(45 100 500)"></use>
                    <use href="#sb_c_E" x="700" y="700" opacity="0.4"></use>
                </symbol>

                <symbol id="sb_stars_Layer3">
                    <g fill="#F0F0FF" opacity="0.12">
                        <circle cx="30" cy="40" r="0.8"></circle> <circle cx="140" cy="140" r="0.7"></circle>
                        <circle cx="300" cy="50" r="0.9"></circle> <circle cx="550" cy="20" r="0.8"></circle>
                        <circle cx="750" cy="150" r="0.7"></circle> <circle cx="40" cy="280" r="0.8"></circle>
                        <circle cx="220" cy="350" r="0.9"></circle> <circle cx="460" cy="500" r="0.7"></circle>
                        <circle cx="640" cy="350" r="0.8"></circle> <circle cx="50" cy="550" r="0.9"></circle>
                        <circle cx="340" cy="720" r="0.7"></circle> <circle cx="600" cy="750" r="0.8"></circle>
                        <circle cx="180" cy="780" r="0.9"></circle> <circle cx="720" cy="550" r="0.7"></circle>
                        <circle cx="400" cy="650" r="0.8"></circle> <circle cx="550" cy="250" r="0.7"></circle>
                    </g>
                    <use href="#sb_c_L" x="500" y="380" opacity="0.3"></use>
                    <use href="#sb_c_A" x="780" y="150" opacity="0.5"></use>
                    <use href="#sb_c_F" x="50" y="600" opacity="0.6"></use>
                    <use href="#sb_c_G" x="300" y="200" opacity="0.4"></use>
                    <use href="#sb_c_I" x="150" y="100" opacity="0.5"></use>
                    <use href="#sb_c_K" x="650" y="450" opacity="0.3"></use>
                </symbol>

                {/* PATTERNS */}
                <pattern id="sb_pat_Layer1" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                    <use href="#sb_stars_Layer1"></use>
                </pattern>
                <pattern id="sb_pat_Layer2" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                    <use href="#sb_stars_Layer2"></use>
                </pattern>
                <pattern id="sb_pat_Layer3" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                    <use href="#sb_stars_Layer3"></use>
                </pattern>

                {/* VIGNETTE */}
                <radialGradient id="sb_vignette" cx="50%" cy="50%" r="80%">
                    <stop offset="60%" stopColor="#10121A" stopOpacity="0"></stop>
                    <stop offset="100%" stopColor="#10121A" stopOpacity="0.9"></stop>
                </radialGradient>
            </defs>

            {/* 1. BASE BACKGROUND */}
            <rect width="100%" height="100%" fill="#10121A"></rect>

            {/* 2. ATMOSPHERE (Static) */}
            <rect width="100%" height="100%" fill="url(#sb_nebulaTop)" style={{ mixBlendMode: 'screen' }}></rect>
            <rect width="100%" height="100%" fill="url(#sb_nebulaBottom)" style={{ mixBlendMode: 'screen' }}></rect>
            <rect width="100%" height="100%" fill="url(#sb_nebulaRight)" style={{ mixBlendMode: 'screen' }}></rect>

            {/* 3. STATIC STAR LAYERS (No Animation Classes) */}
            <g>
                <rect x="0" y="0" width="200%" height="200%" fill="url(#sb_pat_Layer3)" opacity="0.3"></rect>
            </g>
            <g>
                <rect x="0" y="0" width="200%" height="200%" fill="url(#sb_pat_Layer2)" opacity="0.4"></rect>
            </g>
            <g>
                <rect x="0" y="0" width="200%" height="200%" fill="url(#sb_pat_Layer1)" opacity="0.5"></rect>
            </g>

            {/* 4. STATIC SHARDS */}
            <g style={{ mixBlendMode: 'soft-light' }}>
                <g>
                    <g fill="url(#sb_shardGradWhite)" stroke="#FFFFFF" strokeOpacity="0.3" strokeWidth="1.5">
                        <path d="M 120 120 L 320 160 L 220 320 L 80 260 Z" opacity="0.7"></path>
                        <path d="M -20 600 L 220 640 L 120 820 L 40 780 Z" opacity="0.5"></path>
                        <path d="M 1450 880 L 1650 920 L 1550 1060 L 1320 1020 Z" opacity="0.8"></path>
                        <path d="M 1550 480 L 1750 520 L 1700 680 Z" opacity="0.5"></path>
                    </g>
                    <g fill="url(#sb_shardGradCyan)" stroke="#00FFF0" strokeOpacity="0.4" strokeWidth="1.5">
                        <path d="M 1580 120 L 1780 80 L 1820 320 L 1620 280 Z" opacity="0.8"></path>
                        <path d="M 150 900 L 350 860 L 300 1040 Z" opacity="0.7"></path>
                    </g>
                </g>
                <g>
                    <g fill="url(#sb_shardGradWhite)" stroke="#FFFFFF" strokeOpacity="0.3" strokeWidth="1.5">
                        <path d="M 750 80 L 950 120 L 850 280 Z" opacity="0.4"></path>
                        <path d="M 850 920 L 1050 880 L 1150 1020 L 900 980 Z" opacity="0.6"></path>
                        <path d="M 450 420 L 650 460 L 550 620 Z" opacity="0.3"></path>
                    </g>
                    <g fill="url(#sb_shardGradCyan)" stroke="#00FFF0" strokeOpacity="0.4" strokeWidth="1.5">
                        <path d="M 1200 320 L 1380 280 L 1420 500 L 1250 450 Z" opacity="0.6"></path>
                    </g>
                </g>
            </g>

            {/* 5. STELLAR FLARES (Static) */}
            <g filter="url(#sb_stellarBloom)">
                <circle cx="300" cy="300" r="3" fill="#FFF"></circle>
                <circle cx="1200" cy="150" r="2.5" fill="#FFF"></circle>
                <circle cx="800" cy="800" r="3" fill="#FFF"></circle>
                <circle cx="1500" cy="600" r="2" fill="#FFF"></circle>
                <circle cx="100" cy="1000" r="2.2" fill="#FFF" opacity="0.6"></circle>
                <circle cx="1800" cy="200" r="2.8" fill="#FFF"></circle>
                <circle cx="900" cy="50" r="3" fill="#FFF"></circle>
                <circle cx="500" cy="950" r="2.5" fill="#FFF" opacity="0.7"></circle>
                
                <circle cx="500" cy="200" r="3" fill="#00FFF0" opacity="0.8"></circle>
                {/* REMOVED: Overlapping Cyan stars that interfere with text visibility */}
                {/* <circle cx="1000" cy="500" r="4" fill="#00FFF0" opacity="0.6"></circle> */}
                <circle cx="1700" cy="900" r="3.5" fill="#00FFF0" opacity="0.8"></circle>
                <circle cx="1400" cy="300" r="2" fill="#00FFF0" opacity="0.9"></circle>
                {/* REMOVED: Overlapping Cyan star */}
                {/* <circle cx="600" cy="600" r="3.2" fill="#00FFF0" opacity="0.8"></circle> */}
                <circle cx="1850" cy="500" r="3" fill="#00FFF0" opacity="0.9"></circle>
                {/* REMOVED: Overlapping Cyan star */}
                {/* <circle cx="900" cy="900" r="3.5" fill="#00FFF0" opacity="0.8"></circle> */}
                <circle cx="50" cy="50" r="3" fill="#00FFF0" opacity="0.9"></circle>
            </g>

            {/* 6. OVERLAYS */}
            <rect width="110%" height="110%" fill="url(#sb_scratchPattern)" opacity="0.4"></rect>
            {/* REMOVED: Scanline overlay rect */}
            <rect width="100%" height="100%" fill="url(#sb_vignette)"></rect>
        </g>
    );
}

--- END OF FILE components/studio/social/shared/SpaceBackground.tsx ---

================================================================================

--- START OF FILE components/studio/social/shared/VibranceSlider.tsx ---



--- END OF FILE components/studio/social/shared/VibranceSlider.tsx ---

================================================================================

--- START OF FILE components/studio/social/shared/canvas-utils.ts ---

// components/studio/social/shared/canvas-utils.ts

export const stripHtml = (html: string) => {
    if (typeof document === 'undefined') return html.replace(/<[^>]*>?/gm, '');
    const tmp = document.createElement("DIV");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
};

export const calculateWrappedLines = (text: string, fontSize: number, maxWidth: number, fontWeight: number | string = 700, fontFamily: string = "'Dystopian', 'Cairo', sans-serif") => {
    if (typeof document === 'undefined') return [text];
    
    // STRIP HTML TAGS
    const plainText = stripHtml(text);
    
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    if (!context) return [plainText];

    context.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    
    const words = plainText.split(' ');
    const lines = [];
    let currentLine = words[0];

    for (let i = 1; i < words.length; i++) {
        const word = words[i];
        const width = context.measureText(currentLine + " " + word).width;
        if (width < maxWidth) {
            currentLine += " " + word;
        } else {
            lines.push(currentLine);
            currentLine = word;
        }
    }
    lines.push(currentLine);
    return lines;
};

--- END OF FILE components/studio/social/shared/canvas-utils.ts ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/SmartFillerWeekly.tsx ---

// components/studio/social/weekly-news/SmartFillerWeekly.tsx
'use client';

import { useState, useTransition, useEffect } from 'react';
import Modal from '@/components/modals/Modal';
import modalStyles from '@/components/modals/Modals.module.css';
import { getRecentWeeksAction, getNewsForWeekAction, WeeklyNewsItem, WeekOption } from '@/app/studio/social-templates/weekly-news/actions';
import Image from 'next/image';
import { sanityLoader } from '@/lib/sanity.loader';
import { WeeklyNewsTemplateData, WeeklyListItem } from './types';

interface SmartFillerWeeklyProps {
    isOpen: boolean;
    onClose: () => void;
    onApply: (data: Partial<WeeklyNewsTemplateData>) => void;
    currentData: WeeklyNewsTemplateData; // NEW PROP
}

const AddIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>;
const TrashIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>;
const CheckIcon = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points="20 6 9 17 4 12"></polyline></svg>;
const ArrowUpIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points="18 15 12 9 6 15"></polyline></svg>;
const ArrowDownIcon = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points="6 9 12 15 18 9"></polyline></svg>;

export default function SmartFillerWeekly({ isOpen, onClose, onApply, currentData }: SmartFillerWeeklyProps) {
    // Default to current month
    const now = new Date();
    const currentMonthStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    
    const [weeks, setWeeks] = useState<WeekOption[]>([]);
    const [selectedWeek, setSelectedWeek] = useState<WeekOption | null>(null);
    const [newsItems, setNewsItems] = useState<WeeklyNewsItem[]>([]);
    const [isPending, startTransition] = useTransition();

    // Assignment State
    const [assignedHero, setAssignedHero] = useState<WeeklyNewsItem | null>(null);
    const [assignedCards, setAssignedCards] = useState<(WeeklyNewsItem | null)[]>([null, null, null]);
    
    // Map list items back to a structure compatible with WeeklyNewsItem for display
    const [assignedList, setAssignedList] = useState<{ item: WeeklyNewsItem, isImportant: boolean }[]>([]);

    // --- HYDRATION LOGIC ---
    useEffect(() => {
        if (isOpen && currentData) {
            // Reconstruct WeeklyNewsItem from currentData where possible
            // Note: We might be missing fields like 'publishedAt' if we rely solely on template data.
            // But we have 'sourceId' now which helps identification.
            
            // 1. Hero
            if (currentData.hero.sourceId || currentData.hero.title) {
                setAssignedHero({
                    _id: currentData.hero.sourceId || 'manual-hero',
                    title: currentData.hero.title.replace(/<\/?[^>]+(>|$)/g, ""), // Strip HTML for list view
                    imageUrl: currentData.hero.image,
                    publishedAt: '', // Unknown
                    category: currentData.hero.tag,
                    newsType: currentData.hero.badges.type, // HYDRATE TYPE
                });
            }

            // 2. Cards
            const newCards = currentData.cards.map(c => {
                if (!c.title) return null;
                return {
                    _id: c.sourceId || `manual-card-${c.id}`,
                    title: c.title.replace(/<\/?[^>]+(>|$)/g, ""),
                    imageUrl: c.image,
                    publishedAt: '',
                    newsType: c.badges.type // HYDRATE TYPE
                } as WeeklyNewsItem;
            });
            setAssignedCards(newCards);

            // 3. List
            const newList = currentData.newsList.map(l => ({
                item: {
                    _id: l.sourceId || `manual-list-${l.id}`,
                    title: l.text.replace(/<\/?[^>]+(>|$)/g, ""),
                    imageUrl: '', // List items usually don't show image in template, but we can't recover it if lost
                    publishedAt: '',
                    newsType: l.type // HYDRATE TYPE
                },
                isImportant: l.isImportant
            }));
            setAssignedList(newList);

            // Fetch weeks
            startTransition(async () => {
                const recentWeeks = await getRecentWeeksAction();
                setWeeks(recentWeeks);
                if (recentWeeks.length > 0) {
                    setSelectedWeek(recentWeeks[0]);
                    const news = await getNewsForWeekAction(recentWeeks[0].startDate, recentWeeks[0].endDate);
                    setNewsItems(news);
                }
            });
        }
    }, [isOpen, currentData]);

    // ... (Handlers for WeekChange, Toggles same as before) ...
    const handleWeekChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const week = weeks.find(w => w.startDate === e.target.value);
        if (week) {
            setSelectedWeek(week);
            startTransition(async () => {
                const news = await getNewsForWeekAction(week.startDate, week.endDate);
                setNewsItems(news);
            });
        }
    };

    const toggleAssignHero = (item: WeeklyNewsItem) => {
        setAssignedHero(prev => prev?._id === item._id ? null : item);
    };

    const toggleAssignCard = (item: WeeklyNewsItem) => {
        const idx = assignedCards.findIndex(c => c?._id === item._id);
        if (idx !== -1) {
            const newCards = [...assignedCards];
            newCards[idx] = null;
            setAssignedCards(newCards);
        } else {
            const emptyIdx = assignedCards.findIndex(c => c === null);
            const targetIdx = emptyIdx !== -1 ? emptyIdx : 2; // Default to last if full
            const newCards = [...assignedCards];
            newCards[targetIdx] = item;
            setAssignedCards(newCards);
        }
    };

    const toggleAssignList = (item: WeeklyNewsItem) => {
        const exists = assignedList.some(l => l.item._id === item._id);
        if (exists) {
            setAssignedList(prev => prev.filter(l => l.item._id !== item._id));
        } else {
            if (assignedList.length >= 12) return;
            setAssignedList([...assignedList, { item, isImportant: false }]);
        }
    };

    const handleRemoveCard = (index: number) => {
        setAssignedCards(prev => {
            const next = [...prev];
            next[index] = null;
            return next;
        });
    };

    const handleRemoveList = (index: number) => {
        setAssignedList(prev => prev.filter((_, i) => i !== index));
    };
    
    // NEW: Re-ordering functionality for List
    const moveListItem = (index: number, direction: -1 | 1) => {
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= assignedList.length) return;
        
        const newList = [...assignedList];
        const [movedItem] = newList.splice(index, 1);
        newList.splice(newIndex, 0, movedItem);
        setAssignedList(newList);
    };

    const toggleImportant = (index: number) => {
        setAssignedList(prev => {
            const next = [...prev];
            next[index] = { ...next[index], isImportant: !next[index].isImportant };
            return next;
        });
    };

    const handleFinalApply = () => {
        const newData: any = {};
        
        if (selectedWeek) {
            newData.weekNumber = `الأسبوع ${selectedWeek.weekNum}`;
            newData.year = selectedWeek.year.toString();
        }

        if (assignedHero) {
            newData.hero = {
                sourceId: assignedHero._id,
                title: assignedHero.title,
                image: assignedHero.imageUrl || '',
                tag: 'خبر عاجل',
                imageSettings: { x: 0, y: 0, scale: 1 },
                // THE FIX: Apply the newsType from the fetched item
                badges: { ...currentData.hero.badges, type: assignedHero.newsType || 'official' }
            };
        }

        const validCards = assignedCards.map((c, i) => {
            if (!c) return null;
            return {
                sourceId: c._id,
                id: i + 1,
                title: c.title,
                image: c.imageUrl || '',
                imageSettings: { x: 0, y: 0, scale: 1 },
                // THE FIX: Apply the newsType from the fetched item
                badges: { ...(currentData.cards[i]?.badges || {}), type: c.newsType || 'official' }
            };
        }).filter(Boolean);
        
        if (validCards.length > 0) {
            newData.cards = validCards;
        }

        if (assignedList.length > 0) {
            newData.newsList = assignedList.map((item, i) => ({
                sourceId: item.item._id,
                id: i + 5,
                number: (i + 5).toString().padStart(2, '0'),
                text: item.item.title,
                isImportant: item.isImportant,
                // THE FIX: Apply the newsType from the fetched item
                type: item.item.newsType || 'official'
            }));
        }

        onApply(newData);
        onClose();
    };
    
    // THE FIX: No longer need selectedIds. We count from the assigned lists directly.
    const totalSelected = (assignedHero ? 1 : 0) + assignedCards.filter(Boolean).length + assignedList.length;

    return (
        <Modal isOpen={isOpen} onClose={onClose} style={{ maxWidth: '95vw', width: '1200px', height: '85vh', display: 'flex', flexDirection: 'column', padding: '0' }}>
            <div style={{ padding: '2rem 2rem 1rem 2rem', borderBottom: '1px solid var(--border-color)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <h3 style={{ margin: 0, fontFamily: 'var(--font-main)' }}>إدارة محتوى النشرة</h3>
                <div style={{ display: 'flex', gap: '1rem' }}>
                     <select 
                        className="profile-input" 
                        style={{ height: '40px', padding: '0 3rem 0 1rem', width: 'auto' }}
                        onChange={handleWeekChange}
                        value={selectedWeek?.startDate || ''}
                    >
                        {weeks.map(w => (
                            <option key={w.startDate} value={w.startDate}>{w.label}</option>
                        ))}
                    </select>
                </div>
            </div>

            <div style={{ flexGrow: 1, display: 'flex', overflow: 'hidden' }}>
                {/* LEFT: Available News */}
                <div style={{ width: '40%', borderLeft: '1px solid var(--border-color)', display: 'flex', flexDirection: 'column', backgroundColor: 'var(--bg-secondary)' }}>
                     <div style={{ padding: '1rem', fontWeight: 'bold' }}>الأخبار المتاحة</div>
                     <div style={{ overflowY: 'auto', flexGrow: 1, padding: '1rem', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        {isPending ? <div className="spinner" style={{ margin: 'auto' }} /> : 
                         newsItems.map(item => {
                            const isHero = assignedHero?._id === item._id;
                            const isCard = assignedCards.some(c => c?._id === item._id);
                            const isList = assignedList.some(l => l.item._id === item._id);
                            return (
                                <div key={item._id} style={{ background: 'var(--bg-primary)', border: '1px solid var(--border-color)', borderRadius: '8px', padding: '1rem' }}>
                                    <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                        {item.imageUrl && <Image src={item.imageUrl} alt="" width={60} height={40} style={{ borderRadius: '4px', objectFit: 'cover' }} loader={sanityLoader} />}
                                        <div><p style={{ margin: 0, fontWeight: 'bold', fontSize: '1.1rem' }}>{item.title}</p></div>
                                    </div>
                                    <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                        <button onClick={() => toggleAssignHero(item)} className={isHero ? "primary-button" : "outline-button"} style={{ padding: '0.3rem 0.8rem', fontSize: '1rem' }}>Hero</button>
                                        <button onClick={() => toggleAssignCard(item)} className={isCard ? "primary-button" : "outline-button"} style={{ padding: '0.3rem 0.8rem', fontSize: '1rem' }}>Card</button>
                                        <button onClick={() => toggleAssignList(item)} className={isList ? "primary-button" : "outline-button"} style={{ padding: '0.3rem 0.8rem', fontSize: '1rem' }}>List</button>
                                    </div>
                                </div>
                            );
                         })}
                     </div>
                </div>

                {/* RIGHT: Assignments (Manager) */}
                <div style={{ width: '60%', display: 'flex', flexDirection: 'column', overflowY: 'auto', padding: '2rem', gap: '2rem', backgroundColor: '#050505' }}>
                    {/* ... Hero & Cards sections same as before ... */}
                    
                    {/* List Assignment with Ordering */}
                    <div style={{ border: '1px solid #333', borderRadius: '8px', padding: '1rem', background: '#111', flexGrow: 1 }}>
                        <h4 style={{ margin: '0 0 1rem 0', color: '#00FFF0' }}>قائمة الأخبار (News List)</h4>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                            {assignedList.map((item, i) => (
                                <div key={i} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: '#1A1A1A', padding: '0.5rem', borderRadius: '4px' }}>
                                    {/* Reorder Controls */}
                                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                                        <button onClick={() => moveListItem(i, -1)} disabled={i === 0} style={{ background: 'none', border: 'none', color: '#555', cursor: i===0?'default':'pointer' }}><ArrowUpIcon /></button>
                                        <button onClick={() => moveListItem(i, 1)} disabled={i === assignedList.length - 1} style={{ background: 'none', border: 'none', color: '#555', cursor: i===assignedList.length-1?'default':'pointer' }}><ArrowDownIcon /></button>
                                    </div>
                                    
                                    <span style={{ color: '#00FFF0', fontFamily: 'monospace', width: '25px', textAlign: 'center' }}>{(i + 5).toString().padStart(2, '0')}</span>
                                    <p style={{ margin: 0, color: '#fff', flexGrow: 1, fontSize: '0.9rem', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{item.item.title}</p>
                                    
                                    <button 
                                        onClick={() => toggleImportant(i)}
                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: item.isImportant ? '#00FFF0' : '#444' }}
                                    >
                                        <CheckIcon />
                                    </button>

                                    <button onClick={() => handleRemoveList(i)} style={{ color: '#DC2626', background: 'none', border: 'none', cursor: 'pointer' }}><TrashIcon /></button>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            
            <div className={modalStyles.modalActions} style={{ padding: '1.5rem', borderTop: '1px solid var(--border-color)', justifyContent: 'space-between', alignItems: 'center' }}>
                <span style={{ color: totalSelected >= 16 ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: 'bold' }}>
                    تم تحديد {totalSelected} / 16
                </span>
                <div style={{ display: 'flex', gap: '1rem' }}>
                    <button onClick={onClose} className="outline-button">إلغاء</button>
                    <button onClick={handleFinalApply} className="primary-button" disabled={totalSelected === 0}>
                        تطبيق ({totalSelected})
                    </button>
                </div>
            </div>
        </Modal>
    );
}

--- END OF FILE components/studio/social/weekly-news/SmartFillerWeekly.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/WeeklyNewsCanvas.tsx ---

// components/studio/social/weekly-news/WeeklyNewsCanvas.tsx
'use client';

import React, { useState } from 'react';
import { WeeklyNewsTemplateData } from './types';
import WeeklyNewsDefs from './WeeklyNewsDefs';
import WeeklyNewsHero from './WeeklyNewsHero';
import WeeklyNewsMainCards from './WeeklyNewsMainCards';
import WeeklyNewsList from './WeeklyNewsList';
import EditableText from '../shared/EditableText';
import SpaceBackground from '../shared/SpaceBackground';

interface Props {
    data: WeeklyNewsTemplateData;
    onChange: (newData: Partial<WeeklyNewsTemplateData>) => void;
    scale?: number;
}

export default function WeeklyNewsCanvas({ data, onChange, scale = 1 }: Props) {
    const [editingField, setEditingField] = useState<string | null>(null);

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault(); e.stopPropagation();
    };

    // Calculate vibrance value
    const vibranceValue = (data.vibrance ?? 100) / 100;

    return (
        <div 
            className="canvas-container"
            id="weekly-news-canvas"
            style={{ 
                width: `${1080 * scale}px`, 
                height: `${1350 * scale}px`,
                transformOrigin: 'top left',
                position: 'relative',
                boxShadow: '0 0 50px rgba(0,0,0,0.5)',
                overflow: 'hidden'
            }}
            onDragOver={(e) => e.preventDefault()}
            onDrop={handleDrop}
        >
            <svg 
                viewBox="0 0 1080 1350" 
                width="100%" 
                height="100%" 
                xmlns="http://www.w3.org/2000/svg" 
                preserveAspectRatio="xMidYMid slice"
                style={{ 
                    backgroundColor: '#050505', 
                    direction: 'rtl',
                    // Apply Saturation Filter to the entire SVG
                    filter: `saturate(${vibranceValue})` 
                }}
            >
                <WeeklyNewsDefs />

                {/* BACKGROUND LAYER */}
                <SpaceBackground />
                <rect width="100%" height="100%" fill="url(#wn-dataStream)" opacity="0.10" style={{ mixBlendMode: 'overlay' }}></rect>
                
                {/* LOGO (TOP CENTER) */}
                 <g transform="translate(530, 11) scale(0.053)">
                    <path fill="#0dffff" d="M579 0 502 248 446 315 460 388 366 690 483 815 550 734 456 738 541 715 572 678 601 595 586 688 607 658 653 521 629 451 617 540 598 374 642 441 630 111zM237 196 300 413 195 633 186 551 150 619 146 690 133 659 0 911 274 732 260 665 293 719 323 697 314 593 338 660 423 413zM317 739 150 841 185 886 125 856 71 889 200 1052 169 1052 253 1156 254 1079 490 1276 523 1390 529 1295 484 1107 357 1034 328 978 277 978 312 964 369 846 317 868 281 912 290 870 261 870 221 898 278 833zM353 727 335 782 428 860 457 910 457 838zM576 762 490 842 479 919zM610 793 475 965 514 1035 524 1004 606 924zM744 564 744 734 629 826 629 934 682 962 679 972 714 1026 658 987 636 955 598 961 536 1026 602 987 628 985 646 1007 491 1617 728 1150 732 1205 841 1030 775 1062 892 841z" filter="url(#wn-neonGlow)"/>
                </g>

                <g transform="translate(40, 60)">
                    {/* REMOVED BLACK BACKGROUND RECT HERE */}
                    <rect x="0" y="49" width="1000" height="1" fill="#00FFF0"></rect>
                    <rect x="994" y="-5" width="6" height="50" fill="#00FFF0"></rect>
                    
                    {/* Unified Title Bar with Space */}
                    <text x="980" y="32" direction="rtl" textAnchor="start" fontWeight="900" fontSize="34" fill="#FFFFFF" fontFamily="'Dystopian', 'Cairo', sans-serif">
                        الجريدة <tspan fill="#00FFF0">الأسبوعية</tspan>
                    </text>

                    <g transform="translate(0, 5)">
                        <path d="M 0,0 L 140,0 L 140,20 L 120,40 L 0,40 Z" fill="#00FFF0"></path>
                        
                        <EditableText
                            x={70} y={24}
                            text={data.weekNumber}
                            fontSize={22}
                            align="middle"
                            style={{ fill: "#000000", fontWeight: 900, fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                            onChange={(val) => onChange({ weekNumber: val })}
                            isEditing={editingField === 'weekNum'}
                            setEditing={(v) => setEditingField(v ? 'weekNum' : null)}
                            width={100}
                        />
                        
                        {/* FIXED: Year Position - Aligned Left inside the cyan box */}
                        <EditableText
                            x={15} y={34}
                            text={data.year}
                            fontSize={12}
                            align="end" // 'end' in RTL aligns to the LEFT edge
                            style={{ fill: "#000000", fontWeight: 'bold', fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                            onChange={(val) => onChange({ year: val })}
                            isEditing={editingField === 'year'}
                            setEditing={(v) => setEditingField(v ? 'year' : null)}
                            width={50}
                            inputStyle={{ fontFamily: "'Dystopian', 'Cairo', sans-serif" }}
                        />
                    </g>
                </g>

                <WeeklyNewsHero data={data} onChange={onChange} scale={scale} />
                <WeeklyNewsMainCards data={data} onChange={onChange} scale={scale} />
                <WeeklyNewsList data={data} onChange={onChange} />
                
                {/* CREDIT LINE (BOTTOM) */}
                <g transform="translate(540, 1330)">
                    <text x="0" y="-25" textAnchor="middle" fontWeight="bold" fontSize="16" fill="#00FFF0" fontFamily="'Dystopian', 'Cairo', sans-serif" letterSpacing="1">تصميم 1EternalGames // @MoVisionX@</text>
                </g>

                <rect width="100%" height="100%" filter="url(#wn-grain)" opacity="0.06" style={{ mixBlendMode: 'overlay' }} pointerEvents="none"></rect>
            </svg>
        </div>
    );
}

--- END OF FILE components/studio/social/weekly-news/WeeklyNewsCanvas.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/WeeklyNewsDefs.tsx ---

// components/studio/social/weekly-news/WeeklyNewsDefs.tsx
import React from 'react';

export default function WeeklyNewsDefs() {
    return (
        <defs>
            <linearGradient id="wn-cleanVoid" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#0B0D12"></stop>
                <stop offset="100%" stopColor="#050505"></stop>
            </linearGradient>

            <linearGradient id="wn-heroShadow" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="50%" stopColor="#000" stopOpacity="0"></stop>
                <stop offset="100%" stopColor="#000" stopOpacity="0.95"></stop>
            </linearGradient>

            <linearGradient id="wn-cardShadow" x1="50%" y1="0%" x2="50%" y2="100%">
                <stop offset="0%" stopColor="#050505" stopOpacity="0"></stop>
                <stop offset="100%" stopColor="#050505" stopOpacity="0.9"></stop>
            </linearGradient>

            <pattern id="wn-dataStream" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                <circle cx="1" cy="1" r="0.5" fill="#00FFF0" opacity="0.3"></circle>
            </pattern>
            <pattern id="wn-techGrid" x="0" y="0" width="60" height="60" patternUnits="userSpaceOnUse">
                <path d="M 60 0 L 0 0 0 60" fill="none" stroke="#1A202C" strokeWidth="1"></path>
                <rect x="0" y="0" width="2" height="2" fill="#00FFF0" opacity="0.1"></rect>
            </pattern>

            <filter id="wn-neonGlow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                    <feMergeNode in="coloredBlur"></feMergeNode>
                    <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
            </filter>
            
            <filter id="wn-strongNeonGlow">
                <feGaussianBlur stdDeviation="3.5" result="coloredBlur"></feGaussianBlur>
                <feMerge>
                    <feMergeNode in="coloredBlur"></feMergeNode>
                    <feMergeNode in="SourceGraphic"></feMergeNode>
                </feMerge>
            </filter>
            
            {/* Added: Red Glow for Leaks */}
            <filter id="wn-leakGlow">
                <feGaussianBlur stdDeviation="3" result="blur" />
                <feFlood floodColor="#DC2626" result="color" />
                <feComposite in="color" in2="blur" operator="in" result="coloredBlur" />
                <feMerge>
                    <feMergeNode in="coloredBlur" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>

            {/* Added: Amber Glow for Rumors */}
            <filter id="wn-rumorGlow">
                <feGaussianBlur stdDeviation="3" result="blur" />
                <feFlood floodColor="#F59E0B" result="color" />
                <feComposite in="color" in2="blur" operator="in" result="coloredBlur" />
                <feMerge>
                    <feMergeNode in="coloredBlur" />
                    <feMergeNode in="SourceGraphic" />
                </feMerge>
            </filter>

            <filter id="wn-grain">
                <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"></feTurbulence>
                <feColorMatrix type="saturate" values="0"></feColorMatrix>
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.1"></feFuncA>
                </feComponentTransfer>
            </filter>

            <clipPath id="wn-heroClipNotched">
                <path d="M 0,0 L 1080,0 L 1080,100 L 1065,110 L 1065,150 L 1080,160 L 1080,260 L 1040,300 L 700,300 L 680,320 L 400,320 L 380,300 L 40,300 L 0,260 L 0,160 L 15,150 L 15,110 L 0,100 Z"></path>
            </clipPath>

            <clipPath id="wn-platformClipV2">
                <path d="M 20,0 L 300,0 L 320,20 L 320,140 L 300,160 L 190,160 L 180,150 L 140,150 L 130,160 L 20,160 L 0,140 L 0,20 Z"></path>
            </clipPath>
        </defs>
    );
}




--- END OF FILE components/studio/social/weekly-news/WeeklyNewsDefs.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/WeeklyNewsHero.tsx ---

// components/studio/social/weekly-news/WeeklyNewsHero.tsx
'use client';

import React, { useState, useRef, useEffect, useMemo } from 'react';
import { WeeklyNewsTemplateData, NewsType, BadgeState } from './types';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import EditableText from '../shared/EditableText';
import { PLATFORM_ICONS } from '../monthly-games/utils';

interface Props {
    data: WeeklyNewsTemplateData;
    onChange: (newData: Partial<WeeklyNewsTemplateData>) => void;
    scale: number;
}

const NEWS_TYPE_CONFIG: Record<NewsType, { label: string, color: string }> = {
    official: { label: 'رسمي', color: '#00FFF0' },
    rumor: { label: 'إشاعة', color: '#FFD700' },
    leak: { label: 'تسريب', color: '#DC2626' }
};

const PLATFORM_CONFIG: Record<string, { color: string, icon: any }> = {
    xbox: { color: '#10B981', icon: PLATFORM_ICONS['XSX'] },
    playstation: { color: '#3B82F6', icon: PLATFORM_ICONS['PS5'] },
    nintendo: { color: '#EF4444', icon: PLATFORM_ICONS['NSW'] },
    pc: { color: '#E2E8F0', icon: PLATFORM_ICONS['PC'] }
};

export default function WeeklyNewsHero({ data, onChange, scale }: Props) {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const dragStart = useRef({ x: 0, y: 0 });
    const initialImgPos = useRef({ x: 0, y: 0 });
    const [editingField, setEditingField] = useState<string | null>(null);
    const [isHovered, setIsHovered] = useState(false);
    
    // Image Dimensions
    const [imgDims, setImgDims] = useState({ width: 1080, height: 350 });
    const [baseScale, setBaseScale] = useState(1);

    useEffect(() => {
        if (!data.hero.image) return;
        const img = new Image();
        img.src = data.hero.image;
        img.onload = () => {
            const w = img.naturalWidth || 1080;
            const h = img.naturalHeight || 350;
            setImgDims({ width: w, height: h });
            const scaleW = 1080 / w;
            const scaleH = 350 / h;
            setBaseScale(Math.max(scaleW, scaleH));
        };
    }, [data.hero.image]);

    // Image Handlers
    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                if(ev.target?.result) {
                    onChange({ hero: { ...data.hero, image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } } });
                }
            };
            reader.readAsDataURL(file);
        }
    };
    const handleMouseDown = (e: React.MouseEvent) => { if (e.button !== 0) return; e.preventDefault(); e.stopPropagation(); setIsDragging(true); dragStart.current = { x: e.clientX, y: e.clientY }; initialImgPos.current = { ...data.hero.imageSettings }; };
    const handleMouseMove = (e: React.MouseEvent) => { if (!isDragging) return; e.preventDefault(); e.stopPropagation(); const dx = (e.clientX - dragStart.current.x) / scale; const dy = (e.clientY - dragStart.current.y) / scale; onChange({ hero: { ...data.hero, imageSettings: { ...data.hero.imageSettings, x: initialImgPos.current.x + dx, y: initialImgPos.current.y + dy } } }); };
    const handleMouseUp = () => setIsDragging(false);
    const handleWheel = (e: React.WheelEvent) => { e.stopPropagation(); const settings = data.hero.imageSettings; const newScale = Math.max(0.1, Math.min(5, settings.scale - e.deltaY * 0.001)); onChange({ hero: { ...data.hero, imageSettings: { ...settings, scale: newScale } } }); };

    // --- Badge Logic ---
    const badges = data.hero.badges || { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false };

    const toggleBadgeType = () => {
        const types: NewsType[] = ['official', 'rumor', 'leak'];
        const nextIndex = (types.indexOf(badges.type) + 1) % types.length;
        onChange({ hero: { ...data.hero, badges: { ...badges, type: types[nextIndex] } } });
    };

    const togglePlatform = (key: 'xbox' | 'playstation' | 'nintendo' | 'pc') => {
        onChange({ hero: { ...data.hero, badges: { ...badges, [key]: !badges[key] } } });
    };

    const activeBadges = useMemo(() => {
        const list: any[] = [];
        const typeConfig = NEWS_TYPE_CONFIG[badges.type];
        list.push({ type: 'type', ...typeConfig, width: 90 });
        if (badges.playstation) list.push({ type: 'platform', ...PLATFORM_CONFIG.playstation, width: 50 });
        if (badges.xbox) list.push({ type: 'platform', ...PLATFORM_CONFIG.xbox, width: 50 });
        if (badges.nintendo) list.push({ type: 'platform', ...PLATFORM_CONFIG.nintendo, width: 50 });
        if (badges.pc) list.push({ type: 'platform', ...PLATFORM_CONFIG.pc, width: 50 });

        const BADGE_HEIGHT = 30;
        const DIAGONAL_OFFSET = 15;
        let currentY = 0;
        let prevBottomWidth = 0;
        
        const RIGHT_EDGE = 1080; 

        return list.map((b, i) => {
            const isFirst = i === 0;
            const topWidth = isFirst ? b.width + 20 : prevBottomWidth;
            const bottomWidth = topWidth - DIAGONAL_OFFSET;
            prevBottomWidth = bottomWidth;
            
            const shape = `M ${RIGHT_EDGE},${currentY} L ${RIGHT_EDGE},${currentY + BADGE_HEIGHT} L ${RIGHT_EDGE - bottomWidth},${currentY + BADGE_HEIGHT} L ${RIGHT_EDGE - topWidth},${currentY} Z`;
            const cx = RIGHT_EDGE - (topWidth + bottomWidth) / 4; 
            const badgeY = currentY;
            currentY += BADGE_HEIGHT;
            return { ...b, shape, y: badgeY, cx };
        });
    }, [badges]);

    const settings = data.hero.imageSettings;
    const totalScale = baseScale * settings.scale;
    const transform = `translate(${540 + settings.x} ${175 + settings.y}) scale(${totalScale}) translate(${-imgDims.width / 2} ${-imgDims.height / 2})`;

    return (
        <g transform="translate(0, 110)"
           onMouseEnter={() => setIsHovered(true)}
           onMouseLeave={() => setIsHovered(false)}
        >
            <foreignObject width="0" height="0">
                 <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
            </foreignObject>

            <g clipPath="url(#wn-heroClipNotched)">
                 <rect width="1080" height="350" fill="#000000" />
                 <g 
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                    onDoubleClick={() => fileInputRef.current?.click()}
                    style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
                >
                    {/* Transparent rect to ensure clickability when empty */}
                    <rect x="0" y="0" width="1080" height="350" fill="transparent" />
                    <image 
                        href={data.hero.image} 
                        width={imgDims.width}
                        height={imgDims.height}
                        transform={transform}
                        preserveAspectRatio="none"
                    />
                </g>
                <rect width="1080" height="350" fill="url(#wn-heroShadow)" pointerEvents="none"></rect>
            </g>

            <path d="M 0,0 L 1080,0 L 1080,100 L 1065,110 L 1065,150 L 1080,160 L 1080,260 L 1040,300 L 700,300 L 680,320 L 400,320 L 380,300 L 40,300 L 0,260 L 0,160 L 15,150 L 15,110 L 0,100 Z" fill="none" stroke="#556070" strokeWidth="2" pointerEvents="none"></path>
            <path d="M 1080,260 L 1040,300 L 700,300 L 680,320 L 400,320 L 380,300 L 40,300 L 0,260" fill="none" stroke="#00FFF0" strokeWidth="4" strokeLinecap="square" filter="url(#wn-neonGlow)" pointerEvents="none"></path>
            
            <rect x="1070" y="115" width="2" height="30" fill="#00FFF0" opacity="0.6"></rect>
            <rect x="8" y="115" width="2" height="30" fill="#00FFF0" opacity="0.6"></rect>

            <g transform="translate(0, 0)"> 
                {activeBadges.map((badge, i) => (
                    <g key={i} onClick={(e) => { e.stopPropagation(); if (badge.type === 'type') toggleBadgeType(); }} style={{ cursor: 'pointer' }}>
                        <path d={badge.shape} fill={badge.color} stroke="none" />
                        {badge.type === 'type' ? (
                            <text x={badge.cx} y={badge.y + 20} textAnchor="middle" fill="#000" fontWeight="900" fontSize="14" fontFamily="'Dystopian', 'Cairo', sans-serif">
                                {badge.label}
                            </text>
                        ) : (
                            <g transform={`translate(${badge.cx - 10}, ${badge.y + 5})`} color="#fff">
                                <badge.icon width={20} height={20} />
                            </g>
                        )}
                    </g>
                ))}
            </g>

            <g transform="translate(850, 0)" opacity={isHovered ? 1 : 0} style={{ transition: 'opacity 0.2s' }}>
                 {['playstation', 'xbox', 'nintendo', 'pc'].map((p, i) => {
                     const isActive = badges[p as keyof BadgeState];
                     const cfg = PLATFORM_CONFIG[p];
                     return (
                         <g key={p} transform={`translate(${i * 40}, 0)`} onClick={(e) => { e.stopPropagation(); togglePlatform(p as any); }} style={{ cursor: 'pointer' }}>
                            <rect width="35" height="35" fill="#1A202C" stroke={isActive ? cfg.color : '#555'} rx="4" />
                            <g transform="translate(7.5, 7.5)" color={isActive ? cfg.color : '#888'}>
                                <cfg.icon width={20} height={20} />
                            </g>
                         </g>
                     )
                 })}
            </g>

            <g transform="translate(1040, 235)">
                <foreignObject x={-900} y={-30} width={900} height={140}>
                    <SocialNewsBodyEditor 
                        content={data.hero.title} 
                        onChange={(val) => onChange({ hero: { ...data.hero, title: val }})}
                        fontSize={44}
                        textAlign="right"
                        isEditing={editingField === 'heroTitle'}
                        setEditing={(v) => setEditingField(v ? 'heroTitle' : null)}
                        customStyle={{
                            color: "#FFFFFF",
                            fontWeight: 900,
                            textShadow: "0 2px 10px rgba(0,0,0,0.5)",
                            lineHeight: 1.1,
                            fontFamily: "'Dystopian', 'Cairo', sans-serif"
                        }}
                        autoHeight
                        stylingVariant="hero"
                        disableAutoEnglish 
                    />
                </foreignObject>
            </g>
        </g>
    );
}

--- END OF FILE components/studio/social/weekly-news/WeeklyNewsHero.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/WeeklyNewsList.tsx ---

// components/studio/social/weekly-news/WeeklyNewsList.tsx
'use client';

import React, { useState } from 'react';
import { WeeklyNewsTemplateData } from './types';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import EditableText from '../shared/EditableText';

interface Props {
    data: WeeklyNewsTemplateData;
    onChange: (newData: Partial<WeeklyNewsTemplateData>) => void;
}

// Colors: Official (Cyan), Rumor (Gold), Leak (Red)
const TYPE_COLORS: Record<string, string> = {
    official: '#00FFF0', 
    rumor: '#FFD700',    
    leak: '#FF3333'      
};

export default function WeeklyNewsList({ data, onChange }: Props) {
    const [editingField, setEditingField] = useState<string | null>(null);

    const handleItemChange = (index: number, field: 'number' | 'text', value: string) => {
        const newList = [...data.newsList];
        newList[index] = { ...newList[index], [field]: value };
        onChange({ newsList: newList });
    };
    
    // Cycle through types: Official -> Rumor -> Leak -> Official
    const toggleItemType = (index: number) => {
        const newList = [...data.newsList];
        const types = ['official', 'rumor', 'leak'] as const;
        const currentTypeIndex = types.indexOf(newList[index].type || 'official');
        newList[index].type = types[(currentTypeIndex + 1) % types.length];
        onChange({ newsList: newList });
    };

    const renderColumn = (startIndex: number, xOffset: number) => {
        const items = data.newsList.slice(startIndex, startIndex + 6);
        return (
            <g transform={`translate(${xOffset}, 70)`}>
                {items.map((item, localIndex) => {
                    const globalIndex = startIndex + localIndex;
                    const yPos = localIndex * 75;
                    
                    const isImportant = !!item.isImportant;
                    const typeColor = TYPE_COLORS[item.type || 'official'];
                    const numberColor = isImportant ? typeColor : "#556070";

                    return (
                        <g key={item.id} transform={`translate(0, ${yPos})`}>
                            {/* Vertical Line Marker (Important Only) */}
                            {isImportant && (
                                <rect 
                                    x="456" y="0" width="4" height="20" fill={typeColor} 
                                    onClick={(e) => { e.stopPropagation(); toggleItemType(globalIndex); }}
                                    style={{ cursor: 'pointer' }}
                                />
                            )}
                            
                            {/* Number Text */}
                            <EditableText
                                x={425} y={16}
                                text={item.number}
                                fontSize={16}
                                align="end"
                                style={{ fill: numberColor, fontFamily: "monospace", fontWeight: 700 }}
                                onChange={(val) => handleItemChange(globalIndex, 'number', val)}
                                isEditing={editingField === `num-${globalIndex}`}
                                setEditing={(v) => setEditingField(v ? `num-${globalIndex}` : null)}
                                width={50}
                                inputStyle={{fontFamily: 'monospace'}}
                            />
                            
                            {/* INTERACTIVE OVERLAY: Placed AFTER EditableText to capture clicks on top of it */}
                            <rect 
                                x={375} y={0} width={60} height={30} 
                                fill="transparent" 
                                style={{ cursor: 'pointer' }}
                                onClick={(e) => { 
                                    e.stopPropagation(); 
                                    toggleItemType(globalIndex); 
                                }}
                            />
                            
                            {/* Text Body */}
                            <foreignObject x={0} y={0} width={410} height={60}>
                                <SocialNewsBodyEditor
                                    content={item.text}
                                    onChange={(val) => handleItemChange(globalIndex, 'text', val)}
                                    fontSize={14}
                                    textAlign="right"
                                    isEditing={editingField === `text-${globalIndex}`}
                                    setEditing={(v) => setEditingField(v ? `text-${globalIndex}` : null)}
                                    customStyle={{
                                        color: "#FFFFFF",
                                        fontWeight: 700,
                                        lineHeight: 1.4,
                                        fontFamily: "'Dystopian', 'Cairo', sans-serif"
                                    }}
                                    enableFirstWordColor={true}
                                    firstWordColor={typeColor}
                                    disableAutoEnglish={true}
                                />
                            </foreignObject>
                        </g>
                    );
                })}
            </g>
        );
    };

    return (
        <g transform="translate(40, 700)">
             {/* Header (Title) */}
             <g transform="translate(0, 5)">
                <rect x="0" y="-15" width="1000" height="1" fill="#333"></rect>
                <rect x="800" y="-17" width="200" height="4" fill="#00FFF0" filter="url(#wn-neonGlow)"></rect>
                <text x="1000" y="30" direction="rtl" textAnchor="start" fontWeight="900" fontSize="28" fill="#FFF" fontFamily="'Dystopian', 'Cairo', sans-serif">بقية الأخبار</text>
            </g>

            {/* Content Group (Shifted down to avoid overlap) */}
            <g transform="translate(0, 35)">
                {/* CUT CORNER BACKGROUND */}
                <path 
                    d="M 0,60 L 20,40 L 980,40 L 1000,60 L 1000,500 L 980,520 L 20,520 L 0,500 Z" 
                    fill="#0B0D12" 
                    stroke="#1A202C" 
                    strokeWidth="1"
                />
                
                {/* CORNER ACCENTS */}
                <path d="M 0,80 L 0,60 L 20,40 L 40,40" fill="none" stroke="#00FFF0" strokeWidth="2" filter="url(#wn-neonGlow)" />
                <path d="M 960,40 L 980,40 L 1000,60 L 1000,80" fill="none" stroke="#00FFF0" strokeWidth="2" filter="url(#wn-neonGlow)" />
                <path d="M 1000,480 L 1000,500 L 980,520 L 960,520" fill="none" stroke="#00FFF0" strokeWidth="2" filter="url(#wn-neonGlow)" />
                <path d="M 40,520 L 20,520 L 0,500 L 0,480" fill="none" stroke="#00FFF0" strokeWidth="2" filter="url(#wn-neonGlow)" />

                {renderColumn(0, 520)}
                {renderColumn(6, 20)}
            </g>
        </g>
    );
}

--- END OF FILE components/studio/social/weekly-news/WeeklyNewsList.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/WeeklyNewsMainCards.tsx ---

// components/studio/social/weekly-news/WeeklyNewsMainCards.tsx
'use client';

import React, { useState, useRef, useEffect, useMemo } from 'react';
import { WeeklyNewsTemplateData, WeeklyCardData, NewsType, BadgeState } from './types';
import SocialNewsBodyEditor from '../SocialNewsBodyEditor';
import { PLATFORM_ICONS } from '../monthly-games/utils';

interface Props {
    data: WeeklyNewsTemplateData;
    onChange: (newData: Partial<WeeklyNewsTemplateData>) => void;
    scale: number;
}

const NEWS_TYPE_CONFIG: Record<NewsType, { label: string, color: string }> = {
    official: { label: 'رسمي', color: '#00FFF0' },
    rumor: { label: 'إشاعة', color: '#F59E0B' },
    leak: { label: 'تسريب', color: '#DC2626' }
};

const PLATFORM_CONFIG: Record<string, { color: string, icon: any }> = {
    xbox: { color: '#10B981', icon: PLATFORM_ICONS['XSX'] },
    playstation: { color: '#3B82F6', icon: PLATFORM_ICONS['PS5'] },
    nintendo: { color: '#EF4444', icon: PLATFORM_ICONS['NSW'] },
    pc: { color: '#E2E8F0', icon: PLATFORM_ICONS['PC'] }
};

const SingleCard = ({ 
    card, 
    index, 
    onCardChange, 
    scale 
}: { 
    card: WeeklyCardData, 
    index: number, 
    onCardChange: (d: WeeklyCardData) => void, 
    scale: number 
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const dragStart = useRef({ x: 0, y: 0 });
    const initialImgPos = useRef({ x: 0, y: 0 });
    const [imgDims, setImgDims] = useState({ width: 320, height: 160 });
    const [baseScale, setBaseScale] = useState(1);
    const [editingField, setEditingField] = useState<string | null>(null);
    const [isHovered, setIsHovered] = useState(false);

    useEffect(() => {
        if (!card.image) return;
        const img = new Image();
        img.src = card.image;
        img.onload = () => {
            const w = img.naturalWidth || 320;
            const h = img.naturalHeight || 160;
            setImgDims({ width: w, height: h });
            const scaleW = 320 / w;
            const scaleH = 160 / h;
            setBaseScale(Math.max(scaleW, scaleH));
        };
    }, [card.image]);

    // ... Image Handlers ...
    const handleMouseDown = (e: React.MouseEvent) => { if (e.button !== 0) return; e.preventDefault(); e.stopPropagation(); setIsDragging(true); dragStart.current = { x: e.clientX, y: e.clientY }; initialImgPos.current = { ...card.imageSettings }; };
    const handleMouseMove = (e: React.MouseEvent) => { if (!isDragging) return; e.preventDefault(); e.stopPropagation(); const dx = (e.clientX - dragStart.current.x) / scale; const dy = (e.clientY - dragStart.current.y) / scale; onCardChange({ ...card, imageSettings: { ...card.imageSettings, x: initialImgPos.current.x + dx, y: initialImgPos.current.y + dy } }); };
    const handleMouseUp = () => setIsDragging(false);
    const handleWheel = (e: React.WheelEvent) => { e.stopPropagation(); const settings = card.imageSettings; const newScale = Math.max(0.1, Math.min(5, settings.scale - e.deltaY * 0.001)); onCardChange({ ...card, imageSettings: { ...settings, scale: newScale } }); };
    const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => { const file = e.target.files?.[0]; if (file) { const reader = new FileReader(); reader.onload = (ev) => { if(ev.target?.result) { onCardChange({ ...card, image: ev.target.result as string, imageSettings: { x: 0, y: 0, scale: 1 } }); } }; reader.readAsDataURL(file); } };

    // --- Badge Logic ---
    const badges = card.badges || { type: 'official', xbox: false, playstation: false, nintendo: false, pc: false };

    const toggleBadgeType = () => {
        const types: NewsType[] = ['official', 'rumor', 'leak'];
        const nextIndex = (types.indexOf(badges.type) + 1) % types.length;
        onCardChange({ ...card, badges: { ...badges, type: types[nextIndex] } });
    };

    const togglePlatform = (key: 'xbox' | 'playstation' | 'nintendo' | 'pc') => {
        onCardChange({ ...card, badges: { ...badges, [key]: !badges[key] } });
    };

    const activeBadges = useMemo(() => {
        const list: any[] = [];
        const typeConfig = NEWS_TYPE_CONFIG[badges.type];
        list.push({ type: 'type', ...typeConfig, width: 80 });
        if (badges.playstation) list.push({ type: 'platform', ...PLATFORM_CONFIG.playstation, width: 45 });
        if (badges.xbox) list.push({ type: 'platform', ...PLATFORM_CONFIG.xbox, width: 45 });
        if (badges.nintendo) list.push({ type: 'platform', ...PLATFORM_CONFIG.nintendo, width: 45 });
        if (badges.pc) list.push({ type: 'platform', ...PLATFORM_CONFIG.pc, width: 45 });

        const BADGE_HEIGHT = 26;
        const DIAGONAL_OFFSET = 15;
        let currentY = 0;
        let prevBottomWidth = 0;
        
        const RIGHT_EDGE = 320; 

        return list.map((b, i) => {
            const isFirst = i === 0;
            const topWidth = isFirst ? b.width + 10 : prevBottomWidth;
            const bottomWidth = topWidth - DIAGONAL_OFFSET;
            prevBottomWidth = bottomWidth;
            
            const shape = `M ${RIGHT_EDGE},${currentY} L ${RIGHT_EDGE},${currentY + BADGE_HEIGHT} L ${RIGHT_EDGE - bottomWidth},${currentY + BADGE_HEIGHT} L ${RIGHT_EDGE - topWidth},${currentY} Z`;
            const cx = RIGHT_EDGE - (topWidth + bottomWidth) / 4; 
            const badgeY = currentY;
            currentY += BADGE_HEIGHT;
            return { ...b, shape, y: badgeY, cx };
        });
    }, [badges]);

    const settings = card.imageSettings;
    const totalScale = baseScale * settings.scale;
    const transform = `translate(${160 + settings.x} ${80 + settings.y}) scale(${totalScale}) translate(${-imgDims.width / 2} ${-imgDims.height / 2})`;
    const xPos = index * 340;

    return (
        <g transform={`translate(${xPos}, 0)`}
           onMouseEnter={() => setIsHovered(true)}
           onMouseLeave={() => setIsHovered(false)}
        >
            <foreignObject width="0" height="0">
                 <input type="file" ref={fileInputRef} style={{ display: 'none' }} accept="image/*" onChange={handleImageUpload} />
            </foreignObject>
            
            <g clipPath="url(#wn-platformClipV2)">
                <rect width="320" height="160" fill="#000000" />
                <g
                     onMouseDown={handleMouseDown}
                     onMouseMove={handleMouseMove}
                     onMouseUp={handleMouseUp}
                     onMouseLeave={handleMouseUp}
                     onWheel={handleWheel}
                     onDoubleClick={() => fileInputRef.current?.click()}
                     style={{ cursor: isDragging ? 'grabbing' : 'grab' }}
                >
                     {/* Transparent Hit Area */}
                     <rect x="0" y="0" width="320" height="160" fill="transparent" />
                     <image 
                        href={card.image} 
                        width={imgDims.width}
                        height={imgDims.height}
                        transform={transform}
                        preserveAspectRatio="none"
                    />
                </g>
                <rect width="320" height="160" fill="url(#wn-cardShadow)" pointerEvents="none"></rect>
            </g>

            <path d="M 20,0 L 300,0 L 320,20 L 320,140 L 300,160 L 190,160 L 180,150 L 140,150 L 130,160 L 20,160 L 0,140 L 0,20 Z" fill="none" stroke="#556070" strokeWidth="2" pointerEvents="none"></path>
            <path d="M 128,160 L 140,150 L 180,150 L 192,160" stroke="#00FFF0" strokeWidth="3" fill="none" filter="url(#wn-strongNeonGlow)"></path>
            
            {/* BADGES */}
            <g transform="translate(0, 0)"> 
                {activeBadges.map((badge, i) => (
                    <g key={i} onClick={(e) => { e.stopPropagation(); if (badge.type === 'type') toggleBadgeType(); }} style={{ cursor: 'pointer' }}>
                        <path d={badge.shape} fill={badge.color} stroke="none" />
                        {badge.type === 'type' ? (
                            <text x={badge.cx} y={badge.y + 18} textAnchor="middle" fill="#000" fontWeight="900" fontSize="12" fontFamily="'Dystopian', 'Cairo', sans-serif">
                                {badge.label}
                            </text>
                        ) : (
                            <g transform={`translate(${badge.cx - 8}, ${badge.y + 5})`} color="#fff">
                                <badge.icon width={16} height={16} />
                            </g>
                        )}
                    </g>
                ))}
            </g>

             {/* PLATFORM CONTROLS ON HOVER */}
             <g transform="translate(20, -35)" opacity={isHovered ? 1 : 0} style={{ transition: 'opacity 0.2s' }}>
                 {['playstation', 'xbox', 'nintendo', 'pc'].map((p, i) => {
                     const isActive = badges[p as keyof BadgeState];
                     const cfg = PLATFORM_CONFIG[p];
                     return (
                         <g key={p} transform={`translate(${i * 30}, 0)`} onClick={(e) => { e.stopPropagation(); togglePlatform(p as any); }} style={{ cursor: 'pointer' }}>
                            <rect width="25" height="25" fill="#1A202C" stroke={isActive ? cfg.color : '#555'} rx="4" />
                            <g transform="translate(5, 5)" color={isActive ? cfg.color : '#888'}>
                                <cfg.icon width={15} height={15} />
                            </g>
                         </g>
                     )
                 })}
            </g>

            <foreignObject x={10} y={95} width={300} height={70}>
                <SocialNewsBodyEditor 
                    content={card.title} 
                    onChange={(val) => onCardChange({ ...card, title: val })}
                    fontSize={18}
                    textAlign="right"
                    isEditing={editingField === 'title'}
                    setEditing={(v) => setEditingField(v ? 'title' : null)}
                    customStyle={{
                        color: "#FFFFFF",
                        fontWeight: 700,
                        textShadow: "0 2px 4px #000",
                        fontFamily: "'Dystopian', 'Cairo', sans-serif"
                    }}
                    stylingVariant="card"
                    disableAutoEnglish
                />
            </foreignObject>
        </g>
    );
}

export default function WeeklyNewsMainCards({ data, onChange, scale }: Props) {
    const handleCardChange = (index: number, newCard: WeeklyCardData) => {
        const newCards = [...data.cards];
        newCards[index] = newCard;
        onChange({ cards: newCards });
    };

    return (
        <g transform="translate(40, 460)">
            {data.cards.map((card, index) => (
                <SingleCard 
                    key={card.id} 
                    index={index} 
                    card={card} 
                    onCardChange={(d) => handleCardChange(index, d)} 
                    scale={scale}
                />
            ))}
        </g>
    );
}

--- END OF FILE components/studio/social/weekly-news/WeeklyNewsMainCards.tsx ---

================================================================================

--- START OF FILE components/studio/social/weekly-news/types.ts ---

// components/studio/social/weekly-news/types.ts

export type NewsType = 'official' | 'rumor' | 'leak';

export interface ImageSettings {
    x: number;
    y: number;
    scale: number;
}

export interface BadgeState {
    type: NewsType;
    xbox: boolean;
    playstation: boolean;
    nintendo: boolean;
    pc: boolean;
}

export interface WeeklyHeroData {
    sourceId?: string; // NEW
    tag: string;
    title: string;
    image: string;
    imageSettings: ImageSettings;
    badges: BadgeState;
}

export interface WeeklyCardData {
    sourceId?: string; // NEW
    id: number;
    title: string;
    image: string;
    imageSettings: ImageSettings;
    badges: BadgeState;
}

export interface WeeklyListItem {
    sourceId?: string; // NEW
    id: number;
    number: string;
    text: string;
    type: NewsType;
    isImportant: boolean;
}

export interface WeeklyNewsTemplateData {
    weekNumber: string;
    year: string;
    hero: WeeklyHeroData;
    cards: WeeklyCardData[];
    newsList: WeeklyListItem[];
    vibrance?: number; // ADDED
}

--- END OF FILE components/studio/social/weekly-news/types.ts ---

================================================================================

--- START OF FILE components/ui/ArticleCardSkeleton.module.css ---

/* components/ui/ArticleCardSkeleton.module.css */
@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 0.3; }
}

.skeletonCard {
    position: relative;
    width: 100%;
    /* Match the 16/10 aspect ratio of the real card */
    aspect-ratio: 16 / 10;
    min-height: 180px;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    overflow: hidden;
}

.imageSkeleton {
    position: absolute;
    inset: 0;
    background-color: var(--border-color);
    animation: pulse 1.5s ease-in-out infinite;
    z-index: 1;
}

/* Simulate the gradient overlay */
.overlaySkeleton {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60%;
    background: linear-gradient(to top, rgba(10, 11, 15, 0.95) 10%, transparent 100%);
    z-index: 2;
}

/* Mimic the Title Area */
.titleArea {
    position: absolute;
    bottom: 60px; /* Push up above HUD */
    right: 20px;
    left: 20px;
    z-index: 3;
    display: flex;
    flex-direction: column;
    /* ALIGN LEFT (Start of text in LTR, End in RTL - force left visual) */
    align-items: flex-start; 
    gap: 10px;
}

.titleLine {
    height: 24px;
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    animation: pulse 1.5s ease-in-out infinite;
}

/* Mimic the Score Badge (Top Right now to oppose content?) No, keep Top Left per original design */
.scoreBadge {
    position: absolute;
    top: 15px;
    left: 15px;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    z-index: 3;
    animation: pulse 1.5s ease-in-out infinite;
}

/* Mimic the Creator Capsule (Bottom Left) */
.creatorCapsule {
    position: absolute;
    bottom: 15px;
    left: 15px; /* Forced Left */
    width: 100px;
    height: 32px;
    border-radius: 999px;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    z-index: 3;
    animation: pulse 1.5s ease-in-out infinite;
}

/* Mimic the Date/Decor (Bottom Right) */
.metaArea {
    position: absolute;
    bottom: 20px;
    right: 20px; /* Forced Right */
    width: 80px;
    height: 16px;
    border-radius: 4px;
    background-color: rgba(255, 255, 255, 0.1);
    z-index: 3;
    animation: pulse 1.5s ease-in-out infinite;
}

--- END OF FILE components/ui/ArticleCardSkeleton.module.css ---

================================================================================

--- START OF FILE components/ui/ArticleCardSkeleton.tsx ---

// components/ui/ArticleCardSkeleton.tsx
import React from 'react';
import styles from './ArticleCardSkeleton.module.css';

interface SkeletonProps {
    variant?: 'default' | 'no-score';
}

export default function ArticleCardSkeleton({ variant = 'default' }: SkeletonProps) {
    return (
        <div className={styles.skeletonCard}>
            {/* Background Image Placeholder */}
            <div className={styles.imageSkeleton} />
            
            {/* Gradient Overlay */}
            <div className={styles.overlaySkeleton} />

            {/* Score Badge (Top Left) - Only if default */}
            {variant === 'default' && <div className={styles.scoreBadge} />}

            {/* Title Lines (Bottom Left) */}
            <div className={styles.titleArea}>
                <div className={styles.titleLine} style={{ width: '70%' }} />
                <div className={styles.titleLine} style={{ width: '40%' }} />
            </div>

            {/* Creator Capsule (Bottom Left) */}
            <div className={styles.creatorCapsule} />
            
            {/* Date/Meta (Bottom Right) */}
            <div className={styles.metaArea} />
        </div>
    );
}

--- END OF FILE components/ui/ArticleCardSkeleton.tsx ---

================================================================================

--- START OF FILE components/ui/ButtonLoader.tsx ---

// components/ui/ButtonLoader.tsx
'use client';

import { motion } from 'framer-motion';

// SVG paths for the left and right loops of the infinity symbol
const leftLoopPath = "M 50 50 C 50 25, 25 25, 25 50 C 25 75, 50 75, 50 50";
const rightLoopPath = "M 50 50 C 50 25, 75 25, 75 50 C 75 75, 50 75, 50 50";

// Shared transition for a seamless, continuous loop
const transition = {
  duration: 1.5,
  ease: "easeInOut" as const,
  repeat: Infinity,
  repeatType: "loop" as const,
};

/**
 * The "Glyph Deconstruction" loader.
 * Animates the two halves of an infinity symbol, breaking them apart,
 * orbiting them, and reassembling them in a fluid loop.
 */
export default function ButtonLoader() {
  return (
    <motion.svg
      viewBox="0 0 100 100"
      width="24"
      height="24"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      style={{
        stroke: "currentColor",
        strokeWidth: 8,
        fill: "none",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        overflow: "visible", // Prevents clipping during rotation
      }}
    >
      {/* Left loop of the infinity symbol */}
      <motion.path
        d={leftLoopPath}
        style={{ transformOrigin: "25px 50px" }} // Set rotation center to the loop's center
        animate={{
          rotate: [0, -180, -360],
          x: [0, -15, 0],
        }}
        transition={transition}
      />
      {/* Right loop of the infinity symbol */}
      <motion.path
        d={rightLoopPath}
        style={{ transformOrigin: "75px 50px" }} // Set rotation center to the loop's center
        animate={{
          rotate: [0, 180, 360],
          x: [0, 15, 0],
        }}
        transition={transition}
      />
    </motion.svg>
  );
}




--- END OF FILE components/ui/ButtonLoader.tsx ---

================================================================================

--- START OF FILE components/ui/InfiniteScrollSentinel.tsx ---

// components/ui/InfiniteScrollSentinel.tsx
'use client';

import { useEffect, useRef } from 'react';

export default function InfiniteScrollSentinel({ onIntersect }: { onIntersect: () => void }) {
    const ref = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const element = ref.current;
        if (!element) return;

        const observer = new IntersectionObserver(
            (entries) => {
                const first = entries[0];
                if (first.isIntersecting) {
                    onIntersect();
                }
            },
            {
                root: null, // null means the browser viewport, which works for both window and nested scroll containers
                rootMargin: '400px', // Trigger well before the bottom
                threshold: 0,
            }
        );

        observer.observe(element);

        return () => {
            observer.disconnect();
        };
    }, [onIntersect]);

    return <div ref={ref} style={{ height: '1px', width: '1px', pointerEvents: 'none', opacity: 0 }} aria-hidden="true" />;
}

--- END OF FILE components/ui/InfiniteScrollSentinel.tsx ---

================================================================================

--- START OF FILE components/ui/JoinVanguardCard.module.css ---

/* components/ui/JoinVanguardCard.module.css */

.card {
    position: relative;
    background: linear-gradient(180deg, rgba(10, 11, 15, 0.8) 0%, rgba(5, 5, 5, 0.95) 100%);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 2.5rem 2rem;
    overflow: hidden;
    margin-bottom: 3rem;
    text-align: center;
    box-shadow: 0 15px 40px -10px rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
}

/* The Cyber Glow Border */
.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 20%;
    right: 20%;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 1;
    box-shadow: 0 0 15px var(--accent);
}

.iconWrapper {
    width: 60px;
    height: 60px;
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
    border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 1.5rem auto;
    color: var(--accent);
    box-shadow: 0 0 25px color-mix(in srgb, var(--accent) 15%, transparent);
}

.title {
    font-family: var(--font-heading);
    font-size: 2rem;
    font-weight: 800;
    margin-bottom: 0.8rem;
    color: var(--text-primary);
}

.description {
    font-size: 1.5rem;
    color: var(--text-secondary);
    line-height: 1.6;
    margin-bottom: 2.5rem;
}

.featureGrid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2.5rem;
    padding: 0 1rem;
}

.feature {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.featureIcon {
    width: 24px;
    height: 24px;
    color: var(--text-primary);
    margin-bottom: 0.2rem;
}

.featureText {
    font-size: 1.2rem;
    color: var(--text-secondary);
    font-family: var(--font-ui);
    font-weight: 500;
}

.signInBtn {
    width: 100%;
    background-color: var(--accent);
    color: #050505;
    font-weight: 800;
    padding: 1.2rem;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-family: var(--font-main);
    font-size: 1.6rem;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 5px 20px color-mix(in srgb, var(--accent) 30%, transparent);
}

@media (hover: hover) {
    .signInBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px color-mix(in srgb, var(--accent) 50%, transparent);
    }
}

.dismissBtn {
    position: absolute;
    top: 1rem;
    left: 1rem; /* RTL */
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
    padding: 0.4rem;
    opacity: 0.5;
    transition: opacity 0.2s, color 0.2s;
}
.dismissBtn:hover { opacity: 1; color: var(--text-primary); }

--- END OF FILE components/ui/JoinVanguardCard.module.css ---

================================================================================

--- START OF FILE components/ui/JoinVanguardCard.tsx ---

// components/ui/JoinVanguardCard.tsx
'use client';

import { useSession } from 'next-auth/react';
import { useUserStore } from '@/lib/store';
import { motion, AnimatePresence } from 'framer-motion';
import { useState, useEffect } from 'react';
import styles from './JoinVanguardCard.module.css';
import { UserCircleIcon, AllBookmarkIcon, StarIcon } from '@/components/icons';

// Using SVG path for specific feature icons not in main library
const CommentIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
    </svg>
);

const HistoryIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M12 20v-6M6 20V10M18 20V4"></path>
    </svg>
);

const CloseIcon = () => (
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
);

// Import Constellation Icon directly
const ConstellationIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor" {...props}>
        <path d="M12 14C13.1046 14 14 13.1046 14 12C14 10.8954 13.1046 10 12 10C10.8954 10 10 10.8954 10 12C10 13.1046 10.8954 14 12 14Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M20 18C21.1046 18 22 17.1046 22 16C22 14.8954 21.1046 14 20 14C18.8954 14 18 14.8954 18 16C18 17.1046 18.8954 18 20 18Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M11 22C12.1046 22 13 21.1046 13 20C13 18.8954 12.1046 18 11 18C9.89543 18 9 18.8954 9 20C9 21.1046 9.89543 22 11 22Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M15 6C16.1046 6 17 5.10457 17 4C17 2.89543 16.1046 2 15 2C13.8954 2 13 2.89543 13 4C13 5.10457 13.8954 6 15 6Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M4 10C5.10457 10 6 9.10457 6 8C6 6.89543 5.10457 6 4 6C2.89543 6 2 6.89543 2 8C2 9.10457 2.89543 10 4 10Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
        <path d="M14.5 6L12.5 10M13 4.5L6 7.5M12 14L11 18M14 13L18 15M18 17L13 19.5" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round"></path>
    </svg>
);

export default function JoinVanguardCard() {
    const { status } = useSession();
    const { setSignInModalOpen } = useUserStore();
    const [isVisible, setIsVisible] = useState(false);

    useEffect(() => {
        const isDismissed = sessionStorage.getItem('vanguard_dismissed');
        if (status === 'unauthenticated' && !isDismissed) {
            setIsVisible(true);
        } else {
            setIsVisible(false);
        }
    }, [status]);

    const handleDismiss = () => {
        setIsVisible(false);
        sessionStorage.setItem('vanguard_dismissed', 'true');
    };

    if (!isVisible) return null;

    return (
        <AnimatePresence>
            <motion.div 
                className={styles.card}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, height: 0, marginBottom: 0 }}
                transition={{ duration: 0.5 }}
            >
                <button onClick={handleDismiss} className={styles.dismissBtn} aria-label="Dismiss">
                    <CloseIcon />
                </button>

                <div className={styles.iconWrapper}>
                    <UserCircleIcon width={32} height={32} />
                </div>
                
                <h3 className={styles.title}>انضم إلى الطليعة</h3>
                <p className={styles.description}>
                    سجل دخولك لفتح ميزات "ديوان الصنعة" الكاملة وتخصيص تجربتك.
                </p>

                <div className={styles.featureGrid}>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}><AllBookmarkIcon /></div>
                        <span className={styles.featureText}>حفظ ومزامنة</span>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}><ConstellationIcon /></div>
                        <span className={styles.featureText}>أوسمة وجوائز</span>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}><CommentIcon /></div>
                        <span className={styles.featureText}>نقاش المجتمع</span>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}><HistoryIcon /></div>
                        <span className={styles.featureText}>سجل القراءة</span>
                    </div>
                </div>

                <motion.button 
                    onClick={() => setSignInModalOpen(true)}
                    className={styles.signInBtn}
                    whileHover={{ scale: 1.03 }}
                    whileTap={{ scale: 0.98 }}
                >
                    تسجيل الدخول / إنشاء حساب
                </motion.button>
            </motion.div>
        </AnimatePresence>
    );
}

--- END OF FILE components/ui/JoinVanguardCard.tsx ---

================================================================================

--- START OF FILE components/ui/NewsItemSkeleton.module.css ---

/* components/ui/NewsItemSkeleton.module.css */
@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 0.3; }
}

.skeletonCard {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    height: 100%;
    min-height: 160px; /* Approximate height of news card */
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.innerGrid {
    display: grid;
    /* Match NewsGridCard layout: 240px thumbnail | content */
    grid-template-columns: 240px 1fr;
    height: 100%;
}

.imageSkeleton {
    width: 100%;
    height: 100%;
    background-color: var(--border-color);
    animation: pulse 1.5s ease-in-out infinite;
}

.contentSkeleton {
    padding: 1.2rem;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.textLine {
    height: 20px;
    background-color: var(--border-color);
    border-radius: 4px;
    animation: pulse 1.5s ease-in-out infinite;
    margin-bottom: 0.8rem;
}

.titleLine {
    height: 24px;
    width: 90%;
    margin-bottom: 0.5rem;
}

.metaLine {
    height: 16px;
    width: 40%;
    margin-top: auto;
}

@media (max-width: 768px) {
    .innerGrid {
        grid-template-columns: 110px 1fr; /* Mobile layout match */
    }
    .skeletonCard {
        min-height: 110px;
    }
}

--- END OF FILE components/ui/NewsItemSkeleton.module.css ---

================================================================================

--- START OF FILE components/ui/NewsItemSkeleton.tsx ---

// components/ui/NewsItemSkeleton.tsx
import React from 'react';
import styles from './NewsItemSkeleton.module.css';

export default function NewsItemSkeleton() {
    return (
        <div className={styles.skeletonCard}>
            <div className={styles.innerGrid}>
                <div className={styles.imageSkeleton} />
                <div className={styles.contentSkeleton}>
                    <div>
                        <div className={`${styles.textLine} ${styles.titleLine}`} />
                        <div className={`${styles.textLine} ${styles.titleLine}`} style={{ width: '60%' }} />
                    </div>
                    <div className={`${styles.textLine} ${styles.metaLine}`} />
                </div>
            </div>
        </div>
    );
}

--- END OF FILE components/ui/NewsItemSkeleton.tsx ---

================================================================================

--- START OF FILE components/ui/ProgressBar.tsx ---

// components/ui/ProgressBar.tsx
'use client';

import { useEffect, useState, Suspense } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';

// Global event bus for the progress bar
type Listener = (state: boolean) => void;
let listeners: Listener[] = [];

const notify = (state: boolean) => listeners.forEach(l => l(state));

export const startNavigation = () => notify(true);
export const endNavigation = () => notify(false);

function ProgressBarInner() {
    const [isLoading, setIsLoading] = useState(false);
    const pathname = usePathname();
    const searchParams = useSearchParams();

    useEffect(() => {
        const handler = (state: boolean) => setIsLoading(state);
        listeners.push(handler);
        return () => { listeners = listeners.filter(l => l !== handler); };
    }, []);

    useEffect(() => {
        // Stop loading when route changes
        endNavigation();
    }, [pathname, searchParams]);

    return (
        <AnimatePresence>
            {isLoading && (
                <motion.div
                    initial={{ scaleX: 0, opacity: 1 }}
                    animate={{ 
                        scaleX: 0.9, 
                        opacity: 1,
                        transition: { duration: 6, ease: "circOut" } // Slow fake progress
                    }}
                    exit={{ 
                        scaleX: 1, 
                        opacity: 0,
                        transition: { duration: 0.3 } 
                    }}
                    style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        height: '3px',
                        backgroundColor: 'var(--accent)',
                        transformOrigin: 'left',
                        zIndex: 99999,
                        boxShadow: '0 0 15px var(--accent)'
                    }}
                />
            )}
        </AnimatePresence>
    );
}

export default function ProgressBar() {
    return (
        <Suspense fallback={null}>
            <ProgressBarInner />
        </Suspense>
    );
}

--- END OF FILE components/ui/ProgressBar.tsx ---

================================================================================

--- START OF FILE components/ui/ScrollToTopButton.module.css ---

/* components/ui/ScrollToTopButton.module.css */

.scrollToTopButton {
    position: fixed;
    bottom: 2rem;
    left: 2rem; /* Consistent with toast position */
    right: auto;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background-color: var(--accent);
    color: #fff;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 5px 20px -5px color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 1000;
}

[data-theme="dark"] .scrollToTopButton {
    color: var(--bg-primary);
}




--- END OF FILE components/ui/ScrollToTopButton.module.css ---

================================================================================

--- START OF FILE components/ui/ScrollToTopButton.tsx ---

// components/ui/ScrollToTopButton.tsx
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { useScrolled } from '@/hooks/useScrolled';
import { useUIStore } from '@/lib/uiStore';
import styles from './ScrollToTopButton.module.css';

const ArrowUpIcon = () => (
    <svg width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="19" x2="12" y2="5"></line>
        <polyline points="5 12 12 5 19 12"></polyline>
    </svg>
);

export default function ScrollToTopButton() {
    const isScrolled = useScrolled(400); 
    const { overlayScrollRef } = useUIStore();

    const scrollToTop = () => {
        if (overlayScrollRef) {
            overlayScrollRef.scrollTo({ top: 0, behavior: 'smooth' });
        } else {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    };

    return (
        <AnimatePresence>
            {isScrolled && (
                <motion.button
                    className={styles.scrollToTopButton}
                    onClick={scrollToTop}
                    initial={{ opacity: 0, y: 50 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 50 }}
                    transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.95 }}
                    aria-label="Scroll to top"
                >
                    <ArrowUpIcon />
                </motion.button>
            )}
        </AnimatePresence>
    );
}

--- END OF FILE components/ui/ScrollToTopButton.tsx ---

================================================================================

--- START OF FILE components/ui/SmoothScrolling.tsx ---

// components/ui/SmoothScrolling.tsx
'use client';

import { ReactLenis } from 'lenis/react';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useEffect, useState } from 'react';

export default function SmoothScrolling({ children }: { children: React.ReactNode }) {
  // FIXED: Property now exists in the store interface
  const isEnabled = usePerformanceStore((state) => state.isSmoothScrollingEnabled);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    // Rehydrate store on mount
    usePerformanceStore.persist.rehydrate();
    setMounted(true);
  }, []);

  // If not mounted or disabled, render native scrolling
  if (!mounted || !isEnabled) {
    return <>{children}</>;
  }
  
  // FIXED: Explicitly cast 'vertical' strings to the specific type expected by LenisOptions
  // or cast the whole object to any if the types are strict.
  const lenisOptions = {
    duration: 1.2,
    easing: (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
    orientation: 'vertical' as const, // Fixes type error
    gestureOrientation: 'vertical' as const, // Fixes type error
    wheelMultiplier: 1,
    smoothWheel: true,
    touchMultiplier: 2,
    smoothTouch: false,
  };

  return (
    <ReactLenis root options={lenisOptions}>
      {children}
    </ReactLenis>
  );
}

--- END OF FILE components/ui/SmoothScrolling.tsx ---

================================================================================

--- START OF FILE components/ui/SpaceBackground.module.css ---

/* components/ui/SpaceBackground.module.css */

.backgroundContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1000;
    background-color: #10121A;
    overflow: hidden;
    pointer-events: none;
    transform: translateZ(0); 
    backface-visibility: hidden;
    contain: paint;
}

.canvasSvg {
    display: block;
    width: 100%;
    height: 100%;
    shape-rendering: geometricPrecision;
}

/* --- GPU ANIMATIONS --- */

@keyframes pulse {
    0%, 100% { opacity: 0.8; transform: scale(1); }
    50% { opacity: 0.4; transform: scale(0.95); }
}

@keyframes driftTop {
    0% { transform: translate(0, 0); }
    50% { transform: translate(2%, 2%); }
    100% { transform: translate(0, 0); }
}

@keyframes driftBottom {
    0% { transform: translate(0, 0); }
    50% { transform: translate(-2%, -2%); }
    100% { transform: translate(0, 0); }
}

@keyframes driftRight {
    0% { transform: translate(0, 0) scale(1); }
    50% { transform: translate(-1%, 2%) scale(1.05); }
    100% { transform: translate(0, 0) scale(1); }
}

/* NEW: Parallax Star Drifts */
/* Layer 1: Closest (Fastest, moves diagonal up-left) */
@keyframes starDrift1 {
    0% { transform: translate(0, 0); }
    100% { transform: translate(-200px, -100px); }
}

/* Layer 2: Mid-range (Medium speed, moves left) */
@keyframes starDrift2 {
    0% { transform: translate(0, 0); }
    100% { transform: translate(-150px, 20px); }
}

/* Layer 3: Farthest (Slowest, moves slight diagonal up-right) */
@keyframes starDrift3 {
    0% { transform: translate(0, 0); }
    100% { transform: translate(100px, -50px); }
}

/* Animation Classes */
.nebulaAnimTop {
    will-change: transform;
    animation: driftTop 20s ease-in-out infinite;
}

.nebulaAnimBottom {
    will-change: transform;
    animation: driftBottom 25s ease-in-out infinite;
}

.nebulaAnimRight {
    will-change: transform;
    animation: driftRight 30s ease-in-out infinite;
}

.starsLayer1 {
    will-change: transform;
    /* 120s duration for noticeable but smooth movement */
    animation: starDrift1 120s linear infinite;
}

.starsLayer2 {
    will-change: transform;
    animation: starDrift2 160s linear infinite;
}

.starsLayer3 {
    will-change: transform;
    animation: starDrift3 200s linear infinite;
}

.starAnim {
    will-change: opacity, transform;
    transform-origin: center center;
    animation: pulse 8s ease-in-out infinite;
}

/* --- THE FREEZE SWITCH --- */
.static * {
    animation-play-state: paused !important;
}

--- END OF FILE components/ui/SpaceBackground.module.css ---

================================================================================

--- START OF FILE components/ui/SpaceBackground.tsx ---

// components/ui/SpaceBackground.tsx
'use client';

import React, { useEffect, useState } from 'react';
import styles from './SpaceBackground.module.css';
import { usePerformanceStore } from '@/lib/performanceStore';
import { useTheme } from 'next-themes';
import Image from 'next/image';

// Configuration
const BACKGROUND_BRIGHTNESS = 1.0; 

export default function SpaceBackground() {
    const { isBackgroundVisible, isBackgroundAnimated } = usePerformanceStore();
    const { resolvedTheme } = useTheme();
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
    }, []);

    // 1. GLOBAL OFF SWITCH
    // If not mounted or light mode, render nothing immediately.
    if (!mounted || resolvedTheme === 'light') return null;

    // 2. PERFORMANCE OFF SWITCH
    // If background is toggled off (Tier 0), render a simple div color.
    if (!isBackgroundVisible) {
        return <div className={styles.backgroundContainer} style={{ backgroundColor: '#10121A' }} />;
    }

    // 3. STATIC MODE (The Default)
    // If animation is OFF, we return the Image component directly.
    // The code stops here. The SVG below is never reached or calculated.
    if (!isBackgroundAnimated) {
        return (
            <div className={styles.backgroundContainer} style={{ filter: `brightness(${BACKGROUND_BRIGHTNESS})` }}>
                <Image 
                    src="/EGBG.jpg" 
                    alt="" 
                    fill 
                    priority 
                    // High quality for 4K background (Max fidelity)
                    quality={100} 
                    // "100vw" tells the browser: "This image is always 100% of the viewport width".
                    // The browser then selects the most appropriate size from the srcset automatically.
                    sizes="100vw"
                    style={{ objectFit: 'cover', objectPosition: 'center' }} 
                    draggable={false}
                />
            </div>
        );
    }

    // 4. ANIMATED MODE (Only runs if manually enabled)
    // This code is isolated and won't impact performance in Static Mode.
    const containerClass = `${styles.backgroundContainer}`;

    return (
        <div className={containerClass} style={{ filter: `brightness(${BACKGROUND_BRIGHTNESS})` }}>
            <svg 
                className={styles.canvasSvg}
                viewBox="0 0 1920 1080" 
                xmlns="http://www.w3.org/2000/svg" 
                preserveAspectRatio="xMidYMid slice"
            >
                <defs>
                    <filter id="sb_stellarBloom">
                        <feGaussianBlur stdDeviation="2" result="blur"></feGaussianBlur>
                        <feComposite in="SourceGraphic" in2="blur" operator="over"></feComposite>
                    </filter>

                    <linearGradient id="sb_shardGradWhite" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stopColor="#FFFFFF" stopOpacity="0.30"></stop>
                        <stop offset="40%" stopColor="#FFFFFF" stopOpacity="0.10"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                    </linearGradient>

                    <linearGradient id="sb_shardGradCyan" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.35"></stop>
                        <stop offset="50%" stopColor="#00FFF0" stopOpacity="0.1"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                    </linearGradient>

                    <radialGradient id="sb_nebulaTop" cx="50%" cy="0%" r="80%">
                        <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.12"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                    </radialGradient>
                    <radialGradient id="sb_nebulaBottom" cx="10%" cy="100%" r="60%">
                        <stop offset="0%" stopColor="#556070" stopOpacity="0.2"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                    </radialGradient>
                    <radialGradient id="sb_nebulaRight" cx="95%" cy="50%" r="50%">
                        <stop offset="0%" stopColor="#00FFF0" stopOpacity="0.08"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0"></stop>
                    </radialGradient>

                    <pattern id="sb_scanlinePattern" x="0" y="0" width="10" height="4" patternUnits="userSpaceOnUse">
                        <line x1="0" y1="3" x2="10" y2="3" stroke="#000" strokeWidth="1" opacity="0.4"></line>
                    </pattern>

                    <pattern id="sb_scratchPattern" x="0" y="0" width="500" height="500" patternUnits="userSpaceOnUse">
                        <path d="M 50 50 L 80 80 M 200 100 L 220 90 M 350 300 L 360 320 M 100 300 L 80 320" stroke="#FFF" strokeWidth="0.5" opacity="0.15" strokeLinecap="square"></path>
                        <path d="M 400 50 L 420 80 M 10 400 L 30 380" stroke="#FFF" strokeWidth="0.5" opacity="0.1"></path>
                    </pattern>

                    <g id="sb_star"><circle r="1.5" fill="#F0F0FF"></circle></g>
                    <g id="sb_c_A"><path d="M0,0 L30,40 L-20,30" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="40"></use><use href="#sb_star" x="-20" y="30"></use></g>
                    <g id="sb_c_B"><path d="M0,0 L40,0 L80,0" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="40" y="0"></use><use href="#sb_star" x="80" y="0"></use></g>
                    <g id="sb_c_C"><path d="M0,0 L0,40 L30,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="0" y="40"></use><use href="#sb_star" x="30" y="60"></use></g>
                    <g id="sb_c_D"><path d="M0,0 L20,30 M20,30 L0,60 M20,30 L40,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="20" y="30"></use><use href="#sb_star" x="0" y="60"></use><use href="#sb_star" x="40" y="60"></use></g>
                    <g id="sb_c_E"><path d="M0,0 L40,10 L30,50 L-10,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="40" y="10"></use><use href="#sb_star" x="30" y="50"></use><use href="#sb_star" x="-10" y="40"></use></g>
                    <g id="sb_c_F"><path d="M0,0 L30,20 L0,40 L30,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="20"></use><use href="#sb_star" x="0" y="40"></use><use href="#sb_star" x="30" y="60"></use></g>
                    <g id="sb_c_G"><path d="M0,20 L40,20 M40,20 L20,0 M40,20 L20,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="20"></use><use href="#sb_star" x="40" y="20"></use><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="20" y="40"></use></g>
                    <g id="sb_c_H"><path d="M0,0 L30,10 L60,30 L90,60" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="10"></use><use href="#sb_star" x="60" y="30"></use><use href="#sb_star" x="90" y="60"></use></g>
                    <g id="sb_c_I"><path d="M0,0 L20,0 L10,15" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="10" y="15"></use></g>
                    <g id="sb_c_J"><path d="M20,0 L20,40 M0,20 L40,20" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="20" y="0"></use><use href="#sb_star" x="20" y="40"></use><use href="#sb_star" x="0" y="20"></use><use href="#sb_star" x="40" y="20"></use><use href="#sb_star" x="20" y="20"></use></g>
                    <g id="sb_c_K"><path d="M0,0 L30,10 L60,10 L80,30 L50,40" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="0" y="0"></use><use href="#sb_star" x="30" y="10"></use><use href="#sb_star" x="60" y="10"></use><use href="#sb_star" x="80" y="30"></use><use href="#sb_star" x="50" y="40"></use></g>
                    <g id="sb_c_L"><path d="M10,0 L30,0 L40,17 L30,34 L10,34" stroke="#556070" strokeWidth="0.5" fill="none"></path><use href="#sb_star" x="10" y="0"></use><use href="#sb_star" x="30" y="0"></use><use href="#sb_star" x="40" y="17"></use><use href="#sb_star" x="30" y="34"></use><use href="#sb_star" x="10" y="34"></use></g>

                    <symbol id="sb_stars_Layer1">
                        <g fill="#F0F0FF" opacity="0.2">
                            <circle cx="20" cy="20" r="1.5"></circle> <circle cx="400" cy="10" r="1.2"></circle>
                            <circle cx="600" cy="80" r="1.5"></circle> <circle cx="100" cy="400" r="1.2"></circle>
                            <circle cx="500" cy="420" r="0.8"></circle> <circle cx="20" cy="700" r="1.5"></circle>
                            <circle cx="550" cy="700" r="1"></circle> <circle cx="400" cy="200" r="1.2"></circle>
                            <circle cx="750" cy="50" r="1"></circle> <circle cx="150" cy="600" r="1.4"></circle>
                            <circle cx="300" cy="100" r="1"></circle> <circle cx="680" cy="350" r="1.3"></circle>
                        </g>
                        <use href="#sb_c_A" x="50" y="50" opacity="0.6"></use>
                        <use href="#sb_c_B" x="500" y="50" opacity="0.5"></use>
                        <use href="#sb_c_D" x="200" y="300" opacity="0.6" transform="rotate(20 200 300)"></use>
                        <use href="#sb_c_G" x="600" y="600" opacity="0.5"></use>
                        <use href="#sb_c_H" x="100" y="700" opacity="0.6" transform="rotate(-15 100 700)"></use>
                    </symbol>

                    <symbol id="sb_stars_Layer2">
                        <g fill="#F0F0FF" opacity="0.15">
                            <circle cx="50" cy="100" r="1"></circle> <circle cx="250" cy="20" r="0.8"></circle>
                            <circle cx="700" cy="120" r="1"></circle> <circle cx="350" cy="650" r="0.8"></circle>
                            <circle cx="150" cy="550" r="1.1"></circle> <circle cx="450" cy="300" r="1"></circle>
                            <circle cx="650" cy="450" r="0.8"></circle> <circle cx="50" cy="350" r="1"></circle>
                            <circle cx="780" cy="780" r="0.9"></circle> <circle cx="250" cy="400" r="1.1"></circle>
                            <circle cx="10" cy="600" r="1"></circle> <circle cx="550" cy="100" r="0.8"></circle>
                        </g>
                        <use href="#sb_c_C" x="50" y="150" opacity="0.5"></use>
                        <use href="#sb_c_E" x="350" y="100" opacity="0.5"></use>
                        <use href="#sb_c_F" x="650" y="180" transform="rotate(60 650 180)" opacity="0.5"></use>
                        <use href="#sb_c_L" x="300" y="350" opacity="0.5"></use>
                        <use href="#sb_c_A" x="500" y="500" opacity="0.4" transform="rotate(180 500 500)"></use>
                        <use href="#sb_c_B" x="100" y="500" opacity="0.5" transform="rotate(45 100 500)"></use>
                        <use href="#sb_c_E" x="700" y="700" opacity="0.4"></use>
                    </symbol>

                    <symbol id="sb_stars_Layer3">
                        <g fill="#F0F0FF" opacity="0.12">
                            <circle cx="30" cy="40" r="0.8"></circle> <circle cx="140" cy="140" r="0.7"></circle>
                            <circle cx="300" cy="50" r="0.9"></circle> <circle cx="550" cy="20" r="0.8"></circle>
                            <circle cx="750" cy="150" r="0.7"></circle> <circle cx="40" cy="280" r="0.8"></circle>
                            <circle cx="220" cy="350" r="0.9"></circle> <circle cx="460" cy="500" r="0.7"></circle>
                            <circle cx="640" cy="350" r="0.8"></circle> <circle cx="50" cy="550" r="0.9"></circle>
                            <circle cx="340" cy="720" r="0.7"></circle> <circle cx="600" cy="750" r="0.8"></circle>
                            <circle cx="180" cy="780" r="0.9"></circle> <circle cx="720" cy="550" r="0.7"></circle>
                            <circle cx="400" cy="650" r="0.8"></circle> <circle cx="550" cy="250" r="0.7"></circle>
                        </g>
                        <use href="#sb_c_L" x="500" y="380" opacity="0.3"></use>
                        <use href="#sb_c_A" x="780" y="150" opacity="0.5"></use>
                        <use href="#sb_c_F" x="50" y="600" opacity="0.6"></use>
                        <use href="#sb_c_G" x="300" y="200" opacity="0.4"></use>
                        <use href="#sb_c_I" x="150" y="100" opacity="0.5"></use>
                        <use href="#sb_c_K" x="650" y="450" opacity="0.3"></use>
                    </symbol>

                    {/* PATTERNS (Static for Export) */}
                    <pattern id="sb_pat_Layer1" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                        <use href="#sb_stars_Layer1"></use>
                    </pattern>
                    <pattern id="sb_pat_Layer2" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                        <use href="#sb_stars_Layer2"></use>
                    </pattern>
                    <pattern id="sb_pat_Layer3" x="0" y="0" width="800" height="800" patternUnits="userSpaceOnUse">
                        <use href="#sb_stars_Layer3"></use>
                    </pattern>

                    {/* VIGNETTE */}
                    <radialGradient id="sb_vignette" cx="50%" cy="50%" r="80%">
                        <stop offset="60%" stopColor="#10121A" stopOpacity="0"></stop>
                        <stop offset="100%" stopColor="#10121A" stopOpacity="0.9"></stop>
                    </radialGradient>
                </defs>

                {/* 1. BASE BACKGROUND */}
                <rect width="100%" height="100%" fill="#10121A"></rect>

                {/* 2. ATMOSPHERE (CSS Animated) */}
                <rect className={styles.nebulaAnimTop} width="100%" height="100%" fill="url(#sb_nebulaTop)" style={{ mixBlendMode: 'screen' }}></rect>
                <rect className={styles.nebulaAnimBottom} width="100%" height="100%" fill="url(#sb_nebulaBottom)" style={{ mixBlendMode: 'screen' }}></rect>
                <rect className={styles.nebulaAnimRight} width="100%" height="100%" fill="url(#sb_nebulaRight)" style={{ mixBlendMode: 'screen' }}></rect>

                {/* 3. MOVING STAR LAYERS (Parallax Drift) */}
                {/* Layer 3: Farthest, Slowest */}
                <g className={styles.starsLayer3}>
                     {/* Increased size and offset to prevent clipping during drift */}
                    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#sb_pat_Layer3)" opacity="0.3"></rect>
                </g>
                
                {/* Layer 2: Mid */}
                <g className={styles.starsLayer2}>
                    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#sb_pat_Layer2)" opacity="0.4"></rect>
                </g>
                
                {/* Layer 1: Closest, Fastest */}
                <g className={styles.starsLayer1}>
                    <rect x="-50%" y="-50%" width="200%" height="200%" fill="url(#sb_pat_Layer1)" opacity="0.5"></rect>
                </g>

                {/* 4. STATIC SHARDS */}
                <g style={{ mixBlendMode: 'soft-light' }}>
                    <g>
                        <g fill="url(#sb_shardGradWhite)" stroke="#FFFFFF" strokeOpacity="0.3" strokeWidth="1.5">
                            <path d="M 120 120 L 320 160 L 220 320 L 80 260 Z" opacity="0.7"></path>
                            <path d="M -20 600 L 220 640 L 120 820 L 40 780 Z" opacity="0.5"></path>
                            <path d="M 1450 880 L 1650 920 L 1550 1060 L 1320 1020 Z" opacity="0.8"></path>
                            <path d="M 1550 480 L 1750 520 L 1700 680 Z" opacity="0.5"></path>
                        </g>
                        <g fill="url(#sb_shardGradCyan)" stroke="#00FFF0" strokeOpacity="0.4" strokeWidth="1.5">
                            <path d="M 1580 120 L 1780 80 L 1820 320 L 1620 280 Z" opacity="0.8"></path>
                            <path d="M 150 900 L 350 860 L 300 1040 Z" opacity="0.7"></path>
                        </g>
                    </g>
                    <g>
                        <g fill="url(#sb_shardGradWhite)" stroke="#FFFFFF" strokeOpacity="0.3" strokeWidth="1.5">
                            <path d="M 750 80 L 950 120 L 850 280 Z" opacity="0.4"></path>
                            <path d="M 850 920 L 1050 880 L 1150 1020 L 900 980 Z" opacity="0.6"></path>
                            <path d="M 450 420 L 650 460 L 550 620 Z" opacity="0.3"></path>
                        </g>
                        <g fill="url(#sb_shardGradCyan)" stroke="#00FFF0" strokeOpacity="0.4" strokeWidth="1.5">
                            <path d="M 1200 320 L 1380 280 L 1420 500 L 1250 450 Z" opacity="0.6"></path>
                        </g>
                    </g>
                </g>

                {/* 5. STELLAR FLARES */}
                <g filter="url(#sb_stellarBloom)" className={styles.starAnim}>
                    <circle cx="300" cy="300" r="3" fill="#FFF"></circle>
                    <circle cx="1200" cy="150" r="2.5" fill="#FFF"></circle>
                    <circle cx="800" cy="800" r="3" fill="#FFF"></circle>
                    <circle cx="1500" cy="600" r="2" fill="#FFF"></circle>
                    <circle cx="100" cy="1000" r="2.2" fill="#FFF" opacity="0.6"></circle>
                    <circle cx="1800" cy="200" r="2.8" fill="#FFF"></circle>
                    <circle cx="900" cy="50" r="3" fill="#FFF"></circle>
                    <circle cx="500" cy="950" r="2.5" fill="#FFF" opacity="0.7"></circle>
                    
                    <circle cx="500" cy="200" r="3" fill="#00FFF0" opacity="0.8"></circle>
                    <circle cx="1000" cy="500" r="4" fill="#00FFF0" opacity="0.6"></circle>
                    <circle cx="1700" cy="900" r="3.5" fill="#00FFF0" opacity="0.8"></circle>
                    <circle cx="1400" cy="300" r="2" fill="#00FFF0" opacity="0.9"></circle>
                    <circle cx="600" cy="600" r="3.2" fill="#00FFF0" opacity="0.8"></circle>
                    <circle cx="1850" cy="500" r="3" fill="#00FFF0" opacity="0.9"></circle>
                    <circle cx="900" cy="900" r="3.5" fill="#00FFF0" opacity="0.8"></circle>
                    <circle cx="50" cy="50" r="3" fill="#00FFF0" opacity="0.9"></circle>
                </g>

                {/* 6. OVERLAYS */}
                <rect width="110%" height="110%" fill="url(#sb_scratchPattern)" opacity="0.4"></rect>
                <rect width="100%" height="120%" fill="url(#sb_scanlinePattern)" pointerEvents="none"></rect>
                <rect width="100%" height="100%" fill="url(#sb_vignette)"></rect>
            </svg>
        </div>
    );
}

--- END OF FILE components/ui/SpaceBackground.tsx ---

================================================================================

--- START OF FILE components/ui/Toast.tsx ---

// components/ui/Toast.tsx

'use client';

import { motion } from 'framer-motion';
import { useEffect } from 'react';
import React from 'react';

export type ToastType = 'success' | 'error' | 'info';

export interface ToastProps {
id: string;
message: string;
type: ToastType;
onDismiss: (id: string) => void;
duration?: number;
}

const icons: Record<ToastType, React.JSX.Element> = {
success: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>,
error: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
info: <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>,
};

//  DEFINITIVE FIX FOR COLORS
// 'success' now uses the brand's accent color.
const bgColors: Record<ToastType, string> = {
success: 'var(--accent)',
error: '#DC2626',
info: '#6B7280', // Using a neutral secondary text color for info
};

const toastVariants = {
initial: { opacity: 0, y: 50, scale: 0.8 },
animate: { opacity: 1, y: 0, scale: 1, transition: { type: 'spring' as const, damping: 20, stiffness: 200 } },
exit: { opacity: 0, scale: 0.9, transition: { duration: 0.2, ease: 'easeOut' as const } },
};

export const Toast = ({ id, message, type, onDismiss, duration = 5000 }: ToastProps) => {
useEffect(() => {
const timer = setTimeout(() => {
onDismiss(id);
}, duration);

return () => clearTimeout(timer);
}, [id, duration, onDismiss]);

return (
<motion.div
layout
variants={toastVariants}
initial="initial"
animate="animate"
exit="exit"
style={{
display: 'flex',
alignItems: 'center',
gap: '1rem',
padding: '1.25rem 1.5rem',
borderRadius: '8px',
color: '#fff',
backgroundColor: bgColors[type],
boxShadow: '0 10px 25px -5px rgba(0,0,0,0.2)',
width: '100%',
maxWidth: '380px',
}}
>
<div style={{ flexShrink: 0 }}>{icons[type]}</div>
<p style={{ margin: 0, flexGrow: 1, fontWeight: 500 }}>{message}</p>
<button onClick={() => onDismiss(id)} style={{ background: 'none', border: 'none', color: 'inherit', cursor: 'pointer', padding: '0.25rem', marginLeft: 'auto' }}>
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
</button>
</motion.div>
);
};







--- END OF FILE components/ui/Toast.tsx ---

================================================================================

--- START OF FILE components/upscaler/Upscaler.module.css ---

/* components/upscaler/Upscaler.module.css */

.dropzone {
    width: 100%;
    height: 400px;
    border: 2px dashed var(--border-color);
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background-color: color-mix(in srgb, var(--bg-secondary) 50%, transparent);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}
@media (hover: hover) {@media (hover: hover) {
  
  .dropzone:hover  {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}
}

  .dropzone:active  {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}
}
.dropzone:active {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 5%, transparent);
}


.dropzone.active {
    border-color: var(--accent);
    background-color: color-mix(in srgb, var(--accent) 10%, transparent);
}

.dropzoneContent {
    text-align: center;
    color: var(--text-primary);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    z-index: 2;
}

.dropzoneContent h3 {
    font-size: 2.4rem;
    margin: 0;
    font-family: var(--font-heading);
}

.dropzoneContent p {
    color: var(--text-secondary);
    font-size: 1.6rem;
}

.specsLabel {
    font-family: monospace;
    font-size: 1.2rem;
    color: var(--accent);
    background: color-mix(in srgb, var(--accent) 10%, transparent);
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    margin-top: 1rem;
    border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
}

.processingContainer {
    width: 100%;
    max-width: 900px;
    margin: 0 auto;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    background-color: #000;
    position: relative;
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.5);
}

.previewWrapper {
    position: relative;
    width: 100%;
    min-height: 500px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.processingImage {
    max-width: 100%;
    max-height: 80vh;
    object-fit: contain;
    opacity: 0.4;
    filter: blur(8px);
    transition: opacity 0.5s ease;
}

.scanBeam {
    position: absolute;
    left: 0;
    right: 0;
    height: 4px;
    background: var(--accent);
    box-shadow: 0 0 30px 5px var(--accent);
    z-index: 10;
}

.statusOverlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
    background: rgba(0,0,0,0.2);
    backdrop-filter: blur(2px);
}

.statusMessage {
    color: white;
    font-size: 2rem;
    margin-top: 2rem;
    font-weight: 700;
    text-shadow: 0 2px 10px rgba(0,0,0,0.8);
}

.progressBarContainer {
    width: 300px;
    margin-top: 2rem;
    text-align: center;
}

.progressBarTrack {
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.2);
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progressBarFill {
    height: 100%;
    background: var(--accent);
    border-radius: 3px;
    transition: width 0.2s linear;
    box-shadow: 0 0 10px var(--accent);
}

.progressText {
    color: rgba(255,255,255,0.8);
    font-size: 1.2rem;
    font-family: monospace;
}

.resultContainer {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    animation: fadeIn 0.5s ease-out;
}

.compareContainer {
    height: 600px;
    border-radius: 16px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    box-shadow: 0 20px 50px -10px rgba(0,0,0,0.3);
}

.actionsBar {
    display: flex;
    justify-content: center;
    gap: 2rem;
    padding: 2rem;
    background: var(--bg-secondary);
    border-radius: 12px;
    border: 1px solid var(--border-color);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

@media (max-width: 768px) {
    .dropzone { height: 300px; }
    .processingContainer, .compareContainer { min-height: 400px; height: auto; }
    .actionsBar { flex-direction: column; }
}




--- END OF FILE components/upscaler/Upscaler.module.css ---

================================================================================

--- START OF FILE components/upscaler/UpscalerClient.tsx ---

// components/upscaler/UpscalerClient.tsx
'use client';

import { useUpscaler } from '@/hooks/useUpscaler';
import UpscalerDropzone from './UpscalerDropzone';
import UpscalerProcessing from './UpscalerProcessing';
import { ReactCompareSlider, ReactCompareSliderImage } from 'react-compare-slider';
import styles from './Upscaler.module.css';
import { motion } from 'framer-motion';

export default function UpscalerClient() {
    const { status, progress, message, resultSrc, originalSrc, upscaleImage, reset } = useUpscaler();

    const handleDownload = () => {
        if (!resultSrc) return;
        const link = document.createElement('a');
        link.href = resultSrc;
        link.download = `eternal-upscale-${Date.now()}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    if (status === 'idle') {
        return <UpscalerDropzone onImageSelect={upscaleImage} />;
    }

    if (status === 'error') {
        return (
            <div className={styles.dropzone} style={{ flexDirection: 'column', gap: '1rem', borderColor: '#DC2626' }}>
                <h3 style={{ color: '#DC2626', margin: 0 }}>فشلت المعالجة</h3>
                <p style={{ color: 'var(--text-secondary)', textAlign: 'center', maxWidth: '80%' }}>{message}</p>
                <p style={{ fontSize: '1.2rem', color: 'var(--text-secondary)' }}>تأكد من دعم المتصفح لـ WebGL وافتح (F12) للتفاصيل.</p>
                <button onClick={reset} className="primary-button" style={{ marginTop: '1rem' }}>
                    حاول مجدداً
                </button>
            </div>
        );
    }

    if (status === 'complete' && resultSrc && originalSrc) {
        return (
            <div className={styles.resultContainer}>
                <div className={styles.compareContainer}>
                    <ReactCompareSlider
                        itemOne={<ReactCompareSliderImage src={originalSrc} alt="Original" />}
                        itemTwo={<ReactCompareSliderImage src={resultSrc} alt="Upscaled" />}
                        style={{ width: '100%', height: '100%' }}
                    />
                </div>
                <div className={styles.actionsBar}>
                    <motion.button 
                        onClick={handleDownload} 
                        className="primary-button"
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                    >
                        تحميل الصورة (PNG)
                    </motion.button>
                    <button onClick={reset} className="outline-button">
                        صورة جديدة
                    </button>
                </div>
            </div>
        );
    }

    return (
        <UpscalerProcessing 
            status={status} 
            progress={progress} 
            message={message} 
            imageSrc={originalSrc || ''} 
        />
    );
}




--- END OF FILE components/upscaler/UpscalerClient.tsx ---

================================================================================

--- START OF FILE components/upscaler/UpscalerDropzone.tsx ---

// components/upscaler/UpscalerDropzone.tsx
'use client';

import { useState, useRef } from 'react';
import { motion } from 'framer-motion';
import styles from './Upscaler.module.css';

const ScanIcon = () => (
    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
        <path d="M3 7V5a2 2 0 0 1 2-2h2" />
        <path d="M17 3h2a2 2 0 0 1 2 2v2" />
        <path d="M21 17v2a2 2 0 0 1-2 2h-2" />
        <path d="M7 21H5a2 2 0 0 1-2-2v-2" />
        <circle cx="12" cy="12" r="3" />
        <path d="M12 16v3" />
        <path d="M12 5v3" />
        <path d="M16 12h3" />
        <path d="M5 12h3" />
    </svg>
);

export default function UpscalerDropzone({ onImageSelect }: { onImageSelect: (file: File) => void }) {
    const [isDragging, setIsDragging] = useState(false);
    const inputRef = useRef<HTMLInputElement>(null);

    const handleDrag = (e: React.DragEvent, active: boolean) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(active);
    };

    const handleDrop = (e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            onImageSelect(e.dataTransfer.files[0]);
        }
    };

    return (
        <motion.div
            className={`${styles.dropzone} ${isDragging ? styles.active : ''}`}
            onDragEnter={(e) => handleDrag(e, true)}
            onDragOver={(e) => handleDrag(e, true)}
            onDragLeave={(e) => handleDrag(e, false)}
            onDrop={handleDrop}
            onClick={() => inputRef.current?.click()}
            whileHover={{ scale: 1.005 }}
            whileTap={{ scale: 0.99 }}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
        >
            <input 
                ref={inputRef} 
                type="file" 
                accept="image/*" 
                style={{ display: 'none' }} 
                onChange={(e) => e.target.files && onImageSelect(e.target.files[0])}
            />
            <div className={styles.dropzoneContent}>
                <motion.div 
                    animate={{ rotate: isDragging ? 180 : 0, scale: isDragging ? 1.2 : 1 }} 
                    transition={{ type: 'spring', stiffness: 200, damping: 15 }}
                    style={{ color: 'var(--accent)', marginBottom: '1rem' }}
                >
                    <ScanIcon />
                </motion.div>
                <h3>المسبك البصري (Optical Foundry)</h3>
                <p>أفلت الصورة هنا لرفع دقتها x2 باستخدام الذكاء الاصطناعي.</p>
                <div className={styles.specsLabel}>
                    AI Model: Swin2SR Real-World Super Resolution
                </div>
            </div>
        </motion.div>
    );
}




--- END OF FILE components/upscaler/UpscalerDropzone.tsx ---

================================================================================

--- START OF FILE components/upscaler/UpscalerProcessing.tsx ---

// components/upscaler/UpscalerProcessing.tsx
'use client';

import { motion } from 'framer-motion';
import styles from './Upscaler.module.css';
import { UpscaleStatus } from '@/hooks/useUpscaler';

interface ProcessingProps {
    status: UpscaleStatus;
    progress: number;
    message: string;
    imageSrc: string;
}

export default function UpscalerProcessing({ status, progress, message, imageSrc }: ProcessingProps) {
    return (
        <div className={styles.processingContainer}>
            <div className={styles.previewWrapper}>
                {/* Blurry Background Image */}
                <img src={imageSrc} alt="Processing" className={styles.processingImage} />
                
                {/* Scanning Beam */}
                <motion.div 
                    className={styles.scanBeam}
                    animate={{ top: ['0%', '100%', '0%'] }}
                    transition={{ duration: 4, repeat: Infinity, ease: "easeInOut" }}
                />
                
                <div className={styles.statusOverlay}>
                    <div className="spinner" style={{ width: '50px', height: '50px', borderTopColor: 'var(--accent)' }} />
                    <p className={styles.statusMessage}>{message}</p>
                    
                    {/* Show progress bar for both downloading AND processing tiles */}
                    {(status === 'downloading' || status === 'processing') && progress > 0 && (
                        <div className={styles.progressBarContainer}>
                            <div className={styles.progressBarTrack}>
                                <motion.div 
                                    className={styles.progressBarFill} 
                                    style={{ width: `${progress}%` }}
                                    animate={{ width: `${progress}%` }}
                                />
                            </div>
                            <span className={styles.progressText}>{Math.round(progress)}%</span>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}




--- END OF FILE components/upscaler/UpscalerProcessing.tsx ---

================================================================================

--- START OF FILE components/utils/GlobalContentHydrator.tsx ---

// components/utils/GlobalContentHydrator.tsx
'use client';

import { useEffect } from 'react';
import { useContentStore } from '@/lib/contentStore';

// Invisible component that runs ONCE on the homepage to dump data into the store
export default function GlobalContentHydrator({ items }: { items: any[] }) {
    const hydrateContent = useContentStore((state) => state.hydrateContent); // FIX: Use correct selector

    useEffect(() => {
        if (items && items.length > 0) {
            hydrateContent(items);
        }
    }, [items, hydrateContent]);

    return null;
}

--- END OF FILE components/utils/GlobalContentHydrator.tsx ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.module.css ---

/* components/VanguardReviews/VanguardReviews.module.css */

.vanguardContainer {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 780px;
    position: relative;
    padding: 15rem 10rem;
    margin: -15rem -10rem;
    --card-gap: 1.5rem;
    --center-width: 400px;
    --side-width: 280px;
    background-color: transparent; 
    width: calc(100% + 20rem);
    overflow-x: clip; 
    
    /* 3D Context Setup - Optimized for Safari */
    transform-style: preserve-3d;
    perspective: 1200px;
    
    /* OPTIMIZATION: Isolate layout to prevent page-wide reflows */
    contain: layout style;
    
    touch-action: pan-y;
    pointer-events: none;
}

.vanguardContainer > * {
    pointer-events: auto;
}

.spotlightGlow {
    position: absolute;
    width: 800px;
    height: 800px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle at 50% 50%, color-mix(in srgb, var(--accent) 15%, transparent) 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
    
    /* GPU Hint */
    will-change: opacity;
}

.cardSlot {
    position: absolute;
    pointer-events: auto;
    transform-style: preserve-3d;
    
    width: var(--center-width);
    height: 500px;
    touch-action: pan-y;
    
    /* GPU Hint: Only transform is animated heavily */
    will-change: transform;
    
    /* OPTIMIZATION: Do not render back of card (Saves ~50% GPU fill rate) */
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}

.cardWrapper {
    height: 100%;
    transform-style: preserve-3d;
    transition: filter 0.4s ease-out;
    position: relative;
    /* Force GPU layer for the wrapper content */
    transform: translateZ(0); 
}

.vanguardContainer.manual-hover .cardWrapper {
    filter: brightness(0.6) saturate(0.8);
}
.vanguardContainer.manual-hover .cardSlot.activeState .cardWrapper {
    filter: brightness(1) saturate(1);
}

@media (hover: hover) {
    .vanguardContainer.manual-hover .cardSlot:hover .cardWrapper {
        filter: brightness(1) saturate(1);
    }
}

.vanguardCard {
    background-color: transparent !important;
    background: transparent !important;
    border-radius: 0; 
    overflow: visible; 
    height: 100%;
    border: none;
    box-shadow: none !important; 
    color: #fff;
    position: relative;
    transform-style: preserve-3d;
    
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
}

/* FIX: New Clipping Container for Image and Effects */
.clippedInnerContainer {
    position: absolute;
    inset: 0;
    z-index: 1;
    clip-path: url(#vg-cardClip);
    background-color: var(--bg-secondary); 
    overflow: hidden; 
    transform: translateZ(0); 
    border-radius: 20px; 
    /* Safari Fix: Prevents bleeding during 3D transform */
    -webkit-mask-image: -webkit-radial-gradient(white, black);
}

/* Hit Area */
.hitArea {
    position: absolute;
    inset: 0;
    z-index: 20; 
    background-color: transparent; 
    clip-path: url(#vg-cardClip);
    cursor: pointer;
    pointer-events: auto;
    transform: translateZ(10px); 
}

/* --- FRAME & SVG --- */
.frameSvgContainer {
    position: absolute;
    inset: -2px;
    width: calc(100% + 4px);
    height: calc(100% + 4px);
    pointer-events: none;
    z-index: 5;
    transform: translateZ(1px);
}
.frameSvg {
    width: 100%;
    height: 100%;
    overflow: visible;
}

/* --- IMAGE --- */
.cardImageContainer {
    position: absolute;
    inset: 0;
    z-index: 1;
    background-color: transparent; 
    pointer-events: none;
    transform: translateZ(0);
}

.cardImage {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
    /* Optimization: Use low-quality interpolation during movement if needed, but 'auto' is usually fine */
    image-rendering: -webkit-optimize-contrast;
}

.cardSlot.activeState .cardImage { transform: scale(1.05); }
@media (hover: hover) { .cardSlot:hover .cardImage { transform: scale(1.05); } }

/* --- EFFECT LAYER --- */
.effectLayer {
    position: absolute;
    inset: 0;
    z-index: 10;
    pointer-events: none;
    transform: translateZ(2px);
}

/* --- CONTENT --- */
.cardContent {
    position: absolute;
    inset: 0;
    padding: 2.5rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    text-align: right;
    pointer-events: none;
    z-index: 15;
    transform: translateZ(5px);
}

.cardContent h3 { 
    font-size: 2.4rem; 
    line-height: 1.2; 
    margin: 0 0 0.75rem 0; 
    text-shadow: 0 2px 10px rgba(0,0,0,0.8);
    transition: color 0.3s ease, text-shadow 0.3s ease;
}

.cardMetaRow {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 1rem;
    width: 100%;
}

.cardDate { 
    font-size: 1.4rem; 
    color: var(--accent); 
    font-weight: 600; 
    text-shadow: 0 2px 5px rgba(0,0,0,0.8);
    margin: 0;
}

.cardSlot.activeState .cardContent h3 { 
    color: var(--accent);
    text-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent); 
}

@media (hover: hover) { 
    .cardSlot:hover .cardContent h3 { 
        color: var(--accent);
        text-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
    } 
}

/* --- BADGE --- */
.vanguardScoreBadge {
    position: absolute;
    top: 1.5rem;
    right: 1.5rem; 
    left: auto;
    width: 64px;
    height: 64px;
    background-color: var(--bg-secondary);
    backdrop-filter: blur(16px);
    border: 2px solid var(--accent);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--accent);
    font-family: var(--font-heading), sans-serif;
    font-weight: 900;
    font-size: 2.2rem;
    letter-spacing: -1px;
    z-index: 30; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    
    transform: translateZ(60px);
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.4s ease, background-color 0.4s ease, color 0.4s ease;
    pointer-events: none;
}

.cardSlot.activeState .vanguardScoreBadge { 
    transform: translateZ(100px) scale(1.3) rotate(10deg); 
    background-color: var(--accent);
    color: #000;
    box-shadow: 0 0 25px var(--accent), 0 10px 40px rgba(0,0,0,0.5); 
}
@media (hover: hover) { 
    .cardSlot:hover .vanguardScoreBadge { 
        transform: translateZ(100px) scale(1.3) rotate(10deg); 
        background-color: var(--accent);
        color: #000;
        box-shadow: 0 0 25px var(--accent), 0 10px 40px rgba(0,0,0,0.5); 
    } 
}

/* --- CREATORS --- */
.creatorCapsuleContainer {
    position: absolute;
    top: 35%;
    right: -2.5rem; 
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.6rem;
    z-index: 50; 
    transform: translateZ(70px); 
    pointer-events: none; 
}

.creatorCapsuleContainer::before {
    content: '';
    position: absolute;
    right: 100%;
    top: -10%;
    height: 120%;
    width: 50px;
    background: transparent;
    pointer-events: auto;
    z-index: 49;
}

.safeBridgeWrapper {
    position: relative;
    overflow: visible; 
    pointer-events: auto;
}

.capsuleWrapper {
    position: relative;
    display: flex;
    align-items: center;
    cursor: pointer;
}

.creditCapsule {
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 0;
    background: #0A0B0F; 
    border: 1px solid rgba(255,255,255,0.15);
    padding: 0;
    border-radius: 999px;
    height: 28px;
    text-decoration: none;
    box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    overflow: hidden;
    position: relative;
    z-index: 2;
    transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
}

.capsuleIcon {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #000;
    color: var(--accent);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.3s ease;
    border: none;
    margin: 0;
}
.capsuleIcon svg { width: 14px; height: 14px; }

.creditCapsule :global(span) {
    font-size: 1.1rem;
    font-weight: 700;
    color: #fff; 
    white-space: nowrap;
    transition: color 0.3s ease;
    padding: 0 12px;
}

.capsuleArrow {
    position: absolute;
    left: -20px; 
    top: 50%;
    transform: translateY(-50%);
    color: var(--accent);
    opacity: 0;
    z-index: 1;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
}

.capsuleWrapper:hover .creditCapsule {
    background-color: var(--accent);
    border-color: var(--accent);
    box-shadow: 0 0 15px rgba(0, 229, 255, 0.4);
}
.capsuleWrapper:hover .capsuleIcon {
    background-color: #000;
    color: var(--accent);
}
.capsuleWrapper:hover .creditCapsule :global(span) {
    color: #000;
}

/* --- EFFECTS --- */
.cyberCorner { display: none; }

.holoSpotlight {
    position: absolute;
    width: 250px; 
    height: 250px;
    top: 0; left: 0;
    pointer-events: none;
    z-index: 15;
    opacity: 0;
    transition: opacity 0.2s ease;
    background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.05) 50%, transparent 70%);
    mix-blend-mode: overlay; 
    border-radius: 50%;
}

.cardSlot:hover .holoSpotlight,
.cardSlot.activeState .holoSpotlight { opacity: 1; }

.scanLine {
    position: absolute;
    top: -50%;
    left: 0;
    width: 100%;
    height: 10%;
    background: linear-gradient(to bottom, transparent, rgba(0, 255, 240, 0.3) 50%, transparent);
    z-index: 10;
    pointer-events: none;
    mix-blend-mode: overlay;
    opacity: 0;
    transition: opacity 0.3s ease;
}

@keyframes scan { 0% { top: -30%; } 100% { top: 130%; } }

.cardSlot:hover .scanLine,
.cardSlot.activeState .scanLine {
    opacity: 1;
    animation: scan 3s cubic-bezier(0.45, 0.05, 0.55, 0.95) infinite;
}

.techDecoration {
    display: flex;
    gap: 5px;
    align-items: center;
    pointer-events: none;
    opacity: 0.6;
}

.techDot {
    width: 4px;
    height: 4px;
    background-color: rgba(255,255,255,0.3);
    border-radius: 50%;
    transition: background-color 0.3s ease;
}

@keyframes pulse-dot { 0%, 100% { transform: scale(1); opacity: 0.6; } 50% { transform: scale(1.6); opacity: 1; box-shadow: 0 0 10px var(--accent); } }

.cardSlot:hover .techDot,
.cardSlot.activeState .techDot {
    background-color: var(--accent);
    animation: pulse-dot 1.2s infinite ease-in-out;
}
.cardSlot.activeState .techDot:nth-child(2) { animation-delay: 0.2s; }
.cardSlot.activeState .techDot:nth-child(3) { animation-delay: 0.4s; }

/* Satellite Field */
.satelliteField {
    position: absolute;
    inset: -200px;
    pointer-events: none;
    z-index: 100;
    overflow: visible;
    transform-style: preserve-3d;
}

.satelliteBridgeSvg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 90; 
    overflow: visible;
}

.satelliteBridgeLine {
    fill: none;
    stroke: transparent;
    stroke-width: 50px;
    pointer-events: auto;
    cursor: auto; 
}

.satelliteShard {
    position: absolute;
    padding: 0;
    background: transparent;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    transform-style: preserve-3d;
}

.satelliteShardLink {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem 1.2rem;
    background: rgba(10, 10, 15, 0.95);
    border: 1.5px solid var(--accent);
    color: var(--accent);
    font-family: var(--font-ui);
    font-size: 1.3rem;
    font-weight: 800;
    border-radius: 8px;
    white-space: nowrap;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    filter: drop-shadow(0 0 10px rgba(0,255,240,0.3));
    text-decoration: none;
    transition: all 0.3s ease;
    cursor: pointer;
    pointer-events: auto;
    position: relative;
    z-index: 101;
    backdrop-filter: blur(4px);
}

@media (hover: hover) {
    .satelliteShardLink:hover {
        background-color: var(--accent);
        color: #000;
        transform: scale(1.15) translateY(-3px);
        box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
        z-index: 200;
    }
}

.satelliteShardLink:active {
    background-color: var(--accent);
    color: #000;
    box-shadow: 0 0 20px color-mix(in srgb, var(--accent) 60%, transparent);
    transform: scale(0.95);
}

/* --- NAVIGATOR --- */
.kineticNavigator { 
    position: absolute; 
    bottom: 15rem; 
    width: 100%; 
    display: flex; 
    justify-content: center; 
    z-index: 50;
    pointer-events: none;
}

.navTrack { 
    display: flex; 
    flex-direction: row-reverse; 
    align-items: center; 
    gap: 8px; 
    padding: 8px; 
    background-color: color-mix(in srgb, var(--bg-secondary) 80%, transparent); 
    border: 1px solid var(--border-color); 
    border-radius: 16px; 
    backdrop-filter: blur(10px); 
    z-index: 10; 
    max-width: 90vw; 
    overflow-x: auto; 
    scrollbar-width: none; 
    pointer-events: auto; 
}

@media (max-width: 768px) {
    .navTrack {
        backdrop-filter: none !important;
        background-color: rgba(20, 20, 25, 0.95);
    }
}
.navTrack::-webkit-scrollbar { display: none; }
.navItem { position: relative; border-radius: 8px; cursor: pointer; overflow: hidden; border: 1px solid transparent; transition: border-color 0.4s ease; }
.navImage { display: block; width: 100%; height: 100%; object-fit: cover; transition: filter 0.4s ease, transform 0.4s ease; }
.navItem[data-active="false"] .navImage { filter: grayscale(100%) brightness(0.7); }
.navItem[data-active="true"] { border-color: var(--accent); box-shadow: 0 0 15px -2px var(--accent); }
.navTitle { position: absolute; bottom: 0; left: 0; right: 0; padding: 8px; font-size: 1.2rem; font-weight: 600; color: #fff; background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%); text-align: right; }

@media (max-width: 1024px) {
    .vanguardContainer { --center-width: 60vw; --side-width: 40vw; padding-bottom: 10rem; padding-top: 4rem; }
    .cardSlot { height: 380px; }
}

@media (max-width: 768px) {
    .vanguardContainer { 
        --center-width: 65vw; --side-width: 45vw; 
        min-height: 780px;
        padding: 15rem 10rem;
        margin: -15rem -10rem;
        width: calc(100% + 20rem);
    }
    
    .cardContent { padding: 1.5rem; }
    .cardContent h3 { font-size: 1.8rem; }
    .vanguardScoreBadge { width: 55px; height: 55px; font-size: 2rem; top: 1rem; left: 1rem; }
    
    .holoSpotlight, .scanLine { display: none; }
    
    .satelliteShardLink {
        backdrop-filter: none !important;
        background: #000;
        font-size: 1.1rem;
        padding: 0.4rem 1rem;
    }
    
    .satelliteShardLink:active {
        background-color: var(--accent) !important;
        color: #000 !important;
    }
    
    .satelliteField { display: none; }
    .cardSlot.activeState .satelliteField { display: block; }

    .kineticNavigator {
        bottom: 17rem;
    }
}
@media (max-width: 480px) {
    .vanguardContainer { --center-width: 70vw; --side-width: 50vw; }
}

/* --- LIGHT MODE + NO-GLASS OVERRIDES --- */

/* 1. Shadows (Switch to White/Cyan Glow) */
:global([data-theme="light"]) .vanguardScoreBadge {
  box-shadow: 0 4px 15px rgba(255, 255, 255, 0.4);
}
:global([data-theme="light"]) .cardSlot.activeState .vanguardScoreBadge,
:global([data-theme="light"]) .cardSlot:hover .vanguardScoreBadge {
  box-shadow: 0 0 25px var(--accent), 0 10px 40px rgba(255, 255, 255, 0.6);
}
:global([data-theme="light"]) .satelliteShardLink {
  box-shadow: 0 10px 30px rgba(255, 255, 255, 0.5);
  filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.3)); /* Cyan glow */
}

/* 2. Credits (Capsule: White BG, Cyan Text, Cyan Circle, White Icon) - IDLE STATE */
:global([data-theme="light"]) .creditCapsule {
  background-color: #ffffff !important; /* Force White */
  border-color: rgba(0,0,0,0.1) !important;
  box-shadow: 0 2px 10px rgba(255, 255, 255, 0.5);
}
:global([data-theme="light"]) .creditCapsule :global(span) {
  color: var(--accent) !important; /* Force Cyan Text */
}
:global([data-theme="light"]) .capsuleIcon {
  background-color: var(--accent) !important; /* Force Cyan Circle */
  color: #ffffff !important; /* Force White Icon */
}

/* 2b. Credits - HOVER STATE (Swap: Cyan BG, White Text, White Circle, Cyan Icon) */
:global([data-theme="light"]) .capsuleWrapper:hover .creditCapsule {
    background-color: var(--accent) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 20px var(--accent);
}
:global([data-theme="light"]) .capsuleWrapper:hover .creditCapsule :global(span) {
    color: #ffffff !important;
}
:global([data-theme="light"]) .capsuleWrapper:hover .capsuleIcon {
    background-color: #ffffff !important;
    color: var(--accent) !important;
}

/* 3. Tags (Cyan BG, White Text) - Remains the same per previous turn, adjust if needed */
:global([data-theme="light"]) .satelliteShardLink {
    background: var(--accent) !important;
    border-color: var(--accent) !important;
    color: #ffffff !important;
}
:global([data-theme="light"]) .satelliteShardLink:hover {
    background-color: var(--accent) !important;
    color: #ffffff !important;
    box-shadow: 0 0 25px var(--accent);
}

/* 4. Navigator (White/Cyan Glow) */
:global([data-theme="light"]) .navTrack {
    background-color: rgba(255, 255, 255, 0.85);
    border-color: rgba(0, 229, 255, 0.3);
}
:global([data-theme="light"]) .navItem[data-active="true"] {
    box-shadow: 0 0 15px var(--accent);
}

/* 5. Mobile & No-Glass Specifics (Ensuring overrides stick) */
:global([data-theme="light"] body.no-glass) .creditCapsule {
    background-color: #ffffff !important;
}
/* Ensure hover works in no-glass mode too */
:global([data-theme="light"] body.no-glass) .capsuleWrapper:hover .creditCapsule {
    background-color: var(--accent) !important;
}

:global([data-theme="light"] body.no-glass) .satelliteShardLink {
    background-color: var(--accent) !important;
}
:global([data-theme="light"] body.no-glass) .navTrack {
    background-color: #ffffff !important;
}

--- END OF FILE components/VanguardReviews/VanguardReviews.module.css ---

================================================================================

--- START OF FILE components/VanguardReviews/VanguardReviews.tsx ---

// components/VanguardReviews/VanguardReviews.tsx
'use client';

import { useState, useEffect, useRef, memo, useCallback } from 'react';
import { motion, AnimatePresence, useInView, animate, PanInfo, useMotionValue, useSpring, Variants } from 'framer-motion';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import Link from 'next/link';
import { useLivingCard } from '@/hooks/useLivingCard';
import { useLayoutIdStore } from '@/lib/layoutIdStore';
import { useVanguardCarousel } from '@/hooks/useVanguardCarousel';
import { urlFor } from '@/sanity/lib/image';
import type { SanityAuthor } from '@/types/sanity';
import type { CardProps } from '@/types';
import styles from './VanguardReviews.module.css';
import { sanityLoader } from '@/lib/sanity.loader';
import { usePerformanceStore } from '@/lib/performanceStore';
import { translateTag } from '@/lib/translations';
import { PenEdit02Icon, ColorPaletteIcon } from '@/components/icons/index';
import KineticLink from '@/components/kinetic/KineticLink'; 
import { generateLayoutId } from '@/lib/layoutUtils'; 
import { useContentStore } from '@/lib/contentStore'; 

// REMOVED: creatorBubbleContainerVariants and creatorBubbleItemVariants
// We want instant rendering without stagger to prevent "catching up"

const ArrowIcon = () => ( <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" role="img" color="currentColor"> <path d="M12.293 5.29273C12.6591 4.92662 13.2381 4.90402 13.6309 5.22437L13.707 5.29273L19.707 11.2927L19.7754 11.3689C20.0957 11.7617 20.0731 12.3407 19.707 12.7068L13.707 18.7068C13.3165 19.0973 12.6835 19.0973 12.293 18.7068C11.9025 18.3163 11.9025 17.6833 12.293 17.2927L16.5859 12.9998H5C4.44772 12.9998 4 12.552 4 11.9998C4 11.4475 4.44772 10.9998 5 10.9998H16.5859L12.293 6.7068L12.2246 6.63063C11.9043 6.23785 11.9269 5.65885 12.293 5.29273Z" fill="currentColor"></path> </svg> );

const CARD_SHAPE_PATH = `M 20,0 L 280,0 Q 300,0 300,20 L 300,146 Q 300,150 297,152 L 293,154 Q 290,156 290,160 L 290,220 Q 290,224 293,226 L 297,228 Q 300,230 300,234 L 300,335 Q 300,345 292,352 L 272,372 Q 265,380 255,380 L 45,380 Q 35,380 28,372 L 8,352 Q 0,345 0,335 L 0,234 Q 0,230 3,228 L 7,226 Q 10,224 10,220 L 10,160 Q 10,156 7,154 L 3,152 Q 0,150 0,146 L 0,20 Q 0,0 20,0 Z`;

const VanguardGlobalDefs = () => ( <svg width="0" height="0" style={{ position: 'absolute', pointerEvents: 'none' }}> <defs> <filter id="vg-activeGlow" x="-50%" y="-50%" width="200%" height="200%"> <feGaussianBlur stdDeviation="3" result="coloredBlur"></feGaussianBlur> <feMerge> <feMergeNode in="coloredBlur"></feMergeNode> <feMergeNode in="SourceGraphic"></feMergeNode> </feMerge> </filter> <clipPath id="vg-cardClip" clipPathUnits="objectBoundingBox"> <path d={CARD_SHAPE_PATH} transform="scale(0.00333333, 0.00263158)" /> </clipPath> </defs> </svg> );

const VanguardCardFrame = ({ isActive, isEnabled }: { isActive: boolean, isEnabled: boolean }) => { if (!isEnabled) return null; const defaultTopLength = 0.13; const defaultSideLength = 0.09; const defaultOpacity = 0.6; const activeTopLength = 0.66; const activeSideLength = 1.05; const topWingPath = `M 0,20 Q 0,0 20,0 L 280,0 Q 300,0 300,20 L 300,146 Q 300,150 297,152 L 293,154 Q 290,156 290,160 L 290,220 Q 290,224 293,226 L 297,228 Q 300,230 300,234 L 300,335`; const leftWingPath = `M 0,20.1 L 0,146 Q 0,150 3,152 L 7,154 Q 10,156 10,160 L 10,220 Q 10,224 7,226 L 3,228 Q 0,230 0,234 L 0,335 Q 0,345 8,352 L 28,372 Q 35,380 45,380 L 150,380`; const bottomRightPath = `M 150,380 L 255,380 Q 265,380 272,372 L 292,352 Q 300,345 300,335 L 300,234 Q 300,230 297,228 L 293,226 Q 290,224 290,220 L 290,130`; const bottomLeftPath = `M 150,380 L 45,380 Q 35,380 28,372 L 8,352 Q 0,345 0,335 L 0,234 Q 0,230 3,228 L 7,226 Q 10,224 10,220 L 10,130`; const activeStrokeThickness = "4"; const staticStrokeThickness = "2"; const activeTransition = { pathLength: { duration: 0.4, ease: "easeInOut" as const }, opacity: { duration: 0.05 }, filter: { duration: 0.05 } }; const bottomTransition = { duration: 0.4, ease: "easeInOut" as const }; return ( <div className={styles.frameSvgContainer}> <svg className={styles.frameSvg} viewBox="0 0 300 380" preserveAspectRatio="none"> {/* FIX: Removed solid fill path that was obscuring the image */} <motion.path d={bottomRightPath} fill="none" stroke="var(--accent)" strokeWidth={staticStrokeThickness} vectorEffect="non-scaling-stroke" strokeLinecap="round" filter={isActive ? "url(#vg-activeGlow)" : "none"} initial={{ pathLength: 1, opacity: 1 }} animate={{ pathLength: isActive ? 0 : 1, opacity: isActive ? 0 : 1 }} transition={bottomTransition} /> <motion.path d={bottomLeftPath} fill="none" stroke="var(--accent)" strokeWidth={staticStrokeThickness} vectorEffect="non-scaling-stroke" strokeLinecap="round" filter={isActive ? "url(#vg-activeGlow)" : "none"} initial={{ pathLength: 1, opacity: 1 }} animate={{ pathLength: isActive ? 0 : 1, opacity: isActive ? 0 : 1 }} transition={bottomTransition} /> {isEnabled && ( <> <motion.path d={topWingPath} fill="none" stroke="var(--accent)" strokeWidth={activeStrokeThickness} vectorEffect="non-scaling-stroke" strokeLinecap="round" initial={{ pathLength: defaultTopLength, opacity: defaultOpacity }} animate={{ pathLength: isActive ? activeTopLength : defaultTopLength, opacity: isActive ? 1 : defaultOpacity, filter: isActive ? "url(#vg-activeGlow)" : "none" }} transition={activeTransition} /> <motion.path d={leftWingPath} fill="none" stroke="var(--accent)" strokeWidth={activeStrokeThickness} vectorEffect="non-scaling-stroke" strokeLinecap="round" initial={{ pathLength: defaultSideLength, opacity: defaultOpacity }} animate={{ pathLength: isActive ? activeSideLength : defaultSideLength, opacity: isActive ? 1 : defaultOpacity, filter: isActive ? "url(#vg-activeGlow)" : "none" }} transition={activeTransition} /> </> )} </svg> </div> ); };

// --- ANIMATION VARIANTS FOR HOVER ---
const capsuleVariants: Variants = {
    idle: { x: 0, scale: 1 },
    hover: { 
        x: -10, 
        scale: 1.1,
        transition: { type: 'spring', stiffness: 400, damping: 15 }
    }
};

const arrowVariants: Variants = {
    idle: { opacity: 0, x: 10 },
    hover: { 
        opacity: 1, 
        x: 0,
        transition: { type: 'spring', stiffness: 400, damping: 15 }
    }
};

const ARROW_SETTINGS = { xOffset: -45, yOffset: -10 };

const CreatorCapsule = ({ label, creator }: { label: string, creator: SanityAuthor }) => {
    const handleBubbleClick = (e: React.MouseEvent) => { e.stopPropagation(); };
    const profileSlug = creator.username || (creator.slug as any)?.current || creator.name?.toLowerCase().replace(/\s+/g, '-');
    const hasPublicProfile = !!profileSlug;
    
    const IconComponent = label === 'تصميم' ? ColorPaletteIcon : PenEdit02Icon;

    const InnerContent = ( 
        <> 
            <div className={styles.capsuleIcon}>
                <IconComponent style={{ width: 14, height: 14 }} />
            </div> 
            <span className={styles.creatorName}>{creator.name}</span> 
        </> 
    ); 
    
    const InteractiveWrapper = ({ children }: { children: React.ReactNode }) => ( 
        <motion.div className={styles.capsuleWrapper} initial="idle" whileHover="hover"> 
            <motion.div className={styles.capsuleArrow} variants={arrowVariants} style={{ left: ARROW_SETTINGS.xOffset, marginTop: ARROW_SETTINGS.yOffset }}>
                <ArrowIcon />
            </motion.div> 
            <motion.div className={styles.creditCapsule} variants={capsuleVariants}>
                {children}
            </motion.div> 
        </motion.div> 
    ); 
    
    // MODIFIED: Removed variants prop from motion.div wrapper to stop staggered entrance
    return ( 
        <motion.div className={styles.safeBridgeWrapper}> 
            {hasPublicProfile ? ( 
                <KineticLink 
                    href={`/creators/${profileSlug}`} 
                    slug={profileSlug}
                    type="creators"
                    onClick={handleBubbleClick} 
                    className="no-underline"
                    // PASS DATA
                    preloadedData={{ name: creator.name, image: creator.image }}
                >
                    <InteractiveWrapper>{InnerContent}</InteractiveWrapper>
                </KineticLink> 
            ) : ( 
                <div title={`${creator.name}`}>
                    <InteractiveWrapper>{InnerContent}</InteractiveWrapper>
                </div> 
            )} 
        </motion.div> 
    ); 
};

const SATELLITE_CONFIG = [
    { hoverX: -240, hoverY: -100, rotate: -12 }, 
    { hoverX: 180, hoverY: 60, rotate: 10 },    
    { hoverX: -50, hoverY: -265, rotate: 5 }     
];
const CARD_VERTICAL_OFFSET_DESKTOP = -80; 
const CARD_VERTICAL_OFFSET_MOBILE = -70;  
const MOBILE_SATELLITE_SCALE = 0.45;

interface VanguardCardProps {
    review: CardProps;
    isCenter: boolean;
    isInView: boolean;
    isPriority: boolean;
    isMobile: boolean;
    isHovered: boolean;
    isInteractive: boolean;
    isVisible: boolean; 
    onHoverChange: (isHovering: boolean) => void;
}

const VanguardCard = memo(({ review, isCenter, isInView, isPriority, isMobile, isHovered, isInteractive, isVisible, onHoverChange }: VanguardCardProps) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();
    const router = useRouter(); 
    const setPrefix = useLayoutIdStore((state) => state.setPrefix);
    const scoreRef = useRef<HTMLParagraphElement>(null);
    
    const { isFlyingTagsEnabled, isLivingCardEnabled, isCornerAnimationEnabled, isHeroTransitionEnabled } = usePerformanceStore();
    const effectivelyDisabledLiving = !isLivingCardEnabled;

    const mouseX = useMotionValue(0);
    const mouseY = useMotionValue(0);
    const smoothMouseX = useSpring(mouseX, { stiffness: 300, damping: 25 });
    const smoothMouseY = useSpring(mouseY, { stiffness: 300, damping: 25 });

    useEffect(() => {
        if (isInView && isVisible && scoreRef.current && typeof review.score === 'number') {
            const controls = animate(0, review.score, {
                duration: 1.5, ease: [0.22, 1, 0.36, 1],
                onUpdate(value) { if (scoreRef.current) { scoreRef.current.textContent = value.toFixed(1); } }
            });
            return () => controls.stop();
        }
    }, [isInView, review.score, isVisible]);

    const linkPath = `/reviews/${review.slug}`;
    const layoutIdPrefix = "vanguard-reviews";
    const layoutId = isHeroTransitionEnabled ? layoutIdPrefix : undefined;
    
    const imageLayoutId = generateLayoutId(layoutIdPrefix, 'image', review.legacyId);
    const titleLayoutId = generateLayoutId(layoutIdPrefix, 'title', review.legacyId);

    const handleClick = (e: React.MouseEvent) => {
        if (e.ctrlKey || e.metaKey) return; 
        if ((e.target as HTMLElement).closest('a[href^="/creators"]')) {
            e.stopPropagation();
            return;
        }
        if ((e.target as HTMLElement).closest('a[href^="/tags/"]')) return;
    };
    
    // DEFINED HANDLE BRIDGE CLICK
    const handleBridgeClick = (e: React.MouseEvent) => { 
        e.stopPropagation();
    };
    
    // 1. Image for the CARD DISPLAY (Vertical preferred)
    const cardImageRef = review.mainImageVerticalRef || review.mainImageRef;
    const cardImageUrl = cardImageRef 
        ? urlFor(cardImageRef).width(isCenter ? 800 : 560).height(isCenter ? 1000 : 700).fit('crop').auto('format').url()
        : review.imageUrl;

    // 2. Image for the OVERLAY HERO (Horizontal preferred)
    const overlayImageRef = review.mainImageRef;
    const overlayImageUrl = overlayImageRef
        ? urlFor(overlayImageRef).width(1920).height(1080).fit('crop').auto('format').url()
        : review.imageUrl;
    
    // 3. LOW RES (Pre-load) Image for Horizontal Overlay
    // We fetch a small version (e.g., width 480) to ensure the browser caches the horizontal asset
    // before the transition happens. This prevents "blank" or "white" flashes.
    const preLoadOverlayUrl = overlayImageRef
        ? urlFor(overlayImageRef).width(480).auto('format').url()
        : null;

    // MODIFIED: Credits show logic
    // They are always rendered but opacity controlled to prevent mount flicker
    const showCredits = isCenter || isHovered;
    const displayTags = review.tags.slice(0, 3);
    
    const livingCardHandlers = (isInteractive && isVisible) ? {
        onMouseMove: (e: React.MouseEvent<HTMLDivElement>) => {
            if (!effectivelyDisabledLiving) {
                livingCardAnimation.onMouseMove(e);
                const rect = e.currentTarget.getBoundingClientRect();
                mouseX.set(e.clientX - rect.left - 125); 
                mouseY.set(e.clientY - rect.top - 125);
            }
        },
        onTouchStart: (e: React.TouchEvent<HTMLDivElement>) => {
            if (!effectivelyDisabledLiving) livingCardAnimation.onTouchStart(e);
            onHoverChange(true);
        },
        onTouchEnd: () => {
            if (!effectivelyDisabledLiving) livingCardAnimation.onTouchEnd();
            onHoverChange(false);
        },
        onTouchCancel: () => {
             if (!effectivelyDisabledLiving) livingCardAnimation.onTouchCancel();
             onHoverChange(false);
        },
        onTouchMove: !effectivelyDisabledLiving ? livingCardAnimation.onTouchMove : undefined,
        onMouseEnter: () => { 
            if (!effectivelyDisabledLiving) livingCardAnimation.onMouseEnter(); 
            onHoverChange(true); 
        },
        onMouseLeave: () => { 
            if (!effectivelyDisabledLiving) livingCardAnimation.onMouseLeave(); 
            onHoverChange(false); 
        },
    } : {};
    
    const animationStyles = !effectivelyDisabledLiving ? livingCardAnimation.style : {};

    return (
        <div className={styles.cardWrapper}>
            {/* FIX: Pre-load the horizontal image invisibly so it's cached for the transition */}
            {preLoadOverlayUrl && (
                <img 
                    src={preLoadOverlayUrl} 
                    alt="" 
                    style={{ position: 'absolute', opacity: 0, pointerEvents: 'none', width: 1, height: 1 }} 
                    aria-hidden="true"
                />
            )}

            <KineticLink 
                href={linkPath}
                slug={review.slug}
                type="reviews"
                layoutId={layoutId} 
                imageSrc={overlayImageUrl} // Pass HORIZONTAL image for overlay
                onClick={handleClick}
                className="no-underline"
                style={{ display: 'block', height: '100%', cursor: 'pointer' }}
            >
                <motion.div
                    ref={livingCardRef}
                    {...livingCardHandlers}
                    style={{ 
                        ...animationStyles, 
                        transformStyle: 'preserve-3d', 
                        height: '100%',
                        background: 'transparent',
                        boxShadow: 'none',
                        backgroundColor: 'transparent'
                    }}
                    className={styles.vanguardCard}
                >
                    <div className={styles.hitArea} />

                    {/* OPTIMIZATION: Condition Render - Only render dynamic frame if visible */}
                    {isVisible && <VanguardCardFrame isActive={isHovered} isEnabled={isCornerAnimationEnabled} />}
                    
                    {/* NEW: Clipped Inner Container for Content to Fix Bleed */}
                    <div className={styles.clippedInnerContainer}>
                        <div className={styles.effectLayer}>
                            {isVisible && !isMobile && (
                                <motion.div className={styles.holoSpotlight} style={{ x: smoothMouseX, y: smoothMouseY }} />
                            )}
                            {isVisible && <div className={styles.scanLine} />}
                        </div>

                        <motion.div 
                            layoutId={!isMobile && imageLayoutId ? imageLayoutId : undefined} 
                            className={styles.cardImageContainer}
                        >
                            <Image 
                                loader={sanityLoader}
                                src={cardImageUrl} // Use VERTICAL image for card display
                                alt={review.title} 
                                fill 
                                sizes={isCenter ? "(max-width: 768px) 80vw, 400px" : "(max-width: 768px) 60vw, 280px"}
                                className={styles.cardImage} 
                                // FIX: Conditional blur data
                                placeholder={review.blurDataURL ? 'blur' : 'empty'}
                                blurDataURL={review.blurDataURL}
                                priority={isPriority}
                            />
                        </motion.div>
                        
                        <motion.div className={styles.cardContent} animate={{ background: isCenter ? 'linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 50%)' : 'linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 60%)' }} transition={{ duration: 0.5, ease: 'circOut' }}>
                            <motion.h3 
                                layoutId={!isMobile && titleLayoutId ? titleLayoutId : undefined}
                            >
                                {review.title}
                            </motion.h3>
                            
                            <div className={styles.cardMetaRow}>
                                {review.date && <p className={styles.cardDate}>{review.date.split(' - ')[0]}</p>}
                                <div className={styles.techDecoration}>
                                    <div className={styles.techDot} />
                                    <div className={styles.techDot} />
                                    <div className={styles.techDot} />
                                </div>
                            </div>
                        </motion.div>
                    </div>

                    {/* OVERHANGING ELEMENTS (OUTSIDE CLIP) */}
                    {isVisible && (
                        <motion.div
                            className={styles.creatorCapsuleContainer}
                            initial={{ opacity: 0 }}
                            animate={{ opacity: showCredits ? 1 : 0 }} 
                            transition={{ duration: 0.3 }}
                            style={{ 
                                pointerEvents: showCredits ? 'auto' : 'none', 
                                transform: 'translateZ(50px)' 
                            }}
                        >
                            {review.authors.map(author => <CreatorCapsule key={author._id} label="بقلم" creator={author} />)}
                            {review.designers?.map(designer => <CreatorCapsule key={designer._id} label="تصميم" creator={designer} />)}
                        </motion.div>
                    )}

                    {typeof review.score === 'number' && (<div className={styles.vanguardScoreBadge}><p ref={scoreRef} style={{ margin: 0 }}>0.0</p></div>)}
                    
                    {isVisible && isFlyingTagsEnabled && (
                        <div className={styles.satelliteField} style={{ transform: 'translateZ(60px)' }}>
                            <AnimatePresence>
                                {isHovered && displayTags.map((tag, i) => {
                                    const rawConfig = SATELLITE_CONFIG[i];
                                    const hoverX = isMobile && rawConfig ? rawConfig.hoverX * MOBILE_SATELLITE_SCALE : (rawConfig?.hoverX || 0);
                                    const hoverY = isMobile && rawConfig ? rawConfig.hoverY * MOBILE_SATELLITE_SCALE : (rawConfig?.hoverY || 0);
                                    const rotate = rawConfig?.rotate || 0;

                                    return (
                                        <motion.div
                                            key={`${review.id}-${tag.slug}`}
                                            className={styles.satelliteShard}
                                            initial={{ opacity: 0, scale: 0, x: 0, y: 0, z: 0 }}
                                            animate={{ opacity: 1, scale: 1.15, x: hoverX, y: hoverY, rotate: rotate, z: -30 }}
                                            exit={{ opacity: 0, scale: 0.4, x: 0, y: 0, rotate: 0, z: 0 }}
                                            transition={{ type: "spring", stiffness: 180, damping: 20, delay: i * 0.05 }}
                                            style={{ position: 'absolute', left: '50%', top: '50%', transformStyle: 'preserve-3d' }}
                                            onClick={(e) => e.stopPropagation()}
                                         >
                                             <KineticLink 
                                                href={`/tags/${tag.slug}`} 
                                                slug={tag.slug}
                                                type="tags"
                                                onClick={(e) => e.stopPropagation()} 
                                                className={`${styles.satelliteShardLink} no-underline`} 
                                            >
                                                 {translateTag(tag.title)}
                                             </KineticLink>
                                         </motion.div>
                                    );
                                })}
                            </AnimatePresence>
                            
                            {isHovered && (
                                <svg className={styles.satelliteBridgeSvg}>
                                    {displayTags.map((_, i) => {
                                        const rawConfig = SATELLITE_CONFIG[i];
                                        const hoverX = isMobile && rawConfig ? rawConfig.hoverX * MOBILE_SATELLITE_SCALE : (rawConfig?.hoverX || 0);
                                        const hoverY = isMobile && rawConfig ? rawConfig.hoverY * MOBILE_SATELLITE_SCALE : (rawConfig?.hoverY || 0);
                                        return ( <line key={`bridge-${i}`} x1="0" y1="0" x2={hoverX} y2={hoverY} className={styles.satelliteBridgeLine} onClick={handleBridgeClick} /> );
                                    })}
                                </svg>
                            )}
                        </div>
                    )}
                </motion.div>
            </KineticLink>
        </div>
    );
});
VanguardCard.displayName = "VanguardCard";

const KineticNavigator = ({ reviews, currentIndex, navigateToIndex }: { reviews: CardProps[], currentIndex: number, navigateToIndex: (index: number) => void }) => {
    const itemRefs = useRef<(HTMLButtonElement | null)[]>([]);
    const trackRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const activeItem = itemRefs.current[currentIndex];
        const track = trackRef.current;
        if (activeItem && track) {
            const itemRect = activeItem.getBoundingClientRect();
            const trackRect = track.getBoundingClientRect();
            const relativeLeft = itemRect.left - trackRect.left + track.scrollLeft;
            const targetScrollLeft = relativeLeft - (trackRect.width / 2) + (itemRect.width / 2);
            track.scrollTo({ left: targetScrollLeft, behavior: 'smooth' });
        }
    }, [currentIndex]);

    return (
        <div className={styles.kineticNavigator}>
            <div className={styles.navTrack} ref={trackRef}>
                {reviews.map((review, index) => {
                    const isActive = currentIndex === index;
                    return (
                        <motion.button 
                            key={review.id} 
                            ref={el => { itemRefs.current[index] = el }} 
                            className={styles.navItem} 
                            data-active={isActive} 
                            onTap={() => navigateToIndex(index)}
                            whileTap={{ scale: 0.95 }}
                            initial={{ scale: 1 }}
                            animate={{ scale: isActive ? 1.2 : 1 }} 
                            transition={{ type: 'spring', stiffness: 400, damping: 30 }}
                            style={{ width: 60, height: 40, transformOrigin: 'center' }}
                        >
                            <Image loader={sanityLoader} src={`${review.imageUrl.split('?')[0]}?w=200&auto=format`} alt={review.title} fill sizes="10vw" className={styles.navImage} unoptimized />
                            <AnimatePresence>{isActive && <motion.div className={styles.navTitle} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>{review.title}</motion.div>}</AnimatePresence>
                        </motion.button>
                    );
                })}
            </div>
        </div>
    );
};

export default function VanguardReviews({ reviews }: { reviews: CardProps[] }) {
    const containerRef = useRef(null);
    const hasAnimatedIn = useInView(containerRef, { once: true, amount: 0.1 });
    const isCurrentlyInView = useInView(containerRef, { amount: 0.4 });
    const [initialAnimHasRun, setInitialAnimHasRun] = useState(false);
    const [isManualHover, setIsManualHover] = useState(false);
    const hoverTimeoutRef = useRef<NodeJS.Timeout | null>(null);

    // MODIFIED: Read overlay state
    const isOverlayOpen = useContentStore((s) => s.isOverlayOpen);
    
    // MODIFIED: Pass paused condition to hook
    const { currentIndex, hoveredId, setHoveredId, navigateToIndex, getCardState, isMobile, isAnimating } = useVanguardCarousel(reviews.length, isCurrentlyInView && !isOverlayOpen);

    useEffect(() => {
        if (hasAnimatedIn && !initialAnimHasRun) {
            const timer = setTimeout(() => setInitialAnimHasRun(true), 800);
            return () => clearTimeout(timer);
        }
    }, [hasAnimatedIn, initialAnimHasRun]);

    const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
        const swipeThreshold = 50;
        if (info.offset.x < -swipeThreshold) navigateToIndex((currentIndex + 1) % reviews.length);
        else if (info.offset.x > swipeThreshold) navigateToIndex((currentIndex - 1 + reviews.length) % reviews.length);
    };
    
    const handleCardHoverChange = useCallback((id: string, isHovering: boolean) => {
        if (!initialAnimHasRun || isAnimating) { setHoveredId(null); setIsManualHover(false); return; }
        if (isMobile) {
            if (isHovering) { setHoveredId(id); setIsManualHover(true); } else { setHoveredId(null); setIsManualHover(false); }
            return;
        }
        if (hoverTimeoutRef.current) { clearTimeout(hoverTimeoutRef.current); hoverTimeoutRef.current = null; }
        if (isHovering) { hoverTimeoutRef.current = setTimeout(() => { setHoveredId(id); setIsManualHover(true); }, 0); } 
        else { hoverTimeoutRef.current = setTimeout(() => { setHoveredId(null); setIsManualHover(false); }, 50); }
    }, [initialAnimHasRun, isMobile, setHoveredId, isAnimating]);

    if (reviews.length === 0) return null;

    const { layout: centerLayout } = getCardState(currentIndex, reviews[currentIndex].id);
    const initialAnimationConfig = {
        ...centerLayout,
        opacity: 0,
        scale: 0.8 // Force smaller start
    };

    return (
        <div ref={containerRef} className={`${styles.vanguardContainer} ${isManualHover ? styles['manual-hover'] : ''} gpu-cull`}>
            <VanguardGlobalDefs />
            <motion.div className={styles.spotlightGlow} animate={{ opacity: hoveredId ? 0.5 : 1 }} />
            <motion.div
                style={{ position: 'relative', width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                drag={isMobile ? "x" : false}
                dragConstraints={{ left: 0, right: 0 }}
                dragElastic={0.1}
                onDragEnd={handleDragEnd}
                onTouchEnd={() => initialAnimHasRun && setHoveredId(null)}
                onTouchCancel={() => initialAnimHasRun && setHoveredId(null)}
            >
                {reviews.map((review, reviewIndex) => {
                    const { layout, isCenter, isVisible } = getCardState(reviewIndex, review.id);
                    const isHovered = hoveredId === review.id;
                    
                    // FIX: REMOVED MANUAL Y CALCULATION.
                    // The hook now returns the correct 'y' (80) or lifted 'y' (65) directly in `layout.y`.

                    // RESTORED: Standard smooth spring transition for all moves
                    const transitionConfig = { ease: [0.4, 0, 0.2, 1] as const, duration: 0.7, delay: !initialAnimHasRun ? (isCenter ? 0 : 0.2) : 0 };

                    return (
                        <motion.div 
                            key={review.id} 
                            className={`${styles.cardSlot} ${isHovered ? styles.activeState : ''}`} 
                            initial={!initialAnimHasRun ? initialAnimationConfig : false}
                            
                            // Use individual transforms
                            animate={{
                                x: layout.x,
                                y: layout.y, // Use the Y value directly from the hook
                                scale: layout.scale,
                                zIndex: layout.zIndex,
                                opacity: layout.opacity,
                                visibility: layout.visibility
                            }}
                            
                            transition={transitionConfig}
                            style={{ 
                                pointerEvents: layout.pointerEvents as any
                            }}
                        >
                            <VanguardCard 
                                review={review} isCenter={isCenter} isInView={hasAnimatedIn} isPriority={isCenter} isMobile={isMobile} isHovered={isHovered} isInteractive={initialAnimHasRun} isVisible={isVisible} onHoverChange={(val) => handleCardHoverChange(review.id, val)}
                            />
                        </motion.div>
                    );
                })}
            </motion.div>
            {hasAnimatedIn && <KineticNavigator reviews={reviews} currentIndex={currentIndex} navigateToIndex={navigateToIndex} />}
        </div>
    );
}

--- END OF FILE components/VanguardReviews/VanguardReviews.tsx ---

================================================================================

--- START OF FILE hooks/useAsyncValidation.ts ---

// hooks/useAsyncValidation.ts
'use client';

import { useState, useEffect, useTransition } from 'react';
import { useDebounce } from './useDebounce';

type ValidationStatus = 'idle' | 'checking' | 'valid' | 'invalid';
type ValidationResult = { type: ValidationStatus; message: string };

/**
 * A hook to perform debounced, asynchronous validation on an input value.
 * @param value The current value of the input to be validated.
 * @param validationFn The server action or async function to call for validation.
 * @param initialValue The original/initial value of the field to compare against.
 * @param delay The debounce delay in milliseconds.
 * @returns A validation result object: { type: ValidationStatus; message: string }.
 */
export function useAsyncValidation<T>(
    value: T,
    validationFn: (value: T, ...args: any[]) => Promise<{ isValid?: boolean; available?: boolean; message: string }>,
    initialValue?: T,
    delay: number = 500
): ValidationResult {
    const [status, setStatus] = useState<ValidationResult>({ type: 'idle', message: '' });
    const [isPending, startTransition] = useTransition();
    const debouncedValue = useDebounce(value, delay);

    useEffect(() => {
        // Don't validate if the value is empty or hasn't changed from its initial state
        if (!debouncedValue || debouncedValue === initialValue) {
            setStatus({ type: 'idle', message: '' });
            return;
        }

        setStatus({ type: 'checking', message: 'جارٍ التحقق...' });

        startTransition(async () => {
            const result = await validationFn(debouncedValue);
            const isValid = result.isValid ?? result.available ?? false;
            setStatus({
                type: isValid ? 'valid' : 'invalid',
                message: result.message,
            });
        });
    }, [debouncedValue, initialValue, validationFn]);

    return status;
}







--- END OF FILE hooks/useAsyncValidation.ts ---

================================================================================

--- START OF FILE hooks/useBodyClass.ts ---

// hooks/useBodyClass.ts
'use client';

import { useEffect } from 'react';

/**
 * A custom hook to manage adding and removing classes from the `<body>` element.
 * @param {string | string[]} classNames - The class name or an array of class names to apply.
 * @param {boolean} [condition=true] - A boolean condition. The class is applied if true, removed if false.
 */
export function useBodyClass(classNames: string | string[], condition: boolean = true) {
    useEffect(() => {
        const classes = Array.isArray(classNames) ? classNames : [classNames];

        if (condition) {
            document.body.classList.add(...classes);
        } else {
            document.body.classList.remove(...classes);
        }

        // Cleanup function to remove the class when the component unmounts
        // or when the condition becomes false in the next render.
        return () => {
            document.body.classList.remove(...classes);
        };
    }, [classNames, condition]); // Re-run the effect if the class name or condition changes
}







--- END OF FILE hooks/useBodyClass.ts ---

================================================================================

--- START OF FILE hooks/useClickOutside.ts ---

// hooks/useClickOutside.ts
import { useEffect, RefObject } from 'react';

type Event = MouseEvent | TouchEvent;

export const useClickOutside = <T extends HTMLElement = HTMLElement>(
  ref: RefObject<T | null>,
  handler: (event: Event) => void,
  active: boolean = true // Added active flag to conditionally disable
) => {
  useEffect(() => {
    if (!active) return; // Skip if disabled

    const listener = (event: Event) => {
      const el = ref?.current;
      // Do nothing if clicking ref's element or descendent elements
      if (!el || el.contains((event?.target as Node) || null)) {
        return;
      }
      handler(event);
    };

    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);

    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler, active]);
};




--- END OF FILE hooks/useClickOutside.ts ---

================================================================================

--- START OF FILE hooks/useDebounce.ts ---

'use client'

import { useState, useEffect } from 'react'

export function useDebounce<T>(value: T, delay: number): T {
const [debouncedValue, setDebouncedValue] = useState<T>(value)

useEffect(() => {
const handler = setTimeout(() => {
setDebouncedValue(value)
}, delay)

return () => {
clearTimeout(handler)
}
}, [value, delay])

return debouncedValue
}



































--- END OF FILE hooks/useDebounce.ts ---

================================================================================

--- START OF FILE hooks/useIsMobile.ts ---

// hooks/useIsMobile.ts
'use client';

import { useState, useEffect } from 'react';

export function useIsMobile() {
    const [isMobile, setIsMobile] = useState(false);

    useEffect(() => {
        const checkMobile = () => {
            // Detect both screen size AND pointer type (to catch tablets/hybrid devices)
            const isSmallScreen = window.innerWidth <= 768;
            const isTouch = window.matchMedia("(hover: none) and (pointer: coarse)").matches;
            setIsMobile(isSmallScreen || isTouch);
        };

        checkMobile();
        window.addEventListener('resize', checkMobile);
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    return isMobile;
}




--- END OF FILE hooks/useIsMobile.ts ---

================================================================================

--- START OF FILE hooks/useLivingCard.ts ---

// hooks/useLivingCard.ts
'use client';

import { useRef, useState } from 'react';
import { MotionValue, useMotionValue, useSpring, useTransform } from 'framer-motion';
import { useTheme } from 'next-themes';

const springConfig = { stiffness: 250, damping: 25 };

export function useLivingCard<T extends HTMLElement = HTMLDivElement>({ isLead = false } = {}) {
    const ref = useRef<T>(null);
    const { resolvedTheme } = useTheme();
    // We manage isHovered locally for desktop mouse events. 
    // Mobile "locking" logic will be handled in the component by overriding this state.
    const [isHovered, setIsHovered] = useState(false);

    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);

    const smoothMouseX = useSpring(mouseX, springConfig);
    const smoothMouseY = useSpring(mouseY, springConfig);

    const rotateMultiplier = isLead ? 8 / 15 : 1;
    const rotateX = useTransform(smoothMouseY, [0, 1], [15 * rotateMultiplier, -15 * rotateMultiplier]);
    const rotateY = useTransform(smoothMouseX, [0, 1], [-15 * rotateMultiplier, 15 * rotateMultiplier]);
    const scale = useSpring(isHovered ? 1.03 : 1, { stiffness: 400, damping: 30 });

    const transform = useTransform(
        [rotateX, rotateY, scale],
        ([rX, rY, s]: (string | number)[]) => `perspective(1000px) rotateX(${rX}deg) rotateY(${rY}deg) scale(${s})`
    );

    const boxShadow = useTransform<number, string>(
        [smoothMouseX, smoothMouseY],
        ([x, y]: number[]) => {
            const offsetX = (0.5 - x) * 30;
            const offsetY = (0.5 - y) * 30;
            // Note: Components can override this opacity logic if they force isHovered=true
            const shadowOpacity = 0.1; // Base opacity
            const shadowColor = resolvedTheme === 'dark' 
                ? `rgba(0, 229, 255, ${shadowOpacity})`
                : `rgba(0, 0, 0, ${shadowOpacity * 1.5})`;
            return `${offsetX}px ${offsetY}px 35px ${shadowColor}`;
        }
    );

    const handlePointerMove = (e: React.MouseEvent<T> | React.TouchEvent<T>) => {
        // REMOVED MOBILE BLOCK: 3D calculations are active on all devices
        if (!ref.current) return;
        const { left, top, width, height } = ref.current.getBoundingClientRect();
        
        const clientX = 'touches' in e ? e.touches[0].clientX : (e as React.MouseEvent<T>).clientX;
        const clientY = 'touches' in e ? e.touches[0].clientY : (e as React.MouseEvent<T>).clientY;

        mouseX.set((clientX - left) / width);
        mouseY.set((clientY - top) / height);
    };
    
    const onPointerEnter = () => {
        setIsHovered(true);
    };

    const onPointerLeave = () => {
        setIsHovered(false);
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    return {
        livingCardRef: ref,
        livingCardAnimation: {
            style: {
                transform,
                boxShadow,
            },
            onMouseMove: handlePointerMove,
            onTouchMove: handlePointerMove,
            onMouseEnter: onPointerEnter,
            onMouseLeave: onPointerLeave,
            onTouchStart: (e: React.TouchEvent<T>) => {
                onPointerEnter();
                handlePointerMove(e);
            },
            // Note: Components implementing "Touch Lock" might ignore onTouchEnd to keep state active
            onTouchEnd: onPointerLeave,
            onTouchCancel: onPointerLeave,
        },
    };
}




--- END OF FILE hooks/useLivingCard.ts ---

================================================================================

--- START OF FILE hooks/usePopoverManager.ts ---

// hooks/usePopoverManager.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

type PopoverIdentifier = string | null;

export function usePopoverManager() {
    const [openPopover, setOpenPopover] = useState<PopoverIdentifier>(null);
    const popoverRef = useRef<HTMLDivElement>(null);

    const togglePopover = useCallback((popoverId: string) => {
        setOpenPopover(current => (current === popoverId ? null : popoverId));
    }, []);

    const closePopover = useCallback(() => {
        setOpenPopover(null);
    }, []);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            // THE DEFINITIVE FIX:
            // The ref is now placed on the container of the popovers and their triggers.
            // If a click happens AND the popoverRef exists AND the click is OUTSIDE the ref's boundary,
            // then we close the currently open popover.
            if (popoverRef.current && !popoverRef.current.contains(event.target as Node)) {
                closePopover();
            }
        };
        
        // We only add the listener if a popover is open.
        if (openPopover) {
            document.addEventListener('mousedown', handleClickOutside);
        }

        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [openPopover, closePopover]); // Re-run effect when the open popover changes

    return { popoverRef, openPopover, togglePopover, closePopover };
}




--- END OF FILE hooks/usePopoverManager.ts ---

================================================================================

--- START OF FILE hooks/useScrolled.ts ---

// hooks/useScrolled.ts
'use client';

import { useState, useEffect } from 'react';
import { useUIStore } from '@/lib/uiStore';

export function useScrolled(threshold: number = 50): boolean {
    const [isScrolled, setIsScrolled] = useState(false);
    const { overlayScrollRef } = useUIStore();

    useEffect(() => {
        // Determine which container to listen to
        // If overlayRef is present, use it. Otherwise use window.
        const target = overlayScrollRef || window;
        
        const handleScroll = () => {
            const scrollTop = overlayScrollRef ? overlayScrollRef.scrollTop : window.scrollY;
            setIsScrolled(scrollTop > threshold);
        };

        // Call once to set initial state
        handleScroll();

        // Attach listener
        target.addEventListener('scroll', handleScroll, { passive: true });

        return () => {
            target.removeEventListener('scroll', handleScroll);
        };
    }, [threshold, overlayScrollRef]);

    return isScrolled;
}

--- END OF FILE hooks/useScrolled.ts ---

================================================================================

--- START OF FILE hooks/useSearchablePopover.ts ---

// hooks/useSearchablePopover.ts
'use client';

import { useState, useEffect, useRef, useTransition, useCallback } from 'react';

interface UseSearchablePopoverProps<T> {
    searchAction: (query: string) => Promise<T[]>;
    initialResults?: T[];
}

export function useSearchablePopover<T>({ searchAction, initialResults = [] }: UseSearchablePopoverProps<T>) {
    const [isOpen, setIsOpen] = useState(false);
    const [searchTerm, setSearchTerm] = useState('');
    const [results, setResults] = useState<T[]>(initialResults);
    const [isSearching, startSearchTransition] = useTransition();
    const popoverRef = useRef<HTMLDivElement>(null);

    const togglePopover = useCallback(() => setIsOpen(prev => !prev), []);
    const closePopover = useCallback(() => setIsOpen(false), []);
    const openPopover = useCallback(() => setIsOpen(true), []);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (popoverRef.current && !popoverRef.current.contains(event.target as Node)) {
                closePopover();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, [closePopover]);

    useEffect(() => {
        if (!isOpen) {
            setSearchTerm('');
            setResults(initialResults);
            return;
        }

        startSearchTransition(async () => {
            if (searchTerm.length > 0) {
                const searchResults = await searchAction(searchTerm);
                setResults(searchResults);
            } else {
                setResults(initialResults);
            }
        });
    }, [isOpen, searchTerm, searchAction, initialResults]);

    return {
        popoverRef,
        isOpen,
        searchTerm,
        results,
        isSearching,
        setSearchTerm,
        togglePopover,
        closePopover,
        openPopover,
    };
}







--- END OF FILE hooks/useSearchablePopover.ts ---

================================================================================

--- START OF FILE hooks/useUpscaler.ts ---

// hooks/useUpscaler.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';

export type UpscaleStatus = 'idle' | 'init' | 'downloading' | 'processing' | 'complete' | 'error';

interface UpscalerState {
    status: UpscaleStatus;
    progress: number; // 0-100
    message: string;
    resultSrc: string | null;
    originalSrc: string | null;
}

export function useUpscaler() {
    const [state, setState] = useState<UpscalerState>({
        status: 'idle',
        progress: 0,
        message: '',
        resultSrc: null,
        originalSrc: null,
    });

    const workerRef = useRef<Worker | null>(null);

    useEffect(() => {
        // Initialize Worker
        workerRef.current = new Worker(new URL('../lib/workers/upscaler.worker.ts', import.meta.url), {
            type: 'module'
        });

        workerRef.current.onmessage = (event) => {
            const { status, message, progress, result } = event.data;

            switch (status) {
                case 'init':
                    setState(prev => ({ ...prev, status: 'init', message: message || 'البدء...', progress: 0 }));
                    break;
                case 'downloading':
                    setState(prev => ({ ...prev, status: 'downloading', progress: progress || 0, message: 'تحميل نموذج الذكاء الاصطناعي...' }));
                    break;
                case 'processing':
                    // Update progress bar during tile processing
                    setState(prev => ({ ...prev, status: 'processing', progress: progress || 0, message: message || 'جارٍ المعالجة...' }));
                    break;
                case 'complete':
                    setState(prev => ({ ...prev, status: 'complete', resultSrc: result, progress: 100 }));
                    break;
                case 'error':
                    setState(prev => ({ ...prev, status: 'error', message: message || 'حدث خطأ.' }));
                    break;
            }
        };

        return () => {
            workerRef.current?.terminate();
        };
    }, []);

    const upscaleImage = useCallback((file: File) => {
        const originalUrl = URL.createObjectURL(file);
        setState({
            status: 'init',
            progress: 0,
            message: 'جارٍ التهيئة...',
            resultSrc: null,
            originalSrc: originalUrl
        });

        workerRef.current?.postMessage({ type: 'upscale', image: originalUrl });
    }, []);

    const reset = useCallback(() => {
        setState({
            status: 'idle',
            progress: 0,
            message: '',
            resultSrc: null,
            originalSrc: null,
        });
    }, []);

    return { ...state, upscaleImage, reset };
}




--- END OF FILE hooks/useUpscaler.ts ---

================================================================================

--- START OF FILE hooks/useVanguardCarousel.ts ---

// hooks/useVanguardCarousel.ts
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { usePerformanceStore } from '@/lib/performanceStore';

const VANGUARD_SLOTS = 5;
export const ANIMATION_COOLDOWN = 750; 
const AUTO_NAVIGATE_INTERVAL = 2500;
const MOBILE_BREAKPOINT = 1024;
const CENTER_SLOT_INDEX = 2;

// --- Helper type for raw transform data ---
export type CarouselCardLayout = {
    x: number;
    y: number;
    scale: number;
    zIndex: number;
    opacity: number;
    pointerEvents: 'auto' | 'none';
    visibility: 'visible' | 'hidden';
};

export function useVanguardCarousel(itemCount: number, isCurrentlyInView: boolean) {
    const [currentIndex, setCurrentIndex] = useState(0);
    const [hoveredId, setHoveredId] = useState<string | number | null>(null);
    const [isAnimating, setIsAnimating] = useState(false);
    const [isPageVisible, setIsPageVisible] = useState(true);
    const [isMobile, setIsMobile] = useState(false);
    const intervalRef = useRef<NodeJS.Timeout | null>(null);
    
    // Check performance settings
    const { isCarouselAutoScrollEnabled } = usePerformanceStore();
    
    useEffect(() => {
        const checkDevice = () => setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
        checkDevice();
        window.addEventListener('resize', checkDevice);
        return () => window.removeEventListener('resize', checkDevice);
    }, []);

    useEffect(() => {
        const handleVisibilityChange = () => setIsPageVisible(document.visibilityState === 'visible');
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
    }, []);

    const stopInterval = useCallback(() => {
        if (intervalRef.current) clearInterval(intervalRef.current);
    }, []);

    const startInterval = useCallback(() => {
        stopInterval();
        // Only start if auto-scroll is enabled
        if (itemCount > 0 && isCarouselAutoScrollEnabled) {
            intervalRef.current = setInterval(() => {
                setIsAnimating(true);
                setHoveredId(null);
                setCurrentIndex(prevIndex => (prevIndex + 1) % itemCount);
                setTimeout(() => setIsAnimating(false), ANIMATION_COOLDOWN);
            }, AUTO_NAVIGATE_INTERVAL);
        }
    }, [itemCount, stopInterval, isCarouselAutoScrollEnabled]);

    const navigateToIndex = useCallback((index: number) => {
        if (isAnimating || index === currentIndex) return;
        setIsAnimating(true);
        setHoveredId(null);
        setCurrentIndex(index);
        startInterval(); 
        setTimeout(() => {
            setIsAnimating(false);
        }, ANIMATION_COOLDOWN);
    }, [isAnimating, currentIndex, startInterval]);

    useEffect(() => {
        // Only run if auto-scroll enabled
        if (!hoveredId && isCurrentlyInView && isPageVisible && isCarouselAutoScrollEnabled) {
            startInterval();
        } else {
            stopInterval();
        }
        return () => stopInterval();
    }, [hoveredId, isCurrentlyInView, isPageVisible, startInterval, stopInterval, isCarouselAutoScrollEnabled]);

    const handleSetHoveredId = useCallback((id: string | number | null) => {
        if (isAnimating) return;
        setHoveredId(id);
    }, [isAnimating]);

    const getCardState = useCallback((reviewIndex: number, itemId: string | number) => {
        // Default "Hidden" State
        const hiddenLayout: CarouselCardLayout = {
            x: 0,
            y: 0,
            scale: 0.5,
            zIndex: -1,
            opacity: 0,
            pointerEvents: 'none',
            visibility: 'hidden'
        };

        if (itemCount === 0) return { layout: hiddenLayout, isCenter: false, isVisible: false, slotIndex: -1 };

        let diff = reviewIndex - currentIndex;
        if (diff > itemCount / 2) diff -= itemCount;
        if (diff < -itemCount / 2) diff += itemCount;
        const slotIndex = diff + CENTER_SLOT_INDEX;

        if (slotIndex < 0 || slotIndex >= VANGUARD_SLOTS) {
            // Determine exit direction for smoother fade
            const isFarRight = diff > 0;
            return {
                layout: { 
                    ...hiddenLayout,
                    x: isFarRight ? 600 : -600 // Push far off screen
                },
                isCenter: false, 
                isVisible: false,
                slotIndex
            };
        }

        const isCenter = slotIndex === CENTER_SLOT_INDEX;
        const isHovered = hoveredId === itemId;

        // Base layout values
        let x = 0;
        let y = 0;
        let scale = 1;
        let zIndex = 10;

        const BASE_Z = 10;
        const CENTER_Z = 20;
        const HOVER_Z = 100; // Increased to ensure it pops well above others

        if (isMobile) {
            // Mobile Layout Logic
            const offsetPx = 140; 
            
            switch (slotIndex) {
                case 0: x = -offsetPx * 1.6; scale = 0.75; zIndex = BASE_Z; break;
                case 1: x = -offsetPx * 0.9; scale = 0.8;  zIndex = BASE_Z + 1; break;
                case 2: x = 0;               scale = 1;    zIndex = CENTER_Z; break;
                case 3: x = offsetPx * 0.9;  scale = 0.8;  zIndex = BASE_Z + 1; break;
                case 4: x = offsetPx * 1.6;  scale = 0.75; zIndex = BASE_Z; break;
            }

            // Mobile Y Adjustment
            y = -80; 

            // Hover Scale & Z-Index
            if (isHovered) {
                scale *= 1.05;
                zIndex = HOVER_Z;
            }
            
        } else { // Desktop Layout Logic
            const offset = 250;
            
            switch (slotIndex) {
                case 0: x = -offset * 1.6; scale = 0.6;  zIndex = BASE_Z; break;
                case 1: x = -offset * 0.9; scale = 0.65; zIndex = BASE_Z + 1; break;
                case 2: x = 0;             scale = 1;    zIndex = CENTER_Z; break;
                case 3: x = offset * 0.9;  scale = 0.65; zIndex = BASE_Z + 1; break;
                case 4: x = offset * 1.6;  scale = 0.6;  zIndex = BASE_Z; break;
            }

            // Desktop Vertical Position
            y = -80;

            // Hover Logic
            if (isHovered) {
                zIndex = HOVER_Z; // Apply highest Z-Index
                y -= 15; // Lift up slightly
            }
        }

        const isVisibleOnMobile = isMobile ? slotIndex >= 1 && slotIndex <= 3 : true;
        
        return { 
            layout: {
                x,
                y,
                scale,
                zIndex,
                opacity: isVisibleOnMobile ? 1 : 0,
                pointerEvents: isVisibleOnMobile ? 'auto' : 'none',
                visibility: isVisibleOnMobile ? 'visible' : 'hidden'
            },
            isCenter, 
            isVisible: true, 
            slotIndex 
        };
    }, [currentIndex, itemCount, hoveredId, isMobile]);
    
    return {
        currentIndex,
        hoveredId,
        setHoveredId: handleSetHoveredId,
        navigateToIndex,
        getCardState,
        isMobile,
        isAnimating,
    };
}

--- END OF FILE hooks/useVanguardCarousel.ts ---

================================================================================

--- START OF FILE lib/activeCardStore.ts ---

import { create } from 'zustand';

interface ActiveCardState {
  activeCardId: string | null;
  setActiveCardId: (id: string | null) => void;
}

export const useActiveCardStore = create<ActiveCardState>((set) => ({
  activeCardId: null,
  setActiveCardId: (id) => set({ activeCardId: id }),
}));




--- END OF FILE lib/activeCardStore.ts ---

================================================================================

--- START OF FILE lib/adapters.ts ---

// lib/adapters.ts
import { urlFor } from '@/sanity/lib/image';
import { CardProps } from '@/types';

const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];

export const adaptToCardProps = (item: any, options: { width?: number } = {}): CardProps | null => {
    if (!item || (!item._id && !item.id)) {
        return null;
    }
    
    // THE FIX: Ensure slug is a valid string or null, never an empty string.
    const slug = item.slug?.current ?? item.slug ?? null;
    if (!slug) {
        // If there's no slug, we can't link to it, so discard the item.
        return null;
    }

    // Defensive Image Extraction
    let imageAsset = item.mainImage?.asset || item.mainImageRef;
    
    if (!imageAsset && item.mainImage && item.mainImage._type === 'image') {
         imageAsset = item.mainImage.asset;
    }

    let imageUrl = null;
    // FIX: Initialize with the GROQ-fetched LQIP (Base64) if available
    let blurDataURL: string = item.blurDataURL || item.mainImage?.blurDataURL || '';
    
    const targetWidth = options.width || 1200;
    const targetHeight = Math.round(targetWidth * 0.5625);

    // FIXED: Strict check for asset existence
    if (imageAsset && (imageAsset._ref || imageAsset._id || imageAsset.url)) {
        try {
            imageUrl = urlFor(imageAsset).width(targetWidth).height(targetHeight).fit('crop').auto('format').url();
            
            // FIX: Only generate a URL-based blur fallback if we DON'T have a base64 string.
            // Note: Next.js <Image> really prefers Base64 for 'blurDataURL'. 
            // Passing a CDN URL here usually won't work for the 'blur' placeholder effect unless configured specifically.
            // So we primarily rely on the incoming `blurDataURL`.
            if (!blurDataURL) {
                 // Fallback: If no LQIP, we can't easily sync-generate one. 
                 // We leave it empty to avoid broken image icons.
                 blurDataURL = '';
            }
        } catch (e) {
            console.warn("Image URL generation failed", e);
            imageUrl = '/placeholder-game.jpg';
        }
    } else if (item.imageUrl) {
        imageUrl = item.imageUrl;
    } else {
        imageUrl = '/placeholder-game.jpg';
    }

    const verticalImageAsset = item.mainImageVertical?.asset || item.mainImageVerticalRef;
    let verticalImageUrl = null;
    if (verticalImageAsset && (verticalImageAsset._ref || verticalImageAsset._id || verticalImageAsset.url)) {
        try {
            verticalImageUrl = urlFor(verticalImageAsset).width(600).height(900).fit('crop').auto('format').url();
        } catch (e) {
             // Ignore vertical fail
        }
    }

    let formattedDate = '';
    let publishedYear = null;

    if (item.publishedAt) {
        const date = new Date(item.publishedAt);
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        formattedDate = `${day} ${arabicMonths[monthIndex]} ${year}`;
        publishedYear = year;
    } else if (item.releaseDate) {
        const date = new Date(item.releaseDate);
        const day = date.getDate();
        const monthIndex = date.getMonth();
        const year = date.getFullYear();
        publishedYear = year;

        if (item.isTBA) {
            formattedDate = "غير معلن";
        } else if (item.datePrecision === 'year') {
            formattedDate = `${year}`;
        } else if (item.datePrecision === 'month') {
            formattedDate = `${arabicMonths[monthIndex]} ${year}`;
        } else {
            formattedDate = `${day} ${arabicMonths[monthIndex]} ${year}`;
        }
    }

    let primaryCreators = [];
    if (item._type === 'review' || item._type === 'article') {
        primaryCreators = item.authors || [];
    } else if (item._type === 'news') {
        primaryCreators = item.reporters || [];
    }
    
    if (primaryCreators.length === 0) {
        primaryCreators = item.authors || item.reporters || [];
    }

    const gameTitle = item.game?.title || item.game; // Handle both object and string
    const gameSlug = item.game?.slug;

    // IMPORTANT: Pass through the raw content array so the store can use it
    const contentBody = item.content || [];

    return {
        type: item._type,
        id: item._id, 
        legacyId: item.legacyId || 0,
        slug: slug,
        game: gameTitle,
        gameSlug: gameSlug,
        title: item.title,
        authors: primaryCreators,
        designers: item.designers || [],
        date: formattedDate,
        year: publishedYear,
        imageUrl: imageUrl,
        verticalImageUrl: verticalImageUrl, 
        mainImageRef: imageAsset,
        mainImageVerticalRef: verticalImageAsset, 
        score: item.score,
        tags: (item.tags || []).map((t: any) => ({ title: t.title, slug: t.slug })).filter(Boolean),
        blurDataURL: blurDataURL, // Now correctly using the Base64 string
        category: item.category?.title,
        newsType: item.newsType || 'official', 
        verdict: item.verdict || '',
        pros: item.pros || [],
        cons: item.cons || [],
        content: contentBody, // Pass body
        relatedReviewIds: item.relatedReviewIds || [],
        synopsis: item.synopsis,
        onGamePass: item.onGamePass || false,
        onPSPlus: item.onPSPlus || false,
        trailer: item.trailer || '',
        isPinned: item.isPinned || false,
        datePrecision: item.datePrecision || 'day', 
        isTBA: item.isTBA || false,
    };
};

--- END OF FILE lib/adapters.ts ---

================================================================================

--- START OF FILE lib/auth.ts ---

// lib/auth.ts
'use server';

import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/authOptions';
import { Session } from 'next-auth';
import prisma from '@/lib/prisma';
import { unstable_cache } from 'next/cache';

// Cache the heavy DB lookup for the user session
// This key is unique per user ID.
const getCachedUser = unstable_cache(
    async (userId: string) => {
        return await prisma.user.findUnique({
            where: { id: userId },
            select: { 
                roles: { select: { name: true } }, 
                username: true, 
                name: true, 
                image: true, 
                email: true 
            }
        });
    },
    ['session-user-data'], // Key prefix
    { tags: ['session-user'] } // We will append the ID dynamically in usage or just use a broad tag if granular isn't needed, but let's rely on the key.
);

export async function getAuthenticatedSession(): Promise<Session> {
    const session = await getServerSession(authOptions);
    if (!session || !session.user?.id) {
        throw new Error('Authentication required. Please sign in.');
    }

    const cachedUserLookup = unstable_cache(
        async (uid: string) => {
            return await prisma.user.findUnique({
                where: { id: uid },
                select: { 
                    roles: { select: { name: true } }, 
                    username: true, 
                    name: true, 
                    image: true, 
                    email: true 
                }
            });
        },
        ['session-user-lookup'],
        { tags: [`user-session-${session.user.id}`] } // Unique tag for invalidation
    );

    const user = await cachedUserLookup(session.user.id);

    if (!user) {
        throw new Error('User record not found.');
    }

    // Overwrite session data with cached DB data
    session.user.roles = user.roles.map((r: any) => r.name);
    session.user.username = user.username;
    session.user.name = user.name;
    session.user.image = user.image;
    session.user.email = user.email;

    return session;
}




--- END OF FILE lib/auth.ts ---

================================================================================

--- START OF FILE lib/badges.tsx ---

// lib/badges.tsx
import React from 'react';

export type BadgeId = 'DIRECTOR' | 'REVIEWER' | 'AUTHOR' | 'REPORTER' | 'DESIGNER' | 'FOUNDER' | 'FIRST_COMMENT' | 'ENGAGED_COMMENTER' | 'TOP_CONTRIBUTOR';

export interface Badge {
    id: BadgeId;
    name: string;
    description: string;
    Icon: (props: { className?: string }) => React.JSX.Element;
}

const DirectorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2z"/></svg>;
const ReviewerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-5.17 11.17l-2.83-2.83-2.83 2.83-1.17-1.17 2.83-2.83-2.83-2.83 1.17-1.17 2.83 2.83 2.83-2.83 1.17 1.17-2.83 2.83 2.83 2.83-1.17 1.17z"/></svg>;
const AuthorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>;
const ReporterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg>;
const DesignerIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-2.5-11.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm5 0c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm-2.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg>;

const FounderIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>;
const FirstCommentIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 12H5v-2h14v2zm0-3H5V9h14v2zm0-3H5V6h14v2z"/></svg>;
const EngagedCommenterIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"/></svg>;
const TopContributorIcon = ({ className = '' }) => <svg className={className} xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2l-5.5 9h11zM12 21.8l-5.5-9h11z"/></svg>;

export const BADGES: Record<BadgeId, Badge> = {
    DIRECTOR: { id: 'DIRECTOR', name: 'مدير', description: 'يشرف على مشروع EternalGames.', Icon: DirectorIcon },
    REVIEWER: { id: 'REVIEWER', name: 'مُراجع', description: 'صوت موثوق لمراجعات الألعاب.', Icon: ReviewerIcon },
    AUTHOR: { id: 'AUTHOR', name: 'كاتب', description: 'يخطُّ المقالات والمواضيع.', Icon: AuthorIcon },
    REPORTER: { id: 'REPORTER', name: 'مراسل', description: 'يقتفي أثر أخبار الصناعة.', Icon: ReporterIcon },
    DESIGNER: { id: 'DESIGNER', name: 'مصمم', description: 'يضفي رونقًا على المحتوى.', Icon: DesignerIcon },
    FOUNDER: { id: 'FOUNDER', name: 'مؤسس', description: 'التحق بركب EternalGames في شهره الأول.', Icon: FounderIcon },
    FIRST_COMMENT: { id: 'FIRST_COMMENT', name: 'مبادر', description: 'خطَّ أول تعليقٍ له.', Icon: FirstCommentIcon },
    ENGAGED_COMMENTER: { id: 'ENGAGED_COMMENTER', name: 'مساهم', description: 'جاوزت تعليقاته العشرة.', Icon: EngagedCommenterIcon },
    TOP_CONTRIBUTOR: { id: 'TOP_CONTRIBUTOR', name: 'عمود المجتمع', description: 'جاوز الخمسين تعليقًا.', Icon: TopContributorIcon },
};

export function getBadgesForUser(user: { createdAt: Date; _count: { comments: number }, roles: string[] }): Badge[] {
    const earnedBadges: Badge[] = [];
    const roles = new Set(user.roles);

    if (roles.has('DIRECTOR')) earnedBadges.push(BADGES.DIRECTOR);
    if (roles.has('REVIEWER')) earnedBadges.push(BADGES.REVIEWER);
    if (roles.has('AUTHOR')) earnedBadges.push(BADGES.AUTHOR);
    if (roles.has('REPORTER')) earnedBadges.push(BADGES.REPORTER);
    if (roles.has('DESIGNER')) earnedBadges.push(BADGES.DESIGNER);

    const founderCutoffDate = new Date('2025-11-01');
    if (user.createdAt < founderCutoffDate) {
        earnedBadges.push(BADGES.FOUNDER);
    }

    const commentCount = user._count.comments;
    if (commentCount >= 50) earnedBadges.push(BADGES.TOP_CONTRIBUTOR);
    else if (commentCount >= 10) earnedBadges.push(BADGES.ENGAGED_COMMENTER);
    else if (commentCount >= 1) earnedBadges.push(BADGES.FIRST_COMMENT);

    return earnedBadges;
}







--- END OF FILE lib/badges.tsx ---

================================================================================

--- START OF FILE lib/cache.ts ---

import { unstable_cache } from 'next/cache';

// Helper to cache expensive DB operations
// refreshInterval is in seconds
export const cacheDb = <T, P extends any[]>(
  fn: (...params: P) => Promise<T>,
  keyParts: string[],
  tags: string[],
  refreshInterval: number = 300 // Default 5 minutes
) => {
  return unstable_cache(fn, keyParts, {
    tags: tags,
    revalidate: refreshInterval,
  });
};




--- END OF FILE lib/cache.ts ---

================================================================================

--- START OF FILE lib/contentStore.ts ---

// lib/contentStore.ts
import { create } from 'zustand';
import { 
    fetchGameContentAction, 
    fetchCreatorContentAction, 
    fetchTagContentAction,
    fetchSingleContentAction,
    fetchCreatorByUsernameAction,
    fetchGameHubDataAction // IMPORTED
} from '@/app/actions/batchActions';

export interface KineticContentState {
  universalData: any | null;
  contentMap: Map<string, any>;
  pageMap: Map<string, any>;
  creatorMap: Map<string, any>;
  tagMap: Map<string, any>;
  
  // Fetch Lock to prevent duplicate requests
  pendingFetches: Set<string>; 

  isOverlayOpen: boolean;
  activeSlug: string | null;
  activeType: 'reviews' | 'articles' | 'news' | 'releases' | 'index' | 'games' | 'creators' | 'tags' | null;
  indexSection: 'reviews' | 'articles' | 'news' | 'releases' | null;
  
  sourceLayoutId: string | null;
  activeImageSrc: string | null;
  savedScrollPosition: number;
  previousPath: string | null;
  
  hydrateUniversal: (data: any) => void;
  hydrateContent: (items: any[]) => void;
  hydrateIndex: (section: string, data: any) => void;
  hydrateCreators: (creators: any[]) => void;
  hydrateTags: (tags: any[]) => void;
  
  appendToSection: (section: 'reviews' | 'articles' | 'news', newItems: any[], nextOffset: number | null) => void;
  openOverlay: (slug: string, type: 'reviews' | 'articles' | 'news' | 'releases' | 'games' | 'creators' | 'tags', layoutId?: string, imageSrc?: string, overrideUrl?: string, preloadedData?: any) => void;
  openIndexOverlay: (section: 'reviews' | 'articles' | 'news' | 'releases') => void;
  navigateInternal: (slug: string, type: string) => void;
  closeOverlay: () => void;
  forceCloseOverlay: () => void;
  
  fetchLinkedContent: (slug: string) => Promise<void>;
  fetchCreatorContent: (slug: string, creatorId: string) => Promise<void>;
  fetchTagContent: (slug: string) => Promise<void>;
  fetchFullContent: (slug: string) => Promise<void>;
  fetchCreatorByUsername: (username: string) => Promise<void>;
}

// Helper for consistent key generation
const normalizeKey = (key: string) => key ? key.toLowerCase().trim() : '';

export const useContentStore = create<KineticContentState>((set, get) => ({
  universalData: null, 
  contentMap: new Map(),
  pageMap: new Map(),
  creatorMap: new Map(),
  tagMap: new Map(),
  pendingFetches: new Set(),
  
  isOverlayOpen: false,
  activeSlug: null,
  activeType: null,
  indexSection: null,
  sourceLayoutId: null,
  activeImageSrc: null,
  savedScrollPosition: 0,
  previousPath: null,

  hydrateUniversal: (data) => {
      set({ universalData: data });

      const { hydrateContent, hydrateIndex, hydrateCreators, hydrateTags } = get();
      
      const hubContent: any[] = [];
      const gameHubs: any[] = [];
      const tagHubs: any[] = [];
      const creatorHubs: any[] = [];
      
      if (data.hubs) {
          if (data.hubs.games) {
              gameHubs.push(...data.hubs.games);
              data.hubs.games.forEach((g: any) => g.linkedContent && hubContent.push(...g.linkedContent));
          }
          if (data.hubs.tags) {
              tagHubs.push(...data.hubs.tags);
              data.hubs.tags.forEach((t: any) => t.items && hubContent.push(...t.items));
          }
          if (data.hubs.creators) {
              creatorHubs.push(...data.hubs.creators);
              data.hubs.creators.forEach((c: any) => c.linkedContent && hubContent.push(...c.linkedContent));
          }
      }

      const allContent = [
          ...(data.reviews || []), 
          ...(data.articles || []), 
          ...(data.news || []), 
          ...(data.releases || []),
          ...hubContent
      ];

      const processedContent = allContent.map(item => {
          const hasBody = item.content && Array.isArray(item.content) && item.content.length > 0;
          const hasHub = item.linkedContent && Array.isArray(item.linkedContent);
          
          return {
              ...item,
              contentLoaded: hasBody || hasHub
          };
      });

      gameHubs.forEach(g => processedContent.push({ ...g, contentLoaded: true }));
      
      if (data.metadata && data.metadata.games) {
          data.metadata.games.forEach((g: any) => {
              processedContent.push({ ...g, contentLoaded: false });
          });
      }

      hydrateContent(processedContent);
      
      if (data.reviews) {
          hydrateIndex('reviews', {
              hero: data.reviews[0],
              grid: data.reviews,
              allGames: data.metadata?.games || [],
              allTags: data.metadata?.gameTags || [],
              nextOffset: data.reviews.length
          });
      }
      
      if (data.articles) {
          hydrateIndex('articles', {
              featured: data.articles.slice(0, 5),
              grid: data.articles,
              allGames: data.metadata?.games || [],
              allGameTags: data.metadata?.gameTags || [],
              allArticleTypeTags: data.metadata?.articleTags || [],
              nextOffset: data.articles.length
          });
      }
      
      if (data.news) {
          hydrateIndex('news', {
              hero: data.news.slice(0, 4),
              grid: data.news,
              allGames: data.metadata?.games || [],
              allTags: data.metadata?.newsTags || [],
              nextOffset: data.news.length
          });
      }
      
      if (data.releases) {
          hydrateIndex('releases', {
              releases: data.releases
          });
      }
      
      // Hydrate Creators
      const allCreators = [...(data.credits || []), ...creatorHubs.map((c: any) => ({ ...c, contentLoaded: true }))];
      if (data.metadata && data.metadata.creators) {
          allCreators.push(...data.metadata.creators.map((c: any) => ({ ...c, contentLoaded: false })));
      }
      hydrateCreators(allCreators);

      // Hydrate Tags
      const allTags = [...tagHubs.map((t: any) => ({ ...t, contentLoaded: true }))];
      if (data.metadata) {
          const metaTags = [
              ...(data.metadata.gameTags || []),
              ...(data.metadata.newsTags || []),
              ...(data.metadata.articleTags || [])
          ];
          const uniqueMetaTags = Array.from(new Map(metaTags.map((t:any) => [t.slug, t])).values());
          allTags.push(...uniqueMetaTags.map((t: any) => ({ ...t, contentLoaded: false })));
      }
      hydrateTags(allTags);
  },

  hydrateContent: (items) => {
    const newMap = new Map(get().contentMap);
    items.forEach(item => {
      if (item && item.slug) {
        const slugStr = typeof item.slug === 'string' ? item.slug : item.slug.current;
        if (slugStr) {
             const key = normalizeKey(slugStr);
             const existing = newMap.get(key);
             let isLoaded = false;
             
             if (item.contentLoaded === true) { isLoaded = true; } 
             else if (existing?.contentLoaded) { isLoaded = true; }
             else {
                 const hasBody = item.content && Array.isArray(item.content) && item.content.length > 0;
                 const hasLinked = item.linkedContent && Array.isArray(item.linkedContent);
                 if (hasBody || hasLinked) isLoaded = true;
             }

             const content = (item.content && item.content.length > 0) ? item.content : existing?.content;
             const linkedContent = (item.linkedContent && item.linkedContent.length > 0) ? item.linkedContent : existing?.linkedContent;
             const tiptapContent = item.tiptapContent || existing?.tiptapContent;

             const newItem = { 
                 ...existing, 
                 ...item,
                 content,
                 linkedContent,
                 tiptapContent,
                 contentLoaded: isLoaded
             };

             newMap.set(key, newItem);
        }
      }
    });
    set({ contentMap: newMap });
  },

  hydrateIndex: (section, data) => {
      const newPageMap = new Map(get().pageMap);
      newPageMap.set(section, data);
      set({ pageMap: newPageMap });
  },

  appendToSection: (section, newItems, nextOffset) => {
      const { pageMap } = get();
      const currentData = pageMap.get(section);
      if (currentData) {
          const currentGrid = currentData.grid || [];
          const updatedData = { ...currentData, grid: [...currentGrid, ...newItems], nextOffset: nextOffset };
          const newPageMap = new Map(pageMap);
          newPageMap.set(section, updatedData);
          set({ pageMap: newPageMap });
      }
  },

  hydrateCreators: (creators) => {
      const newMap = new Map(get().creatorMap);
      
      creators.forEach(c => {
          const keys = [];
          if (c.username) keys.push(normalizeKey(c.username));
          if (c._id) keys.push(c._id); // IDs are kept as is
          if (c.prismaUserId) keys.push(c.prismaUserId);

          let existing = null;
          for (const key of keys) { 
              if (newMap.has(key)) { 
                  existing = newMap.get(key); 
                  break; 
              } 
          }

          let merged = { ...c };

          if (existing) {
              merged = { ...existing, ...c };

              if (c.linkedContent && c.linkedContent.length > 0) {
                  const existingContent = existing.linkedContent || [];
                  const newContent = c.linkedContent;
                  
                  const combinedMap = new Map();
                  existingContent.forEach((item: any) => combinedMap.set(item._id, item));
                  newContent.forEach((item: any) => combinedMap.set(item._id, item));
                  
                  const mergedContent = Array.from(combinedMap.values());
                  
                  mergedContent.sort((a: any, b: any) => 
                      new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime()
                  );
                  
                  merged.linkedContent = mergedContent;
              } else if (existing.linkedContent) {
                  merged.linkedContent = existing.linkedContent;
              }
              
              if (!merged.bio && existing.bio) merged.bio = existing.bio;
              if (!merged.image && existing.image) merged.image = existing.image;
          }

          let isLoaded = false;
          if (c.contentLoaded === true) isLoaded = true;
          else if (existing?.contentLoaded) isLoaded = true;
          else if (merged.linkedContent && merged.linkedContent.length > 0) isLoaded = true; 
          
          merged.contentLoaded = isLoaded;
          
          if (merged.username) newMap.set(normalizeKey(merged.username), merged);
          if (merged._id) newMap.set(merged._id, merged);
          if (merged.prismaUserId) newMap.set(merged.prismaUserId, merged);
      });
      set({ creatorMap: newMap });
  },

  hydrateTags: (tags) => {
      const newMap = new Map(get().tagMap);
      tags.forEach(t => {
          if (t.slug) {
              const slugStr = typeof t.slug === 'string' ? t.slug : t.slug.current;
              if (slugStr) {
                  const key = normalizeKey(slugStr);
                  const existing = newMap.get(key);
                  const merged = existing ? { ...t, ...existing } : { ...t };
                  
                  let isLoaded = false;
                  if (t.contentLoaded === true) isLoaded = true;
                  else if (existing?.contentLoaded) isLoaded = true;
                  else if (t.items !== undefined) isLoaded = true;

                  if (t.items !== undefined) { merged.items = t.items; }
                  merged.contentLoaded = isLoaded;
                  
                  newMap.set(key, merged);
              }
          }
      });
      set({ tagMap: newMap });
  },

  openOverlay: (slug, type, layoutId, imageSrc, overrideUrl, preloadedData) => {
    const currentState = get();
    const currentPath = typeof window !== 'undefined' ? window.location.pathname : '/';
    const scrollY = !currentState.isOverlayOpen && typeof window !== 'undefined' ? window.scrollY : currentState.savedScrollPosition;
    
    // Normalize slug for lookup
    const lookupSlug = normalizeKey(slug);
    
    // Optimistic Seeding
    if (type === 'creators' && preloadedData) {
        const { creatorMap } = currentState;
        if (!creatorMap.has(lookupSlug)) {
             const newMap = new Map(creatorMap);
             newMap.set(lookupSlug, { username: slug, ...preloadedData, contentLoaded: false });
             set({ creatorMap: newMap });
        }
    }
    
    if (type === 'tags') {
        const { tagMap } = currentState;
        if (!tagMap.has(lookupSlug)) {
            const newMap = new Map(tagMap);
            newMap.set(lookupSlug, { slug: slug, title: slug, contentLoaded: false });
            set({ tagMap: newMap });
        }
    }

    let targetUrl = overrideUrl;
    if (!targetUrl) {
        if (type === 'creators') targetUrl = `/creators/${slug}`;
        else if (type === 'tags') targetUrl = `/tags/${slug}`;
        else targetUrl = `/${type}/${slug}`;
    }
    
    if (typeof window !== 'undefined') window.history.pushState({ overlay: true, slug, type }, '', targetUrl);

    set({ 
        isOverlayOpen: true, 
        activeSlug: lookupSlug, // Store normalized key
        activeType: type, 
        indexSection: null,
        sourceLayoutId: layoutId || null, 
        activeImageSrc: imageSrc || null, 
        savedScrollPosition: scrollY,
        previousPath: currentState.isOverlayOpen ? currentState.previousPath : currentPath
    });
  },

  openIndexOverlay: (section) => {
      const currentState = get();
      const currentPath = typeof window !== 'undefined' ? window.location.pathname : '/';
      const scrollY = !currentState.isOverlayOpen && typeof window !== 'undefined' ? window.scrollY : currentState.savedScrollPosition;
      if (typeof window !== 'undefined') window.history.pushState({ overlay: true, type: 'index', section }, '', `/${section}`);
      set({
          isOverlayOpen: true, activeSlug: null, activeType: 'index', indexSection: section,
          sourceLayoutId: null, activeImageSrc: null, savedScrollPosition: scrollY,
          previousPath: currentState.isOverlayOpen ? currentState.previousPath : currentPath
      });
  },

  navigateInternal: (slug, type) => {
      set({
          isOverlayOpen: true, activeSlug: normalizeKey(slug), activeType: type as any,
          indexSection: type === 'index' ? slug as any : null,
          sourceLayoutId: null, activeImageSrc: null
      });
  },

  closeOverlay: () => {
    const { previousPath } = get();
    if (typeof window !== 'undefined' && previousPath) {
        window.history.replaceState(null, '', previousPath);
    }
    set({ isOverlayOpen: false, activeSlug: null, activeType: null, indexSection: null, sourceLayoutId: null, activeImageSrc: null, previousPath: null });
  },

  forceCloseOverlay: () => {
      set({ isOverlayOpen: false, activeSlug: null, activeType: null, indexSection: null, sourceLayoutId: null, activeImageSrc: null, previousPath: null });
  },

  fetchLinkedContent: async (slug: string) => {
      const key = normalizeKey(slug);
      const { contentMap, pendingFetches } = get();
      
      if (pendingFetches.has(key)) return; // Lock check
      
      const item = contentMap.get(key);
      if (item && item.contentLoaded) return;
      
      set(state => ({ pendingFetches: new Set(state.pendingFetches).add(key) }));
      
      try {
          const fullGameData = await fetchGameHubDataAction(slug); // Original slug for API
          if (fullGameData) {
              const newMap = new Map(get().contentMap);
              const updatedItem = {
                  ...item,
                  ...fullGameData,
                  linkedContent: fullGameData.items, 
                  contentLoaded: true
              };
              newMap.set(key, updatedItem);
              set({ contentMap: newMap });
          }
      } catch (e) { 
          console.error("Failed to fetch linked content", e); 
      } finally {
          set(state => {
              const next = new Set(state.pendingFetches);
              next.delete(key);
              return { pendingFetches: next };
          });
      }
  },

  fetchCreatorContent: async (slug: string, creatorId: string) => {
      const key = normalizeKey(slug);
      const { creatorMap, pendingFetches } = get();
      
      if (pendingFetches.has(key)) return;

      const creator = creatorMap.get(key);
      if (creator && creator.contentLoaded) return;
      
      set(state => ({ pendingFetches: new Set(state.pendingFetches).add(key) }));
      
      try {
           const enrichedContent = await fetchCreatorContentAction(creatorId);
           const existingContent = creator?.linkedContent || [];
           const newContent = [...existingContent, ...enrichedContent];
           const uniqueContent = Array.from(new Map(newContent.map((i: any) => [i._id, i])).values());
           uniqueContent.sort((a: any, b: any) => new Date(b.publishedAt).getTime() - new Date(a.publishedAt).getTime());

           const updatedCreator = { ...creator, linkedContent: uniqueContent, contentLoaded: true };
           const newMap = new Map(get().creatorMap);
           
           if (updatedCreator.username) newMap.set(normalizeKey(updatedCreator.username), updatedCreator);
           if (updatedCreator._id) newMap.set(updatedCreator._id, updatedCreator);
           if (updatedCreator.prismaUserId) newMap.set(updatedCreator.prismaUserId, updatedCreator);
           
           set({ creatorMap: newMap });
      } catch (e) { 
          console.error("Failed to fetch creator content", e); 
      } finally {
          set(state => {
              const next = new Set(state.pendingFetches);
              next.delete(key);
              return { pendingFetches: next };
          });
      }
  },

  fetchTagContent: async (slug: string) => {
      const key = normalizeKey(slug);
      const { tagMap, pendingFetches } = get();
      
      if (pendingFetches.has(key)) return;

      const tag = tagMap.get(key);
      if (tag && tag.contentLoaded) return;

      set(state => ({ pendingFetches: new Set(state.pendingFetches).add(key) }));

      try {
          const updatedTagData = await fetchTagContentAction(slug);
          if (updatedTagData) {
              const newMap = new Map(get().tagMap);
              const merged = tag ? { ...tag, ...updatedTagData, contentLoaded: true } : { ...updatedTagData, contentLoaded: true };
              newMap.set(key, merged);
              set({ tagMap: newMap });
          }
      } catch (e) { 
          console.error("Failed to fetch tag content", e); 
      } finally {
          set(state => {
              const next = new Set(state.pendingFetches);
              next.delete(key);
              return { pendingFetches: next };
          });
      }
  },

  fetchFullContent: async (slug: string) => {
      const key = normalizeKey(slug);
      const { contentMap, pendingFetches } = get();
      
      if (pendingFetches.has(key)) return;

      const item = contentMap.get(key);
      if (item && item.contentLoaded) return; 
      
      set(state => ({ pendingFetches: new Set(state.pendingFetches).add(key) }));
      
      try {
          const fullItem = await fetchSingleContentAction(slug);
          if (fullItem) {
               const newMap = new Map(get().contentMap);
               newMap.set(key, { ...item, ...fullItem, contentLoaded: true });
               set({ contentMap: newMap });
          }
      } catch (e) { 
          console.error("Failed to fetch full content", e); 
      } finally {
          set(state => {
              const next = new Set(state.pendingFetches);
              next.delete(key);
              return { pendingFetches: next };
          });
      }
  },

  fetchCreatorByUsername: async (username: string) => {
      const key = normalizeKey(username);
      const { creatorMap, hydrateCreators, pendingFetches } = get();
      
      if (pendingFetches.has(key)) return;
      if (creatorMap.has(key) && creatorMap.get(key).contentLoaded) return;
      
      set(state => ({ pendingFetches: new Set(state.pendingFetches).add(key) }));
      
      try {
          const creatorData = await fetchCreatorByUsernameAction(username);
          if (creatorData) { hydrateCreators([creatorData]); }
      } catch (e) { 
          console.error("Failed to fetch creator by username", e); 
      } finally {
          set(state => {
              const next = new Set(state.pendingFetches);
              next.delete(key);
              return { pendingFetches: next };
          });
      }
  },
}));

--- END OF FILE lib/contentStore.ts ---

================================================================================

--- START OF FILE lib/countries.ts ---

// lib/countries.ts

export const countries: string[] = [
  'Afghanistan', 'Albania', 'Algeria', 'Andorra', 'Angola', 'Antigua and Barbuda', 'Argentina', 'Armenia', 'Australia', 'Austria',
  'Azerbaijan', 'Bahamas', 'Bahrain', 'Bangladesh', 'Barbados', 'Belarus', 'Belgium', 'Belize', 'Benin', 'Bhutan',
  'Bolivia', 'Bosnia and Herzegovina', 'Botswana', 'Brazil', 'Brunei', 'Bulgaria', 'Burkina Faso', 'Burundi', 'Cabo Verde', 'Cambodia',
  'Cameroon', 'Canada', 'Central African Republic', 'Chad', 'Chile', 'China', 'Colombia', 'Comoros', 'Congo, Democratic Republic of the', 'Congo, Republic of the',
  'Costa Rica', 'Cote d\'Ivoire', 'Croatia', 'Cuba', 'Cyprus', 'Czech Republic', 'Denmark', 'Djibouti', 'Dominica', 'Dominican Republic',
  'Ecuador', 'Egypt', 'El Salvador', 'Equatorial Guinea', 'Eritrea', 'Estonia', 'Eswatini', 'Ethiopia', 'Fiji', 'Finland',
  'France', 'Gabon', 'Gambia', 'Georgia', 'Germany', 'Ghana', 'Greece', 'Grenada', 'Guatemala', 'Guinea',
  'Guinea-Bissau', 'Guyana', 'Haiti', 'Honduras', 'Hungary', 'Iceland', 'India', 'Indonesia', 'Iran', 'Iraq',
  'Ireland', 'Israel', 'Italy', 'Jamaica', 'Japan', 'Jordan', 'Kazakhstan', 'Kenya', 'Kiribati', 'Kuwait',
  'Kyrgyzstan', 'Laos', 'Latvia', 'Lebanon', 'Lesotho', 'Liberia', 'Libya', 'Liechtenstein', 'Lithuania', 'Luxembourg',
  'Madagascar', 'Malawi', 'Malaysia', 'Maldives', 'Mali', 'Malta', 'Marshall Islands', 'Mauritania', 'Mauritius', 'Mexico',
  'Micronesia', 'Moldova', 'Monaco', 'Mongolia', 'Montenegro', 'Morocco', 'Mozambique', 'Myanmar', 'Namibia', 'Nauru',
  'Nepal', 'Netherlands', 'New Zealand', 'Nicaragua', 'Niger', 'Nigeria', 'North Korea', 'North Macedonia', 'Norway', 'Oman',
  'Pakistan', 'Palau', 'Palestine State', 'Panama', 'Papua New Guinea', 'Paraguay', 'Peru', 'Philippines', 'Poland', 'Portugal',
  'Qatar', 'Romania', 'Russia', 'Rwanda', 'Saint Kitts and Nevis', 'Saint Lucia', 'Saint Vincent and the Grenadines', 'Samoa', 'San Marino', 'Sao Tome and Principe',
  'Saudi Arabia', 'Senegal', 'Serbia', 'Seychelles', 'Sierra Leone', 'Singapore', 'Slovakia', 'Slovenia', 'Solomon Islands', 'Somalia',
  'South Africa', 'South Korea', 'South Sudan', 'Spain', 'Sri Lanka', 'Sudan', 'Suriname', 'Sweden', 'Switzerland', 'Syria',
  'Taiwan', 'Tajikistan', 'Tanzania', 'Thailand', 'Timor-Leste', 'Togo', 'Tonga', 'Trinidad and Tobago', 'Tunisia', 'Turkey',
  'Turkmenistan', 'Tuvalu', 'Uganda', 'Ukraine', 'United Arab Emirates', 'United Kingdom', 'United States of America', 'Uruguay', 'Uzbekistan', 'Vanuatu',
  'Vatican City', 'Venezuela', 'Vietnam', 'Yemen', 'Zambia', 'Zimbabwe'
];










--- END OF FILE lib/countries.ts ---

================================================================================

--- START OF FILE lib/editorStore.ts ---

// lib/editorStore.ts
import { create } from 'zustand';
import { UploadQuality } from '@/lib/image-optimizer';

interface EditorState {
  isEditorActive: boolean;
  liveUrl: string | null;
  blockUploadQuality: UploadQuality;
  setEditorActive: (isActive: boolean) => void;
  setLiveUrl: (url: string | null) => void;
  setBlockUploadQuality: (quality: UploadQuality) => void;
}

export const useEditorStore = create<EditorState>((set) => ({
  isEditorActive: false,
  liveUrl: null,
  blockUploadQuality: '1080p',
  setEditorActive: (isActive) => set({ isEditorActive: isActive }),
  setLiveUrl: (url) => set({ liveUrl: url }),
  setBlockUploadQuality: (quality) => set({ blockUploadQuality: quality }),
}));




--- END OF FILE lib/editorStore.ts ---

================================================================================

--- START OF FILE lib/enrichment.ts ---

// lib/enrichment.ts
import prisma from '@/lib/prisma';
import { SanityAuthor } from '@/types/sanity';

// REMOVED: unstable_cache entirely.
// Direct DB lookup for IDs is highly optimized and prevents cache explosion
// caused by storing every permutation of creator IDs.
export async function getCachedEnrichedCreators(creatorIds: string[]): Promise<[string, string | null][]> {
    if (!creatorIds || creatorIds.length === 0) return [];
    
    try {
        const users = await prisma.user.findMany({
            where: { id: { in: creatorIds } },
            select: { id: true, username: true },
        });
        
        return users.map((u: any) => [u.id, u.username || null]);
    } catch (error) {
        console.warn(`[Enrichment] Database connection failed during creator lookup.`, error);
        return [];
    }
}

function enrichItemCreators(creators: SanityAuthor[] | undefined, usernameMap: Map<string, string | null>): SanityAuthor[] {
    if (!creators || creators.length === 0) return [];
    return creators.map(creator => ({
        ...creator,
        username: (creator.prismaUserId && usernameMap.get(creator.prismaUserId)) || creator.username || null,
    }));
}

// Helper to collect IDs from a single item
function collectUserIdsFromItem(item: any, idSet: Set<string>) {
    item.authors?.forEach((c: any) => c.prismaUserId && idSet.add(c.prismaUserId));
    item.reporters?.forEach((c: any) => c.prismaUserId && idSet.add(c.prismaUserId));
    item.designers?.forEach((c: any) => c.prismaUserId && idSet.add(c.prismaUserId));
}

// Helper to apply enrichment to a single item
function applyEnrichmentToItem(item: any, usernameMap: Map<string, string | null>) {
    const newItem = { ...item };
    if (newItem.authors) newItem.authors = enrichItemCreators(newItem.authors, usernameMap);
    if (newItem.reporters) newItem.reporters = enrichItemCreators(newItem.reporters, usernameMap);
    if (newItem.designers) newItem.designers = enrichItemCreators(newItem.designers, usernameMap);
    return newItem;
}

export async function enrichContentList(items: any[]) {
    if (!items || items.length === 0) return [];
    
    const allUserIds = new Set<string>();
    
    // 1. Collect IDs from main items AND nested related content
    items.forEach(item => {
        collectUserIdsFromItem(item, allUserIds);

        // Recursively check related arrays
        if (item.relatedReviews) item.relatedReviews.forEach((r: any) => collectUserIdsFromItem(r, allUserIds));
        if (item.relatedArticles) item.relatedArticles.forEach((a: any) => collectUserIdsFromItem(a, allUserIds));
        if (item.relatedNews) item.relatedNews.forEach((n: any) => collectUserIdsFromItem(n, allUserIds));
    });

    if (allUserIds.size === 0) {
        return items;
    }

    const uniqueIdsArray = Array.from(allUserIds).sort();
    
    // Direct DB call now
    const usernameEntries = await getCachedEnrichedCreators(uniqueIdsArray);
    const usernameMap = new Map(usernameEntries);

    // 2. Map usernames back to items AND nested related content
    return items.map(item => {
        let enrichedItem = applyEnrichmentToItem(item, usernameMap);

        if (enrichedItem.relatedReviews) {
            enrichedItem.relatedReviews = enrichedItem.relatedReviews.map((r: any) => applyEnrichmentToItem(r, usernameMap));
        }
        if (enrichedItem.relatedArticles) {
            enrichedItem.relatedArticles = enrichedItem.relatedArticles.map((a: any) => applyEnrichmentToItem(a, usernameMap));
        }
        if (enrichedItem.relatedNews) {
            enrichedItem.relatedNews = enrichedItem.relatedNews.map((n: any) => applyEnrichmentToItem(n, usernameMap));
        }

        return enrichedItem;
    });
}

export async function enrichCreators(creators: SanityAuthor[] | undefined): Promise<SanityAuthor[]> {
    if (!creators || creators.length === 0) return [];
    
    const userIds = creators.map(c => c.prismaUserId).filter(Boolean).sort();
    
    if (userIds.length === 0) return creators;
    
    const usernameArray = await getCachedEnrichedCreators(userIds);
    const usernameMap = new Map(usernameArray);
    return enrichItemCreators(creators, usernameMap);
}

--- END OF FILE lib/enrichment.ts ---

================================================================================

--- START OF FILE lib/gtm.ts ---

// lib/gtm.ts
export const GA_TRACKING_ID = process.env.NEXT_PUBLIC_GOOGLE_ANALYTICS_ID || '';

export const pageview = (url: string) => {
  if (typeof window.gtag !== 'undefined') {
    window.gtag('config', GA_TRACKING_ID, {
      page_path: url,
    });
  }
};

type GTagEvent = {
  action: string;
  category: string;
  label: string;
  value: number;
};

export const event = ({ action, category, label, value }: GTagEvent) => {
  if (typeof window.gtag !== 'undefined') {
    window.gtag('event', action, {
      event_category: category,
      event_label: label,
      value: value,
    });
  }
};

// UPDATED: Now supports granular consent object
export const setConsent = (consent: { analytics: boolean; marketing: boolean }) => {
    if (typeof window.gtag !== 'undefined') {
        window.gtag('consent', 'update', {
            analytics_storage: consent.analytics ? 'granted' : 'denied',
            ad_storage: consent.marketing ? 'granted' : 'denied',
            ad_user_data: consent.marketing ? 'granted' : 'denied',
            ad_personalization: consent.marketing ? 'granted' : 'denied',
        });
    }
};

--- END OF FILE lib/gtm.ts ---

================================================================================

--- START OF FILE lib/image-export.ts ---

// lib/image-export.ts

/**
 * Loads local font files, converts them to Base64, and generates the @font-face CSS.
 * This ensures the exact font file (with all Arabic glyphs) is embedded in the SVG.
 */
async function getFontStyles() {
    // List of fonts to embed. 
    // Ensure these files exist in your /public/fonts/ folder.
    const fonts = [
        { family: 'Cairo', weight: '400', src: '/fonts/Cairo-Regular.ttf' },
        { family: 'Cairo', weight: '500', src: '/fonts/Cairo-Medium.ttf' },
        { family: 'Cairo', weight: '700', src: '/fonts/Cairo-Bold.ttf' },
        { family: 'Cairo', weight: '900', src: '/fonts/Cairo-Black.ttf' },
        // Add Dystopian with unicode range logic in CSS below
        { family: 'Dystopian', weight: '400', src: '/fonts/SDDystopianFull.ttf' },
    ];

    let css = '';

    for (const font of fonts) {
        try {
            // Fetch the local file
            // Note: In Next.js, fetching from the public folder via URL works relative to the domain
            const response = await fetch(font.src);
            if (!response.ok) throw new Error(`Failed to load ${font.src}`);
            
            const blob = await response.blob();
            
            // Convert to Base64
            const base64 = await new Promise<string>((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result as string);
                reader.readAsDataURL(blob);
            });

            // Generate CSS Rule
            if (font.family === 'Dystopian') {
                 // Special handling for Dystopian with Unicode Range
                 css += `
                    @font-face {
                        font-family: '${font.family}';
                        font-style: normal;
                        font-weight: ${font.weight};
                        src: url(${base64}) format('truetype');
                        unicode-range: U+002E, U+0030-003A, U+0041-005A, U+0061-007A;
                    }
                `;
            } else {
                // Default handling for Cairo
                css += `
                    @font-face {
                        font-family: '${font.family}';
                        font-style: normal;
                        font-weight: ${font.weight};
                        src: url(${base64}) format('truetype');
                    }
                `;
            }

            // --- ALIASING ---
            // Map 'Anton' (Impact-style) to Cairo-Black for consistency if Arabic is used there
            if (font.weight === '900') {
                css += `
                    @font-face {
                        font-family: 'Anton';
                        font-style: normal;
                        font-weight: 400; 
                        src: url(${base64}) format('truetype');
                    }
                    @font-face {
                        font-family: 'Impact';
                        font-style: normal;
                        font-weight: 400; 
                        src: url(${base64}) format('truetype');
                    }
                `;
            }

            // Map 'Roboto'/'Arial' to Cairo-Regular/Bold to ensure Arabic glyphs render 
            // even if the template requested a Latin font
            if (['400', '700'].includes(font.weight)) {
                css += `
                    @font-face {
                        font-family: 'Arial';
                        font-style: normal;
                        font-weight: ${font.weight};
                        src: url(${base64}) format('truetype');
                    }
                    @font-face {
                        font-family: 'Roboto';
                        font-style: normal;
                        font-weight: ${font.weight};
                        src: url(${base64}) format('truetype');
                    }
                `;
            }

        } catch (error) {
            console.error(`Error embedding font ${font.src}:`, error);
        }
    }

    return css;
}

export async function downloadElementAsImage(
    elementId: string, 
    fileName: string, 
    format: 'png' | 'jpeg' = 'jpeg', 
    scale: number = 2, 
    quality: number = 0.9 
) {
    const element = document.getElementById(elementId);
    if (!element) return;

    // Clone the element to manipulate it safely
    const clone = element.cloneNode(true) as HTMLElement;
    const svg = clone.querySelector('svg');
    if (!svg) return;

    // 1. Pre-process Images (Convert external hrefs to Base64)
    const images = svg.querySelectorAll('image');
    for (const img of Array.from(images)) {
        const href = img.getAttribute('href');
        if (href && !href.startsWith('data:')) {
            try {
                const response = await fetch(href);
                const blob = await response.blob();
                const base64 = await new Promise<string>((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result as string);
                    reader.readAsDataURL(blob);
                });
                img.setAttribute('href', base64);
            } catch (err) {
                console.warn('Failed to convert image for export:', err);
            }
        }
    }

    // 2. Inject Local Fonts
    const fontStyles = await getFontStyles();
    
    // Critical Styles to force Font Stack
    // Uses the new Dystopian -> Cairo cascade
    const criticalStyles = `
        text, input, div, span, p, foreignObject { 
            font-family: 'Dystopian', 'Cairo', sans-serif !important; 
        } 
        .social-editor-content p { margin: 0 !important; }
        .variant-hero p { margin: 0; font-size: 0.55em !important; color: #00FFF0 !important; line-height: 1.4 !important; font-weight: 700; }
        .variant-hero p::first-line { font-size: 1.81em !important; color: #FFFFFF !important; line-height: 1.1 !important; font-weight: 900; }
        .variant-card p { margin: 0; font-size: 0.85em !important; color: #FFFFFF !important; opacity: 0.9; font-weight: 500; line-height: 1.3 !important; }
        .variant-card p::first-line { font-size: 1.17em !important; color: #FFFFFF !important; opacity: 1; font-weight: 700; line-height: 1.2 !important; }
    `;
    
    let styleTag = svg.querySelector('style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        svg.prepend(styleTag);
    }
    styleTag.textContent = (styleTag.textContent || '') + criticalStyles + (fontStyles || '');

    // 3. Serialize and Draw
    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(svg);
    
    const baseWidth = 1080; 
    const baseHeight = 1350;
    const width = baseWidth * scale;
    const height = baseHeight * scale;
    
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');

    if (!ctx) return;

    const img = new Image();
    const svgBase64 = window.btoa(unescape(encodeURIComponent(svgString)));
    img.src = `data:image/svg+xml;base64,${svgBase64}`;

    return new Promise<void>((resolve, reject) => {
        img.onload = () => {
            if (format === 'jpeg') {
                ctx.fillStyle = '#050505'; 
                ctx.fillRect(0, 0, width, height);
            }
            ctx.drawImage(img, 0, 0, width, height);
            
            canvas.toBlob((blob) => {
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${fileName}.${format}`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    resolve();
                } else {
                    reject(new Error('Canvas conversion failed'));
                }
            }, `image/${format}`, quality);
        };
        img.onerror = (e) => reject(e);
    });
}

--- END OF FILE lib/image-export.ts ---

================================================================================

--- START OF FILE lib/image-optimizer.ts ---

// lib/image-optimizer.ts

export type UploadQuality = '1080p' | '4k' | '8k';

const RESOLUTIONS: Record<UploadQuality, { width: number; height: number }> = {
    '1080p': { width: 1920, height: 1080 },
    '4k': { width: 3840, height: 2160 },
    '8k': { width: 7680, height: 4320 },
};

const MAX_UPLOAD_SIZE_BYTES = 4.5 * 1024 * 1024; // 4.5MB Target, aligned with Vercel's Pro plan body limit
const MAX_INITIAL_FILE_SIZE_BYTES = 25 * 1024 * 1024; // 25MB Hard Limit for initial file read

/**
 * A robust, goal-oriented image optimizer.
 * It guarantees the output file will be under MAX_UPLOAD_SIZE_BYTES, or it will fail with a clear error.
 * THE FIX: Returns an object with the file and the final quality setting.
 */
export function optimizeImageForUpload(file: File, quality: UploadQuality): Promise<{ file: File; finalQuality: number; }> {
  return new Promise((resolve, reject) => {
    if (file.size > MAX_INITIAL_FILE_SIZE_BYTES) {
        return reject(new Error(`حجم الملف يتجاوز الحد الأقصى (25MB).`));
    }
    if (!file.type.startsWith('image/')) {
        return reject(new Error("الملف ليس صورة صالحة."));
    }

    const resolution = RESOLUTIONS[quality];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target?.result as string;
      img.onload = () => {
        if (!img.width || !img.height) {
            return reject(new Error("تعذر قراءة أبعاد الصورة. قد يكون الملف تالفًا."));
        }

        let { width, height } = img;
        const aspectRatio = width / height;

        if (img.width > resolution.width || img.height > resolution.height) {
            const widthRatio = resolution.width / img.width;
            const heightRatio = resolution.height / img.height;
            const ratio = Math.min(widthRatio, heightRatio);
            width = Math.round(img.width * ratio);
            height = Math.round(img.height * ratio);
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return reject(new Error('لا يمكن إنشاء سياق الكانفاس.'));

        ctx.drawImage(img, 0, 0, width, height);
        
        let currentQuality = 0.92;
        
        const attemptCompression = () => {
            canvas.toBlob(
              (blob) => {
                if (!blob) return reject(new Error('فشل تحويل الكانفاس إلى Blob.'));
                
                if (blob.size > MAX_UPLOAD_SIZE_BYTES && currentQuality > 0.5) {
                    currentQuality -= 0.08;
                    attemptCompression();
                } else {
                    if (blob.size > MAX_UPLOAD_SIZE_BYTES) {
                        reject(new Error("تعذر ضغط الصورة إلى حجم مقبول (<4.5MB). الرجاء اختيار جودة أقل أو استخدم صورة مختلفة."));
                    } else {
                        const newFileName = file.name.replace(/\.[^/.]+$/, ".jpg");
                        const optimizedFile = new File([blob], newFileName, { type: 'image/jpeg', lastModified: Date.now() });
                        // THE FIX: Resolve with the object containing file and quality
                        resolve({ file: optimizedFile, finalQuality: currentQuality });
                    }
                }
              }, 'image/jpeg', currentQuality );
        };

        attemptCompression();
      };
      img.onerror = () => reject(new Error("تعذر تحميل الصورة. قد يكون الملف تالفًا أو غير مدعوم."));
    };
    reader.onerror = () => reject(new Error("فشل قراءة الملف."));
  });
}







--- END OF FILE lib/image-optimizer.ts ---

================================================================================

--- START OF FILE lib/layoutIdStore.ts ---

// lib/layoutIdStore.ts
import { create } from 'zustand';

interface LayoutIdState {
    prefix: string;
    setPrefix: (prefix: string) => void;
}

export const useLayoutIdStore = create<LayoutIdState>((set) => ({
    prefix: 'default',
    setPrefix: (prefix) => set({ prefix }),
}));










--- END OF FILE lib/layoutIdStore.ts ---

================================================================================

--- START OF FILE lib/layoutUtils.ts ---

// lib/layoutUtils.ts

export const generateLayoutId = (prefix: string | null | undefined, type: 'container' | 'image' | 'title', id: number | string): string | undefined => {
    // If no prefix (e.g. standard navigation), return undefined to disable transition
    if (!prefix || prefix === 'default') return undefined;

    return `${prefix}-card-${type}-${id}`;
};

--- END OF FILE lib/layoutUtils.ts ---

================================================================================

--- START OF FILE lib/lightboxStore.ts ---

// lib/lightboxStore.ts
import { create } from 'zustand';

interface LightboxState {
  isOpen: boolean;
  imageUrls: string[];
  currentIndex: number;
  openLightbox: (urls: string[], startIndex: number) => void;
  closeLightbox: () => void;
  goToNext: () => void;
  goToPrevious: () => void;
}

export const useLightboxStore = create<LightboxState>((set, get) => ({
  isOpen: false,
  imageUrls: [],
  currentIndex: 0,
  openLightbox: (urls, startIndex = 0) => set({ 
    isOpen: true, 
    imageUrls: urls,
    currentIndex: startIndex 
  }),
  closeLightbox: () => set({ 
    isOpen: false, 
    imageUrls: [], 
    currentIndex: 0 
  }),
  goToNext: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const nextIndex = (currentIndex + 1) % imageUrls.length;
      set({ currentIndex: nextIndex });
    }
  },
  goToPrevious: () => {
    const { imageUrls, currentIndex } = get();
    if (imageUrls.length > 1) {
      const prevIndex = (currentIndex - 1 + imageUrls.length) % imageUrls.length;
      set({ currentIndex: prevIndex });
    }
  },
}));







--- END OF FILE lib/lightboxStore.ts ---

================================================================================

--- START OF FILE lib/notificationStore.ts ---

// lib/notificationStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
// Removed import of getNotifications action

interface NotificationState {
    notifications: any[];
    unreadCount: number;
    isFetching: boolean;
    lastFetched: number;
    fetchNotifications: (force?: boolean) => Promise<void>;
    setUnreadCount: (count: number | ((prev: number) => number)) => void;
    setNotifications: (notifs: any[] | ((prev: any[]) => any[])) => void;
}

export const useNotificationStore = create<NotificationState>()(
    persist(
        (set, get) => ({
            notifications: [],
            unreadCount: 0,
            isFetching: false,
            lastFetched: 0,

            fetchNotifications: async (force = false) => {
                const { isFetching, lastFetched, notifications } = get();
                const now = Date.now();
                
                // Cache policy: 15 minutes
                const STALE_TIME = 15 * 60 * 1000; 
                const isFresh = (now - lastFetched < STALE_TIME);
                const hasData = notifications.length > 0;

                if (isFetching) return;
                if (!force && hasData && isFresh) return;

                set({ isFetching: true });
                try {
                    // UPDATED: Fetch from dedicated API route instead of Server Action
                    const res = await fetch('/api/notifications');
                    const result = await res.json();
                    
                    if (result.success) {
                        set({
                            notifications: result.notifications || [],
                            unreadCount: result.unreadCount || 0,
                            lastFetched: Date.now()
                        });
                    }
                } catch (error) {
                    console.error("Failed to fetch notifications");
                } finally {
                    set({ isFetching: false });
                }
            },

            setUnreadCount: (updater) => set(state => ({
                unreadCount: typeof updater === 'function' ? updater(state.unreadCount) : updater
            })),
            setNotifications: (updater) => set(state => ({
                notifications: typeof updater === 'function' ? updater(state.notifications) : updater
            }))
        }),
        {
            name: 'eternalgames-notifications-v1', 
            partialize: (state) => ({ 
                notifications: state.notifications, 
                unreadCount: state.unreadCount, 
                lastFetched: state.lastFetched 
            }),
        }
    )
);




--- END OF FILE lib/notificationStore.ts ---

================================================================================

--- START OF FILE lib/performanceStore.ts ---

// lib/performanceStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

export type PerformanceTier = 0 | 1 | 2 | 3 | 4 | 5 | 6;

interface PerformanceState {
  // Toggles
  isLivingCardEnabled: boolean;
  isFlyingTagsEnabled: boolean;
  isHeroTransitionEnabled: boolean;
  isCornerAnimationEnabled: boolean;
  isHoverDebounceEnabled: boolean;
  isCarouselAutoScrollEnabled: boolean;
  isSmoothScrollingEnabled: boolean; 
  
  // Background
  isBackgroundAnimated: boolean;
  isBackgroundVisible: boolean;

  // Rendering
  isGlassmorphismEnabled: boolean;
  
  // Automation
  isAutoTuningEnabled: boolean;

  // Actions
  toggleLivingCard: () => void;
  toggleFlyingTags: () => void;
  toggleHeroTransition: () => void;
  toggleCornerAnimation: () => void;
  toggleHoverDebounce: () => void;
  toggleCarouselAutoScroll: () => void;
  toggleSmoothScrolling: () => void; 
  
  toggleBackgroundAnimation: () => void;
  toggleBackgroundVisibility: () => void;
  toggleGlassmorphism: () => void;
  
  toggleAutoTuning: () => void;
  
  setPerformanceTier: (tier: PerformanceTier) => void;
}

export const usePerformanceStore = create<PerformanceState>()(
  persist(
    (set) => ({
      // --- DEFAULTS ---
      isLivingCardEnabled: true,
      isFlyingTagsEnabled: true,
      isHeroTransitionEnabled: true, // ENABLED DEFAULT
      isCornerAnimationEnabled: true,
      isGlassmorphismEnabled: true,
      isHoverDebounceEnabled: true,
      isCarouselAutoScrollEnabled: true,
      isSmoothScrollingEnabled: false, 
      
      isBackgroundVisible: true,
      isBackgroundAnimated: false, 
      isAutoTuningEnabled: true,

      toggleLivingCard: () => set((state) => ({ isLivingCardEnabled: !state.isLivingCardEnabled, isAutoTuningEnabled: false })),
      toggleFlyingTags: () => set((state) => ({ isFlyingTagsEnabled: !state.isFlyingTagsEnabled, isAutoTuningEnabled: false })),
      toggleHeroTransition: () => set((state) => ({ isHeroTransitionEnabled: !state.isHeroTransitionEnabled, isAutoTuningEnabled: false })), 
      toggleCornerAnimation: () => set((state) => ({ isCornerAnimationEnabled: !state.isCornerAnimationEnabled, isAutoTuningEnabled: false })),
      toggleHoverDebounce: () => set((state) => ({ isHoverDebounceEnabled: !state.isHoverDebounceEnabled, isAutoTuningEnabled: false })),
      toggleCarouselAutoScroll: () => set((state) => ({ isCarouselAutoScrollEnabled: !state.isCarouselAutoScrollEnabled, isAutoTuningEnabled: false })),
      
      toggleSmoothScrolling: () => set((state) => ({ isSmoothScrollingEnabled: !state.isSmoothScrollingEnabled })), 
      
      toggleBackgroundAnimation: () => set((state) => ({ isBackgroundAnimated: !state.isBackgroundAnimated, isAutoTuningEnabled: false })),
      toggleBackgroundVisibility: () => set((state) => ({ isBackgroundVisible: !state.isBackgroundVisible, isAutoTuningEnabled: false })),
      toggleGlassmorphism: () => set((state) => ({ isGlassmorphismEnabled: !state.isGlassmorphismEnabled, isAutoTuningEnabled: false })),
      
      toggleAutoTuning: () => set((state) => ({ isAutoTuningEnabled: !state.isAutoTuningEnabled })),

      setPerformanceTier: (tier: PerformanceTier) => set((state) => {
          switch (tier) {
              case 6: // ULTRA: Everything ON
                  return {
                      isGlassmorphismEnabled: true, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: true,
                      isFlyingTagsEnabled: true, 
                      isCornerAnimationEnabled: true, 
                      isHoverDebounceEnabled: false, 
                      isCarouselAutoScrollEnabled: true,
                      isHeroTransitionEnabled: true, // ENABLED
                  };
              case 5: // HIGH
                  return {
                      isGlassmorphismEnabled: true, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: true,
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: true, 
                      isHoverDebounceEnabled: false, 
                      isCarouselAutoScrollEnabled: true,
                      isHeroTransitionEnabled: false,
                  };
              case 4: // MEDIUM
                  return {
                      isGlassmorphismEnabled: false, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: true, 
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: true, 
                      isHoverDebounceEnabled: true, 
                      isCarouselAutoScrollEnabled: true,
                      isHeroTransitionEnabled: false,
                  };
              case 3: // LOW
                  return {
                      isGlassmorphismEnabled: false, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: false, 
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: false, 
                      isHoverDebounceEnabled: true, 
                      isCarouselAutoScrollEnabled: true,
                      isHeroTransitionEnabled: false,
                  };
              case 2: // MINIMAL
                  return {
                      isGlassmorphismEnabled: false, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: false, 
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: false, 
                      isHoverDebounceEnabled: true, 
                      isCarouselAutoScrollEnabled: false, 
                      isHeroTransitionEnabled: false,
                  };
              case 1: // POTATO
                  return {
                      isGlassmorphismEnabled: false, 
                      isBackgroundVisible: true, 
                      isLivingCardEnabled: false, 
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: false, 
                      isHoverDebounceEnabled: true, 
                      isCarouselAutoScrollEnabled: false, 
                      isHeroTransitionEnabled: false,
                  };
              case 0: // ABYSSAL
                  return {
                      isGlassmorphismEnabled: false, 
                      isBackgroundVisible: false, 
                      isLivingCardEnabled: false, 
                      isFlyingTagsEnabled: false, 
                      isCornerAnimationEnabled: false, 
                      isHoverDebounceEnabled: true, 
                      isCarouselAutoScrollEnabled: false, 
                      isHeroTransitionEnabled: false,
                  };
              default:
                  return state;
          }
      })
    }),
    {
      name: 'eternalgames-performance-settings',
      storage: createJSONStorage(() => localStorage),
      skipHydration: true,
    }
  )
);

--- END OF FILE lib/performanceStore.ts ---

================================================================================

--- START OF FILE lib/prisma.ts ---

// lib/prisma.ts
import { PrismaClient } from './generated/client'
import { Pool } from 'pg'
import { PrismaPg } from '@prisma/adapter-pg'

const prismaClientSingleton = () => {
    // Determine if we are using the pooled connection string
    const connectionString = process.env.DATABASE_URL

    if (!connectionString) {
        throw new Error('DATABASE_URL is not set in your environment variables')
    }

    const pool = new Pool({ 
        connectionString,
        max: 5, // REDUCE max connections to prevent exhaustion during dev
        idleTimeoutMillis: 10000, // Close idle clients faster
        connectionTimeoutMillis: 10000, // Fail fast if DB is sleeping
    })
    
    const adapter = new PrismaPg(pool)
    
    return new PrismaClient({ adapter })
}

declare global {
    var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma

--- END OF FILE lib/prisma.ts ---

================================================================================

--- START OF FILE lib/rate-limit.ts ---

// lib/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

// 1. Create the Redis connection
// This automatically looks for UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN
const redis = Redis.fromEnv();

const limiters = new Map<string, Ratelimit>();

const getLimiter = (limit: number, window: "10 s" | "60 s", prefix: string) => {
  const key = `${prefix}-${limit}`;
  
  if (!limiters.has(key)) {
    limiters.set(key, new Ratelimit({
      redis: redis, // <--- Using the native Redis client
      limiter: Ratelimit.slidingWindow(limit, window),
      prefix: key,
      analytics: true,
    }));
  }
  return limiters.get(key)!;
};

// 1. Standard Limiter (10s window)
export const standardLimiter = {
  check: async (identifier: string, limit: number = 10) => {
    try {
      const limiter = getLimiter(limit, "10 s", "@upstash/standard");
      const { success } = await limiter.limit(identifier);
      return { success };
    } catch (error) {
      console.error("Rate limit error:", error);
      return { success: true };
    }
  },
};

// 2. Sensitive Limiter (60s window)
export const sensitiveLimiter = {
  check: async (identifier: string, limit: number = 5) => {
    try {
      const limiter = getLimiter(limit, "60 s", "@upstash/sensitive");
      const { success } = await limiter.limit(identifier);
      return { success };
    } catch (error) {
      console.error("Rate limit error:", error);
      return { success: true };
    }
  },
};

--- END OF FILE lib/rate-limit.ts ---

================================================================================

--- START OF FILE lib/readingTime.ts ---

// lib/readingTime.ts

export function calculateReadingTime(text: string): number {
    if (!text) return 0;
    
    const wordsPerMinute = 200;
    // Strip HTML tags if any (though usually we pass plain text)
    const cleanText = text.replace(/<[^>]*>?/gm, '');
    const wordCount = cleanText.trim().split(/\s+/).length;
    const readingTime = Math.ceil(wordCount / wordsPerMinute);
    
    return readingTime;
}

/**
 * Extracts plain text from Portable Text blocks for analysis
 */
export function toPlainText(blocks: any[] = []): string {
    return blocks
      .map(block => {
        if (block._type !== 'block' || !block.children) {
          return ''
        }
        return block.children.map((child: any) => child.text).join('')
      })
      .join('\n\n')
}

--- END OF FILE lib/readingTime.ts ---

================================================================================

--- START OF FILE lib/rippleStore.ts ---

// lib/rippleStore.ts
import { create } from 'zustand';

type Ripple = {
  id: number;
  x: number;
  y: number;
};

interface RippleState {
  ripples: Ripple[];
  addRipple: (x: number, y: number) => void;
  removeRipple: (id: number) => void;
}

export const useRippleStore = create<RippleState>((set) => ({
  ripples: [],
  addRipple: (x, y) => {
    const newRipple = { id: Date.now(), x, y };
    set((state) => ({ ripples: [...state.ripples, newRipple] }));
  },
  removeRipple: (id) => {
    set((state) => ({ ripples: state.ripples.filter((r) => r.id !== id) }));
  },
}));







--- END OF FILE lib/rippleStore.ts ---

================================================================================

--- START OF FILE lib/sanity.client.ts ---

// lib/sanity.client.ts

import { createClient, type SanityClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

// FIX: Removed 'token'.
// Even with useCdn: true, providing a token forces the client to skip the CDN.
// We remove it to allow public, anonymous, cached access (Instant Speed).
export const client = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: true, 
    perspective: 'published',
})




--- END OF FILE lib/sanity.client.ts ---

================================================================================

--- START OF FILE lib/sanity.env.ts ---

// lib/sanity.env.ts

function assertValue<T>(v: T | undefined, errorMessage: string): T {
    if (v === undefined) {
        throw new Error(errorMessage)
    }
    return v
}

export const apiVersion = process.env.SANITY_API_VERSION || '2025-09-28'

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable, falling back to the server-only one.
// This makes the file safe for both client and server environments.
export const dataset = assertValue(
    process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_DATASET,
    'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_DATASET'
)

// MODIFIED: Prioritize the NEXT_PUBLIC_ variable for the project ID as well.
export const projectId = assertValue(
    process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_PROJECT_ID,
    'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_PROJECT_ID'
)




--- END OF FILE lib/sanity.env.ts ---

================================================================================

--- START OF FILE lib/sanity.fetch.ts ---

// lib/sanity.fetch.ts
import { cache } from 'react';
import { client } from './sanity.client';
import { 
    reviewBySlugQuery, 
    articleBySlugQuery, 
    newsBySlugQuery,
    tagPageDataQuery,
    gamePageDataQuery,
    colorDictionaryQuery,
    minimalMetadataQuery 
} from './sanity.queries';
import { groq } from 'next-sanity';

const queryMap: Record<string, string> = {
    review: reviewBySlugQuery,
    article: articleBySlugQuery,
    news: newsBySlugQuery,
};

export const getCachedMetadata = cache(async (slug: string) => {
    // Only depends on the specific slug
    return await client.fetch(minimalMetadataQuery, { slug }, {
        next: { tags: [slug] }
    });
});

export const getCachedDocument = cache(async (type: string, slug: string) => {
    const query = queryMap[type];
    if (!query) return null;

    // --- THE FIX ---
    // Removed 'content' tag. 
    // Removed 'type' tag (so publishing a NEW review doesn't kill OLD review pages).
    // Now depends ONLY on the specific slug. 
    // This page will NEVER rebuild unless THIS SPECIFIC DOCUMENT changes.
    return await client.fetch(query, { slug }, {
        next: { 
            tags: [slug] 
        } 
    });
});

export const getCachedTagPageData = cache(async (slug: string) => {
    return await client.fetch(tagPageDataQuery, { slug }, {
        next: { 
            // Depends on the tag itself, but also needs 'content' 
            // because if a NEW review is added with this tag, this page needs to update.
            tags: ['tag', slug, 'content'], 
        }
    });
});

export const getCachedGamePageData = cache(async (slug: string) => {
    return await client.fetch(gamePageDataQuery, { slug }, {
        next: { 
            // Depends on the game itself, and 'content' for new items linked to it.
            tags: ['game', slug, 'content'], 
        }
    });
});

export const getCachedColorDictionary = cache(async () => {
    return await client.fetch(colorDictionaryQuery, {}, {
        next: { tags: ['colorDictionary'] }
    });
});

export const getCachedContentAndDictionary = cache(async (type: string, slug: string) => {
    const docQuery = queryMap[type];
    if (!docQuery) return { item: null, dictionary: null };

    const combinedQuery = groq`{
        "item": ${docQuery},
        "dictionary": ${colorDictionaryQuery}
    }`;

    // --- THE FIX ---
    // Removed generic 'content' tag.
    // Preserved 'colorDictionary' so global color updates propagate.
    return await client.fetch(combinedQuery, { slug }, {
        next: { tags: [slug, 'colorDictionary'] }
    });
});

--- END OF FILE lib/sanity.fetch.ts ---

================================================================================

--- START OF FILE lib/sanity.loader.ts ---

// lib/sanity.loader.ts

interface SanityImageLoaderProps {
  src: string
  width: number
  quality?: number
}

export const sanityLoader = ({ src, width, quality }: SanityImageLoaderProps) => {
  try {

    const url = new URL(src, 'http://dummy-base.com')

    if (url.origin !== 'https://cdn.sanity.io') {

      const separator = src.includes('?') ? '&' : '?'
      return `${src}${separator}width=${width}`
    }

    const originalW = url.searchParams.get('w')
    const originalH = url.searchParams.get('h')

    url.searchParams.set('w', width.toString())
    
    if (quality) {
      url.searchParams.set('q', quality.toString())
    } else {
      url.searchParams.delete('q')
    }

    if (originalW && originalH) {
       const aspectRatio = parseInt(originalH, 10) / parseInt(originalW, 10)
       if (!isNaN(aspectRatio)) {
         const newHeight = Math.round(width * aspectRatio)
         url.searchParams.set('h', newHeight.toString())
       }
    }

    url.searchParams.set('auto', 'format')

    return url.href
  } catch (e) {
    const separator = src.includes('?') ? '&' : '?'
    return `${src}${separator}width=${width}`
  }
}




--- END OF FILE lib/sanity.loader.ts ---

================================================================================

--- START OF FILE lib/sanity.queries.ts ---

// lib/sanity.queries.ts
import {groq} from 'next-sanity'

// EXPORT THIS FIELD
export const mainImageFields = groq`asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt`

const creatorFields = groq`_id, name, prismaUserId, image, bio, username`
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- 1. LIGHT PROJECTION (For Lists/Cards) ---
export const lightCardProjection = groq`
  _id, 
  _type, 
  legacyId, 
  title, 
  "slug": slug.current,
  "mainImage": mainImage{${mainImageFields}},
  "mainImageVertical": mainImageVertical{${mainImageFields}},
  score, 
  verdict, 
  "authors": authors[]->{${creatorFields}},
  "reporters": reporters[]->{${creatorFields}},
  "designers": designers[]->{${creatorFields}},
  publishedAt, 
  "game": game->{_id, title, "slug": slug.current}, 
  "tags": tags[]->{${tagFields}}, 
  "category": category->{title, "slug": slug.current}, 
  newsType,
  synopsis,
  
  releaseDate, isTBA, platforms, price, 
  "developer": developer->{title, "slug": slug.current}, 
  "publisher": publisher->{title, "slug": slug.current}, 
  "onGamePass": coalesce(onGamePass, false), 
  "onPSPlus": coalesce(onPSPlus, false),
  "isPinned": coalesce(isPinned, false),
  "trailer": trailer,
  datePrecision
`;

// --- 2. FULL PROJECTION (For Single Page Views & Editor & Instant Click) ---
export const fullDocProjection = groq`
  _id, _type, legacyId, title, "slug": slug.current,
  "mainImage": mainImage{${mainImageFields}},
  "mainImageVertical": mainImageVertical{${mainImageFields}},
  score, verdict, pros, cons,
  "authors": authors[]->{${creatorFields}},
  "reporters": reporters[]->{${creatorFields}},
  "designers": designers[]->{${creatorFields}},
  publishedAt, 
  "game": game->{_id, title, "slug": slug.current}, 
  "tags": tags[]->{${tagFields}}, 
  "category": category->{title, "slug": slug.current}, 
  newsType,
  synopsis,
  
  releaseDate, isTBA, platforms, price, 
  "developer": developer->{title, "slug": slug.current}, 
  "publisher": publisher->{title, "slug": slug.current}, 
  "onGamePass": coalesce(onGamePass, false), 
  "onPSPlus": coalesce(onPSPlus, false),
  "isPinned": coalesce(isPinned, false),
  "trailer": trailer,
  datePrecision,

  // Full Content
  content[]{ 
    ..., 
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, 
    _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, 
    _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, 
    _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} }, 
    _type == "table" => {..., rows[]{..., cells[]{..., content[]{...}}}}, 
    _type == "gameDetails" => { ... }, 
    _type == 'youtube' => { ... } 
  },
  
  // Related Content
  _type == "review" => {
    "relatedReviews": select(
      defined(relatedReviews) && count(relatedReviews) > 0 => relatedReviews[]->{${lightCardProjection}},
      *[_type == "review" && ${publishedFilter} && _id != ^._id] | order(publishedAt desc)[0...3] {${lightCardProjection}}
    )
  },
  _type == "article" => {
    "relatedArticles": select(
      defined(relatedArticles) && count(relatedArticles) > 0 => relatedArticles[]->{${lightCardProjection}},
      *[_type == "article" && ${publishedFilter} && _id != ^._id] | order(publishedAt desc)[0...3] {${lightCardProjection}}
    )
  },
  _type == "news" => {
    "relatedNews": select(
      defined(relatedNews) && count(relatedNews) > 0 => relatedNews[]->{${lightCardProjection}},
      *[_type == "news" && ${publishedFilter} && _id != ^._id] | order(publishedAt desc)[0...3] {${lightCardProjection}}
    )
  }
`;

const gameReleaseProjection = groq`
    _id, legacyId, title, releaseDate, isTBA, platforms, synopsis, price, 
    "isPinned": coalesce(isPinned, false),
    "trailer": trailer,
    "datePrecision": datePrecision, 
    "onGamePass": coalesce(onGamePass, false),
    "onPSPlus": coalesce(onPSPlus, false),
    "developer": developer->{title, "slug": slug.current}, 
    "publisher": publisher->{title, "slug": slug.current}, 
    "mainImage": mainImage{${mainImageFields}}, 
    "game": game->{ _id, "slug": slug.current }, 
    "slug": game->slug.current, 
    "tags": tags[]->{${tagFields}}
`

// --- Queries ---

export const newsHeroQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...4] { ${fullDocProjection}, synopsis }`
export const newsGridInitialQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...20] { ${fullDocProjection} }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] { ${fullDocProjection} }`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] { ${fullDocProjection} }`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] { ${fullDocProjection} }`

export const minimalMetadataQuery = groq`
  *[_type in ["review", "article", "news"] && slug.current == $slug][0] {
    title,
    synopsis,
    "mainImage": mainImage.asset->{ url }
  }
`

export const tagPageDataQuery = groq`
  *[_type == "tag" && slug.current == $slug][0] {
    _id, title,
    "items": *[_type in ["review", "article", "news"] && ${publishedFilter} && (references(^._id) || category._ref == ^._id)] | order(publishedAt desc)[0...24] { ${lightCardProjection} }
  }
`

export const gamePageDataQuery = groq`
  *[_type == "game" && slug.current == $slug][0] {
    _id, title, 
    "mainImage": mainImage{${mainImageFields}},
    "items": *[_type in ["review", "article", "news"] && ${publishedFilter} && game._ref == ^._id] | order(publishedAt desc)[0...24] { ${lightCardProjection} },
    
    // THE FIX: Directly fetch linked gameRelease data here
    "release": *[_type == "gameRelease" && game._ref == ^._id][0] {
        synopsis, price, releaseDate,
        "developer": developer->title,
        "publisher": publisher->title,
        platforms,
        "onGamePass": coalesce(onGamePass, false),
        "onPSPlus": coalesce(onPSPlus, false),
        "releaseTags": tags[]->{${tagFields}},
        "releaseImage": mainImage{${mainImageFields}}
    }
  }
`

export const creatorContentQuery = groq`
  *[_type in ["review", "article", "news"] && ${publishedFilter} && references(*[_type in ["reviewer", "author", "reporter", "designer"] && prismaUserId == $prismaUserId]._id)] | order(publishedAt desc) { ${lightCardProjection} }
`

export const batchGameHubsQuery = groq`
  *[_type == "game" && _id in $ids] {
    _id, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}},
    "linkedContent": *[_type in ["review", "article", "news"] && ${publishedFilter} && game._ref == ^._id] | order(publishedAt desc)[0...24] { ${lightCardProjection} }
  }
`

export const batchTagHubsQuery = groq`
  *[_type == "tag" && _id in $ids] {
    _id, title, "slug": slug.current,
    "items": *[_type in ["review", "article", "news"] && ${publishedFilter} && (references(^._id) || category._ref == ^._id)] | order(publishedAt desc)[0...24] { ${lightCardProjection} }
  }
`

export const batchCreatorHubsQuery = groq`
  *[_type in ["reviewer", "author", "reporter", "designer"] && _id in $ids] {
     _id, name, prismaUserId, image, bio, username,
     "linkedContent": *[_type in ["review", "article", "news"] && ${publishedFilter} && references(^._id)] | order(publishedAt desc)[0...24] { ${lightCardProjection} }
  }
`

// NEW: Query to fetch ALL creators and their content
export const allCreatorsHubQuery = groq`
  *[_type in ["reviewer", "author", "reporter", "designer"]] {
     _id, name, prismaUserId, image, bio, username,
     "linkedContent": *[_type in ["review", "article", "news"] && ${publishedFilter} && references(^._id)] | order(publishedAt desc)[0...24] { ${lightCardProjection} }
  }
`

export const colorDictionaryQuery = groq`*[_type == "colorDictionary" && _id == "colorDictionary"][0]{ autoColors }`

const editorDocProjection = fullDocProjection; 
export const editorDocumentQuery = groq`*[_id in [$id, 'drafts.' + $id]] | order(_updatedAt desc)[0]{ ${editorDocProjection} }`

export const studioMetadataQuery = groq`{
  "games": *[_type == "game"] | order(title asc){_id, title},
  "tags": *[_type == "tag"] | order(title asc){_id, title, category},
  "creators": *[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId},
  "developers": *[_type == "developer"] | order(title asc){_id, title},
  "publishers": *[_type == "publisher"] | order(title asc){_id, title}
}`

export const editorDataQuery = groq`{
  "document": ${editorDocumentQuery},
  "dictionary": ${colorDictionaryQuery},
  "metadata": ${studioMetadataQuery}
}`

export const aboutPageQuery = groq`*[_id == "aboutPageSettings"][0] {
  ceo->{_id, name, image, bio, prismaUserId},
  headOfCommunication->{_id, name, image, bio, prismaUserId},
  headOfReviews->{_id, name, image, bio, prismaUserId},
  editorInChief->{_id, name, image, bio, prismaUserId},
  headOfVisuals->{_id, name, image, bio, prismaUserId},
  reportersSection[]->{_id, name, image, bio, prismaUserId},
  authorsSection[]->{_id, name, image, bio, prismaUserId},
  designersSection[]->{_id, name, image, bio, prismaUserId}
}`

// --- OPTIMIZED HOMEPAGE QUERIES (Using lightCardProjection) ---
export const homepageReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...20] { ${lightCardProjection} }`
export const homepageArticlesQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...20] { ${lightCardProjection} }`
export const homepageNewsQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...30] { ${lightCardProjection} }`
export const homepageReleasesQuery = groq`*[_type == "gameRelease" && (isTBA == true || (defined(releaseDate) && releaseDate >= "2023-01-01"))] | order(isTBA asc, releaseDate asc) { ${gameReleaseProjection} }`

export const homepageCreditsQuery = groq`*[_id == "homepageSettings"][0].releasesCredits[]->{_id, name, image, prismaUserId}`

export const homepageMetadataQuery = groq`{
    "games": *[_type == "game"] | order(title asc) {_id, title, "slug": slug.current},
    "gameTags": *[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current, category},
    "newsTags": *[_type == "tag" && category == "News"] | order(title asc) {_id, title, "slug": slug.current, category},
    "articleTags": *[_type == "tag" && category == "Article"] | order(title asc) {_id, title, "slug": slug.current, category}
}`

export const paginatedNewsQuery = (gameSlug?: string, tagSlugs?: string[], searchTerm?: string, offset: number = 0, limit: number = 20, sort: 'latest' | 'viral' = 'latest', projection: string = lightCardProjection) => {
  let filter = `_type == "news" && ${publishedFilter} && defined(mainImage.asset)`
  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) { const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' || '); filter += ` && (${tagFilter})` }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`
  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'
  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] { ${projection} }`
}

export const paginatedReviewsQuery = (gameSlug?: string, tagSlugs?: string[], searchTerm?: string, scoreRange?: string, offset: number = 0, limit: number = 20, sort: 'latest' | 'score' = 'latest', projection: string = lightCardProjection) => {
  let filter = `_type == "review" && ${publishedFilter}`
  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) { const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && '); filter += ` && (${tagFilter})` }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`
  if (scoreRange) { if (scoreRange === '9-10') filter += ` && score >= 9 && score <= 10`; else if (scoreRange === '8-8.9') filter += ` && score >= 8 && score < 9`; else if (scoreRange === '7-7.9') filter += ` && score >= 7 && score < 8`; else if (scoreRange === '<7') filter += ` && score < 7` }
  const orderBy = sort === 'score' ? 'score desc, publishedAt desc' : 'publishedAt desc'
  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] { ${projection} }`
}

export const paginatedArticlesQuery = (gameSlug?: string, tagSlugs?: string[], searchTerm?: string, offset: number = 0, limit: number = 20, sort: 'latest' | 'viral' = 'latest', projection: string = lightCardProjection) => {
  let filter = `_type == "article" && ${publishedFilter}`
  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`
  if (tagSlugs && tagSlugs.length > 0) { const tagFilter = tagSlugs.map((slug) => `"${slug}" in tags[]->slug.current`).join(' && '); filter += ` && (${tagFilter})` }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`
  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'
  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] { ${projection} }`
}

export const cardListProjection = lightCardProjection; 
export const cardProjection = lightCardProjection; 
export const relatedContentProjection = groq`{ ${lightCardProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${lightCardProjection} }`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${lightCardProjection} }`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && (title match $searchTerm + "*" || pt::text(content) match $searchTerm)] | order(publishedAt desc) [0...10] { ${lightCardProjection} }`

export const allGameTagsQuery = groq`*[_type == "tag" && category == "Game"] | order(title asc) {_id, title, "slug": slug.current, category}`
export const allArticleTypeTagsQuery = groq`*[_type == "tag" && category == "Article"] | order(title asc) {_id, title, "slug": slug.current, category}`
export const allNewsTagsQuery = groq`*[_type == "tag" && category == "News"] | order(title asc) {_id, title, "slug": slug.current, category}`
export const allGamesForStudioQuery = groq`*[_type == "game"] | order(title asc){_id, title, "slug": slug.current}`
export const allTagsForStudioQuery = groq`*[_type == "tag"] | order(title asc){_id, title, category}`
export const allCreatorsForStudioQuery = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId}`
export const homepageArticlesQueryDeprecated = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...12] { ${lightCardProjection} }`
export const homepageNewsQueryDeprecated = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...18] { ${lightCardProjection} }`

--- END OF FILE lib/sanity.queries.ts ---

================================================================================

--- START OF FILE lib/sanity.server.ts ---

// lib/sanity.server.ts

import { createClient } from 'next-sanity'
import { apiVersion, dataset, projectId } from '@/lib/sanity.env'

// This client is for server-side write operations and draft previews.
// It requires a token and bypasses the CDN.
export const sanityWriteClient = createClient({
    projectId,
    dataset,
    apiVersion,
    useCdn: false, // Ensure CDN is off
    // FIX: Correctly check both token names to support local vs prod envs
    token: process.env.SANITY_STUDIO_API_WRITE_TOKEN || process.env.SANITY_API_WRITE_TOKEN,
    // FIX: Explicitly disable stega to prevent encoding issues during writes
    stega: {
        enabled: false,
        studioUrl: '/studio',
    },
    // CRITICAL FIX: Ensure we can see drafts. 
    // Without this, the API defaults to 'published' and hides 'drafts.*' documents even with a token.
    perspective: 'previewDrafts', 
    ignoreBrowserTokenWarning: true
})

--- END OF FILE lib/sanity.server.ts ---

================================================================================

--- START OF FILE lib/scrollStore.ts ---

// lib/scrollStore.ts
import { create } from 'zustand';

interface ScrollState {
  scrollPos: number;
  setScrollPos: (pos: number) => void;
}

export const useScrollStore = create<ScrollState>((set) => ({
  scrollPos: 0,
  setScrollPos: (pos) => set({ scrollPos: pos }),
}));




--- END OF FILE lib/scrollStore.ts ---

================================================================================

--- START OF FILE lib/security.ts ---

// lib/security.ts

export async function validateImageFile(file: File): Promise<{ isValid: boolean; error?: string }> {
  if (!file) return { isValid: false, error: 'No file provided' };
  if (file.size === 0) return { isValid: false, error: 'Empty file' };
  
  const arrayBuffer = await file.slice(0, 4).arrayBuffer();
  const bytes = new Uint8Array(arrayBuffer);
  let header = "";
  for (let i = 0; i < bytes.length; i++) {
    header += bytes[i].toString(16).toUpperCase();
  }

  const isJpeg = header.startsWith('FFD8FF');
  const isPng = header.startsWith('89504E47');
  const isGif = header.startsWith('47494638');
  const isWebp = header.startsWith('52494646');

  if (!isJpeg && !isPng && !isGif && !isWebp) {
    return { 
      isValid: false, 
      error: 'نوع الملف غير مدعوم أو تالف (توقيع ثنائي غير صالح).'
    };
  }

  return { isValid: true };
}

export function sanitizeStrict(input: string): string {
  if (!input) return "";
  return input
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

/**
 * SSRF Protection: Validates that a URL belongs to a trusted image provider
 * or is a relative path. Blocks internal network access.
 */
const ALLOWED_IMAGE_DOMAINS = [
    'lh3.googleusercontent.com', // Google
    'avatars.githubusercontent.com', // GitHub
    'pbs.twimg.com', // Twitter
    'abs.twimg.com', // Twitter default
    'public.blob.vercel-storage.com', // Vercel Blob
    'cdn.sanity.io' // Sanity
];

export function isSafeImageUrl(url: string): boolean {
    if (!url) return false;
    
    try {
        const parsed = new URL(url);
        
        // 1. Block non-http protocols
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') return false;
        
        // 2. Allow specific trusted domains only
        // This is the strongest defense against SSRF
        return ALLOWED_IMAGE_DOMAINS.some(domain => parsed.hostname.endsWith(domain));
    } catch (e) {
        return false;
    }
}
export function sanitizeRedirectUrl(url: string | null): string {
    if (!url) return '/';
    
    // If it starts with / and NOT // (protocol relative), it's safe-ish
    if (url.startsWith('/') && !url.startsWith('//')) {
        return url;
    }
    
    // Otherwise, force root
    return '/';
}
export function sanitizeFilename(filename: string): string {
    return filename.replace(/[^a-zA-Z0-9._-]/g, '');
}

--- END OF FILE lib/security.ts ---

================================================================================

--- START OF FILE lib/store.ts ---

// lib/store.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { setBookmarkAction, setLikeAction, recordShareAction } from '@/app/actions/contentActions';
import useToastStore from './toastStore';

const createContentKey = (id: number, type: string) => `${type}-${id}`;

const debounceTimers: { [key: string]: NodeJS.Timeout } = {};

const initialState = {
    bookmarks: [] as string[],
    likes: [] as string[],
    shares: [] as string[],
    isSignInModalOpen: false,
    isSyncedWithDb: false,
};

type UserState = typeof initialState & { _hasHydrated: boolean };

type UserActions = {
    toggleBookmark: (contentId: number, contentType: string) => void;
    setSignInModalOpen: (isOpen: boolean) => void;
    toggleLike: (contentId: number, contentType: string, contentSlug: string) => void;
    addShare: (contentId: number, contentType: string, contentSlug: string) => void;
    syncWithDb: (dbData: { 
        likes: string[],
        bookmarks: string[],
        shares: string[]
    }) => void;
    setIsSyncedWithDb: (isSynced: boolean) => void;
    reset: () => void;
};

export const useUserStore = create<UserState & UserActions>()(
    persist(
        (set, get) => ({
            ...initialState,
            _hasHydrated: false,

            toggleBookmark: (contentId, contentType) => {
                const key = createContentKey(contentId, contentType);
                const originalBookmarks = get().bookmarks;
                const isCurrentlyBookmarked = originalBookmarks.includes(key);
                const finalState = !isCurrentlyBookmarked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);
                
                set({ bookmarks: finalState ? [...originalBookmarks, key] : originalBookmarks.filter(k => k !== key) });

                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setBookmarkAction(contentId, contentType, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        useToastStore.getState().addToast('فشل الحفظ.', 'error');
                        set({ bookmarks: originalBookmarks });
                    }
                }, 500);
            },
            
            setSignInModalOpen: (isOpen: boolean) => set({ isSignInModalOpen: isOpen }),

            toggleLike: (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                const originalLikes = get().likes;
                const isCurrentlyLiked = originalLikes.includes(key);
                const finalState = !isCurrentlyLiked;

                if (debounceTimers[key]) clearTimeout(debounceTimers[key]);

                set({ likes: finalState ? [...originalLikes, key] : originalLikes.filter(k => k !== key) });
                
                debounceTimers[key] = setTimeout(async () => {
                    try {
                        const result = await setLikeAction(contentId, contentType, contentSlug, finalState);
                        if (!result.success) throw new Error(result.error);
                    } catch (error) {
                        useToastStore.getState().addToast('أخفق تسجيل الإعجاب.', 'error');
                        set({ likes: originalLikes });
                    }
                }, 500);
            },

            addShare: async (contentId, contentType, contentSlug) => {
                const key = createContentKey(contentId, contentType);
                if (get().shares.includes(key)) return;
                set(state => ({ shares: [...state.shares, key] }));
                const result = await recordShareAction(contentId, contentType, contentSlug);
                if (result.success && result.shares) {
                    set({ shares: result.shares.map((s: any) => createContentKey(s.contentId, s.contentType)) });
                }
            },

            // OPTIMIZED: Directly accept arrays of string keys
            syncWithDb: (dbData) => {
                set({ 
                    likes: dbData.likes, 
                    bookmarks: dbData.bookmarks, 
                    shares: dbData.shares 
                });
            },

            setIsSyncedWithDb: (isSynced: boolean) => set({ isSyncedWithDb: isSynced }),
            reset: () => set(initialState),
        }),
        {
            name: 'eternalgames-user-preferences-v3',
            onRehydrateStorage: () => (state) => { if (state) { state._hasHydrated = true; } },
            partialize: (state) => ({
                bookmarks: state.bookmarks,
                likes: state.likes,
                shares: state.shares,
            }),
        }
    )
);




--- END OF FILE lib/store.ts ---

================================================================================

--- START OF FILE lib/text-utils.ts ---

// lib/text-utils.ts

/**
 * Splits a long text into chunks of approximately `maxLength` characters.
 */
export function smartSplitText(text: string, maxLength: number = 400): string[] {
    if (!text) return [''];
    if (text.length <= maxLength) return [text];

    const chunks: string[] = [];
    let remaining = text;

    while (remaining.length > 0) {
        if (remaining.length <= maxLength) {
            chunks.push(remaining.trim());
            break;
        }

        let breakIndex = remaining.lastIndexOf('.', maxLength);
        if (breakIndex === -1) breakIndex = remaining.lastIndexOf('\n', maxLength);
        if (breakIndex === -1) breakIndex = remaining.lastIndexOf(' ', maxLength);
        if (breakIndex === -1) breakIndex = maxLength;

        const includeDelimiter = remaining[breakIndex] === '.';
        const cutIndex = includeDelimiter ? breakIndex + 1 : breakIndex;

        chunks.push(remaining.slice(0, cutIndex).trim());
        remaining = remaining.slice(cutIndex).trim();
    }

    return chunks;
}

/**
 * Formats a duration in minutes according to Arabic grammatical rules.
 */
export function formatArabicDuration(minutes: number): string {
    const m = Math.round(minutes);
    if (m < 1) return 'أقل من دقيقة';
    if (m === 1) return 'دقيقة واحدة';
    if (m === 2) return 'دقيقتين';
    if (m >= 3 && m <= 10) return `${m} دقائق`;
    return `${m} دقيقة`;
}

/**
 * Generates a URL-friendly ID that PRESERVES Arabic characters.
 * Replaces spaces with dashes, removes special punctuation.
 */
export function generateId(text: string): string {
    if (!text) return '';
    return text
        .trim()
        .replace(/[؟?!\.,;:]/g, '') // Remove punctuation
        .replace(/\s+/g, '-')       // Replace spaces with dashes
        .toLowerCase();             // Lowercase (mostly for English parts)
}

/**
 * Extracts headings (h1, h2, h3) from Portable Text blocks.
 */
export function extractHeadingsFromContent(blocks: any[] = []): { id: string; text: string; level: number }[] {
    const headings: { id: string; text: string; level: number }[] = [];

    if (!Array.isArray(blocks)) return headings;

    blocks.forEach((block) => {
        if (block._type === 'block' && block.style && /^h[1-3]$/.test(block.style)) {
            const level = parseInt(block.style.substring(1));
            const text = block.children
                ? block.children.map((child: any) => child.text).join('')
                : '';
            
            if (text) {
                const id = generateId(text);
                headings.push({ id, text, level });
            }
        }
    });

    return headings;
}

--- END OF FILE lib/text-utils.ts ---

================================================================================

--- START OF FILE lib/toastStore.ts ---

// lib/toastStore.ts

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

export type ToastType = 'success' | 'error' | 'info';
export type ToastPosition = 'right' | 'left'; // <-- NEW TYPE

interface ToastMessage {
id: string;
message: string;
type: ToastType;
position?: ToastPosition; // <-- NEW PROPERTY
}

interface ToastState {
toasts: ToastMessage[];
addToast: (message: string, type: ToastType, position?: ToastPosition) => void; // <-- MODIFIED
dismissToast: (id: string) => void;
}

const useToastStore = create<ToastState>((set) => ({
toasts: [],
addToast: (message, type, position = 'right') => { // <-- SET DEFAULT TO RIGHT
const id = uuidv4();
set((state) => ({ toasts: [...state.toasts, { id, message, type, position }] }));
},
dismissToast: (id) => {
set((state) => ({ toasts: state.toasts.filter((toast) => toast.id !== id) }));
},
}));

// This is the public hook that components will use.
export const useToast = () => {
const { addToast } = useToastStore();
return {
success: (message: string, position?: ToastPosition) => addToast(message, 'success', position),
error: (message: string, position?: ToastPosition) => addToast(message, 'error', position),
info: (message: string, position?: ToastPosition) => addToast(message, 'info', position),
};
};

export default useToastStore;



































--- END OF FILE lib/toastStore.ts ---

================================================================================

--- START OF FILE lib/translations.ts ---

// lib/translations.ts

const TAG_TRANSLATIONS: Record<string, string> = {
    // === Game Tags (For Reviews & Articles) ===
    "Action": "أكشن",
    "Adventure": "مغامرات",
    "RPG": "تقمص الأدوار",
    "JRPG": "تقمص أدوار ياباني",
    "Strategy": "استراتيجية",
    "Simulation": "محاكاة",
    "Sports": "رياضة",
    "Racing": "سباقات",
    "Puzzle": "ألغاز",
    "Fighting": "قتال",
    "Horror": "رُعب",
    "Survival": "نجاة",
    "Platformer": "منصات",
    "FPS": "منظور الشخص الأول",
    "TPS": "منظور الشخص الثالث",
    "Sci-Fi": "خيال علمي",
    "Fantasy": "فانتازيا",
    "Historical": "تاريخي",
    "Post-Apocalyptic": "ما بعد الفناء",
    "Cyberpunk": "سايبربنك",
    "Mystery": "غموض",
    "Atmospheric": "أجواء غامرة",
    "Open World": "عالم مفتوح",
    "Single-Player": "طور فردي",
    "Multiplayer": "طور جماعي",
    "Co-op": "طور تعاوني",
    "Competitive": "طور تنافسي",
    "Story-Driven": "عمق قصصي",
    "Pixel Art": "فن البكسل",
    "Anime": "أنمي",
    "Classic": "كلاسيكي",
    "Indie": "ألعاب مستقلة",

    // === News-Specific Tags (Now also used for Category) ===
    "Acquisition": "استحواذ",
    "Sales": "أرقام المبيعات",
    "Game Announcement": "الكشف عن لعبة",
    "Industry News": "نبض الصناعة",
    "Financials": "شؤون مالية",
    "Technology": "تقنية",
    "Esports": "المنافسات الإلكترونية",
    "Game Update": "تحديث للعبة",
    "Layoffs": "تسريح موظفين",
    "Game Size": "حجم اللعبة",
    "Release Date": "موعد الإصدار",
    "Age Ratings": "تقييمات عمرية",

    // === Article-Specific Tags ===
    "Opinion": "رأي",
    "Guide": "إعانة",
    "Everything You Need to Know": "الدليل الشامل",
    "Analysis": "تحليل",
    "Biography": "سيرة",
    "Story": "قصة",
};

// THE FIX: Added role translations
const ROLE_TRANSLATIONS: Record<string, string> = {
    "DIRECTOR": "المدير",
    "ADMIN": "المسؤول",
    "REVIEWER": "المُراجع",
    "AUTHOR": "الكاتب",
    "REPORTER": "المراسل",
    "DESIGNER": "المصمم",
    "USER": "عضو"
};

export const translateTag = (tagTitle: string): string => {
    return TAG_TRANSLATIONS[tagTitle] || tagTitle;
};

export const translateRole = (roleName: string): string => {
    return ROLE_TRANSLATIONS[roleName] || roleName;
};




--- END OF FILE lib/translations.ts ---

================================================================================

--- START OF FILE lib/uiStore.ts ---

// lib/uiStore.ts
import { create } from 'zustand';

interface UIState {
    isMobileMenuOpen: boolean;
    toggleMobileMenu: () => void;
    setMobileMenuOpen: (isOpen: boolean) => void;
    
    // Reference to the active scroll container (Window or Overlay)
    // This allows the Navbar to react to the Overlay's scrolling
    overlayScrollRef: HTMLElement | null;
    setOverlayScrollRef: (ref: HTMLElement | null) => void;
}

export const useUIStore = create<UIState>((set) => ({
    isMobileMenuOpen: false,
    toggleMobileMenu: () => set((state) => ({ isMobileMenuOpen: !state.isMobileMenuOpen })),
    setMobileMenuOpen: (isOpen) => set({ isMobileMenuOpen: isOpen }),
    
    overlayScrollRef: null,
    setOverlayScrollRef: (ref) => set({ overlayScrollRef: ref }),
}));

--- END OF FILE lib/uiStore.ts ---

================================================================================

--- START OF FILE lib/universal-data.ts ---

// lib/universal-data.ts
import { client } from '@/lib/sanity.client';
import { 
    batchGameHubsQuery, 
    batchTagHubsQuery, 
    homepageReleasesQuery,
    homepageCreditsQuery,
    homepageMetadataQuery,
    colorDictionaryQuery,
    fullDocProjection, 
    lightCardProjection,
    allCreatorsHubQuery // IMPORTED
} from '@/lib/sanity.queries';
import { enrichContentList, enrichCreators } from '@/lib/enrichment';
import prisma from '@/lib/prisma';
import { unstable_cache } from 'next/cache';
import { convertContentToHybridHtml } from './server/html-converter';
import { groq } from 'next-sanity';

// --- MODIFIED QUERIES FOR DEEP PRE-FETCHING ---
// Fetch first N items with full content, the rest with light content.

const getCachedReviews = unstable_cache(async () => {
    const query = groq`{
        "full": *[_type == "review" && defined(publishedAt) && publishedAt < now() && defined(mainImage.asset)] | order(publishedAt desc)[0...10] { ${fullDocProjection} },
        "light": *[_type == "review" && defined(publishedAt) && publishedAt < now() && defined(mainImage.asset)] | order(publishedAt desc)[10...20] { ${lightCardProjection} }
    }`;
    const { full, light } = await client.fetch(query);
    return [...(full || []), ...(light || [])];
}, ['homepage-reviews-fragment-v3'], { revalidate: false, tags: ['content', 'review'] });

const getCachedArticles = unstable_cache(async () => {
    const query = groq`{
        "full": *[_type == "article" && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[0...12] { ${fullDocProjection} },
        "light": *[_type == "article" && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[12...20] { ${lightCardProjection} }
    }`;
    const { full, light } = await client.fetch(query);
    return [...(full || []), ...(light || [])];
}, ['homepage-articles-fragment-v3'], { revalidate: false, tags: ['content', 'article'] });

const getCachedNews = unstable_cache(async () => {
    const query = groq`{
        "full": *[_type == "news" && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[0...18] { ${fullDocProjection} },
        "light": *[_type == "news" && defined(publishedAt) && publishedAt < now()] | order(publishedAt desc)[18...30] { ${lightCardProjection} }
    }`;
    const { full, light } = await client.fetch(query);
    return [...(full || []), ...(light || [])];
}, ['homepage-news-fragment-v3'], { revalidate: false, tags: ['content', 'news'] });

// NEW: Cache all creators with content
const getCachedAllCreators = unstable_cache(async () => {
    return await client.fetch(allCreatorsHubQuery);
}, ['all-creators-hubs-fragment-v1'], { revalidate: false, tags: ['creators', 'content'] });

const getCachedReleases = unstable_cache(async () => client.fetch(homepageReleasesQuery), ['homepage-releases-fragment-v2'], { revalidate: false, tags: ['content', 'gameRelease'] });
const getCachedCredits = unstable_cache(async () => client.fetch(homepageCreditsQuery), ['homepage-credits-fragment-v2'], { revalidate: false, tags: ['creators'] });
const getCachedMetadata = unstable_cache(async () => client.fetch(homepageMetadataQuery), ['homepage-metadata-fragment-v2'], { revalidate: false, tags: ['studio-metadata'] });
const getCachedColors = unstable_cache(async () => client.fetch(colorDictionaryQuery), ['color-dictionary-fragment-v2'], { revalidate: false, tags: ['colorDictionary'] });

// Helper to strip heavy base64 strings from non-essential items
const stripHeavyMetadata = (item: any, keepBlur: boolean) => {
    if (!keepBlur) {
        if (item.mainImage) {
            delete item.mainImage.blurDataURL;
            if (item.mainImage.asset && item.mainImage.asset.metadata) {
                 delete item.mainImage.asset.metadata.lqip;
                 delete item.mainImage.asset.lqip; // Handle flat projection
            }
        }
        if (item.mainImageVertical) {
             delete item.mainImageVertical.blurDataURL;
             if (item.mainImageVertical.asset && item.mainImageVertical.asset.metadata) {
                 delete item.mainImageVertical.asset.metadata.lqip;
                 delete item.mainImageVertical.asset.lqip;
            }
        }
    }
    return item;
};

export async function fetchUniversalData() {
    try {
        const [reviews, articles, news, releases, credits, metadata, colorDict, allCreatorsHubs] = await Promise.all([
            getCachedReviews(),
            getCachedArticles(),
            getCachedNews(),
            getCachedReleases(),
            getCachedCredits(),
            getCachedMetadata(),
            getCachedColors(),
            getCachedAllCreators()
        ]);
        
        const colorMappings = colorDict?.autoColors || [];
        
        const gameIds = new Set<string>();
        const tagIds = new Set<string>();

        const collectIds = (items: any[], limit: number) => {
            // Collect IDs from the specific requested range (10 reviews, 12 articles, 18 news)
            items.slice(0, limit).forEach(item => {
                if (item.game?._id) gameIds.add(item.game._id);
                if (item.tags) item.tags.forEach((t: any) => t._id && tagIds.add(t._id));
                if (item.category?._id) tagIds.add(item.category._id);
                // Creators are now fetched globally, no need to collect here
            });
        };

        collectIds(reviews || [], 10);
        collectIds(articles || [], 12);
        collectIds(news || [], 18);
        
        // Also check releases for this month
        if (releases && releases.length > 0) {
            const now = new Date();
            const currentMonth = now.getUTCMonth();
            const currentYear = now.getUTCFullYear();
            const releasesThisMonth = releases.filter((r: any) => {
                if (!r.releaseDate) return false;
                const d = new Date(r.releaseDate);
                return d.getUTCMonth() === currentMonth && d.getUTCFullYear() === currentYear;
            });
            releasesThisMonth.forEach((r: any) => {
                if (r.game?._id) gameIds.add(r.game._id);
            });
        }
        
        const [gameHubs, tagHubs] = await Promise.all([
            gameIds.size > 0 ? client.fetch(batchGameHubsQuery, { ids: Array.from(gameIds) }, { next: { revalidate: false, tags: ['content', 'game'] } }) : [],
            tagIds.size > 0 ? client.fetch(batchTagHubsQuery, { ids: Array.from(tagIds) }, { next: { revalidate: false, tags: ['content', 'tag'] } }) : [],
        ]);

        const allContentLists = [
            ...(gameHubs.map((g: any) => g.linkedContent)),
            ...(tagHubs.map((t: any) => t.items)),
            ...(allCreatorsHubs.map((c: any) => c.linkedContent)), // Flatten linked content from creators
            reviews, 
            articles, 
            news,
        ];
        
        const flattenedContent = allContentLists.flat().filter(Boolean);
        const enrichedFlattened = await enrichContentList(flattenedContent);
        
        // --- OPTIMIZATION PIPELINE ---
        const optimizeItem = (item: any) => {
            if (item.content && Array.isArray(item.content) && item.content.length > 0) {
                // 1. Hybrid HTML Conversion
                item.content = convertContentToHybridHtml(item.content, colorMappings);
            }
            return item;
        };

        const contentMap = new Map(enrichedFlattened.map((i: any) => [i._id, optimizeItem(i)]));
        const enrichArray = (arr: any[]) => arr.map(i => contentMap.get(i._id) || i);
        
        // Strip BlurHash from non-hero items
        const processList = (list: any[], keepCount: number) => {
            const enriched = enrichArray(list || []);
            return enriched.map((item, index) => stripHeavyMetadata(item, index < keepCount));
        };

        const enrichedReviews = processList(reviews, 5);
        const enrichedArticles = processList(articles, 5);
        const enrichedNews = processList(news, 5);
        
        const enrichedGameHubs = gameHubs.map((g: any) => ({ ...g, linkedContent: processList(g.linkedContent, 0) })); 
        const enrichedTagHubs = tagHubs.map((t: any) => ({ ...t, items: processList(t.items, 0) }));
        
        // Enrich Creators (Prisma Lookup for name/username/image)
        const enrichedCreatorHubs = await Promise.all(allCreatorsHubs.map(async (c: any) => {
            let username = c.username;
            let name = c.name;
            let image = c.image;
            
            if (c.prismaUserId) {
                    const u = await prisma.user.findUnique({ where: { id: c.prismaUserId }, select: { username: true, name: true, image: true }});
                    if (u) { username = u.username; name = u.name; image = u.image; }
            }
            return { 
                ...c, 
                username, name, image,
                linkedContent: processList(c.linkedContent || [], 0) 
            };
        }));
        
        const enrichedCredits = await enrichCreators(credits || []);

        // Featured Review Logic
        if (enrichedReviews.length > 0) {
            const topRatedIndex = enrichedReviews.reduce((topIndex: number, current: any, index: number) => {
                return (current.score ?? 0) > (enrichedReviews[topIndex].score ?? 0) ? index : topIndex;
            }, 0);
            if (topRatedIndex > 0) {
                const [best] = enrichedReviews.splice(topRatedIndex, 1);
                enrichedReviews.unshift(best);
            }
        }

        return {
            reviews: enrichedReviews,
            articles: enrichedArticles,
            news: enrichedNews,
            releases: releases || [],
            credits: enrichedCredits,
            metadata: metadata || {},
            hubs: {
                games: enrichedGameHubs,
                tags: enrichedTagHubs,
                creators: enrichedCreatorHubs
            }
        };
    } catch (error) {
        console.error("Critical: Failed to fetch Universal Base Data", error);
        return { reviews: [], articles: [], news: [], releases: [], credits: [], metadata: {}, hubs: { games: [], tags: [], creators: [] } };
    }
}

--- END OF FILE lib/universal-data.ts ---

================================================================================

--- START OF FILE lib/validations.ts ---

// lib/validations.ts
import { z } from 'zod';
import xss from 'xss';

const sanitize = (val: string) => xss(val);

// --- SCHEMAS ---

// 1. User Profile Update Schema
export const profileSchema = z.object({
    name: z.string()
        .min(2, "الاسم قصير جدًا")
        .max(50, "الاسم طويل جدًا")
        .transform(sanitize),
    username: z.string()
        .min(3, "اسم المستخدم يجب أن يكون 3 أحرف على الأقل")
        .max(20, "اسم المستخدم طويل جدًا")
        .regex(/^[a-z0-9_]+$/, "يسمح فقط بالأحرف الإنجليزية والأرقام والشرطة السفلية")
        .transform(val => val.toLowerCase()),
    bio: z.string()
        .max(500, "النبذة طويلة جدًا (الحد 500 حرف)")
        .optional()
        .transform(val => val ? sanitize(val) : ""),
    twitterHandle: z.string().max(30).optional().transform(val => val ? sanitize(val) : ""),
    instagramHandle: z.string().max(30).optional().transform(val => val ? sanitize(val) : ""),
}).strict(); // REJECT UNKNOWN KEYS

// 2. Sign Up Schema
export const signUpSchema = z.object({
    name: z.string().min(2).max(50).transform(sanitize),
    email: z.string().email("البريد الإلكتروني غير صالح").toLowerCase(),
    password: z.string()
        .min(8, "كلمة السر يجب أن تكون 8 أحرف على الأقل")
        .max(100)
        .regex(/[0-9]/, "كلمة السر يجب أن تحتوي على رقم واحد على الأقل"),
    username: z.string()
        .min(3)
        .max(20)
        .regex(/^[a-z0-9_]+$/, "اسم المستخدم غير صالح")
        .toLowerCase(),
}).strict();

// 3. Comment Schema
export const commentSchema = z.object({
    content: z.string()
        .min(1, "التعليق فارغ")
        .max(2000, "التعليق طويل جدًا")
        .transform(sanitize),
    parentId: z.string().optional(),
    contentSlug: z.string().min(1),
}).strict();

// 4. Password Reset Schema
export const passwordResetSchema = z.object({
    token: z.string().min(1),
    newPassword: z.string().min(8, "كلمة السر قصيرة جدًا").max(100),
}).strict();

--- END OF FILE lib/validations.ts ---

================================================================================

--- START OF FILE lib/app/api/articles/route.ts ---




--- END OF FILE lib/app/api/articles/route.ts ---

================================================================================

--- START OF FILE lib/app/api/reviews/route.ts ---




--- END OF FILE lib/app/api/reviews/route.ts ---

================================================================================

--- START OF FILE lib/server/html-converter.ts ---

import 'server-only';
import { PortableTextBlock } from '@portabletext/types';
import { generateId } from '@/lib/text-utils';

// Regex to find English words (Latin alphabet sequences)
const ENGLISH_REGEX = /(\b[a-zA-Z]+(?:['’][a-zA-Z]+)?\b)/g;

type ColorMapping = {
    word: string;
    color: string;
};

// Inline Styles (Minified)
const S = {
    h1: "font-size:3.6rem;margin:5rem 0 2rem 0;padding-bottom:1rem;border-bottom:1px solid var(--border-color);font-family:var(--font-main),sans-serif;line-height:1.2",
    h2: "font-size:2.8rem;margin:5rem 0 2rem 0;padding-bottom:1rem;border-bottom:1px solid var(--border-color);font-family:var(--font-main),sans-serif;line-height:1.2",
    h3: "font-size:2.2rem;margin:4rem 0 1.5rem 0;font-family:var(--font-main),sans-serif;line-height:1.2",
    blockquote: "margin:4rem 0;padding-right:2rem;border-right:4px solid var(--accent);font-size:2.4rem;font-style:italic;color:var(--text-primary)",
    link: "color:var(--accent);text-decoration:underline;text-decoration-color:color-mix(in srgb, var(--accent) 50%, transparent)",
    colorMark: "font-weight:700",
    english: "font-weight:700"
};

// Helper to decode existing entities to prevent double-escaping.
// Uses a loop to handle nested encoding (e.g. &amp;quot; -> &quot; -> ")
const unescapeHtml = (str: string): string => {
    if (!str) return '';
    
    // Map of common entities to their characters
    const entities: Record<string, string> = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#34;': '"',
        '&#039;': "'",
        '&#39;': "'",
        '&nbsp;': ' '
    };

    let current = str;
    // Loop up to 3 times to unwrap double/triple encoding
    for (let i = 0; i < 3; i++) {
        const previous = current;
        // Replace named and numeric entities
        current = current.replace(/&amp;|&lt;|&gt;|&quot;|&#34;|&#039;|&#39;|&nbsp;/g, (match) => {
            return entities[match] || match;
        });
        
        // If nothing changed, we are done
        if (current === previous) break;
    }
    
    return current;
};

const escapeHtml = (unsafe: string): string => {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
};

/**
 * Applies automated text highlighting (English bolding + Color Dictionary)
 * Uses a placeholder strategy to prevent Regex collisions.
 */
const processTextContent = (text: string, colorMap: Map<string, string>, colorRegex: RegExp | null): string => {
    if (!text) return '';

    // 1. Clean the text (Deep unescape first to handle DB entities, then Escape strictly)
    let processed = escapeHtml(unescapeHtml(text));
    
    // Store HTML replacements temporarily to protect them from the English regex
    const replacements: string[] = [];
    const PLACEHOLDER_CHAR = '\uE000'; // Private Use Area character (Won't match English Regex)

    // 2. Apply Color Dictionary
    if (colorRegex) {
        processed = processed.replace(colorRegex, (match) => {
            const lower = match.toLowerCase();
            const color = colorMap.get(lower);
            if (color) {
                // Store the HTML tag in the array
                replacements.push(`<span style="color:${color};font-weight:700">${match}</span>`);
                // Return a safe placeholder (e.g., 0)
                return `${PLACEHOLDER_CHAR}${replacements.length - 1}${PLACEHOLDER_CHAR}`;
            }
            return match;
        });
    }

    // 3. Apply English Bolding
    // Since we replaced HTML tags with \uE000... , this regex will NOT match inside them.
    processed = processed.replace(ENGLISH_REGEX, (match) => {
        // Double check we aren't inside a placeholder (unlikely given regex boundary \b)
        if (match.includes(PLACEHOLDER_CHAR)) return match;
        return `<strong style="${S.english}">${match}</strong>`;
    });

    // 4. Restore Replacements (Inject the HTML tags back)
    if (replacements.length > 0) {
        processed = processed.replace(new RegExp(`${PLACEHOLDER_CHAR}(\\d+)${PLACEHOLDER_CHAR}`, 'g'), (_, index) => {
            return replacements[parseInt(index, 10)];
        });
    }

    return processed;
};

/**
 * Serializes a single Portable Text block to an HTML string.
 */
const serializeBlock = (block: PortableTextBlock, colorMap: Map<string, string>, colorRegex: RegExp | null): string | null => {
    if (!block.children || !Array.isArray(block.children)) return null;

    // 1. Render Children (Spans)
    const childrenHtml = block.children.map((span: any) => {
        if (span._type !== 'span') return '';
        
        let text = processTextContent(span.text, colorMap, colorRegex);
        
        if (!span.marks || span.marks.length === 0) return text;

        // Apply Marks (Decorators & Annotations)
        span.marks.forEach((mark: string) => {
            if (mark === 'strong') text = `<strong>${text}</strong>`;
            else if (mark === 'em') text = `<em>${text}</em>`;
            else if (block.markDefs) {
                const def = block.markDefs.find((d: any) => d._key === mark);
                if (def) {
                    if (def._type === 'link') {
                        // Cast href to string to fix TS error
                        const href = (def.href as string) || '#';
                        const target = href.startsWith('/') ? '_self' : '_blank';
                        const rel = href.startsWith('/') ? '' : 'noreferrer noopener';
                        text = `<a href="${escapeHtml(href)}" style="${S.link}" target="${target}" rel="${rel}">${text}</a>`;
                    } else if (def._type === 'color') {
                        text = `<span style="color:${def.hex};${S.colorMark}">${text}</span>`;
                    }
                }
            }
        });
        return text;
    }).join('');

    // 2. Wrap in Block Tag
    const style = block.style || 'normal';
    
    // Generate ID for headings
    let idAttr = '';
    if (['h1', 'h2', 'h3'].includes(style)) {
        const plainText = block.children.map((c: any) => c.text).join('');
        idAttr = ` id="${generateId(plainText)}"`;
    }

    switch (style) {
        case 'h1': return `<h1${idAttr} style="${S.h1}">${childrenHtml}</h1>`;
        case 'h2': return `<h2${idAttr} style="${S.h2}">${childrenHtml}</h2>`;
        case 'h3': return `<h3${idAttr} style="${S.h3}">${childrenHtml}</h3>`;
        case 'blockquote': return `<blockquote style="${S.blockquote}">${childrenHtml}</blockquote>`;
        case 'normal': return `<p>${childrenHtml}</p>`; // p styles are global/inherited
        default: return `<p>${childrenHtml}</p>`;
    }
};

/**
 * Main conversion function used by Universal Data fetcher
 */
export function convertContentToHybridHtml(content: PortableTextBlock[], colorDictionary: ColorMapping[]) {
    if (!content || !Array.isArray(content)) return [];

    const colorMap = new Map(colorDictionary.map((item) => [item.word.toLowerCase(), item.color]));
    const escapeRegExp = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const colorRegex = colorDictionary.length > 0 
        ? new RegExp(`\\b(${colorDictionary.map((item) => escapeRegExp(item.word)).join('|')})\\b`, 'gi') 
        : null;

    const result: (string | PortableTextBlock)[] = [];
    
    // Batch consecutive strings to reduce array size further
    let htmlBuffer = '';

    content.forEach(block => {
        const isStandardBlock = 
            block._type === 'block' && 
            (!block.style || ['normal', 'h1', 'h2', 'h3', 'blockquote'].includes(block.style));

        if (isStandardBlock) {
            const html = serializeBlock(block, colorMap, colorRegex);
            if (html) {
                htmlBuffer += html;
            }
        } else {
            // Flush buffer if we hit a custom component
            if (htmlBuffer) {
                result.push(htmlBuffer);
                htmlBuffer = '';
            }
            result.push(block);
        }
    });

    // Final flush
    if (htmlBuffer) {
        result.push(htmlBuffer);
    }

    return result;
}

--- END OF FILE lib/server/html-converter.ts ---

================================================================================

--- START OF FILE lib/workers/upscaler.worker.ts ---

// lib/workers/upscaler.worker.ts

// Stubbed worker to preserve architecture without the heavy dependency
self.addEventListener('message', async (event) => {
  const { type } = event.data;

  if (type === 'upscale') {
      // Simulate initialization delay
      self.postMessage({ status: 'init', message: 'جاري الاتصال بالمسبك...' });
      
      setTimeout(() => {
          // Return specific maintenance error to UI
          self.postMessage({ 
              status: 'error', 
              message: 'المسبك البصري يخضع للصيانة حالياً. يرجى المحاولة لاحقاً.' 
          });
      }, 1500);
  }
});




--- END OF FILE lib/workers/upscaler.worker.ts ---

================================================================================

--- START OF FILE prisma/schema.prisma ---

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/client"
  // REMOVED: previewFeatures = ["driverAdapters"] - This is now handled differently in v7
}

datasource db {
  provider = "postgresql"
  // REMOVED: url and directUrl are now configured in prisma.config.ts
}

model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[] @relation("RoleToUser")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                  String               @id @default(cuid())
  name                String?
  username            String?              @unique
  email               String?              @unique
  emailVerified       DateTime?
  image               String?
  password            String?
  createdAt           DateTime             @default(now())
  bio                 String?
  twitterHandle       String?
  age                 Int?
  country             String?
  agePublic           Boolean              @default(true)
  countryPublic       Boolean              @default(true)
  instagramHandle     String?
  
  isBanned            Boolean              @default(false)
  banReason           String?
  bannedAt            DateTime?

  accounts            Account[]
  engagements         Engagement[]
  comments            Comment[]
  commentVotes        CommentVote[]
  passwordResetTokens PasswordResetToken[]
  sessions            Session[]
  shares              Share[]
  roles               Role[]               @relation("RoleToUser")

  receivedNotifications Notification[]     @relation("ReceivedNotifications")
  sentNotifications     Notification[]     @relation("SentNotifications")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  token   String   @unique
  expires DateTime
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Engagement {
  id          String         @id @default(cuid())
  createdAt   DateTime       @default(now())
  type        EngagementType
  userId      String
  contentId   Int
  contentType String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, contentId, contentType, type])
}

model Share {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  userId      String
  contentId   Int
  contentType String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Comment {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  content     String
  contentSlug String
  isDeleted   Boolean       @default(false)
  authorId    String
  parentId    String?
  author      User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent      Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies     Comment[]     @relation("CommentReplies")
  votes       CommentVote[]
}

model CommentVote {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  type      VoteType
  userId    String
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
}

model Notification {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  userId       String           
  senderId     String           
  type         NotificationType
  resourceId   String           
  resourceSlug String           
  link         String           
  read         Boolean          @default(false)

  user         User             @relation("ReceivedNotifications", fields: [userId], references: [id], onDelete: Cascade)
  sender       User             @relation("SentNotifications", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum NotificationType {
  REPLY
}

enum VoteType {
  LIKE
  DISLIKE
}

enum EngagementType {
  LIKE
  BOOKMARK
}




--- END OF FILE prisma/schema.prisma ---

================================================================================

--- START OF FILE prisma/seed.ts ---

// prisma/seed.ts
import { PrismaClient } from '../lib/generated/client';
import { Pool } from 'pg';
import { PrismaPg } from '@prisma/adapter-pg';

const connectionString = process.env.DATABASE_URL;
if (!connectionString) throw new Error('DATABASE_URL is not set');

const pool = new Pool({ connectionString });
const adapter = new PrismaPg(pool);
const prisma = new PrismaClient({ adapter });

const ROLES_TO_CREATE = [
  'DIRECTOR',
  'ADMIN',
  'REVIEWER',
  'AUTHOR',
  'REPORTER',
  'DESIGNER',
  'USER'
];

async function main() {
  console.log('Start seeding roles...');
  for (const roleName of ROLES_TO_CREATE) {
    const role = await prisma.role.upsert({
      where: { name: roleName },
      update: {},
      create: { name: roleName },
    });
    console.log(`Created or found role: ${role.name}`);
  }
  console.log('Seeding finished.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
    await pool.end();
  });




--- END OF FILE prisma/seed.ts ---

================================================================================

--- START OF FILE prisma/migrations/migration_lock.toml ---

# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"











--- END OF FILE prisma/migrations/migration_lock.toml ---

================================================================================

--- START OF FILE prisma/migrations/0_baseline/migration.sql ---

-- CreateEnum
CREATE TYPE "VoteType" AS ENUM ('LIKE', 'DISLIKE');

-- CreateTable
CREATE TABLE "Role" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "Role_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Account" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Session" (
    "id" TEXT NOT NULL,
    "sessionToken" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "username" TEXT,
    "email" TEXT,
    "emailVerified" TIMESTAMP(3),
    "image" TEXT,
    "password" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "bio" TEXT,
    "twitterHandle" TEXT,
    "instagramHandle" TEXT,
    "age" INTEGER,
    "country" TEXT,
    "agePublic" BOOLEAN NOT NULL DEFAULT true,
    "countryPublic" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VerificationToken" (
    "identifier" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL
);

-- CreateTable
CREATE TABLE "Like" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Like_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Share" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Share_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Bookmark" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Bookmark_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "content" TEXT NOT NULL,
    "contentSlug" TEXT NOT NULL,
    "isDeleted" BOOLEAN NOT NULL DEFAULT false,
    "authorId" TEXT NOT NULL,
    "parentId" TEXT,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CommentVote" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "VoteType" NOT NULL,
    "userId" TEXT NOT NULL,
    "commentId" TEXT NOT NULL,

    CONSTRAINT "CommentVote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_RoleToUser" (
    "A" INTEGER NOT NULL,
    "B" TEXT NOT NULL,

    CONSTRAINT "_RoleToUser_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE UNIQUE INDEX "Role_name_key" ON "Role"("name");

-- CreateIndex
CREATE UNIQUE INDEX "Account_provider_providerAccountId_key" ON "Account"("provider", "providerAccountId");

-- CreateIndex
CREATE UNIQUE INDEX "Session_sessionToken_key" ON "Session"("sessionToken");

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_token_key" ON "VerificationToken"("token");

-- CreateIndex
CREATE UNIQUE INDEX "VerificationToken_identifier_token_key" ON "VerificationToken"("identifier", "token");

-- CreateIndex
CREATE UNIQUE INDEX "Like_userId_contentId_contentType_key" ON "Like"("userId", "contentId", "contentType");

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_key" ON "Bookmark"("userId", "contentId");

-- CreateIndex
CREATE UNIQUE INDEX "CommentVote_userId_commentId_key" ON "CommentVote"("userId", "commentId");

-- CreateIndex
CREATE INDEX "_RoleToUser_B_index" ON "_RoleToUser"("B");

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Session" ADD CONSTRAINT "Session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Like" ADD CONSTRAINT "Like_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Share" ADD CONSTRAINT "Share_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Bookmark" ADD CONSTRAINT "Bookmark_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_parentId_fkey" FOREIGN KEY ("parentId") REFERENCES "Comment"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CommentVote" ADD CONSTRAINT "CommentVote_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_A_fkey" FOREIGN KEY ("A") REFERENCES "Role"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_RoleToUser" ADD CONSTRAINT "_RoleToUser_B_fkey" FOREIGN KEY ("B") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;












--- END OF FILE prisma/migrations/0_baseline/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

-- CreateTable
CREATE TABLE "PasswordResetToken" (
    "id" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "expires" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "PasswordResetToken_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "PasswordResetToken_token_key" ON "PasswordResetToken"("token");

-- AddForeignKey
ALTER TABLE "PasswordResetToken" ADD CONSTRAINT "PasswordResetToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;











--- END OF FILE prisma/migrations/20251013095149_add_password_reset_token/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

/*
  Warnings:

  - A unique constraint covering the columns `[userId,contentId,contentType]` on the table `Bookmark` will be added. If there are existing duplicate values, this will fail.

*/
-- DropIndex
DROP INDEX "public"."Bookmark_userId_contentId_key";

-- CreateIndex
CREATE UNIQUE INDEX "Bookmark_userId_contentId_contentType_key" ON "Bookmark"("userId", "contentId", "contentType");











--- END OF FILE prisma/migrations/20251014102152_fix_bookmark_uniqueness/migration.sql ---

================================================================================

--- START OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

/*
  Warnings:

  - You are about to drop the `Bookmark` table. If the table is not empty, all the data it contains will be lost.
  - You are about to drop the `Like` table. If the table is not empty, all the data it contains will be lost.

*/
-- CreateEnum
CREATE TYPE "EngagementType" AS ENUM ('LIKE', 'BOOKMARK');

-- DropForeignKey
ALTER TABLE "public"."Bookmark" DROP CONSTRAINT "Bookmark_userId_fkey";

-- DropForeignKey
ALTER TABLE "public"."Like" DROP CONSTRAINT "Like_userId_fkey";

-- DropTable
DROP TABLE "public"."Bookmark";

-- DropTable
DROP TABLE "public"."Like";

-- CreateTable
CREATE TABLE "Engagement" (
    "id" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "type" "EngagementType" NOT NULL,
    "userId" TEXT NOT NULL,
    "contentId" INTEGER NOT NULL,
    "contentType" TEXT NOT NULL,

    CONSTRAINT "Engagement_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Engagement_userId_contentId_contentType_type_key" ON "Engagement"("userId", "contentId", "contentType", "type");

-- AddForeignKey
ALTER TABLE "Engagement" ADD CONSTRAINT "Engagement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;











--- END OF FILE prisma/migrations/20251018071850_unify_engagements/migration.sql ---

================================================================================

--- START OF FILE sanity/.env ---

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"




--- END OF FILE sanity/.env ---

================================================================================

--- START OF FILE sanity/.env.local ---

# This file is for local Sanity Studio development (npx sanity dev)
# It should NOT be committed to version control.

SANITY_STUDIO_PROJECT_ID="0zany1dm"
SANITY_STUDIO_DATASET="production"
SANITY_STUDIO_API_WRITE_TOKEN="skHSNGizuApQH6cHqPX9Mp12df1fHQOxubYPnpoAiPbwv2BwES2TUb2hJHmmXtJCmGkdVaqjS55DYct7AIQxQYBFIDT3dMEvrCCjOY2wjGVoS8MCeevuy8whHnPwVfD2dzi7JVAXqrAngC1s6WCHkH16iXPBFFOwOIW3YcnuSICQTVVk2gE6"




--- END OF FILE sanity/.env.local ---

================================================================================

--- START OF FILE sanity/env.ts ---

export const apiVersion =
  process.env.NEXT_PUBLIC_SANITY_API_VERSION || '2025-09-28'

export const dataset = assertValue(
  process.env.NEXT_PUBLIC_SANITY_DATASET || process.env.SANITY_STUDIO_DATASET,
  'Missing environment variable: NEXT_PUBLIC_SANITY_DATASET or SANITY_STUDIO_DATASET'
)

export const projectId = assertValue(
  process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || process.env.SANITY_STUDIO_PROJECT_ID,
  'Missing environment variable: NEXT_PUBLIC_SANITY_PROJECT_ID or SANITY_STUDIO_PROJECT_ID'
)

function assertValue<T>(v: T | undefined, errorMessage: string): T {
  if (v === undefined) {
    throw new Error(errorMessage)
  }

  return v
}




--- END OF FILE sanity/env.ts ---

================================================================================

--- START OF FILE sanity/package-lock.json ---

{
  "name": "eternalgames-studio",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "eternalgames-studio",
      "version": "1.0.0",
      "license": "UNLICENSED",
      "dependencies": {
        "styled-components": "^6.1.19"
      }
    },
    "node_modules/@emotion/is-prop-valid": {
      "version": "1.2.2",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.8.1"
      }
    },
    "node_modules/@emotion/memoize": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@emotion/unitless": {
      "version": "0.8.1",
      "license": "MIT"
    },
    "node_modules/@types/stylis": {
      "version": "4.2.5",
      "license": "MIT"
    },
    "node_modules/camelize": {
      "version": "1.0.1",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/css-color-keywords": {
      "version": "1.0.0",
      "license": "ISC",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/css-to-react-native": {
      "version": "3.2.0",
      "license": "MIT",
      "dependencies": {
        "camelize": "^1.0.0",
        "css-color-keywords": "^1.0.0",
        "postcss-value-parser": "^4.0.2"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.4.49",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.7",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "license": "MIT"
    },
    "node_modules/shallowequal": {
      "version": "1.1.0",
      "license": "MIT"
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/styled-components": {
      "version": "6.1.19",
      "resolved": "https://registry.npmjs.org/styled-components/-/styled-components-6.1.19.tgz",
      "integrity": "sha512-1v/e3Dl1BknC37cXMhwGomhO8AkYmN41CqyX9xhUDxry1ns3BFQy2lLDRQXJRdVVWB9OHemv/53xaStimvWyuA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/is-prop-valid": "1.2.2",
        "@emotion/unitless": "0.8.1",
        "@types/stylis": "4.2.5",
        "css-to-react-native": "3.2.0",
        "csstype": "3.1.3",
        "postcss": "8.4.49",
        "shallowequal": "1.1.0",
        "stylis": "4.3.2",
        "tslib": "2.6.2"
      },
      "engines": {
        "node": ">= 16"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/styled-components"
      },
      "peerDependencies": {
        "react": ">= 16.8.0",
        "react-dom": ">= 16.8.0"
      }
    },
    "node_modules/stylis": {
      "version": "4.3.2",
      "license": "MIT"
    },
    "node_modules/tslib": {
      "version": "2.6.2",
      "license": "0BSD"
    }
  }
}








--- END OF FILE sanity/package-lock.json ---

================================================================================

--- START OF FILE sanity/package.json ---

{
  "name": "eternalgames-studio",
  "private": true,
  "version": "1.0.0",
  "main": "package.json",
  "license": "UNLICENSED",
  "scripts": {
    "dev": "sanity dev",
    "start": "sanity start",
    "build": "sanity build",
    "deploy": "sanity deploy",
    "deploy-graphql": "sanity graphql deploy"
  },
  "dependencies": {
    "@sanity/vision": "^4.10.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-is": "^18.3.1",
    "sanity": "^4.10.1",
    "styled-components": "^6.1.19"
  }
}







--- END OF FILE sanity/package.json ---

================================================================================

--- START OF FILE sanity/sanity.config.ts ---

// sanity/sanity.config.ts
import {defineConfig} from 'sanity'
import {structureTool, StructureBuilder} from 'sanity/structure'
import {visionTool} from '@sanity/vision'
import {schemaTypes} from './schemaTypes'
import {apiVersion, dataset, projectId} from './env'
import {ColorWheelIcon, HomeIcon, UsersIcon} from '@sanity/icons'

// Custom desk structure for singletons
export const singletonStructure = (S: StructureBuilder) =>
  S.list()
    .title('Content')
    .items([
      // Homepage Settings Singleton
      S.listItem()
        .title('Homepage Settings')
        .id('homepageSettings')
        .icon(HomeIcon)
        .child(
          S.document()
            .schemaType('homepageSettings')
            .documentId('homepageSettings')
            .title('Homepage Settings')
        ),
      // About Page Settings Singleton
      S.listItem()
        .title('About Page Settings')
        .id('aboutPageSettings')
        .icon(UsersIcon)
        .child(
          S.document()
            .schemaType('aboutPageSettings')
            .documentId('aboutPageSettings')
            .title('About Page Settings')
        ),
      // Color Dictionary Singleton
      S.listItem()
        .title('Color Dictionary')
        .id('colorDictionary')
        .icon(ColorWheelIcon)
        .child(
          S.document()
            .schemaType('colorDictionary')
            .documentId('colorDictionary')
            .title('Automatic Word Color Dictionary')
        ),
      S.divider(),
      // The rest of our document types
      ...S.documentTypeListItems().filter(
        (listItem) => !['colorDictionary', 'homepageSettings', 'aboutPageSettings'].includes(listItem.getId() || '')
      ),
    ])

export default defineConfig({
  basePath: '/studio',
  projectId,
  dataset,
  token: process.env.SANITY_STUDIO_API_WRITE_TOKEN,
  schema: {
    types: schemaTypes,
  },
  plugins: [
    structureTool({
      structure: singletonStructure,
    }),
    visionTool({defaultApiVersion: apiVersion}),
  ],
})

--- END OF FILE sanity/sanity.config.ts ---

================================================================================

--- START OF FILE sanity/data/initial-categories.ndjson ---

{"_id":"news-category-acquisition","_type":"tag","title":"Acquisition","category":"News","slug":{"_type":"slug","current":"acquisition"}}
{"_id":"news-category-sales","_type":"tag","title":"Sales","category":"News","slug":{"_type":"slug","current":"sales"}}
{"_id":"news-category-game-announcement","_type":"tag","title":"Game Announcement","category":"News","slug":{"_type":"slug","current":"game-announcement"}}
{"_id":"news-category-industry-news","_type":"tag","title":"Industry News","category":"News","slug":{"_type":"slug","current":"industry-news"}}
{"_id":"news-category-financials","_type":"tag","title":"Financials","category":"News","slug":{"_type":"slug","current":"financials"}}
{"_id":"news-category-technology","_type":"tag","title":"Technology","category":"News","slug":{"_type":"slug","current":"technology"}}
{"_id":"news-category-esports","_type":"tag","title":"Esports","category":"News","slug":{"_type":"slug","current":"esports"}}
{"_id":"news-category-game-update","_type":"tag","title":"Game Update","category":"News","slug":{"_type":"slug","current":"game-update"}}
{"_id":"news-category-layoffs","_type":"tag","title":"Layoffs","category":"News","slug":{"_type":"slug","current":"layoffs"}}
{"_id":"news-category-game-size","_type":"tag","title":"Game Size","category":"News","slug":{"_type":"slug","current":"game-size"}}
{"_id":"news-category-release-date","_type":"tag","title":"Release Date","category":"News","slug":{"_type":"slug","current":"release-date"}}
{"_id":"news-category-age-ratings","_type":"tag","title":"Age Ratings","category":"News","slug":{"_type":"slug","current":"age-ratings"}}
{"_id":"article-category-opinion","_type":"tag","title":"Opinion","category":"Article","slug":{"_type":"slug","current":"opinion"}}
{"_id":"article-category-guide","_type":"tag","title":"Guide","category":"Article","slug":{"_type":"slug","current":"guide"}}
{"_id":"article-category-everything-you-need-to-know","_type":"tag","title":"Everything You Need to Know","category":"Article","slug":{"_type":"slug","current":"everything-you-need-to-know"}}
{"_id":"article-category-analysis","_type":"tag","title":"Analysis","category":"Article","slug":{"_type":"slug","current":"analysis"}}
{"_id":"article-category-biography","_type":"tag","title":"Biography","category":"Article","slug":{"_type":"slug","current":"biography"}}
{"_id":"article-category-story","_type":"tag","title":"Story","category":"Article","slug":{"_type":"slug","current":"story"}}




--- END OF FILE sanity/data/initial-categories.ndjson ---

================================================================================

--- START OF FILE sanity/lib/client.ts ---

import { createClient } from 'next-sanity'

import { apiVersion, dataset, projectId } from '../env'

export const client = createClient({
projectId,
dataset,
apiVersion,
useCdn: true, // Set to false if statically generating pages, using ISR or tag-based revalidation
})




--- END OF FILE sanity/lib/client.ts ---

================================================================================

--- START OF FILE sanity/lib/image.ts ---

// sanity/lib/image.ts
import createImageUrlBuilder from '@sanity/image-url'
import { SanityImageSource } from "@sanity/image-url/lib/types/types";

import { dataset, projectId } from '../env'

// https://www.sanity.io/docs/image-url
const builder = createImageUrlBuilder({ projectId, dataset })

export const urlFor = (source: SanityImageSource) => {
  return builder.image(source).auto('format').fit('max')
}




--- END OF FILE sanity/lib/image.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/aboutPageSettingsType.ts ---

import {defineField, defineType} from 'sanity'
import {UsersIcon} from '@sanity/icons'

export default defineType({
  name: 'aboutPageSettings',
  title: 'About Page Settings',
  type: 'document',
  icon: UsersIcon,
  fields: [
    defineField({
      name: 'ceo',
      title: 'CEO',
      type: 'reference',
      to: [{type: 'reviewer'}, {type: 'author'}, {type: 'reporter'}, {type: 'designer'}]
    }),
    
    // Leadership Group
    defineField({
      name: 'headOfCommunication',
      title: 'Head of Communication',
      type: 'reference',
      to: [{type: 'reviewer'}, {type: 'author'}, {type: 'reporter'}, {type: 'designer'}]
    }),
    defineField({
      name: 'headOfReviews',
      title: 'Head of Reviews',
      type: 'reference',
      to: [{type: 'reviewer'}, {type: 'author'}, {type: 'reporter'}, {type: 'designer'}]
    }),
    defineField({
      name: 'editorInChief',
      title: 'Editor in Chief (رئيس التحرير)',
      type: 'reference',
      to: [{type: 'reviewer'}, {type: 'author'}, {type: 'reporter'}, {type: 'designer'}]
    }),
    defineField({
      name: 'headOfVisuals',
      title: 'Head of Visuals',
      type: 'reference',
      to: [{type: 'reviewer'}, {type: 'author'}, {type: 'reporter'}, {type: 'designer'}]
    }),

    // Teams
    defineField({
      name: 'reportersSection',
      title: 'Reporters Team',
      type: 'array',
      of: [{type: 'reference', to: [{type: 'reporter'}, {type: 'author'}, {type: 'reviewer'}, {type: 'designer'}]}]
    }),
    defineField({
      name: 'authorsSection',
      title: 'Authors Team',
      type: 'array',
      of: [{type: 'reference', to: [{type: 'author'}, {type: 'reporter'}, {type: 'reviewer'}, {type: 'designer'}]}]
    }),
    defineField({
      name: 'designersSection',
      title: 'Designers Team',
      type: 'array',
      of: [{type: 'reference', to: [{type: 'designer'}, {type: 'author'}, {type: 'reporter'}, {type: 'reviewer'}]}]
    }),
  ],
  preview: {
    prepare() {
      return {
        title: 'About Page Configuration',
      }
    },
  },
})

--- END OF FILE sanity/schemaTypes/aboutPageSettingsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/articleType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
  name: 'article',
  title: 'Article',
  type: 'document',
  fields: [
    defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
    defineField({name: 'slug', title: 'slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
    defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
    defineField({name: 'authors', title: 'Authors', type: 'array', of: [{type: 'reference', to: {type: 'author'}}], validation: (Rule) => Rule.required().min(1)}),
    defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
    defineField({name: 'mainImage', title: 'Main Image (Horizontal)', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
    defineField({name: 'mainImageVertical', title: 'Vertical Image (Vanguard)', type: 'image', options: {hotspot: true}}),
    defineField({
        name: 'category',
        title: 'Category',
        type: 'reference',
        to: [{type: 'tag'}],
        options: { filter: 'category == "Article"' },
        validation: (Rule) => Rule.required()
    }),
    defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
    defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
    defineField({name: 'content', title: 'Content', type: 'blockContent'}),
    defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
    defineField({name: 'relatedArticles', title: 'Related Articles', type: 'array', of: [{type: 'reference', to: {type: 'article'}}]}),
  ],
  preview: {
    select: {title: 'title', media: 'mainImage'},
  },
})




--- END OF FILE sanity/schemaTypes/articleType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/blockContentType.ts ---

// sanity/schemaTypes/blockContentType.ts

import {defineType, defineArrayMember, defineField} from 'sanity'

/**
 * This is the schema definition for the rich text fields used for
 * author biography, collaborator details, and sub-descriptions.
 **/
export default defineType({
  title: 'Block Content',
  name: 'blockContent',
  type: 'array',
  of: [
    defineArrayMember({
      title: 'Block',
      type: 'block',
      styles: [
        {title: 'Normal', value: 'normal'},
        {title: 'H1', value: 'h1'},
        {title: 'H2', value: 'h2'},
        {title: 'H3', value: 'h3'},
        {title: 'H4', value: 'h4'},
        {title: 'Quote', value: 'blockquote'},
      ],
      lists: [{title: 'Bullet', value: 'bullet'}],
      marks: {
        decorators: [
          {title: 'Strong', value: 'strong'},
          {title: 'Emphasis', value: 'em'},
        ],
        annotations: [
          {
            title: 'URL',
            name: 'link',
            type: 'object',
            fields: [
              defineField({
                title: 'URL',
                name: 'href',
                type: 'url',
              }),
            ],
          },
          {
            name: 'color',
            title: 'Color',
            type: 'object',
            fields: [
              {
                name: 'hex',
                title: 'Hex',
                type: 'string',
              },
            ],
          },
        ],
      },
    }),
    defineArrayMember({
      type: 'image',
      options: {hotspot: true},
    }),
    defineArrayMember({
      type: 'imageCompare',
    }),
    defineArrayMember({
      type: 'twoImageGrid',
    }),
    defineArrayMember({
      type: 'fourImageGrid',
    }),
    defineArrayMember({
      type: 'gameDetails',
    }),
    defineArrayMember({
      // ADDED
      type: 'table',
    }),
    defineArrayMember({
      type: 'youtube',
    }),
  ],
})




--- END OF FILE sanity/schemaTypes/blockContentType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/developerType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
  name: 'developer',
  title: 'Developer',
  type: 'document',
  fields: [
    defineField({
      name: 'title',
      title: 'Name',
      type: 'string',
      validation: (Rule) => Rule.required(),
    }),
    defineField({
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'title',
        maxLength: 96,
      },
      validation: (Rule) => Rule.required(),
    }),
  ],
})




--- END OF FILE sanity/schemaTypes/developerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/fourImageGridType.ts ---

// sanity/schemaTypes/fourImageGridType.ts
import { defineType, defineField } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'fourImageGrid',
    title: 'Four Image Grid',
    type: 'object',
    fields: [
        defineField({ name: 'image1', title: 'Image 1', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image2', title: 'Image 2', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image3', title: 'Image 3', type: 'image', options: { hotspot: true } }),
        defineField({ name: 'image4', title: 'Image 4', type: 'image', options: { hotspot: true } }),
    ],
    preview: {
        select: { media: 'image1' },
        prepare({ media }: { media: Image }) {
            return { title: 'Four Image Grid', media };
        },
    },
});







--- END OF FILE sanity/schemaTypes/fourImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameDetailsType.ts ---

// sanity/schemaTypes/gameDetailsType.ts
import { defineType, defineField, defineArrayMember } from 'sanity';

export default defineType({
  name: 'gameDetails',
  title: 'Game Details',
  type: 'object',
  fields: [
    defineField({
      name: 'details',
      title: 'Details',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          name: 'detailItem',
          fields: [
            defineField({
              name: 'label',
              title: 'Label (Arabic)',
              type: 'string',
              validation: (Rule) => Rule.required(),
            }),
            defineField({
              name: 'value',
              title: 'Value (English or Arabic)',
              type: 'string',
              validation: (Rule) => Rule.required(),
            }),
          ],
          preview: {
            select: {
              title: 'value',
              subtitle: 'label',
            },
          },
        }),
      ],
    }),
    defineField({
      name: 'width',
      title: 'Width',
      type: 'string',
      readOnly: true,
      description: 'This value is set automatically by resizing the block in the editor.',
    }),
  ],
  preview: {
    select: {
      details: 'details',
    },
    prepare({ details }) {
      const count = details ? details.length : 0;
      return {
        title: 'Game Details Block',
        subtitle: `${count} detail(s)`,
      };
    },
  },
});




--- END OF FILE sanity/schemaTypes/gameDetailsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameReleaseType.ts ---

// sanity/schemaTypes/gameReleaseType.ts

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'gameRelease',
title: 'Game Release',
type: 'document',
fields: [
    defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
    defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
    defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
    
    // Pinning and Trailer
    defineField({
        name: 'isPinned', 
        title: 'Pin to Top', 
        type: 'boolean', 
        initialValue: false
    }),
    defineField({
        name: 'trailer',
        title: 'Trailer URL (YouTube)',
        type: 'url'
    }),

    // DATE & TBA
    defineField({name: 'releaseDate', title: 'Release Date', type: 'date'}),
    // THE FIX: Added datePrecision field to store the user's intent (Year vs Month vs Day)
    defineField({
        name: 'datePrecision', 
        title: 'Date Precision', 
        type: 'string', 
        options: {list: ['day', 'month', 'year']},
        initialValue: 'day'
    }),
    defineField({name: 'isTBA', title: 'Is TBA?', type: 'boolean', initialValue: false}),

    // METADATA
    defineField({name: 'price', title: 'Price (e.g. $69.99)', type: 'string'}), 
    
    defineField({
        name: 'developer', 
        title: 'Developer', 
        type: 'reference', 
        to: [{type: 'developer'}]
    }),
    defineField({
        name: 'publisher', 
        title: 'Publisher', 
        type: 'reference', 
        to: [{type: 'publisher'}]
    }),

    defineField({name: 'platforms', title: 'Platforms', type: 'array', of: [{type: 'string'}], options: {list: ['PC', 'PlayStation', 'Xbox', 'Switch']}}),
    
    // NEW SUBSCRIPTION FIELDS
    defineField({name: 'onGamePass', title: 'On Game Pass?', type: 'boolean', initialValue: false}),
    defineField({name: 'onPSPlus', title: 'On PS Plus?', type: 'boolean', initialValue: false}),

    defineField({name: 'mainImage', title: 'Main Image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
    defineField({name: 'synopsis', title: 'Synopsis', type: 'text', validation: (Rule) => Rule.required()}),
    defineField({name: 'tags', title: 'Tags (Genres)', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
    defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
    defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', subtitle: 'releaseDate', media: 'mainImage'},
},
})




--- END OF FILE sanity/schemaTypes/gameReleaseType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/gameType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'game',
title: 'Game',
type: 'document',
fields: [
defineField({
name: 'title',
title: 'Title',
type: 'string',
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'slug',
title: 'Slug',
type: 'slug',
options: {
source: 'title',
maxLength: 96,
},
validation: (Rule) => Rule.required(),
}),
defineField({
name: 'mainImage',
title: 'Main Image',
type: 'image',
options: {
hotspot: true,
},
}),
],
})







--- END OF FILE sanity/schemaTypes/gameType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/homepageSettingsType.ts ---

import {defineField, defineType} from 'sanity'
import {HomeIcon} from '@sanity/icons'

export default defineType({
  name: 'homepageSettings',
  title: 'Homepage Settings',
  type: 'document',
  icon: HomeIcon,
  fields: [
    defineField({
      name: 'releasesCredits',
      title: 'Releases Section Credits',
      description: 'The team members credited for curating the releases timeline.',
      type: 'array',
      of: [{
        type: 'reference', 
        to: [
          {type: 'reviewer'}, 
          {type: 'author'}, 
          {type: 'reporter'}, 
          {type: 'designer'}
        ]
      }],
      validation: (Rule) => Rule.unique(),
    }),
  ],
  preview: {
    prepare() {
      return {
        title: 'Homepage Settings',
      }
    },
  },
})




--- END OF FILE sanity/schemaTypes/homepageSettingsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/imageCompareType.ts ---

// sanity/schemaTypes/imageCompareType.ts
import { defineType, defineField, Rule } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'imageCompare',
    title: 'Image Comparison',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1 (Before)',
            type: 'image',
            options: { hotspot: true },
            validation: (Rule) => Rule.required(),
        }),
        defineField({
            name: 'image2',
            title: 'Image 2 (After)',
            type: 'image',
            options: { hotspot: true },
            validation: (Rule) => Rule.required(),
        }),
        defineField({
            name: 'size',
            title: 'Display Size',
            type: 'string',
            options: {
                list: [
                    { title: 'Small', value: 'small' },
                    { title: 'Medium', value: 'medium' },
                    { title: 'Large', value: 'large' },
                ],
                layout: 'radio',
            },
            initialValue: 'large',
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }: { media?: Image, media2?: Image }) {
            return {
                title: 'Image Comparison',
                media: media || media2,
            };
        },
    },
});







--- END OF FILE sanity/schemaTypes/imageCompareType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/index.ts ---

// sanity/schemaTypes/index.ts
import blockContent from './blockContentType'
import tag from './tagType'
import review from './reviewType'
import article from './articleType'
import news from './newsType'
import game from './gameType'
import gameRelease from './gameReleaseType'
import developer from './developerType' 
import publisher from './publisherType' 
import imageCompare from './imageCompareType'
import twoImageGrid from './twoImageGridType'
import fourImageGrid from './fourImageGridType'
import gameDetails from './gameDetailsType'
import table from './tableType'
import author from './creators/authorType'
import designer from './creators/designerType'
import reporter from './creators/reporterType'
import reviewer from './creators/reviewerType'
import colorDictionary from './custom_inputs/colorDictionaryType'
import youtube from './custom_objects/youtubeType'
import homepageSettings from './homepageSettingsType'
import aboutPageSettings from './aboutPageSettingsType'

export const schemaTypes = [
  // Documents
  review,
  article,
  news,
  game,
  gameRelease,
  tag,
  developer, 
  publisher, 
  // Creators
  author,
  designer,
  reporter,
  reviewer,
  // Singleton Documents
  colorDictionary,
  homepageSettings,
  aboutPageSettings,
  // Objects & Custom Inputs
  blockContent,
  imageCompare,
  twoImageGrid,
  fourImageGrid,
  gameDetails,
  table,
  youtube,
]

--- END OF FILE sanity/schemaTypes/index.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/newsType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'news',
    title: 'News',
    type: 'document',
    fields: [
        defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
        defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
        defineField({
            name: 'newsType',
            title: 'Classification',
            type: 'string',
            options: {
                list: [
                    { title: 'Official', value: 'official' },
                    { title: 'Rumor', value: 'rumor' },
                    { title: 'Leak', value: 'leak' }
                ],
                layout: 'radio',
                direction: 'horizontal'
            },
            initialValue: 'official',
            validation: (Rule) => Rule.required()
        }),
        defineField({name: 'reporters', title: 'Reporters', type: 'array', of: [{type: 'reference', to: {type: 'reporter'}}], validation: (Rule) => Rule.required().min(1)}),
        defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
        defineField({
            name: 'category',
            title: 'Category',
            type: 'reference',
            to: {type: 'tag'},
            options: {
                filter: 'category == "News"'
            },
            validation: (Rule) => Rule.required()
        }),
        defineField({name: 'game', title: 'Game (Optional)', type: 'reference', to: {type: 'game'}}),
        defineField({name: 'mainImage', title: 'Main Image (Horizontal)', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
        defineField({name: 'mainImageVertical', title: 'Vertical Image (Vanguard)', type: 'image', options: {hotspot: true}}),
        defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
        defineField({name: 'content', title: 'Content', type: 'blockContent'}),
        defineField({name: 'relatedNews', title: 'Related News', type: 'array', of: [{type: 'reference', to: {type: 'news'}}]}),
        defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
    ],
    preview: {
        select: {title: 'title', media: 'mainImage', category: 'category.title'},
        prepare(selection) {
            const { category } = selection
            return {...selection, subtitle: category}
        }
    },
})




--- END OF FILE sanity/schemaTypes/newsType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/publisherType.ts ---

// sanity/schemaTypes/publisherType.ts
import {defineField, defineType, Rule} from 'sanity'

export default defineType({
  name: 'publisher',
  title: 'Publisher',
  type: 'document',
  fields: [
    defineField({
      name: 'title',
      title: 'Name',
      type: 'string',
      validation: (Rule) => Rule.required(),
    }),
    defineField({
      name: 'slug',
      title: 'Slug',
      type: 'slug',
      options: {
        source: 'title',
        maxLength: 96,
      },
      validation: (Rule) => Rule.required(),
    }),
  ],
})

--- END OF FILE sanity/schemaTypes/publisherType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/reviewType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
  name: 'review',
  title: 'Review',
  type: 'document',
  fields: [
    defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
    defineField({name: 'slug', title: 'Slug', type: 'slug', options: {source: 'title', maxLength: 96}, validation: (Rule) => Rule.required()}),
    defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
    defineField({name: 'authors', title: 'Reviewers', type: 'array', of: [{type: 'reference', to: {type: 'reviewer'}}], validation: (Rule) => Rule.required().min(1)}),
    defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
    defineField({name: 'mainImage', title: 'Main Image (Horizontal)', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
    defineField({name: 'mainImageVertical', title: 'Vertical Image (Vanguard)', type: 'image', options: {hotspot: true}}),
    defineField({name: 'score', title: 'Score', type: 'number', validation: (Rule) => Rule.required().min(0).max(10)}),
    defineField({name: 'verdict', title: 'Verdict', type: 'string', validation: (Rule) => Rule.required()}),
    defineField({name: 'pros', title: 'Pros', type: 'array', of: [{type: 'string'}]}),
    defineField({name: 'cons', title: 'Cons', type: 'array', of: [{type: 'string'}]}),
    defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
    defineField({name: 'publishedAt', title: 'Published at', type: 'datetime'}),
    defineField({name: 'content', title: 'Content', type: 'blockContent', validation: (Rule) => Rule.required()}),
    defineField({name: 'relatedReviews', title: 'Related Reviews', type: 'array', of: [{type: 'reference', to: {type: 'review'}}]}),
    defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
  ],
  preview: {
    select: {title: 'title', author: 'authors.0.name', media: 'mainImage'},
    prepare(selection: {author: string}) {
      const {author} = selection
      return {...selection, subtitle: author && `by ${author}`}
    },
  },
})




--- END OF FILE sanity/schemaTypes/reviewType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/tableType.ts ---

// sanity/schemaTypes/tableType.ts
import {defineType, defineField, defineArrayMember} from 'sanity'
import {ListIcon} from '@sanity/icons'

export default defineType({
  name: 'table',
  title: 'Table',
  type: 'object',
  icon: ListIcon,
  fields: [
    defineField({
      name: 'rows',
      title: 'Rows',
      type: 'array',
      of: [
        defineArrayMember({
          type: 'object',
          name: 'row',
          fields: [
            defineField({
              name: 'cells',
              title: 'Cells',
              type: 'array',
              of: [
                defineArrayMember({
                  type: 'object',
                  name: 'cell',
                  fields: [
                    defineField({
                      name: 'content',
                      title: 'Content',
                      type: 'array',
                      of: [defineArrayMember({type: 'block'})],
                    }),
                    defineField({
                      name: 'isHeader',
                      title: 'Is Header Cell?',
                      type: 'boolean',
                      initialValue: false,
                    }),
                  ],
                  preview: {
                    select: {
                      content: 'content',
                    },
                    prepare({content}) {
                      const text = content?.[0]?.children?.[0]?.text || 'Empty Cell'
                      return {title: text}
                    },
                  },
                }),
              ],
            }),
          ],
        }),
      ],
    }),
  ],
  preview: {
    select: {
      rows: 'rows',
    },
    prepare({rows}) {
      const rowCount = rows ? rows.length : 0
      const colCount = rows?.[0]?.cells?.length || 0
      return {
        title: 'Table Block',
        subtitle: rowCount > 0 ? `${rowCount} rows, ${colCount} columns` : 'Empty table',
      }
    },
  },
})




--- END OF FILE sanity/schemaTypes/tableType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/tagType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'tag',
    title: 'Tag',
    type: 'document',
    fields: [
        defineField({
            name: 'title',
            title: 'Title',
            type: 'string',
        }),
        defineField({
            name: 'slug',
            title: 'Slug',
            type: 'slug',
            options: {
                source: 'title',
                maxLength: 96,
            },
        }),
        defineField({
            name: 'category',
            title: 'Category',
            type: 'string',
            options: {
                list: [
                    { title: 'Game Tag (For Reviews & Releases)', value: 'Game' },
                    { title: 'Article Category (For Articles)', value: 'Article' },
                    { title: 'News Category (For News)', value: 'News' }
                ],
                layout: 'radio'
            },
            validation: (Rule) => Rule.required(),
            initialValue: 'Game'
        }),
    ],
})




--- END OF FILE sanity/schemaTypes/tagType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/twoImageGridType.ts ---

// sanity/schemaTypes/twoImageGridType.ts
import { defineType, defineField } from 'sanity';
import { Image } from '@sanity/types';

export default defineType({
    name: 'twoImageGrid',
    title: 'Two Image Grid',
    type: 'object',
    fields: [
        defineField({
            name: 'image1',
            title: 'Image 1',
            type: 'image',
            options: { hotspot: true },
        }),
        defineField({
            name: 'image2',
            title: 'Image 2',
            type: 'image',
            options: { hotspot: true },
        }),
    ],
    preview: {
        select: {
            media: 'image1',
            media2: 'image2',
        },
        prepare({ media, media2 }: { media?: Image, media2?: Image }) {
            return {
                title: 'Two Image Grid',
                media: media || media2,
            };
        },
    },
});







--- END OF FILE sanity/schemaTypes/twoImageGridType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/authorType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'author',
    title: 'Author', // For Articles
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})







--- END OF FILE sanity/schemaTypes/creators/authorType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/designerType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'designer',
    title: 'Designer',
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})







--- END OF FILE sanity/schemaTypes/creators/designerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reporterType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'reporter',
    title: 'Reporter', // For News
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})







--- END OF FILE sanity/schemaTypes/creators/reporterType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
    name: 'reviewer',
    title: 'Reviewer', // For Reviews
    type: 'document',
    fields: [
        defineField({ name: 'name', title: 'Name', type: 'string', readOnly: true }),
        defineField({ name: 'prismaUserId', title: 'Prisma User ID', type: 'string', readOnly: true, validation: (Rule) => Rule.unique()}),
        defineField({ name: 'image', title: 'Image', type: 'image', options: {hotspot: true}}),
        defineField({ name: 'bio', title: 'Bio', type: 'text', readOnly: true }),
    ],
    preview: { select: { title: 'name', media: 'image' }},
})







--- END OF FILE sanity/schemaTypes/creators/reviewerType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom_inputs/colorDictionaryType.ts ---

// sanity/schemaTypes/custom_inputs/colorDictionaryType.ts
import {defineField, defineType} from 'sanity'
import {ColorWheelIcon} from '@sanity/icons'
import React from 'react' // ADDED: Import React

export default defineType({
  name: 'colorDictionary',
  title: 'Color Dictionary',
  type: 'document',
  icon: ColorWheelIcon,
  fields: [
    defineField({
      name: 'title',
      title: 'Title',
      type: 'string',
      hidden: true, // This is a singleton, title is not needed for display
    }),
    defineField({
      name: 'autoColors',
      title: 'Automatic Word Colors',
      description: 'Define words that should be automatically colored when typed in the editor.',
      type: 'array',
      of: [
        {
          type: 'object',
          name: 'colorMapping',
          fields: [
            defineField({
              name: 'word',
              title: 'Word',
              type: 'string',
              description: 'The exact word to color (case-sensitive).',
              validation: (Rule) => Rule.required(),
            }),
            defineField({
              name: 'color',
              title: 'Color',
              type: 'string',
              description: 'The hex color code (e.g., #00E5FF).',
              validation: (Rule) =>
                Rule.required().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, {
                  name: 'hexColor',
                  invert: false,
                }),
            }),
          ],
          preview: {
            select: {
              title: 'word',
              subtitle: 'color',
            },
            prepare({title, subtitle}) {
              return {
                title: title,
                subtitle: subtitle,
                // THE DEFINITIVE FIX: Use a function that returns a React element
                // This is valid in a .ts file and avoids the JSX syntax error.
                media: React.createElement('div', {
                  style: {
                    backgroundColor: subtitle || 'grey',
                    width: '100%',
                    height: '100%',
                  },
                }),
              }
            },
          },
        },
      ],
    }),
  ],
})




--- END OF FILE sanity/schemaTypes/custom_inputs/colorDictionaryType.ts ---

================================================================================

--- START OF FILE sanity/schemaTypes/custom_objects/youtubeType.ts ---

// sanity/schemaTypes/custom_objects/youtubeType.ts
import {defineType, defineField} from 'sanity'
import {PlayIcon} from '@sanity/icons'

export default defineType({
  name: 'youtube',
  title: 'YouTube Embed',
  type: 'object',
  icon: PlayIcon,
  fields: [
    defineField({
      name: 'url',
      title: 'YouTube Video URL',
      type: 'url',
      validation: (Rule) =>
        Rule.required().regex(
          /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/,
          {
            name: 'youtube-url',
            invert: false,
          },
        ),
    }),
  ],
  preview: {
    select: {
      url: 'url',
    },
    prepare({url}) {
      return {
        title: 'YouTube Embed',
        subtitle: url,
      }
    },
  },
})




--- END OF FILE sanity/schemaTypes/custom_objects/youtubeType.ts ---

================================================================================

--- START OF FILE sanity/scripts/backfillLegacyIds.ts ---

// This is a standalone script to be executed with tsx or ts-node.
// It loads environment variables from the root .env file.
import 'dotenv/config';
import { createClient } from '@sanity/client';

// --- Script Configuration ---
const projectId = process.env.SANITY_PROJECT_ID;
const dataset = process.env.SANITY_DATASET;
const token = process.env.SANITY_API_WRITE_TOKEN;
const apiVersion = '2025-09-28';
const DOC_TYPES = ['review', 'article', 'news', 'gameRelease'];

// --- Validation ---
if (!projectId || !dataset || !token) {
  console.error('Error: Missing SANITY_PROJECT_ID, SANITY_DATASET, or SANITY_API_WRITE_TOKEN in your root .env file.');
  process.exit(1);
}

// --- Create a dedicated, authenticated Sanity client for this script ---
const client = createClient({
  projectId,
  dataset,
  token,
  apiVersion,
  useCdn: false, // Always use fresh data for a script
});

async function backfillLegacyIds() {
  console.log('Starting comprehensive backfill process for legacyIds...');

  // 1. Fetch ALL documents of the relevant types to identify duplicates and find the max ID.
  const query = `*[_type in $types] {_id, _type, title, legacyId}`;
  const allDocs = await client.fetch<{ _id: string, _type: string, title: string, legacyId: number | null }[]>(query, { types: DOC_TYPES });

  if (allDocs.length === 0) {
    console.log('No documents found to process.');
    return;
  }

  // 2. Find the true highest legacyId and identify all documents that need patching.
  const seenIds = new Set<number>();
  const docsToPatch: { _id: string, _type: string, title: string }[] = [];
  let maxId = 0;

  for (const doc of allDocs) {
    if (doc.legacyId !== null && doc.legacyId !== undefined) {
      if (seenIds.has(doc.legacyId)) {
        // This is a duplicate ID, mark for patching.
        docsToPatch.push(doc);
      } else {
        // This is the first time we've seen this ID, it's valid for now.
        seenIds.add(doc.legacyId);
        if (doc.legacyId > maxId) {
          maxId = doc.legacyId;
        }
      }
    } else {
      // The ID is missing entirely, mark for patching.
      docsToPatch.push(doc);
    }
  }

  if (docsToPatch.length === 0) {
    console.log('All documents have unique legacyIds. No action needed.');
    return;
  }

  console.log(`Current highest unique legacyId found: ${maxId}`);
  console.log(`Found ${docsToPatch.length} documents with missing or duplicate legacyIds. Starting patching process...`);

  // 3. Create a transaction to patch all corrupt documents.
  let currentIdCounter = maxId;
  const transaction = client.transaction();

  docsToPatch.forEach(doc => {
    currentIdCounter++;
    console.log(`  - Assigning NEW legacyId: ${currentIdCounter} to document [${doc._type}] "${doc.title}" (${doc._id})`);
    transaction.patch(doc._id, { set: { legacyId: currentIdCounter } });
  });

  // 4. Commit the transaction.
  try {
    const result = await transaction.commit();
    console.log(`Successfully patched ${result.results.length} documents.`);
    console.log('Backfill complete. Your data is now consistent.');
  } catch (error) {
    console.error('An error occurred while committing the transaction:', error);
    console.error('No documents were حُدِّثت. Please try again or check your Sanity token permissions.');
  }
}

// Execute the function
backfillLegacyIds();




--- END OF FILE sanity/scripts/backfillLegacyIds.ts ---

================================================================================

--- START OF FILE sanity/scripts/deleteOrphanedAssets.ts ---

// sanity/scripts/deleteOrphanedAssets.ts
// Run this script with: npx tsx sanity/scripts/deleteOrphanedAssets.ts

import 'dotenv/config';
import { createClient } from '@sanity/client';

const projectId = process.env.SANITY_PROJECT_ID;
const dataset = process.env.SANITY_DATASET;
const token = process.env.SANITY_API_WRITE_TOKEN;
const apiVersion = '2025-09-28';

if (!projectId || !dataset || !token) {
  console.error('Error: Missing Sanity environment variables.');
  process.exit(1);
}

const client = createClient({
  projectId,
  dataset,
  token,
  apiVersion,
  useCdn: false,
});

async function deleteOrphanedAssets() {
  console.log('Scanning for orphaned assets...');

  // 1. Find all image assets that are NOT referenced by any document
  // count(*[references(^._id)]) == 0 checks if nothing refers to this asset ID
  const query = `*[_type == "sanity.imageAsset" && count(*[references(^._id)]) == 0]._id`;
  
  const orphanedIds = await client.fetch<string[]>(query);

  if (orphanedIds.length === 0) {
    console.log('No orphaned assets found. Your Sanity is clean.');
    return;
  }

  console.log(`Found ${orphanedIds.length} orphaned assets. Deleting...`);

  // 2. Batch delete
  const transaction = client.transaction();
  orphanedIds.forEach(id => {
    transaction.delete(id);
  });

  try {
    await transaction.commit();
    console.log('Cleanup complete. Storage space reclaimed.');
  } catch (error) {
    console.error('Failed to delete assets:', error);
  }
}

deleteOrphanedAssets();




--- END OF FILE sanity/scripts/deleteOrphanedAssets.ts ---

================================================================================

--- START OF FILE types/index.ts ---

// types/index.ts
import type { SanityAuthor } from "./sanity";

// This type represents the standardized data structure for all content cards,
// as produced by the `adaptToCardProps` adapter.
export type CardProps = {
    type: 'review' | 'article' | 'news';
    id: string; // Sanity _id
    legacyId: number; // Numeric legacy ID
    slug: string;
    game?: string;
    gameSlug?: string;
    title: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    date?: string;
    year?: number | null;
    imageUrl: string;
    verticalImageUrl?: string | null; // Added: Optional vertical image
    mainImageRef?: any;
    mainImageVerticalRef?: any; // Added: Raw ref for vertical image
    score?: number;
    tags: { title: string, slug: string }[];
    blurDataURL: string;
    category?: string; 
    newsType?: 'official' | 'rumor' | 'leak'; 
    verdict?: string;
    pros?: any[];
    cons?: any[];
    content?: any[];
    relatedReviewIds?: any[];
    synopsis?: string;
    
    // NEW: Release Specific Fields (Optional for other types)
    onGamePass?: boolean;
    onPSPlus?: boolean;
    trailer?: string;
    isPinned?: boolean;
    datePrecision?: 'day' | 'month' | 'year'; 
    isTBA?: boolean;
};

export type EngagementScore = { id: number; engagementScore: number };




--- END OF FILE types/index.ts ---

================================================================================

--- START OF FILE types/sanity.ts ---

// types/sanity.ts
import type { Image, PortableTextBlock } from '@sanity/types'

// ... (Existing Interfaces keep same) ...
export interface SanityImage extends Image {
    url: string;
    blurDataURL: string;
    alt?: string;
}

export interface SanityTag {
    _id: string;
    title: string;
    slug: string;
}

export interface SanityAuthor {
    _id: string;
    name: string;
    slug: string;
    prismaUserId: string;
    username?: string | null;
    image?: string | null;
    bio?: string | null;
}

export interface SanityGame {
    _id: string;
    title: string;
    slug: string;
    mainImage?: SanityImage;
}

export interface SanityDeveloper {
    _id: string;
    title: string;
    slug: string;
}

export interface SanityPublisher {
    _id: string;
    title: string;
    slug: string;
}

export interface SanityReview {
    _id: string;
    _type: 'review';
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { _id: string, title: string };
    mainImage: SanityImage;
    mainImageVertical?: SanityImage; // Added
    score: number;
    verdict: string;
    pros: string[];
    cons: string[];
    content: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string;
    relatedReviews: {
        _id: string;
        legacyId: number;
        title: string;
        slug: string;
        mainImage: SanityImage;
        score: number;
        author: { name: string };
        publishedAt: string;
    }[];
}

export interface SanityArticle {
    _id: string;
    _type: 'article';
    legacyId: number;
    title: string;
    slug: string;
    authors: SanityAuthor[];
    designers?: SanityAuthor[];
    game: { title: string };
    mainImage: SanityImage;
    mainImageVertical?: SanityImage; // Added
    content?: PortableTextBlock[];
    tags: { _id: string, title: string }[];
    publishedAt: string; 
    relatedArticles?: any[];
}

export interface SanityNews {
    _id: string;
    _type: 'news';
    legacyId: number;
    title: string;
    slug: string;
    newsType: 'official' | 'rumor' | 'leak'; 
    reporters: SanityAuthor[];
    designers?: SanityAuthor[];
    mainImage: SanityImage;
    mainImageVertical?: SanityImage; // Added
    category: string;
    tags: { _id: string, title: string }[];
    publishedAt: string; 
    content?: PortableTextBlock[];
}

export interface SanityGameRelease {
    _id: string;
    legacyId: number;
    title: string;
    slug: string;
    releaseDate: string;
    datePrecision?: 'day' | 'month' | 'year';
    isTBA?: boolean;       
    price?: string;        
    developer?: SanityDeveloper; 
    publisher?: SanityPublisher; 
    platforms: ('PC' | 'PlayStation' | 'PlayStation 5' | 'Xbox' | 'Switch')[];
    synopsis: string;
    mainImage: SanityImage;
    tags?: SanityTag[]; 
    isPinned?: boolean;
    trailer?: string;
}

// UPDATED SEARCH RESULT INTERFACE
export interface SanitySearchResult {
    _id: string;
    legacyId: number;
    _type: 'review' | 'article' | 'news';
    title: string;
    slug: string;
    imageUrl?: string;
    blurDataURL?: string;
    publishedAt?: string;
    authors?: SanityAuthor[];
    reporters?: SanityAuthor[];
    game?: string;
    tags?: { title: string, slug: string }[];
    category?: string;
    newsType?: 'official' | 'rumor' | 'leak';
    score?: number;
}

--- END OF FILE types/sanity.ts ---

================================================================================

