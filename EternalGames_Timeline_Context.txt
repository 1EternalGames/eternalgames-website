--- START OF FILE app\releases\page.tsx ---

// app/releases/page.tsx

import { client } from '@/lib/sanity.client';
import { allReleasesQuery } from '@/lib/sanity.queries';
import type { SanityGameRelease } from '@/types/sanity';
import ReleasePageClient from './ReleasePageClient';

export default async function ReleasesPage() {
  const releases: SanityGameRelease[] = await client.fetch(allReleasesQuery);

  const sanitizedReleases = (releases || []).filter(item =>
    item?.mainImage?.url && item.releaseDate && item.title && item.slug
  );

  return (
    <div className="container page-container" style={{ paddingTop: 'calc(var(--nav-height-scrolled) + 2rem)' }}>
      <ReleasePageClient releases={sanitizedReleases} />
    </div>
  );
}

--- END OF FILE app\releases\page.tsx ---

================================================================================

--- START OF FILE app\releases\ReleasePageClient.tsx ---

// app/releases/ReleasePageClient.tsx
'use client';

import { useState, useMemo, useRef } from 'react';
import type { SanityGameRelease } from '@/types/sanity';
import TimelineCard from '@/components/TimelineCard';
import { motion, useInView, AnimatePresence } from 'framer-motion';
import styles from './ReleasesPage.module.css';
import filterStyles from '@/components/filters/Filters.module.css';

type Platform = 'الكل' | 'PC' | 'PlayStation' | 'Xbox' | 'Switch';
const PLATFORMS: Platform[] = ['الكل', 'PC', 'PlayStation', 'Xbox', 'Switch'];
const PLATFORM_LABELS: Record<Platform, string> = { 'الكل': 'الكل', 'PC': 'PC', 'PlayStation': 'PlayStation', 'Xbox': 'Xbox', 'Switch': 'Switch' };

const PlatformFilters = ({ activeFilter, onFilterChange }: { activeFilter: Platform, onFilterChange: (platform: Platform) => void }) => {
  const ref = useRef(null);
  const isInView = useInView(ref, { once: true, amount: 0.5 });
  const animationVariants = { 
    hidden: { opacity: 0, y: 50 }, 
    visible: { opacity: 1, y: 0, transition: { duration: 0.6, ease: 'easeOut' as const } } 
  };
  
  const allButton = PLATFORMS[0];
  const otherPlatforms = PLATFORMS.slice(1);

  return (
    <motion.div ref={ref} variants={animationVariants} initial="hidden" animate={isInView ? 'visible' : 'hidden'} className={styles.platformFilters}>
      <span>تصفية حسب المنصة:</span>
      <div className={styles.filterLayout}>
        <div className={`${filterStyles.filterButtonsGroup} ${styles.allButtonContainer}`}>
            <motion.button 
                key={allButton} 
                onClick={() => onFilterChange(allButton)} 
                className={`${filterStyles.filterButton} ${activeFilter === allButton ? filterStyles.active : ''}`} 
                whileHover={{ scale: 1.05 }} 
                whileTap={{ scale: 0.95 }}
            >
              {PLATFORM_LABELS[allButton]}
              {activeFilter === allButton && ( <motion.div layoutId="release-filter-highlight" className={filterStyles.filterHighlight} transition={{ type: 'spring', stiffness: 300, damping: 25 }}/> )}
            </motion.button>
        </div>
        <div className={filterStyles.filterButtonsGroup}>
            {otherPlatforms.map(platform => {
              const isActive = activeFilter === platform;
              return (
                <motion.button 
                    key={platform} 
                    onClick={() => onFilterChange(platform)} 
                    className={`${filterStyles.filterButton} ${isActive ? filterStyles.active : ''}`} 
                    whileHover={{ scale: 1.05 }} 
                    whileTap={{ scale: 0.95 }}
                >
                  {PLATFORM_LABELS[platform as Platform]}
                  {isActive && ( <motion.div layoutId="release-filter-highlight" className={filterStyles.filterHighlight} transition={{ type: 'spring', stiffness: 300, damping: 25 }}/> )}
                </motion.button>
              );
            })}
        </div>
      </div>
    </motion.div>
  );
};

export default function ReleasePageClient({ releases }: { releases: SanityGameRelease[] }) {
  const [activeFilter, setActiveFilter] = useState<Platform>('الكل');
  const mainRef = useRef(null);
  const isInView = useInView(mainRef, { once: true, amount: 0.1 });
  
  const flatAnimatedContent = useMemo(() => {
    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    
    const sortedReleases = [...releases].sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    
    const isFilteringActive = activeFilter !== 'الكل';
    const filteredReleases = isFilteringActive 
        ? sortedReleases.filter(release => {
            if (!release.platforms) return false;
            // THE DEFINITIVE FIX: Check for both "PlayStation" and the legacy "PlayStation 5" value.
            if (activeFilter === 'PlayStation') {
                return release.platforms.includes('PlayStation') || release.platforms.includes('PlayStation 5');
            }
            return release.platforms.includes(activeFilter);
        }) 
        : sortedReleases;
    
    let currentMonth = '';
    let flatList: { type: 'header' | 'card', key: string, data: SanityGameRelease | string }[] = [];

    filteredReleases.forEach(release => {
      const date = new Date(release.releaseDate);
      const monthIndex = date.getUTCMonth();
      const monthLabel = `${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;
      
      if (monthLabel !== currentMonth) {
        currentMonth = monthLabel;
        flatList.push({ type: 'header', key: `header-${monthLabel}-${date.getFullYear()}`, data: monthLabel });
      }
      flatList.push({ type: 'card', key: `card-${release._id}`, data: release });
    });
    return flatList;
  }, [releases, activeFilter]);

  const cardVariants = { initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, };
  const isListEmpty = flatAnimatedContent.length === 0 && activeFilter !== 'الكل';

  return (
    <div className={styles.chronoStreamLayoutWrapper}>
      <div className={styles.chronoContentWrapper}>
          <h1 className="page-title">إصدارات 2025 المُرتقبة</h1>
          <PlatformFilters activeFilter={activeFilter} onFilterChange={setActiveFilter} />
      </div>
      <div ref={mainRef} className={styles.chronoTimelineSections} style={{ position: 'relative' }}>
          <motion.div layout className={styles.chronoGamesGrid} initial="hidden" animate={isInView ? "visible" : "hidden"} transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
            <AnimatePresence>
              {isListEmpty ? (
                <motion.p key="no-results" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} style={{textAlign: 'center', color: 'var(--text-secondary)', padding: '4rem 0', gridColumn: '1 / -1'}}>
                  لا إصدارات لهذه المنصة بعد.
                </motion.p>
              ) : (
                flatAnimatedContent.map(item => {
                  if (item.type === 'header') {
                    return (
                      <motion.div key={item.key} layout style={{ gridColumn: '1 / -1', padding: '1rem 0 0 0', display: 'flex', justifyContent: 'flex-start' }} initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
                        <h2 className={styles.timelineMonthTitle}>{item.data as string}</h2>
                      </motion.div>
                    );
                  }
                  const release = item.data as SanityGameRelease;
                  return (
                    <motion.div key={item.key} layout variants={cardVariants} initial="initial" animate="animate" exit="exit" transition={{ type: 'spring', stiffness: 250, damping: 25 }}>
                      <TimelineCard release={release} />
                    </motion.div>
                  );
                })
              )}
            </AnimatePresence>
          </motion.div>
      </div>
    </div>
  );
}

--- END OF FILE app\releases\ReleasePageClient.tsx ---

================================================================================

--- START OF FILE app\releases\ReleasesPage.module.css ---

/* app/releases/ReleasesPage.module.css */

.chronoStreamLayoutWrapper {
  position: relative;
  min-height: 80vh;
  padding-bottom: 6rem;
}

.chronoContentWrapper {
  max-width: 1200px;
  margin: 0 auto;
}

.chronoTimelineSections {
  padding-top: 2rem;
  padding-right: 2rem;
  padding-left: 2rem;
}

.platformFilters {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  padding: 2rem 2rem 3rem 2rem;
  font-family: var(--font-ui);
}

.platformFilters > span {
  font-size: 1.6rem;
  font-weight: 500;
  color: var(--text-secondary);
}

.timelineMonthTitle {
  font-size: 3.6rem;
  border-bottom: none;
  padding-bottom: 0.5rem;
  display: block;
  text-align: left;
  margin: 0;
  width: max-content;
  border-bottom: 2px solid var(--accent);
  color: var(--text-primary);
  text-shadow: none;
}

.chronoGamesGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 3rem;
  margin: 0 auto;
  width: 100%;
}

.chronoGamesGrid > div[style*="grid-column: 1 / -1"] {
    margin-bottom: 1.5rem; 
}

/* --- NEW MOBILE FILTER LAYOUT STYLES --- */
.filterLayout {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 1.5rem;
    width: 100%;
    justify-content: center;
}

.allButtonContainer {
    flex-shrink: 0;
}

@media (max-width: 768px) {
    .chronoGamesGrid {
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 2rem;
    }
    .chronoTimelineSections {
        padding-right: 1rem;
        padding-left: 1rem;
    }
    .filterLayout {
        flex-direction: column;
    }
}

--- END OF FILE app\releases\ReleasesPage.module.css ---

================================================================================

--- START OF FILE components\KineticReleaseTimeline.tsx ---

// components/KineticReleaseTimeline.tsx
'use client';

import React, { useMemo, useRef, useState, useLayoutEffect } from 'react';
import { motion, useScroll, useInView, useTransform, MotionValue, AnimatePresence } from 'framer-motion';
import Link from 'next/link';
import TimelineCard from './TimelineCard';
import styles from './KineticReleaseTimeline.module.css';

const ViewAllIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" {...props}>
        <rect x="3" y="3" width="7" height="7"></rect>
        <rect x="14" y="3" width="7" height="7"></rect>
        <rect x="14" y="14" width="7" height="7"></rect>
        <rect x="3" y="14" width="7" height="7"></rect>
    </svg>
);

const SynopsisDisplay = ({ synopsis, isLeft, isInView }: { synopsis: string; isLeft: boolean; isInView: boolean; }) => {
    const [firstWord, ...rest] = synopsis.split(' ');
    const restOfText = rest.join(' ');

    return (
        <AnimatePresence>
            {isInView && (
                <motion.div
                    className={`${styles.synopsisContainer} ${isLeft ? styles.left : styles.right}`}
                    initial={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: isLeft ? 20 : -20 }}
                    transition={{ duration: 0.6, ease: [0.22, 1, 0.36, 1] }}
                >
                    <p>
                        <span className={styles.synopsisFirstWord}>{firstWord}</span>
                        {' '}{restOfText}
                    </p>
                </motion.div>
            )}
        </AnimatePresence>
    );
};


const TimelineItem = ({ release, index }: { release: any, index: number }) => {
    const itemRef = useRef(null);
    const cardIsInView = useInView(itemRef, { once: true, amount: 0.5 });
    const isLeft = index % 2 === 0;
    const variants = {
        hidden: { opacity: 0, x: isLeft ? -50 : 50, scale: 0.9 },
        visible: { opacity: 1, x: 0, scale: 1, transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] as const } }
    };

    return (
        <div ref={itemRef} className={`${styles.timelineItemWrapper} ${isLeft ? styles.left : styles.right}`}>
            <SynopsisDisplay synopsis={release.synopsis} isLeft={isLeft} isInView={cardIsInView} />
            <motion.div variants={variants} initial="hidden" animate={cardIsInView ? "visible" : "hidden"}>
                <TimelineCard release={release} />
            </motion.div>
        </div>
    );
};

const TimelineDot = ({ position, scrollYProgress }: { position: number, scrollYProgress: MotionValue<number> }) => {
    const backgroundColor = useTransform( scrollYProgress, [position - 0.01, position], ['var(--border-color)', 'var(--accent)'] );
    const boxShadow = useTransform( scrollYProgress, [position - 0.01, position], ['0 0 0px 0 rgba(0,0,0,0)', '0 0 8px 0 var(--accent)'] );
    return ( <motion.div className={styles.dot} style={{ top: `${position * 100}%`, backgroundColor: backgroundColor, boxShadow: boxShadow, }} /> );
};

export default function KineticReleaseTimeline({ releases: allReleases }: { releases: any[] }) {
    const timelineRef = useRef<HTMLDivElement>(null);
    const terminusRef = useRef(null);
    const isTerminusInView = useInView(terminusRef, { once: true, amount: 0.8 });
    const [dotPositions, setDotPositions] = useState<number[]>([]);
    const { scrollYProgress } = useScroll({ target: timelineRef, offset: ["start 50%", "end 50%"], });
    
    const releasesForThisMonth = useMemo(() => {
        if (!allReleases) return [];
        const now = new Date();
        const currentMonth = now.getUTCMonth();
        const currentYear = now.getUTCFullYear();
        
        return allReleases
            .filter(release => {
                const releaseDate = new Date(release.releaseDate + 'T00:00:00Z');
                return releaseDate.getUTCMonth() === currentMonth && releaseDate.getUTCFullYear() === currentYear; 
            })
            .sort((a, b) => new Date(a.releaseDate).getTime() - new Date(b.releaseDate).getTime());
    }, [allReleases]);

    useLayoutEffect(() => {
        if (timelineRef.current && releasesForThisMonth.length > 0) {
            const timeoutId = setTimeout(() => {
                const containerEl = timelineRef.current; if (!containerEl) return;
                const containerHeight = containerEl.scrollHeight;
                const itemElements = Array.from(containerEl.querySelectorAll(`.${styles.timelineItemWrapper}`));
                const positions = itemElements.map(el => { const item = el as HTMLElement; const top = item.offsetTop + (item.offsetHeight / 2); return top / containerHeight; });
                setDotPositions(positions);
            }, 100);
            return () => clearTimeout(timeoutId);
        }
    }, [releasesForThisMonth]);

    return (
        <div ref={timelineRef} className={styles.timelineContainer}>
            <div className={styles.timelineSpine}>
                <div className={styles.timelineSpineTrack} />
                <motion.div className={styles.timelineSpineProgress} style={{ scaleY: scrollYProgress }} />
                <div className={styles.dotsContainer}>
                    {dotPositions.map((pos, index) => ( <TimelineDot key={index} position={pos} scrollYProgress={scrollYProgress} /> ))}
                </div>
            </div>
            <div className={styles.timelineItemsWrapper}>
                {releasesForThisMonth.length > 0 ? (
                    releasesForThisMonth.map((release, index) => ( <TimelineItem key={release._id} release={release} index={index} /> ))
                ) : (
                    <motion.div style={{ paddingTop: '20vh', textAlign: 'center', color: 'var(--text-secondary)', width: '100%' }} initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.8, delay: 0.8, ease: 'easeOut' as const }}>لا إصدارات مجدولة لهذا الشهر.</motion.div>
                )}
            </div>

            {releasesForThisMonth.length > 0 && (
                <motion.div
                    ref={terminusRef}
                    className={styles.terminusContainer}
                    initial={{ opacity: 0, y: 30 }}
                    animate={isTerminusInView ? { opacity: 1, y: 0 } : {}}
                    transition={{ duration: 0.6, ease: 'easeOut', delay: 0.3 }}
                >
                    <motion.div 
                        whileHover={{ scale: 1.05 }}
                        whileTap={{ scale: 0.95 }}
                        style={{ display: 'inline-block' }}
                    >
                        <Link href="/releases" className={`${styles.timelineTerminusButton} no-underline`}>
                            <ViewAllIcon className={styles.terminusIcon} />
                            <span>عرض كل الإصدارات</span>
                        </Link>
                    </motion.div>
                </motion.div>
            )}
        </div>
    );
}




--- END OF FILE components\KineticReleaseTimeline.tsx ---

================================================================================

--- START OF FILE components\KineticReleaseTimeline.module.css ---

/* components/KineticReleaseTimeline.module.css */
.timelineContainer {
  position: relative;
  max-width: 760px;
  margin: 0 auto;
  padding: 4rem 2rem;
}
.timelineSpine {
  position: absolute;
  top: 0;
  right: 50%;
  transform: translateX(50%);
  width: 2px;
  height: 100%;
  z-index: 1;
}
.timelineSpineTrack {
  width: 100%;
  height: 100%;
  background-color: var(--border-color);
  border-radius: 2px;
}
.timelineSpineProgress {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  background-color: var(--accent);
  border-radius: 2px;
  transform-origin: top;
  box-shadow: 0 0 10px 0 var(--accent);
}
.timelineItemsWrapper {
  display: flex;
  flex-direction: column;
}

/* --- REVISED LAYOUT LOGIC --- */
.timelineItemWrapper {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  position: relative;
  margin-bottom: 4rem;
  z-index: 2;
  gap: 80px; /* Space for the spine */
}
.timelineItemWrapper.left {
  flex-direction: row-reverse;
}
.timelineItemWrapper.right {
  flex-direction: row;
}
/* This targets the motion.div wrapping the card */
.timelineItemWrapper > div:last-child {
    width: calc(50% - 40px);
}
.synopsisContainer {
  width: calc(50% - 40px);
  display: flex;
  align-items: center;
  font-size: 1.5rem;
  color: var(--text-primary); /* CORRECTED: Use primary text color */
  line-height: 1.7;
  pointer-events: none;
  /* --- NEW BOX STYLES --- */
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 2.5rem;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
}
.synopsisContainer.left {
  text-align: right;
}
.synopsisContainer.right {
  text-align: left;
}
.synopsisFirstWord {
  font-weight: 700;
  color: var(--accent);
}
/* --- END REVISED LAYOUT LOGIC --- */

.dotsContainer {
  position: absolute;
  top: 0;
  right: 0;
  width: 100%;
  height: 100%;
  z-index: 4;
}
.dot {
  position: absolute;
  left: 50%;
  width: 12px;
  height: 12px;
  background-color: var(--border-color);
  border-radius: 50%;
  transform: translateX(-50%) translateY(-50%);
  transition: background-color 0.2s ease-in-out, box-shadow 0.3s ease-in-out;
}
.releasedIndicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background-color: color-mix(in srgb,var(--accent) 90%,transparent);
  backdrop-filter: blur(4px);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 999px;
  font-family: var(--font-ui);
  font-size: 1.3rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  border: 1px solid rgba(255,255,255,0.2);
}
.checkIcon {
  width: 16px;
  height: 16px;
}
.terminusContainer {
  position: relative;
  text-align: center;
  margin-top: 2rem;
  height: 60px;
  z-index: 3;
}
.timelineTerminusButton {
  display: inline-flex;
  align-items: center;
  gap: 1rem;
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 999px;
  padding: 1rem 2.5rem;
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 1.6rem;
  color: var(--text-secondary);
  transition: all 0.15s ease-out;
  box-shadow: 0 5px 20px -5px rgba(0,0,0,0.1);
}
.timelineTerminusButton:hover {
  color: var(--accent);
  border-color: var(--accent);
  transform: translateY(-3px);
  box-shadow: 0 8px 25px -5px color-mix(in srgb, var(--accent) 30%, transparent);
}
.terminusIcon {
  width: 20px;
  height: 20px;
}

/* --- MOBILE OVERRIDES --- */
@media (max-width: 768px) {
  .timelineContainer {
    padding: 4rem 1rem;
  }
  .timelineItemWrapper {
      gap: 40px; /* Reduce gap on mobile */
  }
  .timelineItemWrapper > div:last-child,
  .synopsisContainer {
      width: calc(50% - 20px); /* Reduce item width */
  }
  .synopsisContainer {
      padding: 1.5rem;
      font-size: 1.3rem;
  }
}




--- END OF FILE components\KineticReleaseTimeline.module.css ---

================================================================================

--- START OF FILE components\TimelineCard.tsx ---

// components/TimelineCard.tsx
'use client';

import Link from 'next/link';
import Image from 'next/image';
import type { SanityGameRelease } from '@/types/sanity';
import { motion, useMotionValue, useTransform, useSpring } from 'framer-motion';
import { memo } from 'react';
import { useLivingCard } from '@/hooks/useLivingCard';
import { urlFor } from '@/sanity/lib/image';
import styles from './TimelineCard.module.css';

import PCIcon from '@/components/icons/platforms/PCIcon';
import PS5Icon from '@/components/icons/platforms/PS5Icon';
import XboxIcon from '@/components/icons/platforms/XboxIcon';
import SwitchIcon from '@/components/icons/platforms/SwitchIcon';

const PlatformIcons: Record<string, React.FC<React.SVGProps<SVGSVGElement>>> = {
    'PC': PCIcon,
    'PlayStation 5': PS5Icon,
    'Xbox': XboxIcon,
    'Switch': SwitchIcon,
};

const CheckIcon = (props: React.SVGProps<SVGSVGElement>) => ( <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" {...props}><path fillRule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.052-.143z" clipRule="evenodd" /></svg> );

const TimelineCardComponent = ({ release }: { release: SanityGameRelease & { game?: { slug?: string } } }) => {
    const { livingCardRef, livingCardAnimation } = useLivingCard();
    const mouseX = useMotionValue(0.5);
    const mouseY = useMotionValue(0.5);
    const smoothMouseX = useSpring(mouseX, { damping: 20, stiffness: 150, mass: 0.7 });
    const smoothMouseY = useSpring(mouseY, { damping: 20, stiffness: 150, mass: 0.7 });
    const glareX = useTransform(smoothMouseX, [0, 1], ['-10%', '110%']);
    const glareY = useTransform(smoothMouseY, [0, 1], ['-10%', '110%']);

    const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
        livingCardAnimation.onMouseMove(e);
        if (!livingCardRef.current) return;
        const { left, top, width, height } = livingCardRef.current.getBoundingClientRect();
        mouseX.set((e.clientX - left) / width);
        mouseY.set((e.clientY - top) / height);
    };

    const handleMouseLeave = () => {
        livingCardAnimation.onMouseLeave();
        mouseX.set(0.5);
        mouseY.set(0.5);
    };

    const arabicMonths = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
    const englishMonths = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const date = new Date(release.releaseDate);
    const day = date.getUTCDate();
    const monthIndex = date.getUTCMonth();
    const formattedDate = `${day} ${arabicMonths[monthIndex]} - ${englishMonths[monthIndex]}`;

    const linkPath = release.game?.slug ? `/games/${release.game.slug}` : '/';

    return (
        <motion.div 
            ref={livingCardRef} 
            onMouseMove={handleMouseMove} 
            onMouseEnter={livingCardAnimation.onMouseEnter} 
            onMouseLeave={handleMouseLeave}
            className={styles.livingCardWrapper} 
            style={livingCardAnimation.style}
        >
            <Link href={linkPath} className={`${styles.timelineCard} no-underline`} style={{transformStyle: 'preserve-3d'}}>
                <motion.div
                    className={styles.livingCardGlare}
                    style={{ '--mouse-x': glareX, '--mouse-y': glareY } as any}
                />
                
                <div className={styles.imageContainer} style={{ transform: 'translateZ(20px)' }}>
                    <Image
                        src={urlFor(release.mainImage).width(800).height(450).fit('crop').auto('format').url()}
                        alt={release.title}
                        fill
                        sizes="(max-width: 768px) 90vw, (max-width: 1200px) 45vw, 320px"
                        className={styles.image}
                        placeholder="blur"
                        blurDataURL={release.mainImage.blurDataURL}
                    />
                    {new Date(release.releaseDate) < new Date() && <div className={styles.releasedBadge}><CheckIcon className={styles.checkIcon} /> صدرت</div>}
                </div>
                <div className={styles.cardContent} style={{ transform: 'translateZ(40px)' }}>
                    <div className={styles.cardHeader}>
                        <h4>{release.title}</h4>
                        <p>{formattedDate}</p>
                    </div>
                    <div className={styles.platformIcons}>
                        {(release.platforms || []).map(p => { const Icon = PlatformIcons[p]; return Icon ? <Icon key={p} className={styles.platformIcon} /> : null; })}
                    </div>
                </div>
            </Link>
        </motion.div>
    );
}

export default memo(TimelineCardComponent);

--- END OF FILE components\TimelineCard.tsx ---

================================================================================

--- START OF FILE components\TimelineCard.module.css ---

/* components/TimelineCard.module.css */
.livingCardWrapper {
    transform-style: preserve-d;
    height: 100%;
}

.timelineCard {
    display: flex;
    flex-direction: column;
    height: 100%;
    text-decoration: none;
    background-color: var(--bg-secondary);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    will-change: transform;
    transform-style: preserve-d;
    position: relative; /* For glare positioning */
}

/* --- NEW GLARE EFFECT STYLE --- */
.livingCardGlare {
    position: absolute;
    inset: 0;
    background: radial-gradient(
        circle at var(--mouse-x) var(--mouse-y),
        rgba(255, 255, 255, 0.2),
        transparent 40%
    );
    opacity: 0;
    transition: opacity 0.4s ease-out;
    z-index: 1;
    pointer-events: none;
}

.livingCardWrapper:hover .livingCardGlare {
    opacity: 1;
}
/* --- END NEW STYLE --- */

.imageContainer {
    position: relative;
    width: 100%;
    padding-top: 56.25%; /* 16:9 Aspect Ratio */
    overflow: hidden;
    flex-shrink: 0;
}

.image {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.4s ease-out;
}

.livingCardWrapper:hover .image {
    transform: scale(1.05);
}

@keyframes pulse-glow {
    0%, 100% {
        box-shadow: 0 0 10px 0px color-mix(in srgb, var(--accent) 50%, transparent);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 16px 2px color-mix(in srgb, var(--accent) 70%, transparent);
        transform: scale(1.03);
    }
}

.releasedBadge {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    background-color: color-mix(in srgb, var(--accent) 95%, black 20%);
    backdrop-filter: blur(5px);
    color: #fff;
    padding: 0.4rem 1rem;
    border-radius: 999px;
    font-family: var(--font-ui);
    font-size: 1.2rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border: 1px solid color-mix(in srgb, var(--accent) 50%, transparent);
    z-index: 2;
    animation: pulse-glow 3s infinite ease-in-out;
}

.checkIcon {
    width: 14px;
    height: 14px;
    filter: drop-shadow(0 0 5px #fff);
}

.cardContent {
    padding: 1.5rem;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    background-color: var(--bg-secondary);
}

.cardHeader h4 {
    font-family: var(--font-heading);
    font-size: 1.8rem;
    line-height: 1.3;
    color: var(--text-primary);
    margin: 0 0 0.4rem 0;
}

.cardHeader p {
    font-family: var(--font-ui);
    font-size: 1.4rem;
    color: var(--text-secondary);
    margin: 0;
}

.platformIcons {
    display: flex;
    gap: 1.2rem;
    align-items: center;
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
}

.platformIcon {
    width: 20px;
    height: 20px;
    color: var(--text-secondary);
}

@media (max-width: 768px) {
    .cardContent {
        padding: 1rem;
    }
    .cardHeader h4 {
        font-size: 1.6rem;
    }
    .cardHeader p {
        font-size: 1.2rem;
    }
    .platformIcons {
        gap: 0.8rem;
        padding-top: 0.8rem;
        margin-top: 0.8rem;
    }
    .platformIcon {
        width: 16px;
        height: 16px;
    }
}




--- END OF FILE components\TimelineCard.module.css ---

================================================================================

--- START OF FILE components\AnimatedReleases.tsx ---

'use client';

import { useRef } from 'react';
import { motion, useInView } from 'framer-motion';
import KineticReleaseTimeline from '@/components/KineticReleaseTimeline';

export default function AnimatedReleases({ releases }: { releases: any[] }) {
    const ref = useRef(null);
    const isInView = useInView(ref, { once: true, amount: 0.4 });
    const variants = { hidden: { opacity: 0, y: 50 }, visible: { opacity: 1, y: 0 } };

    return (
        <motion.div 
            ref={ref} 
            variants={variants} 
            initial="hidden" 
            animate={isInView ? "visible" : "hidden"} 
            transition={{ duration: 0.8, ease: "easeOut" as const }}
        >
            <KineticReleaseTimeline releases={releases} />
        </motion.div>
    );
}




--- END OF FILE components\AnimatedReleases.tsx ---

================================================================================

--- START OF FILE lib\sanity.queries.ts ---

// lib/sanity.queries.ts

import { groq } from 'next-sanity'

// --- Base Fields & Projections (Optimized) ---
const mainImageFields = groq`asset, "url": asset->url, "blurDataURL": asset->metadata.lqip, alt`
const creatorFields = groq`_id, name, prismaUserId, image, bio`
const gameFields = groq`_id, title, "slug": slug.current`
const tagFields = groq`_id, title, "slug": slug.current`
const publishedFilter = groq`defined(publishedAt) && publishedAt < now()`

// --- Projections ---
const cardProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}}, 
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}`
const cardListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- API Projections ---
const apiListProjection = groq`
_id, _type, legacyId, title, "slug": slug.current, 
"mainImageRef": mainImage.asset, 
score,
"authors": authors[]->{${creatorFields}},
"reporters": reporters[]->{${creatorFields}},
"designers": designers[]->{${creatorFields}},
"publishedAt": publishedAt, "game": game->{_id, title, "slug": slug.current}, "tags": tags[]->{${tagFields}}, "category": category->{title, "slug": slug.current}
`

// --- News Hub Specific Queries ---

export const newsHeroQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...4] {
  ${cardProjection}, synopsis
}`

export const newsGridInitialQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc, _updatedAt desc)[0...50] {
  ${cardListProjection}
}`

export const paginatedNewsQuery = (
  gameSlug?: string, 
  tagSlugs?: string[], 
  searchTerm?: string, 
  offset: number = 0, 
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest'
) => {
  let filter = `_type == "news" && ${publishedFilter} && defined(mainImage.asset)`;
  
  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`;
  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map(slug => `"${slug}" in tags[]->slug.current`).join(' || ');
    filter += ` && (${tagFilter})`;
  }
  if (searchTerm) filter += ` && title match "${searchTerm}*"`;

  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc'; 

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Reviews API/Page Queries ---
export const paginatedReviewsQuery = (
  gameSlug?: string, 
  tagSlugs?: string[], 
  searchTerm?: string, 
  scoreRange?: string,
  offset: number = 0, 
  limit: number = 20,
  sort: 'latest' | 'score' = 'latest'
) => {
  let filter = `_type == "review" && ${publishedFilter}`;

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`;

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map(slug => `"${slug}" in tags[]->slug.current`).join(' && ');
    filter += ` && (${tagFilter})`;
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`;
  
  if (scoreRange) {
    if (scoreRange === '9-10') filter += ` && score >= 9 && score <= 10`;
    else if (scoreRange === '8-8.9') filter += ` && score >= 8 && score < 9`;
    else if (scoreRange === '7-7.9') filter += ` && score >= 7 && score < 8`;
    else if (scoreRange === '<7') filter += ` && score < 7`;
  }
  
  const orderBy = sort === 'score' ? 'score desc, publishedAt desc' : 'publishedAt desc';

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- Articles API/Page Queries ---
export const paginatedArticlesQuery = (
  gameSlug?: string, 
  tagSlugs?: string[], 
  searchTerm?: string, 
  offset: number = 0, 
  limit: number = 20,
  sort: 'latest' | 'viral' = 'latest'
) => {
  let filter = `_type == "article" && ${publishedFilter}`;

  if (gameSlug) filter += ` && game->slug.current == "${gameSlug}"`;

  if (tagSlugs && tagSlugs.length > 0) {
    const tagFilter = tagSlugs.map(slug => `"${slug}" in tags[]->slug.current`).join(' && ');
    filter += ` && (${tagFilter})`;
  }

  if (searchTerm) filter += ` && title match "${searchTerm}*"`;
  
  const orderBy = sort === 'latest' ? 'publishedAt desc' : '_updatedAt desc';

  return groq`*[${filter}] | order(${orderBy}) [${offset}...${offset + limit}] {
    ${apiListProjection}
  }`
}

// --- List Page Queries ---
export const vanguardReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] { ${cardProjection} }`
export const featuredHeroReviewQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} }`
export const featuredShowcaseArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...7] { ${cardProjection} }`
export const allReviewsListQuery = groq`*[_type == "review" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allArticlesListQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc) [0...20] { ${cardListProjection} }`
export const allContentByCreatorListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && references($creatorIds)] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByGameListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && game->slug.current == $slug] | order(publishedAt desc) { ${cardListProjection} }`
export const allContentByTagListQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && ($slug in tags[]->slug.current || category->slug.current == $slug)] | order(publishedAt desc) { ${cardListProjection} }`

// --- Detail Page Queries ---
const contentProjection = groq`content[]{ ..., _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } }, _type == "imageCompare" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "twoImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}} }, _type == "fourImageGrid" => { "image1": image1{..., asset->{_id, url}}, "image2": image2{..., asset->{_id, url}}, "image3": image3{..., asset->{_id, url}}, "image4": image4{..., asset->{_id, url}} } }`
const relatedContentProjection = groq`{ _id, _type, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, score, "authors": authors[]->{name, prismaUserId}, "reporters": reporters[]->{name, prismaUserId}, "publishedAt": publishedAt }`

export const reviewBySlugQuery = groq`*[_type == "review" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{${tagFields}},
  "relatedReviews": relatedReviews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const articleBySlugQuery = groq`*[_type == "article" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "authors": authors[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "tags": tags[]->{_id, title, "slug": slug.current},
  "relatedArticles": relatedArticles[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`
export const newsBySlugQuery = groq`*[_type == "news" && slug.current == $slug && ${publishedFilter}][0] {
  ..., "reporters": reporters[]->{${creatorFields}}, "designers": designers[]->{${creatorFields}},
  "game": game->{${gameFields}}, "mainImage": mainImage{${mainImageFields}}, "category": category->{_id, title, "slug": slug.current},
  "relatedNews": relatedNews[${publishedFilter}]->${relatedContentProjection},
  ${contentProjection}
}`

// --- Fallback & Miscellaneous Queries ---
export const latestReviewsFallbackQuery = groq`*[_type == "review" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestArticlesFallbackQuery = groq`*[_type == "article" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsFallbackQuery = groq`*[_type == "news" && ${publishedFilter} && _id != $currentId] | order(publishedAt desc)[0...3] ${relatedContentProjection}`
export const latestNewsQuery = groq`*[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...15] { _id, legacyId, title, "slug": slug.current, "mainImage": mainImage{${mainImageFields}}, "reporters": reporters[]->{name, prismaUserId}, publishedAt, "tags": tags[]->{${tagFields}} }`
export const heroContentQuery = groq`{
  "featuredReview": *[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(score desc, publishedAt desc)[0] { ${cardProjection} },
  "latestNews": *[_type == "news" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} },
  "featuredArticle": *[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0] { ${cardProjection} }
}`
export const featuredReviewsQuery = groq`*[_type == "review" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const featuredArticlesQuery = groq`*[_type == "article" && ${publishedFilter} && defined(mainImage.asset)] | order(publishedAt desc)[0...10] {${cardProjection}}`
export const searchQuery = groq`*[_type in ["review", "article", "news"] && ${publishedFilter} && defined(slug.current) && (title match $searchTerm + "*" || pt::text(content) match $searchTerm)] | order(publishedAt desc) [0...10] {
  _id, _type, title, "slug": slug.current, "imageUrl": mainImage.asset->url + '?w=200&h=120&fit=crop&auto=format', publishedAt,
  "authors": authors[]->{name}, "reporters": reporters[]->{name}, 
  "gameTitle": game->title, "tags": tags[]->{title}
}`
export const contentByIdsQuery = groq`*[_type in ["review", "article", "news"] && legacyId in $ids && ${publishedFilter}] { ${cardProjection} }`
export const allReleasesQuery = groq`*[_type == "gameRelease" && defined(releaseDate)] | order(releaseDate asc) { 
  _id, legacyId, title, releaseDate, platforms, synopsis, "mainImage": mainImage{${mainImageFields}},
  "game": game->{ "slug": slug.current },
  "slug": game->slug.current
}`

// --- Studio Editor Queries ---
export const allGamesForStudioQuery = groq`*[_type == "game"] | order(title asc){_id, title, "slug": slug.current}`;
export const allTagsForStudioQuery = groq`*[_type == "tag"] | order(title asc){_id, title, category}`;
export const allCreatorsForStudioQuery = groq`*[_type in ["reviewer", "author", "reporter", "designer"]] | order(name asc){_id, name, _type, prismaUserId}`;

export const editorDocumentQuery = groq`*[_id == $id || _id == 'drafts.' + $id] | order(_updatedAt desc)[0]{
  ...,
  "authors": authors[]->{_id, name, prismaUserId},
  "reporters": reporters[]->{_id, name, prismaUserId},
  "designers": designers[]->{_id, name, prismaUserId},
  "game": game->{_id, title},
  "tags": tags[]->{_id, title},
  "category": category->{_id, title},
  "mainImage": mainImage.asset->{
    "_ref": _id,
    "url": url,
    "metadata": metadata
  },
  content[]{
    ...,
    _type == "image" => { "asset": asset->{ _id, url, "lqip": metadata.lqip, "metadata": metadata } },
    _type == "imageCompare" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "twoImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}}
    },
    _type == "fourImageGrid" => {
      "image1": image1{..., asset->{_id, url, metadata}},
      "image2": image2{..., asset->{_id, url, metadata}},
      "image3": image3{..., asset->{_id, url, metadata}},
      "image4": image4{..., asset->{_id, url, metadata}}
    }
  }
}`;

// --- Homepage Feed Queries ---
export const homepageArticlesQuery = groq`*[_type == "article" && ${publishedFilter}] | order(publishedAt desc)[0...12] { ${cardListProjection} }`;
export const homepageNewsQuery = groq`*[_type == "news" && ${publishedFilter}] | order(publishedAt desc)[0...18] { ${cardListProjection} }`;

--- END OF FILE lib\sanity.queries.ts ---

================================================================================

--- START OF FILE sanity\schemaTypes\gameReleaseType.ts ---

import {defineField, defineType, Rule} from 'sanity'

export default defineType({
name: 'gameRelease',
title: 'Game Release',
type: 'document',
fields: [
defineField({name: 'title', title: 'Title', type: 'string', validation: (Rule) => Rule.required()}),
defineField({name: 'game', title: 'Game', type: 'reference', to: {type: 'game'}, validation: (Rule) => Rule.required()}),
defineField({name: 'releaseDate', title: 'Release Date', type: 'date', validation: (Rule) => Rule.required()}),
defineField({name: 'platforms', title: 'Platforms', type: 'array', of: [{type: 'string'}], options: {list: ['PC', 'PlayStation', 'Xbox', 'Switch']}}),
defineField({name: 'mainImage', title: 'Main Image', type: 'image', options: {hotspot: true}, validation: (Rule) => Rule.required()}),
defineField({name: 'synopsis', title: 'Synopsis', type: 'text', validation: (Rule) => Rule.required()}),
defineField({name: 'tags', title: 'Tags', type: 'array', of: [{type: 'reference', to: {type: 'tag'}, options: { filter: 'category == "Game"' }}]}),
defineField({name: 'designers', title: 'Designers (Optional)', type: 'array', of: [{type: 'reference', to: {type: 'designer'}}]}),
defineField({name: 'legacyId', title: 'Legacy ID', type: 'number', readOnly: true}),
],
preview: {
select: {title: 'title', subtitle: 'releaseDate', media: 'mainImage'},
},
})

--- END OF FILE sanity\schemaTypes\gameReleaseType.ts ---

================================================================================

